<!doctype linuxdoc system>
<article>

<!-- Title information -->

<title>SHILKA (keywords description translator)
<author>Vladimir Makarov, <tt>vmakarov@users.sourceforge.net</tt>
<date>Apr 5, 2001
<abstract>
This document describes SHILKA (translator of a keyword description
into code for fast recognition of the keywords).
</abstract>
<toc>

<sect>Introduction
<p>
SHILKA is translator of keywords description into code for fast
recognition of keywords and standard identifiers in compilers.  SHILKA
is implemented with the aid of other components of COCOM toolset.

SHILKA is analogous to GNU package `gperf' but not based on perfect
hash tables.  SHILKA rather uses minimal pruned O-trie for for keyword
recognition.  As consequence SHILKA can take the presumable frequency
of keyword occurences in the program into accout.  Gperf can not make
it.  Therefore as rule keyword recognition code generated by SHILKA is
faster than one generated by Gperf up to 50%.

SHILKA is suitable for fast recognition from few keywords to huge
dictionary of words (strings).

What is minimal pruned O-trie?  Let us consider what is trie.  If we
have four keywords: case, char, else, enum.  We can recognize the
keywords with the following structure called trie.
<tscreen><verb>
                             |
                    -----------------
                 c |               e |
                -------          --------- 
             a |     h |       l|        n|
             s |     a |       s|        u|
             e |     r |       e|        m|
</verb></tscreen>
The corresponding code for the keywords recognition based on this
structure could be
<tscreen><verb>
              if (kw[0] == 'c')
                {
                  if (kw[1] == 'a')
                    {
                      if (kw[2] == 's')
                        {
                          if (kw[3] == 'e')
                            {
                              /* we recognize keyword case */
                            }
                          else
                            /* this is not a keyword */
                        }
                      else
                       /* this is not a keyword */
                    }
                  else if (kw[1] == 'h')
                    {
                      if (kw[2] == 'a')
                        {
                          if (kw[3] == 'r')
                            {
                              /* we recognize keyword char */
                            }
                          else
                            /* this is not a keyword */
                        }
                      else
                       /* this is not a keyword */
                    }
                  else
                    /* this is not a keyword */
                }
              else if (kw[0] = 'e')
                {
                  if (kw[1] == 'l')
                    {
                      if (kw[2] == 's')
                        {
                          if (kw[3] == 'e')
                            {
                              /* we recognize keyword else */
                            }
                          else
                            /* this is not a keyword */
                        }
                      else
                       /* this is not a keyword */
                    }
                  else if (kw[1] == 'n')
                    {
                      if (kw[2] == 'u')
                        {
                          if (kw[3] == 'm')
                            {
                              /* we recognize keyword enum */
                            }
                          else
                            /* this is not a keyword */
                        }
                      else
                       /* this is not a keyword */
                    }
                  else
                    /* this is not a keyword */
                }
</verb></tscreen>
You can see in the example above that it is not necessary to test all
characters of the keywords.  Instead of this, we can test only several
characters of the keywords and test all kewyord at the end of final
decision that given string is a keyword.  Such technique results in
another structure called pruned trie:
<tscreen><verb>
                             |
                    -----------------
                 c |               e |
                -------          --------- 
             a |     h |      l |       n |
               |       |        |         |
             case     char     else      enum
</verb></tscreen>
The corresponding code for the keywords recognition based on this
structure could be
<tscreen><verb>
              if (kw[0] == 'c')
                {
                  if (kw[1] == 'a')
                    {
                      if (strcmp (kw, "case") == 0)
                        /* we recognize keyword case */
                      else
                        /* this is not a keyword */
                    }
                  else if (kw[1] == 'h')
                    {
                      if (strcmp (kw, "char") == 0)
                        /* we recognize keyword char */
                      else
                        /* this is not a keyword */
                    }
                  else
                    /* this is not a keyword */
                }
              else if (kw[0] = 'e')
                {
                  if (kw[1] == 'l')
                    {
                      if (strcmp (kw, "else") == 0)
                        /* we recognize keyword else */
                      else
                        /* this is not a keyword */
                    }
                  else if (kw[1] == 'n')
                    {
                      if (strcmp (kw, "enum") == 0)
                        /* we recognize keyword enum */
                      else
                        /* this is not a keyword */
                    }
                  else
                    /* this is not a keyword */
                }
</verb></tscreen>
Probably you found that if we test keywords characters in another
order (not in sequential order), we could recognize keywords faster.
Using such approach results in another structure called pruned
O-trie:
<tscreen><verb>
                               |
                   ------------2-------------
                a |      h |       l |     n |
                  |        |         |       |
                case      char     else     enum
</verb></tscreen>
Here number on the intersection means what keyword character (1st,
2nd, ...) is tested.  The corresponding code for the keywords
recognition based on this structure could be
<tscreen><verb>
              if (kw[1] == 'a')
                {
                  if (strcmp (kw, "case") == 0)
                    /* we recognize keyword case */
                  else
                    /* this is not a keyword */
                }
              else if (kw[1] == 'h')
                {
                  if (strcmp (kw, "char") == 0)
                    /* we recognize keyword char */
                  else
                    /* this is not a keyword */
                }
              else if (kw[1] == 'l')
                {
                  if (strcmp (kw, "else") == 0)
                    /* we recognize keyword else */
                  else
                    /* this is not a keyword */
                }
              else if (kw[1] == 'n')
                {
                  if (strcmp (kw, "enum") == 0)
                    /* we recognize keyword enum */
                  else
                    /* this is not a keyword */
                }
              else
                /* this is not a keyword */
</verb></tscreen>
And finally, minimal in the phrase "minimal pruned O-trie" means that
we found pruned O-trie with minimal number of testing the keyword
characters.  Generally speaking we can introduce notion cost for
pruned O-trie and search for prunned O-trie with minimal cost.  Shilka
takes probability of keyword occurences in program into account for
evaluation of the cost of prunned O-trie.


<sect>Keywords description language
<p>
A keywords description describes mainly keywords (or standard
identifiers) of a language and possibly the keywords frequencies in
typical program.  The frequencies are used for generation of pruned
O-trie for faster keyword recognition in the program.  The default
action returning code of recognized keyword can be changed by user
defined action, e.g. returning pointer to the structure describing
given keyword.


<sect1>Layout of keywords description
<p>
Keywords description structure has the following layout which
is similar to one of YACC file.
<tscreen><verb>
     DECLARATIONS
     %%
     KEYWORDS
     %%
     ADDITIONAL C/C++ CODE
</verb></tscreen>
The `%%' serves to separate the sections of description.  All sections
are optional.  The first `%%' starts section of keywords and is
obligatory even if the section is empty, the second `%%' may be absent
if section of additional C/C++ code is absent too.

The section of declarations contains optional declaration of type of
generated function for keyword recognition.  If the type is given then
actions for all keywords and keyword `%other' with the action should
be given.  Otherwise the function will return codes of recognized
keywords (of type `int' or `enum' -- see SHILKA Usage).  The section
of declarations may contain subsections of code on C/C++.

The next section contains keywords list which describes keyword itself
and optional code of the keyword, frequency, and action.

The additional C/C++ code can contain any C/C++ code you want to use.
Often functions which are not generated by the translator but are
relative to the keyword recognition can go here.  This code without
changes is placed at the end of file generated by the translator.

Full YACC syntax of SHILKA description file is placed in Appendix 1.


<sect1>Declarations
<p>
The section of declarations may contain the following construction:
<tscreen><verb>
     %type IDENTIFIER
</verb></tscreen>
Only the first such construction is taken into account.  All
subsequent constructions `%type' are ignored.

Such constructions declare type of data recognized by function
`KR_find_keyword'. E.g. the function can return pointer to structure
which contains additional information of recognized keyword.  By
default the function returns only code of recognized keyword (of
integer type or enumeration -- see SHILKA Usage).  If construction
`%type' is present, we should also put construction `%other' in the
keyword section and actions returning data of the declared type for
each keyword definition in the section of keywords.  Otherwise SHILKA
will generate warning messages.

There may be also the following constructions in the declaration
section
<tscreen><verb>
     %local {
        C/C++ DECLARATIONS
     }

     %import {
        C/C++ DECLARATION
     }

     and

     %export {
        C/C++ DECLARATION
     }
</verb></tscreen>
which contain any C/C++ declarations (types, variables, macros, and so
on) used in sections.

The local C/C++ declarations are inserted at the begin of generated
implementation file (see section `generated code') but after
include-directive of interface file (if present -- see SHILKA Usage).

C/C++ declarations which start with `%import' are inserted at the
begin of generated interface file.  If the interface file is not
generated, the code is inserted at the begin of the part of
implementation file which would correspond the interface file.

C/C++ declarations which start with `%export' are inserted at the end
of generated interface file.  For example, such exported C/C++ code
may contain definitions of external variables and functions which
refer to definitions generated by SHILKA.  If the interface file is
not generated, the code is inserted at the end of the part of
implementation file which would correspond the interface file.

All C/C++ declarations are placed in the same order as in the section
of declarations.


<sect1>Keywords
<p>
The section of declarations is followed by section of keyword
definitions.  Usually keyword definition is described by the following
construction
<tscreen><verb>
     IDENTIFIER = IDENTIFIER frequency action
</verb></tscreen>
What is identifier.  What is action.

Here the first identifier is a keyword itself.  The second identifier
determines the keyword name which will be generated as macro
definition or enumeration (see SHILKA usage) for given keyword.  The
name is formed from the prefix KR_ and the second identifier.  The
second identifier with = may be absent.  In this case the keyword name
is formed from prefix KR_ and the keyword itself (i.e. the first
identifier).

Optional frequency of the keyword occurence in program (in some
abstract unities) is integer value and is used for generation of
minimal cost pruned O-trie.  If the frequency is absent, its value
will be 1.

Optional action (any C/C++ block) is executed when the keyword is
recognized.  Usually the action will be only returning pointer to the
structure describing the recognized keyword.  Default action is simply
returning the keyword name whose value is keyword code defined as
macro or enumeration constant.  If you are going to return data
distinct from the keyword code, we should use declaration %type (see
above) and should define actions for all keywords and for special
keyword definition %other with action (see below).  Otherwise SHILKA
will generate warning messages.

Identifier in SHILKA is the same as one in C.  If you want to
recognize also strings distinct from SHILKA identifier, you should use
the following construction
<tscreen><verb>
     STRING = IDENTIFIER frequency action
</verb></tscreen>
The string here is C string.  The identifier after = is obligatory in
such construction.  All other is the same as in the previous
construction.

The following construction determine optional action when no one
keyword is recognized.
<tscreen><verb>
     OTHER action
</verb></tscreen>
Default action is only returning special code KR__not_found.  If you
are going to return data distinct from the keyword code, we probably
should return value NULL here.

Only the first such construction is taken into account.  All
subsequent such constructions are ignored.


<sect>Generated code
<p>
A specification as described in the previous section is translated by
SHILKA (keywords description translator) into interface and
implementation files having the same names as one of specification
file and correspondingly suffixes `.h' and `.c' (C code) or `.cpp'
(C++ code).  By default the interface file is not generated.


<sect1>C++ code
<p>
The interface and implementation files consist of the following
definitions of generated macros, types, and functions:
     <descrip>
     <tag>Class `KR_recognizer'.</tag>
       Object of the class describes a keyword recognizer.  If the
       interface file is generated, the interface file contains the
       class.  The implementation file contains the class functions
       themself.  The class has the following public members:
        <enum>
        <item>Function 
<tscreen><verb>
              `<type> KR_find_keyword (const char *KR_keyword,
                                       int KR_length)'
</verb></tscreen>
           The function has two parameters: keyword being recognized
           and length in characters of the keyword.  By default the
           function returns code of recognized keyword (integer type
           or enumeration -- see flag `-enum').  The function will
           return value of type given in construction `%type' of the
           description file.  Usually the value contains some
           additional information about recognized keyword.
           <p>
           By default the keyword is suggested to be stored according
           to C representation (with zero byte as end marker).  If
           this is not true, you can use option `-length' during
           generation of the keyword recognizer by SHILKA.  In this
           case the function `strncmp' instead of `strcmp' is used for
           keywords comparison.
           <p>
           If option `-inline' has been used, the function is defined
           as inline.  This can significantly speed up keywords
           recognition.
      
       <item>Function
<tscreen><verb>
             `void KR_output_statistics (void)'
</verb></tscreen>
          The function outputs number of occurrences for each keywords
          since the keyword recognizer start.  The function also
          outputs relative frequencies of occurrences (this value is
          always nonzero).  The frequencies output after work
          recognizer on a large typical program can be used for
          setting up keyword frequencies in the description file for
          generation of faster keyword recognizer.
          <p>
          The function do nothing if SHILKA flag `-strip' has been
          used during the keyword recognizer or flag `-statistics' has
          been not used.  Flag `-statistics' simply generates macro
          definition `__KR__DEBUG__' which includes code for picking
          up and outputting statistics about keyword occurrences.
   
       <item>Function
<tscreen><verb>
             `void KR_reset (void)'
</verb></tscreen>
          The function initiates keyword recognizer.
    
       <item>Constructor
<tscreen><verb>
             `void KR_recognizer (void)'
</verb></tscreen>
          The constructor simply calls function `KR_reset'.

       <item>Destructor
<tscreen><verb>
             `~KR_recognizer (void)'
</verb></tscreen>
          This destructor is for accurate finish work with the keyword
          recognizer.
       </enum>
     <tag>Macros or enumeration (see option `-enum')</tag>
       which declare keyword codes.  Macros or enumeration constants
       have the same name as one in the description file and prefix
       `KR_' (see also option `-p').  SHILKA generates additional code
       `KR__not_found'.  By default such code means that any keyword
       is not found.  Macros or enumeration are generated in interface
       file only if option `-export' is present on SHILKA command
       line.  By default, the macros or the enumeration are generated
       in the implementation file.  Usually, the last case means that
       only the keyword recognizer implementation file is used, and
       the file is included into another C/C++ file.
     </descrip>

<sect1>C code
<p>
The interface and implementation files consist of the following
definitions of generated macros, types, and functions:
    <enum>    
    <item>Macros or enumeration (see option `-enum') which declare
       keyword codes.  Macros or enumeration constants have the same
       name as one in the description file and prefix `KR_' (see also
       option `-p').  SHILKA generates additional code
       `KR__not_found'.  By default such code means that any keyword
       is not found.  Macros or enumeration are generated in interface
       file only if option `-export' is present on SHILKA command
       line.  By default, the macros or the enumeration are generated
       in the implementation file.  Usually, the last case means that
       only the keyword recognizer implementation file is generated,
       and the file is included into another C/C++ file.

    <item>Function 
<tscreen><verb>
          `<type> KR_find_keyword (const char *KR_keyword,
                                   int KR_length)'
</verb></tscreen>
       The function has two parameters: keyword being recognized and
       length in characters of the keyword.  By default the function
       returns code of recognized keyword (integer type or enumeration
       -- see flag `-enum').  The function can also return value of
       type given in construction `%type' of the description file.
       Usually the value contains some additional information about
       recognized keyword.
       <p>
       By default the keyword is suggested to be stored according to C
       representation (with zero byte as end marker).  If this is not
       true, you can use option `-length' during generation of the
       keyword recognizer by SHILKA.  In this case the function
       `strncmp' instead of `strcmp' is used for keywords comparison.
       <p>
       If option `-inline' has been used, the function is defined as
       inline.  This can significantly speed up keywords recognition.
       <p>
       If the interface file is generated, the interface file contains
       external definition of the function.  The implementation file
       contains the function itself.

    <item>Function
<tscreen><verb>
          `void KR_reset (void)'
</verb></tscreen>
       The function initiates keyword recognizer.  Therefore the
       function must be called by the first.  If the interface file is
       generated, the interface file contains external definition of
       the function.  The implementation file contains the function
       itself.
    
    <item>Function
<tscreen><verb>
          `void KR_output_statistics (void)'
</verb></tscreen>
       The function outputs number of occurrences for each keywords
       since the keyword recognizer start.  The function also outputs
       relative frequencies of occurrences (this value is always
       nonzero).  The frequencies output after work recognizer on a
       large typical program can be used for setting up keyword
       frequencies in the description file for generation of faster
       keyword recognizer.
       <p>
       The function do nothing if SHILKA flag `-strip' has been used
       during the keyword recognizer or flag `-statistics' has been
       not used.  Flag `-statistics' simply generates macro definition
       `__KR__DEBUG__' which includes code for picking up and
       outputting statistics about keyword occurrences.
       <p>
       If the interface file is generated, the interface file contains
       external definition of the function.  The implementation file
       contains the function itself.
    </enum>

<sect>SHILKA Usage
<p>
<tscreen><verb>
%%%
</verb></tscreen>

<sect>Future of SHILKA development
<p>
Some C/C++ compilers generate bad code for switch-statement.  In this
case, generation of table-driven keyword recognition based on minimal
pruned O-trie would be useful.


<sect>Appendix 1 - Syntax of SHILKA description file (YACC description)
<p>
<tscreen><verb>
%token PERCENTS LOCAL IMPORT EXPORT TYPE EQUAL OTHER
%token IDENTIFIER STRING CODE_INSERTION ADDITIONAL_C_CODE
%token NUMBER
%start description

%%

description : declaration_part  PERCENTS
              keyword_definition_list  ADDITIONAL_C_CODE
            ;

declaration_part :
                 | declaration_part  declaration
                 ;

declaration : TYPE IDENTIFIER
            | LOCAL  CODE_INSERTION
            | IMPORT CODE_INSERTION
            | EXPORT CODE_INSERTION
            ;

keyword_definition_list :
                        | keyword_definition_list  keyword_definition
                        ;

keyword_definition : IDENTIFIER optional_name frequency optional_action
                   | STRING EQUAL IDENTIFIER frequency optional_action
                   | OTHER optional_action
                   ;

optional_name :
              | EQUAL IDENTIFIER
              ;

frequency :
          | NUMBER
          ;

optional_action :
                | CODE_INSERTION
                ;
</verb></tscreen>

<sect>Appendix 2 - Example of SHILKA description file
<p>
<tscreen><verb>
/* Keywords of ANSI C. */
%import {
   struct keyword {int kw; int primitive_type_flag;};
   typedef struct keyword *keyword_t;
}
%type keyword_t
%%
if            {static struct keyword res = {KR_if, 0}; return &res;}
do            {static struct keyword res = {KR_do, 0}; return &res;}
int           {static struct keyword res = {KR_int, 1}; return &res;}
for           {static struct keyword res = {KR_for, 0}; return &res;}
case          {static struct keyword res = {KR_case, 0}; return &res;}
char     1600 {static struct keyword res = {KR_char, 1}; return &res;}
auto          {static struct keyword res = {KR_auto, 0}; return &res;}
goto          {static struct keyword res = {KR_goto, 0}; return &res;}
else     5700 {static struct keyword res = {KR_else, 0}; return &res;}
long          {static struct keyword res = {KR_long, 0}; return &res;}
void     8200 {static struct keyword res = {KR_void, 1}; return &res;}
enum          {static struct keyword res = {KR_void, 0}; return &res;}
float         {static struct keyword res = {KR_float, 1}; return &res;}
short         {static struct keyword res = {KR_short, 0}; return &res;}
union         {static struct keyword res = {KR_union, 0}; return &res;}
break         {static struct keyword res = {KR_break, 0}; return &res;}
while         {static struct keyword res = {KR_while, 0}; return &res;}
const         {static struct keyword res = {KR_const, 0}; return &res;}
double        {static struct keyword res = {KR_double, 0}; return &res;}
static   7300 {static struct keyword res = {KR_static, 0}; return &res;}
extern        {static struct keyword res = {KR_extern, 0}; return &res;}
struct        {static struct keyword res = {KR_struct, 0}; return &res;}
return   1000 {static struct keyword res = {KR_return, 0}; return &res;}
sizeof   1100 {static struct keyword res = {KR_sizeof, 0}; return &res;}
switch        {static struct keyword res = {KR_switch, 0}; return &res;}
signed        {static struct keyword res = {KR_signed, 0}; return &res;}
typedef       {static struct keyword res = {KR_typedef, 0}; return &res;}
default       {static struct keyword res = {KR_default, 0}; return &res;}
unsigned      {static struct keyword res = {KR_unsigned, 0}; return &res;}
continue      {static struct keyword res = {KR_continue, 0}; return &res;}
register      {static struct keyword res = {KR_register, 0}; return &res;}
volatile      {static struct keyword res = {KR_volatile, 0}; return &res;}
%other        {return NULL;}                                                  

</verb></tscreen>
 
<sect>Appendix 3 - Run of SHILKA on the previous description file
<p>
This output is produced on Compaq Aero 486 SX/25 with 12Mb under Linux 2.0.29.
<tscreen><verb>
bash$ shilka -time d.shilka

32 keywords, 32 different keyword names
5.18 average keywords length, 4.80 weighted average keywords length
34600 achieved trie cost, 27500 minimal cost, 125 % ratio

  building pruned O-trie: 0.10, output: 0.29
Summary:
  parse time 0.11, analyze time 0.00, generation time 0.39, all time:0.51
</verb></tscreen>
</article>
