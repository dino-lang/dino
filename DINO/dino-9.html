<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.66">
 <TITLE>The Programming Language DINO: Predeclared identifiers</TITLE>
 <LINK HREF="dino-10.html" REL=next>
 <LINK HREF="dino-8.html" REL=previous>
 <LINK HREF="dino.html#toc9" REL=contents>
</HEAD>
<BODY>
<A HREF="dino-10.html">Next</A>
<A HREF="dino-8.html">Previous</A>
<A HREF="dino.html#toc9">Contents</A>
<HR>
<H2><A NAME="s9">9.</A> <A HREF="dino.html#toc9">Predeclared identifiers</A></H2>

<P>Dino has quite a lot of predeclared identifiers.  They are combined in
in a few signleton objects also called spaces -- see
section <EM>Declarations and Scope Rules</EM>.  Most of predeclared
identifiers refer for functions. The predeclared functions expect a
given number of actual parameters (may be a variable number of
parameters).  If the actual parameter number is an unexpected one,
exception <CODE>parnumber</CODE> is generated.  The predeclared functions
expect that the actual parameters (may be after implicit conversions)
are of the required type.  If this is not true,
exception <CODE>partype</CODE> is generated.  To show how many parameters
the function requires, we will write the names of the parameters and
use brackets <CODE>[</CODE> and <CODE>]</CODE> for the optional parameters in
the description of the functions.</P>
<P>Examples:  The following description
<BLOCKQUOTE><CODE>
<PRE>
          strtime ([format [, time]])
</PRE>
</CODE></BLOCKQUOTE>

describes that the function can accept zero, one, or two
parameters.  If only one parameter is given, then this is
parameter <CODE>format</CODE>.</P>
<P>If nothing is said about the returned result, the function return
value is undefined.</P>
<P>Predeclared identifiers are describe below according to their spaces.</P>

<H2><A NAME="ss9.1">9.1</A> <A HREF="dino.html#toc9.1">Space <CODE>lang</CODE></A>
</H2>

<P>The space contains fundamental Dino declarations.  All declarations of
the space are always exposed.</P>

<H3>Predeclared variables</H3>

<P>Space <CODE>lang</CODE> has some predeclared variables which contain
useful information or can be used to control the behaviour of the Dino
interpreter.</P>

<H3>Arguments and environment</H3>

<P>To access arguments to the program and the environment, the following
variables can be used:
<UL>
<LI><CODE>argv</CODE>.  The variable value is an immutable vector
whose elements are strings (immutable vectors of characters)
representing arguments to the program (see implementation).</LI>
<LI><CODE>env</CODE>.  The variable value is immutable table whose
elements are strings (immutable vectors of characters)
representing values of environment variables whose names are
the keys of the table.</LI>
</UL>
</P>

<H3>Versions</H3>

<P>As Dino is a live programming language, it and its interpreter are in
the process of development.  To access the Dino interpreter's version
number and the language version, the final variables
<CODE>version</CODE> and <CODE>lang_version</CODE> can be used
correspondingly.  The variable values are the Dino versions as
floating point numbers.  For example, if the current Dino interpreter
version is 0.97 and the Dino language version is 0.5, the variable
values will be 0.97 and 0.5.</P>

<H3>Threads</H3>

<P>To access some information about threads in Dino program, the
following variables can be used.
<UL>
<LI><CODE>main_thread</CODE>.  The variable value is the main
thread.  When the program starts, there is only one thread
which is called <EM>the main thread</EM>.</LI>
<LI><CODE>curr_thread</CODE>.  The variable value is the thread in
which you reference the variable.</LI>
</UL>

All these variables are final, so you can not change their values.</P>

<H3>Exception classes</H3>

<P>All predeclared classes in space <CODE>lang</CODE> describe exceptions
which may be generated in Dino program.  All Dino exceptions are
represented by objects of the predeclared class <CODE>except</CODE> or of
a sub-class of the class <CODE>except</CODE>.  The class <CODE>except</CODE>
has no parameters.  There is one predeclared sub-class
<CODE>error</CODE> of class <CODE>except</CODE>.  All classes corresponding to
user-defined exceptions are suggested to be declared as
sub-class <CODE>except</CODE>.  All other exceptions (e.g. generated by
the Dino interpreter itself or by predeclared functions) are objects
of the class <CODE>error</CODE> or predeclared classes which are
sub-classes of <CODE>error</CODE>.  The class
<CODE>error</CODE> and all its sub-classes has one parameter
<CODE>msg</CODE> which contains a readable message about the exception.
The following classes are declared in space <CODE>lang</CODE> as sub-class
of <CODE>error</CODE>:
<UL>
<LI><CODE>invop</CODE>.  The following sub-classes of this class
describe exceptions when operands of operations have an
incorrect type or value.
<UL>
<LI><CODE>optype</CODE>.  This class describes that the operand
of an operation is not of the required type (possibly after
implicit conversions).</LI>
<LI><CODE>opvalue</CODE>.  This class is reserved for the error
of that an operand of an operation has invalid value.</LI>
</UL>
</LI>
<LI><CODE>invindex</CODE>.  Sub-classes of this class describe
exceptions in referring for a vector element.
<UL>
<LI><CODE>indextype</CODE>.  This class describes that the
index is not of integer type (possibly after implicit
integer conversion).</LI>
<LI><CODE>indexvalue</CODE>.  This class describes that the
index is negative or equal to or more than the vector
length.</LI>
<LI><CODE>indexop</CODE>.  This class describes that the first
operand in referring to a vector element is not a vector.</LI>
</UL>
</LI>
<LI><CODE>invslice</CODE>.  Sub-classes of this class describe
exceptions in referring for a vector slice.
<UL>
<LI><CODE>slicetype</CODE>.  This class describes that the
start index, bound, or step is not of integer type
(possibly after implicit integer conversion).</LI>
<LI><CODE>sliceform</CODE>.  This class describes that the
slice has a wrong form, e.g. start index is negative, step
is zero or slice is applied not to a vector.</LI>
</UL>
</LI>
<LI><CODE>invector</CODE>.  Sub-classes inside this class mostly
describe exceptions in slice operations.
<UL>
<LI><CODE>veclen</CODE>.  This class describes that operands in
a slice operator have different length.</LI>
<LI><CODE>vecform</CODE>.  This class describes that operands
in a slice operator have different dimensions.</LI>
<LI><CODE>matrixform</CODE>.  This class describes error when
matrix transposition (function <CODE>transpose</CODE>) is
applied to a vector of different length vectors.</LI>
</UL>
</LI>
<LI><CODE>invkey</CODE>.  Sub-classes inside this class describe
exceptions in referring to a table element.
<UL>
<LI><CODE>keyvalue</CODE>.  This class describes that there is
no such element in the table with the given key when we
need the value of the element.  The exception does not
occur when a table element reference stands in the left
hand side of an assignment-statement.</LI>
<LI><CODE>keyop</CODE>.  This class describes that the first
operand in referring to a table element is not a table.</LI>
</UL>
</LI>
<LI><CODE>invcall</CODE>.  Sub-classes of this class describe
exceptions in calling functions (mainly predeclared ones).
<UL>
<LI><CODE>abstrcall</CODE>.  This class describes that we try
to call declared but not defined function.</LI>
<LI><CODE>callop</CODE>.  This class describes that we try to
call something which is not a function, class, or
thread-function.  The exception is also generated when you
try to create a class <CODE>file</CODE> instance by calling the
class.</LI>
<LI><CODE>partype</CODE>.  This class describes that a
parameter value of a predeclared function is not of
required type.</LI>
<LI><CODE>parvalue</CODE>.  This class describes that a
parameter value of a predeclared function is not one of
permitted values (see functions <CODE>set_encoding</CODE>,
<CODE>set_file_encoding</CODE>).</LI>
<LI><CODE>parnumber</CODE>.  This class describes that the
number of actual parameters is not valid when we call a
predeclared function.</LI>
<LI><CODE>syncthreadcall</CODE>.  This class describes that the
a thread call occurs inside a critical region -- see wait-statement.</LI>
<LI><CODE>invresult</CODE>.  This class describes that the
result value of function call is not of required type,
e.g. comparison function used in a call of function
<CODE>sort</CODE> returns a non integer value.</LI>
<LI><CODE>internal</CODE>.  This class describes all other
(nonspecified) exceptions in calling predeclared functions.</LI>
</UL>
</LI>
<LI><CODE>invaccess</CODE>.  Sub-classes of this class describe
exceptions in accessing or changing values.
<UL>
<LI><CODE>accessop</CODE>.  This class describes that a given
class declaration can not be found or is private when
accessing to it through the corresponding object.</LI>
<LI><CODE>accessvalue</CODE>.  This class describes that we try
to access to declared but not defined through the
corresponding object -- see <EM>abstract classes</EM>.</LI>
<LI><CODE>immutable</CODE>.  This class describes that we try
to change an immutable value.</LI>
<LI><CODE>patternmatch</CODE>.  This class describes that the
pattern in a variable declaration does not match the
assigned value.</LI>
</UL>
</LI>
<LI><CODE>deadlock</CODE>.  This class describes that a deadlock is
recognized in multi-threaded program.</LI>
<LI><CODE>syncwait</CODE>.  This class describes that we try to
execute a wait-stmt inside a critical region.</LI>
</UL>
</P>

<H3>Functions of space <CODE>lang</CODE></H3>

<P>The following functions are declared in space <CODE>lang</CODE>:
<UL>
<LI><CODE>tolower (str)</CODE>.  The function expects that the
parameter <CODE>str</CODE> (after implicit string conversion) is a
string.  The function returns new string <CODE>str</CODE> in which
upper case letters are changed to the corresponding lower case
letters.</LI>
<LI><CODE>toupper (str)</CODE>.  The function expects that
the parameter <CODE>str</CODE> (after implicit string conversion) is
a string.  The function returns the new string <CODE>str</CODE> in which
lower case letters are changed to the corresponding upper case
letters.</LI>
<LI><CODE>translit (str, what, subst)</CODE>.  The function
transliterates charactes in a string.  The function expects
that the parameters <CODE>str</CODE> (after implicit string
conversion), <CODE>what</CODE>, and <CODE>subst</CODE> are strings.
The function returns the new string <CODE>str</CODE> in which its
characters which are present in <CODE>what</CODE> are changed to
the corresponding characters in <CODE>subst</CODE>.  The last two
strings should have the same length.  The second string may
contain more than one occurence of a character.  In this case
the last correspondence is taken.</LI>
<LI><CODE>eltype (vect)</CODE>.  The function expects that the
parameter value is a vector.  The function returns <CODE>nil</CODE>
if the vector is heterogenous, otherwise the function returns
the type of the vector elements (type of <CODE>nil</CODE> if the
vector is empty).</LI>
<LI><CODE>keys (tab)</CODE>.  The function expects that the
parameter value is a table.  The function returns a new mutable
vector containing all the keys in the table.  The order of keys
in the vector is undefined.</LI>
<LI><CODE>closure (par)</CODE>.  The function accepts any parameter
value.  If the parameter value is object or a block instance of
a function, function <CODE>closure</CODE> returns the corresponding
class or function which contains also its context.  That is why
it is called closure.  In all other cases, the function
returns <CODE>nil</CODE>.</LI>
<LI><CODE>context (par)</CODE>. The function returns the context
(see section <EM>Declarations and Scope Rules</EM>) represented
by a block instance or an object for the given parameter value
which should be a function, a class, a thread, a block
instance, or an object.</LI>
<LI><CODE>inside (par1, par2[, flag])</CODE>.  The goal for
function usage is to check that something is declared inside
something other.  If the third parameter value after implicit
integer conversion is given and nonzero, it is checked with
taking contexts into account.  The second parameter value
should be a function, class, object, or a block instance.  In
the last two cases of the second parameter value, the
corresponding class, function, or block is used.  The first
parameter value should be a function, a class, an object, or a
block instance.  In the last two cases, they define
corresponding a function, class, or block.  If the function,
class, or block defined by the first parameter is declared
inside the function, class, or block given by the second
parameter, the function <CODE>inside</CODE> returns 1.  The
function <CODE>inside</CODE> also returns 1 if the function, class,
or block defined by the first parameter is the same as the
function, class, or block given by the second parameter.
Otherwise the function <CODE>inside</CODE> returns 0.  The
following example illustrates the difference between checking
with taking contexts into account and without it.
<BLOCKQUOTE><CODE>
<PRE>
          class c () {
            class subc () {
            }
          }
          inside (c ().subc (), c ().subc);  // returns 1
          inside (c ().subc (), c ().subc, 1); // returns 0
</PRE>
</CODE></BLOCKQUOTE>

The first call of <CODE>inside</CODE> returns 1, while the second
one returns 0.</LI>
<LI><CODE>isa (fco, fc)</CODE>.  The goal for function usage is to
check that function, class, or object given by the first
parameter <CODE>fco</CODE> uses declarations (through a use-clause)
of a function or a class given by the second
parameter <CODE>fc</CODE>, in other words the first is a subtype of
the second.  If it is true, the function returns 1, otherwise
it returns zero.  If the parameter types are wrong, the
function generates exception <CODE>partype</CODE>.  The following
example illustrates usage of <CODE>isa</CODE>.
<BLOCKQUOTE><CODE>
<PRE>
          class c () {}
          class subc () { use c;}
          isa (subc, c);
          isa (subc (), c);
</PRE>
</CODE></BLOCKQUOTE>

The calls of <CODE>isa</CODE> in the example return 1.</LI>
<LI><CODE>subv (vect, index[, length])</CODE>.  The function is
used to extract a sub-vector.  The first parameter value should
be a vector after implicit string conversion.  The second and
third parameter values should be integers after implicit
integer conversion. The function extracts only an element or
the part of the sub-vector existing in the vector (so you can use
any values of the index and the length).  ?If index is
negative, it is considered to be equal to zero.  If the length
is negative, the sub-vector will finish on the vector end.  The
function returns a new vector which is the sub-vector.  The result
vector is immutable only when the original vector is immutable.</LI>
<LI><CODE>del (vect, index[, length]) or del (tab, key)</CODE>.
The first form of the function is used to remove the vector
element or a sub-vector from the mutable vector
<CODE>vect</CODE>.  The second and the third parameter values
should be integers after implicit integer conversion.  The
function removes only an element or the part of the sub-vector
existing in the vector (so you can use any values of the index
and the length).  ?If index is negative, it is considered to be
equal to zero.  If the length is negative, the sub-vector will
finish on the vector end.  The second form of the function is
used to remove the element (if it exists) with the given key
from the mutable table.  The function generates the exception
<CODE>immutable</CODE> if we are trying to remove from an immutable
vector or table.  The function returns the modified vector.</LI>
<LI><CODE>ins (vect, el[, index])</CODE>.  The function inserts the
element given by the second parameter into the vector given by
the first parameter on the place given by the third parameter.
If the third parameter is not given it is believed to be zero.
The third parameter should be an integer after implicit integer
conversion.  ?If the third parameter is negative or equal to or
greater than the vector length, the element is inserted at the
end of the vector.  The function generates the exception
<CODE>immutable</CODE> if we are trying to insert into an immutable
vector.  The function returns the modified vector.</LI>
<LI><CODE>insv (vect, vect[, index])</CODE>.  The function is
analogous to the function <CODE>ins</CODE> but it is used for
insertion of all vector elements into the vector given as the
first parameter.  So the second parameter value should be a
vector.  The function returns the modified vector.</LI>
<LI><CODE>rev (vect)</CODE>.  The function returns reversion of the
given vector.</LI>
<LI><CODE>cmpv (vect, vect)</CODE>.  The function makes implicit
string conversion of the parameter values.  After that, the
parameter values should be vectors whose first corresponding
equal elements should have the same type (character, integer,
or floating point type).  The first corresponding unequal
elements should have the same type too (the remaining elements
can have different type).  As usual, if this is not true,
exception <CODE>partype</CODE> is generated.  The function returns
1 if the first unequal element value of the first vector is
greater than the corresponding element in the second vector, -1
if less, and 0 if the all corresponding vector elements are
equal.  If the first vector is a prefix of the second vector,
the function returns -1.  If the second vector is a prefix of
the first vector, the function returns 1, so it is in fact
generalized lexicographical order.</LI>
<LI><CODE>filter (f, v [, d])</CODE>.  The function expects
function <CODE>f</CODE>, vector <CODE>v</CODE>, and optional
integer <CODE>d</CODE> after integer conversion.  Otherwise
exception <CODE>partype</CODE> is generated.  If <CODE>d</CODE> is not
given, it is believed to be 1.  The function processes v's
elements if <CODE>d</CODE> is equal one, elements of vectors which
are v's elements if <CODE>d</CODE> is equal to 2 and so on.  In
other words, <CODE>d</CODE> is level on which vector elements are
processed.  If v has no structure necessary for processing,
exception <CODE>vecform</CODE> is generated.  If <CODE>d</CODE> is zero
or negative, the function just returns <CODE>v</CODE>.  Otherwise
the function creates new mutable vector having the same
structure as <CODE>v</CODE> with only elements on level <CODE>d</CODE>
for which function <CODE>f</CODE> returns nonzero value after
integer conversion.  If the result of function <CODE>f</CODE> after
the integer conversion is not integer,
exception <CODE>invresult</CODE> is generated.  The following
example illustrates usage of <CODE>filter</CODE>.
<BLOCKQUOTE><CODE>
<PRE>
          var i, v = [0, 1, -2, 3, -4];
          println (filter (fun (a) {a > 0;}, v));
          v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
          println (filter (fun (a) {a > 0;}, v, 2));
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI><CODE>map (f, v [, d])</CODE>.  The meaning of function
parameters and constraints to their values are analogous to
ones of function <CODE>filter</CODE>.  Only function <CODE>f</CODE> can
return any value.  The elements processed by
function <CODE>f</CODE> is changed onto the result of
function <CODE>f</CODE>.  The following example illustrates usage
of <CODE>map</CODE>.
<BLOCKQUOTE><CODE>
<PRE>
          var i, v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
          println (map (fun (a) {a &lt; 0 ? nil : a;}, v, 2));
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI><CODE>fold (f, v, init [, d])</CODE>.  The meaning of function
parameters <CODE>f</CODE>, <CODE>v</CODE>, and <CODE>d</CODE> and
constraints to their values are analogous to ones of
function <CODE>filter</CODE>.  The function processes all elements
of vectors on level <CODE>d</CODE> and returns value
<CODE>f (f (f (f (init, el0), el1), ...) , eln)</CODE> where
<CODE>el0</CODE>, ..., <CODE>eln</CODE> are vector elements on
level <CODE>d</CODE> taken from left to right.  If <CODE>d</CODE> is
zero or negative or the vectors are empty, the function
returns <CODE>init</CODE>.  The following example illustrates usage
of <CODE>fold</CODE>.
<BLOCKQUOTE><CODE>
<PRE>
          var v = [1,2,3,4];
          println (fold (fun (a, b) {a + b;}, v, 0));
</PRE>
</CODE></BLOCKQUOTE>
 </LI>
<LI><CODE>sort (vect[, compare_function])</CODE>.  The function
returns a new sorted vector.  The original vector given as the
first parameter value should be a homogeneous vector whose
elements are of character, integer, long integer, or floating
point type.  If the second parameter is not given, standard
arithmetic order (see comparison operators) is used.  To use
special ordering, use the second parameter which should be a
function which compares two elements of the vector and returns
a negative integer if the first parameter value (element) is
less than the second one, a positive integer if the first
parameter value is greater than the second one, and zero if
they are equal.</LI>
<LI><CODE>transpose (m)</CODE>.  The function expects
matrix <CODE>m</CODE>.  It means that <CODE>m</CODE> should be vector
(each element is a matrix row) of vectors of equal length.
If <CODE>m</CODE> is not a vector, exception <CODE>partype</CODE> is
generated.  If elements of <CODE>m</CODE> are not vectors of the
same length, exceptions <CODE>matrixform</CODE> is generated.  The
function returns a new mutable vector of mutable vectors which
is a matrix transposition of <CODE>m</CODE>.</LI>
<LI><CODE>gc ()</CODE>.  The function forces garbage collection and
heap compaction.  Usually the Dino interpreter itself invokes
garbage collection when there is no more free memory.</LI>
<LI><CODE>exit (code)</CODE>.  The function finishes the work of
the interpreter with the given code which should be an integer
value after implicit integer conversion.</LI>
</UL>
</P>

<H2><A NAME="ss9.2">9.2</A> <A HREF="dino.html#toc9.2">Space <CODE>io</CODE></A>
</H2>

<P>The space contains functions for input and output and for work with
files and directories.  All declarations of the space are always
exposed.</P>

<H3>Exception classes of space <CODE>io</CODE></H3>

<P>The following classes are declared in space <CODE>io</CODE> as sub-classes
of <CODE>invcall</CODE>:
<UL>
<LI><CODE>invinput</CODE>.  This class describes that the file
input is not of required format.  Usually the exception is
generated by function <CODE>scan</CODE> etc.</LI>
<LI><CODE>invfmt</CODE>.  This class describes that a format of a
format output function is wrong (see function <CODE>putf</CODE>).</LI>
<LI><CODE>eof</CODE>.  This class describes that end of file is
encountered.  Usually the exception is generated by functions
reading files (<CODE>get</CODE>, <CODE>scan</CODE> etc).</LI>
<LI><CODE>invencoding</CODE>.  This class describes different
exceptions with used encodings, e.g. file contains bytes not
corresponding to the expected encoding or in some cases the
encoding should contain ASCII characters.</LI>
</UL>
</P>

<H3>Class <CODE>file</CODE></H3>

<P>Dino has predeclared final class <CODE>file</CODE>.  Work with files in
Dino program are made through objects of the class.  All declarations
inside of class are private.  The objects of the class can be created
only by predeclared functions <CODE>open</CODE> or <CODE>popen</CODE>.  If you
create an object of the class by calling the class, exception
<CODE>callop</CODE> will be generated.  File encoding is defined by the
current DINO encoding at the file creation time (see
functions <CODE>set_encoding</CODE>, <CODE>set_file_encoding</CODE>).  If you
want to work with files on the byte level without any encoding
decoding, you can use encoding called <CODE>"RAW"</CODE>.</P>

<H3>Files</H3>

<P>To output something into standard streams or to input something from
the standard input stream, the following variables can be used:
<UL>
<LI><CODE>stdin</CODE>.  The variable value is an object of the
class <CODE>file</CODE> which corresponds to the standard input
stream.</LI>
<LI><CODE>stdout</CODE>.  The variable value is an object of the
class <CODE>file</CODE> which corresponds to the standard output
stream.</LI>
<LI><CODE>stderr</CODE>.  The variable value is an object of the
class <CODE>file</CODE> which corresponds to the standard error
stream.</LI>
</UL>

All these variables are final, so you can not change their values.
Encoding of the files is DINO current encoding at the program start
(see function <CODE>set_encoding</CODE>).</P>

<H3>Functions for work with files</H3>

<P>The following functions (besides input/output functions) work with OS
files.  The functions may generate an exception declared in the class
<CODE>syserror</CODE> (e.g. <CODE>eaccess</CODE>, <CODE>enametoolong</CODE>,
<CODE>eisdir</CODE> and so on) besides the standard <CODE>partype</CODE>,
and <CODE>parnumber</CODE>.  The function <CODE>rename</CODE> can be used for
renaming a directory, not only a file.
<UL>
<LI><CODE>rename (old_path, new_path)</CODE>.  The function renames
the file (directory) given by its path name.  The old and new
names are given by parameter values which should be strings
after implicit string conversion.</LI>
<LI><CODE>remove (file_path)</CODE>.  The function removes the OS
file given by its path name.  The file path name should be a
string after implicit string conversion.</LI>
<LI><CODE>open (file_path, mode)</CODE>.  The function opens the
file for work in the given <EM>mode</EM>, creates a new class
<CODE>file</CODE> instance, associates the opened file with the
instance, and returns the instance.  The parameter values
should be strings after implicit string conversions.  The first
parameter value is a string representing the file path.  The
second parameter value is string representing the mode for work
with the file (for all possible modes see the ANSI C function
<CODE>fopen</CODE> documentation).  All work with an opened file is
made through the file instance.</LI>
<LI><CODE>close (fileinstance)</CODE>.  The function closes a file
opened by the function <CODE>open</CODE>.  The file is given by the
class <CODE>file</CODE> instance.  The function also removes all
association of the instance with the file.</LI>
<LI><CODE>flush (fileinstance)</CODE>.  The function flushes any
output that has been buffered for the opened file given by
the class <CODE>file</CODE> instance.</LI>
<LI><CODE>popen (command, mode)</CODE>.  The function starts the
shell command given by the first parameter value (which should
be a string after implicit string conversion), creates a pipe,
creates a new class <CODE>file</CODE> instance, associates the pipe
with the instance, and returns the instance.  Writing to such a
pipe (through the class file instance) writes to the standard
input of the command.  Conversely, reading from the pipe reads
the command's standard output.  After implicit string
conversion the second parameter value should be the string "r"
(for reading from the pipe) or "w" (for writing to the pipe).
The pipe should be closed by the function <CODE>pclose</CODE>.</LI>
<LI><CODE>pclose (fileinstance)</CODE>.  The function waits for the
command connected to a pipe to terminate.  The pipe is given by
the class <CODE>file</CODE> instance returned by the function
<CODE>popen</CODE>.  The function also removes the association of
the instance with the pipe.</LI>
<LI><CODE>tell (fileinstance)</CODE>.  The function returns the
current value of the file position indicator for the file
(opened by function <CODE>open</CODE>) given by the class
<CODE>file</CODE> instance.</LI>
<LI><CODE>seek (fileinstance, offset, whence)</CODE>.  The function
sets up the current file position indicator for the file
(opened by function <CODE>open</CODE>) given by the class
<CODE>file</CODE> instance.  The position is given by
<CODE>offset</CODE> which should be an integer after implicit
arithmetic conversion and <CODE>whence</CODE> which should be a
string after implicit string conversion.  The first character
of the string should be <CODE>'s'</CODE>, <CODE>'c'</CODE>, or
<CODE>'e'</CODE> (these characters mean that the offset is relative
to the start of the file, the current position indicator, or
the end-of-file, respectively).</LI>
<LI><CODE>get_file_encoding (fileinstance)</CODE>.  The function
returns a new mutable string which is a name of the current file
encoding.</LI>
<LI><CODE>set_file_encoding (fileinstance, name)</CODE>.  The
accepts file and string and changes the current file encoding.
If the name represents unknown encoding name, the function
generates exceptions <CODE>parvalue</CODE>.</LI>
</UL>
</P>

<H3>File output functions</H3>

<P>The following functions are used to output something into opened
files.  All the function return values are undefined.  The
functions may generate an exception declared in the class <CODE>syserror</CODE>
(e.g. <CODE>eio</CODE>, <CODE>enospc</CODE> and so on) besides the standard
<CODE>partype</CODE>, and <CODE>parnumber</CODE>.
<UL>
<LI><CODE>put (...)</CODE>.  All parameters should be strings after
implicit string conversion.  The function outputs all strings
into the standard output stream.</LI>
<LI><CODE>putln (...)</CODE>.  The function is analogous to the
function <CODE>put</CODE> except for the fact that it additionally
outputs a new line character after output of all the strings.</LI>
<LI><CODE>fput (fileinstance, ...)</CODE>.  The function is
analogous to the function <CODE>put</CODE> except for the fact that
it outputs the string into an opened file associated with a
class <CODE>file</CODE> instance which is the first parameter
value.</LI>
<LI><CODE>fputln (fileinstance, ...)</CODE>.  The function is
analogous to function <CODE>fput</CODE> except for the fact that it
additionally outputs a new line character after output of all
the strings.
</LI>
<LI><CODE>putf (format, ...)</CODE>.  The first parameter should be
strings after implicit string conversion.  The function outputs
the rest of parameters according to the format.  The number of
the rest parameters should be exactly equal to the conversions
(including parameterized widths and precisions) in the format.
Otherwise, exception <CODE>parnumber</CODE> will be generated.  The
types of the parameter should correspond to the corresponding
conversion specifier (or to be integer for parameterized widths
and precisions).  If it is not true, exception <CODE>partype</CODE>
will be generated.  The format is subset of one of standard C
function <CODE>printf</CODE> and has the following syntax:
<BLOCKQUOTE><CODE>
<PRE>
          format : &lt;any character except %>
                 | '%' flags [width] [precision]
                       conversion_specifier
          flags :
                | flag

          flag : '#' | '0' | '-' | ' ' | '+'

          width : '*' | &lt;decimal number starting with non-zero>

          precision : '.' ['*' | &lt;decimal number>]

          conversion_specifier : 'd' | 'o' | 'x' | 'X'
                               | 'e' | 'E' | 'f' | 'g'
                               | 'G' | 'c' | 's' | '%'
       
</PRE>
</CODE></BLOCKQUOTE>

If the format syntax is wrong, exception <CODE>invfmt</CODE> is
generated.

Flag '#' means that the value should be converted into an
alternative form.  It can be present only for conversion
specifiers 'o', 'x', 'X', 'e', 'E', 'f', 'g', and 'G'.  If the
flag is used for conversion specifier 'o', the output will be
prefixed by '0'.  For 'x' and 'X' the output will be prefixed
by '0x' and '0X' correspondingly. For conversions 'e', 'E',
'f', 'g', and 'G' the output will always contain a decimal
point.  For conversions 'g' and 'G' it also means that trailing
zeros are not removed from the output as they would be without
the flag.  The following code using flag '#' in format
<BLOCKQUOTE><CODE>
<PRE>
         putf ("->%#o %#x %#x %#.0e %#.0f %#g&lt;-\n",
               8, 10, 16l, 2., 3., 4.);
</PRE>
</CODE></BLOCKQUOTE>

will output
<BLOCKQUOTE><CODE>
<PRE>
         ->010 0xa 0x10 2.e+00 3. 4.00000&lt;-
</PRE>
</CODE></BLOCKQUOTE>


Flag '0' means that the output value will be zero padded on the
left. If both flags '0' and '-' appear, the flag '0' is
ignored.  It is also ignored for conversions 'd', 'o', 'x', and
'X' if a precision is given.  The flag is prohibited for
conversions 'c' and 's'.  The following code using flag '0' in
format
<BLOCKQUOTE><CODE>
<PRE>
         putf ("->%04d %04x %04x %09.2e %05.2f %05.2g&lt;-\n",
               8, 10, 16l, 2., 3., 4.);
</PRE>
</CODE></BLOCKQUOTE>

will output
<BLOCKQUOTE><CODE>
<PRE>
         ->0008 000a 0010 02.00e+00 03.00 00004&lt;-
</PRE>
</CODE></BLOCKQUOTE>


Flag '-' means that the output will be left adjusted on the
field boundary.  (The default is right justification). Flag '-'
overrides flag '0' if the both are given.  The following code
using flag '-' in format
<BLOCKQUOTE><CODE>
<PRE>
         putf ("->%-04d %-04x %-04x %-09.2e %-05.2f %-05.2g&lt;-\n",
               8, 10, 16l, 2., 3., 4.);
</PRE>
</CODE></BLOCKQUOTE>

will output
<BLOCKQUOTE><CODE>
<PRE>
         ->8    a    10    2.00e+00  3.00  4    &lt;-
</PRE>
</CODE></BLOCKQUOTE>


Flag ' ' means that the output of a signed number will start
with a blank for positives number.  The flag can be used only
for conversions 'd', 'e', 'E', 'f', 'g', and 'G'.  If both
flags ' ' and '+' appear, the flag ' ' is ignored.  The
following code using flag ' ' in format
<BLOCKQUOTE><CODE>
<PRE>
         putf ("->% d % d % .2e % .2f % .2g&lt;-\n",
               8, 16l, 2., 3., 4.);
</PRE>
</CODE></BLOCKQUOTE>

will output
<BLOCKQUOTE><CODE>
<PRE>
         -> 8  16  2.00e+00  3.00  4&lt;-
</PRE>
</CODE></BLOCKQUOTE>


Flag '+' means that the output of a signed number will start
with a plus for positives number.  The flag can be used only
for conversions 'd', 'e', 'E', 'f', 'g', and 'G'.  Flag '+'
overrides flag ' ' if both are given.  The following code using
flag '+' in format
<BLOCKQUOTE><CODE>
<PRE>
         putf ("->%+d %+d %+.2e %+.2f %+.2g&lt;-\n",
               8, 16l, 2., 3., 4.);
</PRE>
</CODE></BLOCKQUOTE>

will output
<BLOCKQUOTE><CODE>
<PRE>
         ->+8 +16 +2.00e+00 +3.00 +4&lt;-
</PRE>
</CODE></BLOCKQUOTE>


The width defines a minimum width of the output value.  If the
output is smaller, it is padded with spaces (or zeros -- see
flag '0') on the left (if flag '-' is used) or right.  The
output is never truncated.  The width should be no more than
maximal integer value, otherwise exception <CODE>invfmt</CODE> is
generated.  The width can be given as a parameter of integer
type if '*' is used.  If the value of width given by the
parameter is negative, flag '-' is believed to be given and the
width is believed to be equal to zero.  The following code
using width in format
<BLOCKQUOTE><CODE>
<PRE>
         putf ("->%5d %05d %-5d %5d %*d %*d&lt;-\n",
               8, 9, 10, 16l, 5, 8, -5, 10);
</PRE>
</CODE></BLOCKQUOTE>

will output
<BLOCKQUOTE><CODE>
<PRE>
         ->    8 00009 10       16     8 10   &lt;-
</PRE>
</CODE></BLOCKQUOTE>


The precision is prohibited for conversions 'c'.  If the number
after the period is absent, its value will be zero.  The
precision can be given as a parameter of integer type if '*' is
used after the period.  If the value of precision given by the
parameter is negative, its value is believed to be zero too.
For conversions 'd', 'o', 'x', and 'X' the precision means
minimum number of output digits.  For conversions 'e', 'E', and
'f' it means the number of digits to appear after the decimal
point.  For 'g' and 'G' it means the maximum number of
significant digits.  For 's' it means the maximum number of
characters to be output from a string.  The following code
using precision in format
<BLOCKQUOTE><CODE>
<PRE>
         putf ("->%.d %.0d %.5d %.d %.0f %.0e %.2g&lt;-\n",
               8, 8, 9, 16l, 2.3, 2.3, 3.53);
         putf ("->%.2s %.0d %.*d %.*d %.*d&lt;-\n",
               "long", 0, 5, 8, -5, 8, 5, 16l);
</PRE>
</CODE></BLOCKQUOTE>

will output
<BLOCKQUOTE><CODE>
<PRE>
         ->8 8 00009 16 2 2e+00 3.5&lt;-
         ->lo  00008 8 00016&lt;-
</PRE>
</CODE></BLOCKQUOTE>


Conversion 'd' should be used to output integer or long
integer.  The default precision is 1.  When 0 is output with an
explicit precision 0, the output is empty.

Conversions 'o', 'x', and 'X' should be used to output an
integer or long integer value as unsigned in octal and
hexadecimal form.  The lower case letters <CODE>abcdef</CODE> are
used for 'x' and the upper case letters <CODE>ABCDEF</CODE> are
used for 'X'.  The precision gives the minimum number of digits
that must appear. If the output value requires fewer digits, it
is padded on the left with zeros.  The default precision is 1.
When 0 is output with an explicit precision 0, the output is
empty.

Conversion 'f' should be used to output floating point values.
The output value has a form <CODE>[-]ddd.ddd</CODE> where the
number of digits after the decimal point is given by the
precision specification.  The default precision value is 6.  If
the precision is explicitly zero, no decimal-point character
appears.

Conversions 'e' and 'E' should be used to output floating point
values with an exponent in form <CODE>[-]d.ddd[e|E][+|-]dd</CODE>.
There is always one digit before the decimal-point.  The number
of digits after the decimal point is defined by the precision.
The default precision value is 6.  If the precision is zero, no
decimal-point appears.  Conversion 'E' uses the letter
<CODE>E</CODE> (rather than <CODE>e</CODE>) to introduce the exponent.
The exponent always contains at least two digits.  If the
exponent value is zero, the exponent is output as <CODE>00</CODE>.

Conversions 'g' and 'G' should be used to output floating point
values in style 'f' or 'e' (or 'E' for conversion 'G').  The
precision defines the number of significant digits.  The
default value of the precision is 6.  If the precision is zero,
it is treated as 1.  Conversion 'e' is used if the exponent
from the conversion is less than -4 or not less than the
precision.  Trailing zeros are removed from the fractional part
of the output.  If all fractional part is zero, the decimal
point is removed too.

Conversion 'c' should be used to output a character value.

Conversion 's' should be used to output strings.

Conversion '%' should be used to output <CODE>%</CODE>.

The following code using different conversions in format
<BLOCKQUOTE><CODE>
<PRE>
         putf ("->%% %c %s %d %o %x %X %d %o %x %X&lt;-\n",
               'c', "string", 7, 8, 20, 20, 8l, 9l, 21l, 21l);
         putf ("->%f&lt;-\n", 1.5);
         putf ("->%e %E %g %G %g %G&lt;-\n",
               2.8, 2.8, 3.7, 3.7, 455555555.555, 5.9e-5);
</PRE>
</CODE></BLOCKQUOTE>

will output
<BLOCKQUOTE><CODE>
<PRE>
         ->% c string 7 10 14 14 8 11 15 15&lt;-
         ->1.500000&lt;-
         ->2.800000e+00 2.800000E+00 3.7 3.7 4.55556e+08 5.9E-05&lt;-
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI><CODE>fput (fileinstance, format, ...)</CODE>.  The function is
analogous to the function <CODE>putf</CODE> except for the fact that
it outputs the string into an opened file associated with a
class <CODE>file</CODE> instance which is the first parameter
value.</LI>
<LI><CODE>print (...)</CODE>.  The function outputs all parameter
values into standard output stream.  The function never makes
implicit conversions of the parameter values.  The parameter
values are output as they could be represented in Dino itself
(e.g. character <CODE>'c'</CODE> is output as <CODE>'c'</CODE>, vector
<CODE>['a', 'b', 'c']</CODE> is output as <CODE>"abc"</CODE>, vector
<CODE>[10, 20]</CODE> as <CODE>[10, 20]</CODE> and so on).  As you know
some values (functions, classes, block instances, class
instances, threads) are not represented fully in DINO.  Such
values are represented schematically.  For example, the output
<CODE>fun f {}.g(unique_number)</CODE> would mean function
<CODE>f</CODE> in the call of function (or class) <CODE>g</CODE> with
the given unique number and function g is in the instance of
the implicit block covering the whole program.  For the
function <CODE>g</CODE>, output would look simply like <CODE>fun
g</CODE> because there is only one instance of the implicit block
covering the whole program.  Output for an instance of the
class <CODE>c</CODE> in the function <CODE>f</CODE> looks like
<CODE>instance {}.f(unique_number).c(unique_number)</CODE>.  Output
for a block instance of the function <CODE>f</CODE> looks like
<CODE>stack {}.f(unique_number)</CODE>.  Output for a thread whose
thread-function <CODE>t</CODE> is declared in the function
<CODE>f</CODE> would look like <CODE>thread unique_number
{}.f(unique_number).t(unique_number)</CODE>.</LI>
<LI><CODE>println (...)</CODE>.  The function is analogous to the
function <CODE>print</CODE> except for the fact that it
additionally outputs new line character after output of all
parameters.</LI>
<LI><CODE>fprint (fileinstance, ...)</CODE>.  The function is
analogous to the function <CODE>print</CODE> except for the fact
that it outputs the parameters into an opened file associated
with a class <CODE>file</CODE> instance which is the value of first
parameter.</LI>
<LI><CODE>fprintln (fileinstance, ...)</CODE>.  The function is
analogous to function <CODE>fprint</CODE> except for the fact that
it additionally outputs a new line character after the output
of all the parameters.</LI>
</UL>
</P>

<H3>File input functions</H3>

<P>The following functions are used to input something from opened files.
The functions may generate an exception declared in the
class <CODE>syserror</CODE> (e.g. <CODE>eio</CODE>, <CODE>enospc</CODE> and so on)
or <CODE>eof</CODE> besides the standard <CODE>partype</CODE>,
and <CODE>parnumber</CODE>.
<UL>
<LI><CODE>get ()</CODE>.  The function reads one character from
standard input stream and returns it.  The function generates
the exception <CODE>eof</CODE> if the function tries to read the
end of file.</LI>
<LI><CODE>getln ()</CODE>.  The function reads one line from
standard input stream and returns it as a new string.  The end
of line is the newline character or end of file.  The returned
string does not contain the newline character.  The function
generates the exception <CODE>eof</CODE> only when the file
position indicator before the function call stands exactly on
the end of file.</LI>
<LI><CODE>getf ([ln_flag])</CODE>.  The function reads the whole
standard input stream and returns it as a new string.  The
function generates the exception <CODE>eof</CODE> only when the
file position indicator before the function call stands exactly
on the end of file.  The function has an optional parameter
which should be integer after implicit integer conversion.  If
the parameter value is nonzero, the function returns a vector
of strings.  Otherwise it behaves as usually.  Each string is a
line in the input stream.  The strings do not contain the
newline character.</LI>
<LI><CODE>fget (fileinstance)</CODE>.  The function is analogous to
function <CODE>get</CODE> except for the fact that it reads from an
opened file associated with the class <CODE>file</CODE> instance
which is the parameter's value.</LI>
<LI><CODE>fgetln (fileinstance)</CODE>.  The function is analogous
to the function <CODE>getln</CODE> except for the fact that it
reads from an opened file associated with a class <CODE>file</CODE>
instance which is the parameter value.</LI>
<LI><CODE>fgetf (fileinstance [, ln_flag])</CODE>.  The function is
analogous to the function <CODE>getf</CODE> except for the fact
that it reads from an opened file associated with a class
<CODE>file</CODE> instance which is the parameter's value.</LI>
<LI><CODE>scan ()</CODE>.  The functions reads a character,
integer, floating point number, string, vector, or table and
returns it as the result.  The input values should be
represented in the file as the ones in the Dino language
(except for the fact that there should be no identifiers in the
input values and there should be no operators in the values,
although the signs <CODE>+</CODE> and <CODE>-</CODE> are possible in an
integer or floating point represenation).  The table or vector
should contains only values of types mentioned above.  The
values in the file can be separated by white characters.  If
there is an error (e.g. unbalanced brackets in a vector value)
in the read value representation the function generates the
exception <CODE>invinput</CODE>.  The functions generates the
exception <CODE>eof</CODE> if only white characters are still
unread in the file.</LI>
<LI><CODE>scanln ()</CODE>.  The function is analogous to the
function <CODE>scan</CODE> except for the fact that it skips all
characters until the end of line or the end of file after
reading the value.  Skipping is made even if the exception
<CODE>invinput</CODE> is generated.</LI>
<LI><CODE>fscan (fileinstance)</CODE>.  The function is analogous
to the function <CODE>scan</CODE> except for the fact that it reads
from an opened file associated with a class <CODE>file</CODE>
instance which is the parameter's value.</LI>
<LI><CODE>fscanln (fileinstance)</CODE>.  The function is analogous
to the function <CODE>scanln</CODE> except for that it reads from
an opened file associated with a class <CODE>file</CODE> instance
which is the parameter value.</LI>
</UL>
</P>

<H3>Encoding functions</H3>

<P>Dino internally uses Unicode for characters.  To provide communication
with the rest of world, it can use different encodings.  The default
encoding is UTF-8.  Dino has two functions to get and change the
current encoding:
<UL>
<LI><CODE>get_encoding ()</CODE>.  The function returns a new
mutable string which is a name of the current encoding.</LI>
<LI><CODE>set_encoding (name)</CODE>.  The function accepts string
and changes the current encoding.  If the name represents
unknown encoding name, the function generates
exceptions <CODE>parvalue</CODE>.</LI>
</UL>
</P>
<P>Examples:
<BLOCKQUOTE><CODE>
<PRE>
          putln (get_encoding ());
          set_encoding ("KOI8-R");
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H3>Functions for work with directories</H3>

<P>The following functions work with directories.  The functions may
generate an exception declared in class syserror
(e.g. <CODE>eaccess</CODE>, <CODE>enametoolong</CODE>, <CODE>enotdir</CODE> and so
on) besides the standard <CODE>partype</CODE>, <CODE>parnumber</CODE>.
<UL>
<LI><CODE>readdir (dirpath)</CODE>.  The function makes implicit
string conversion of the parameter value which should be a
string (directory path).  The function returns a new mutable
vector with elements which are strings representing names of
all files and sub-directories (including <CODE>"."</CODE> and
<CODE>".."</CODE> for the current and parent directory
respectively) in given directory.</LI>
<LI><CODE>mkdir (dirpath)</CODE>.  The function creates a directory
with the given name represented by a string (the parameter
value after implicit string conversion).  The directory has
read/write/execute rights for all.  You can change it with the
aid of the functions <CODE>ch*mod</CODE>.</LI>
<LI><CODE>rmdir (dirpath)</CODE>.  The function removes the
directory given by a string which is parameter value after
implicit string conversion.</LI>
<LI><CODE>getcwd ()</CODE>.  The function returns a new string
representing the full path of the current directory.</LI>
<LI><CODE>chdir (dirpath)</CODE>.  The function makes the directory
given by <CODE>dirpath</CODE> (which should be a string after
implicit string conversion) the current directory.</LI>
</UL>
</P>

<H3>Functions for access to file/directory information</H3>

<P>The following predeclared functions can be used for accessing file or
directory information.  The functions may generate an exception
declared in the class <CODE>syserror</CODE> (e.g. <CODE>eaccess</CODE>,
<CODE>enametoolong</CODE>, <CODE>enfile</CODE> and so on) besides the standard
<CODE>partype</CODE>, and <CODE>parnumber</CODE>.  The functions expect one
parameter which should be a file instance (see the predeclared class
<CODE>file</CODE>) or the path name of a file represented by a string (the
functions make implicit string conversion of the parameter).  The
single exception to this is <CODE>isatty</CODE> which expects a file
instance.
<UL>
<LI><CODE>ftype (fileinstance_or_filename)</CODE>.  The function
returns one the following characters:
<UL>
<LI><CODE>'f'</CODE>.  A regular file.</LI>
<LI><CODE>'d'</CODE>.  A directory.</LI>
<LI><CODE>'L'</CODE>.  A symbolic link.</LI>
<LI><CODE>'c'</CODE>.  A character device.</LI>
<LI><CODE>'b'</CODE>.  A block device.</LI>
<LI><CODE>'p'</CODE>.  A fifo.</LI>
<LI><CODE>'S'</CODE>.  A socket.</LI>
</UL>

Under some OSes the function never returns some of the
characters (e.g. 'c' or 'b').  The function may return nil if
it can not categorize the file as above.</LI>
<LI><CODE>fuidn (fileinstance_or_filename)</CODE>.  The function
returns new string representing name of owner of the file
(directory).  Under some OSes the function may return the new
string <CODE>"Unknown"</CODE> if there is no notion "owner" in the
OS file system.</LI>
<LI><CODE>fgrpn (fileinstance_or_filename)</CODE>.  Analogous to the
previous function except for it returns a new string
representing name of the group of the file (directory).  Under
some OSes the function may return the new string
<CODE>"Unknown"</CODE> if there is no notion "group" in the OS file
system.</LI>
<LI><CODE>fsize (fileinstance_or_filename)</CODE>.  The function
returns an integer value which is the length of the file in
bytes.</LI>
<LI><CODE>fatime (fileinstance_or_filename)</CODE>.  The function
returns integer value which is time of the last access to the
file (directory).  The time is measured in seconds since the
fixed time (usually since January 1, 1970).  See also <EM>time
functions</EM>.</LI>
<LI><CODE>fmtime (fileinstance_or_filename)</CODE>.  Analogous to
the previous functions but returns the time of the last
modification.</LI>
<LI><CODE>fctime (fileinstance_or_filename)</CODE>.  Analogous to
the previous functions but it returns the time of the last
change.  Here `change' usually means changing the file
attributes (owner, modes and so on), while `modification' means
usually changing the file itself.</LI>
<LI><CODE>fumode (fileinstance_or_filename)</CODE>.  The function
returns a new string representing the rights of the owner of
the file (directory).  The string may contain the following
characters (in the following order if the string contains more
than one character):
<UL>
<LI><CODE>'s'</CODE>.  Sticky bit of the file (directory).</LI>
<LI><CODE>'r'</CODE>.  Right to read.</LI>
<LI><CODE>'w'</CODE>.  Right to write.</LI>
<LI><CODE>'x'</CODE>.  Right to execute.</LI>
</UL>
</LI>
<LI><CODE>fgmode (fileinstance_or_filename)</CODE>.  Analogous to
the previous function except for the fact that it returns
information about the file (directory) group user rights and
that the function never returns a string containing the
character <CODE>'s'</CODE>.</LI>
<LI><CODE>fomode (fileinstance_or_filename)</CODE>.  Analogous to
the previous function except for the act that it returns
information about the rights of all other users.</LI>
<LI><CODE>isatty (fileinstance)</CODE>.  The function returns 1 if
the file instance given as a parameter is an open file
connected to a terminal and 0 otherwise.</LI>
</UL>

The following functions can be used to change rights of usage of the
file (directory) for different users.  The function expects two
strings (after implicit string conversion).  The first one is the path
name of the file (directory).  The second one is the rights.  For
instance, if the string contains a character 'r', this is right to
read (see characters used to denote different rights in the
description of the function <CODE>fumode</CODE>).  The function return
values are always undefined.
<UL>
<LI><CODE>chumod (path, mode)</CODE>.  The function sets up rights
for the file (directory) owner according to the given mode.</LI>
<LI><CODE>chgmod (path, mode)</CODE>.  Analogous to the previous
function except for the fact that it sets up rights for the
file (directory) group users and that the function ignores the
character <CODE>'s'</CODE>.</LI>
<LI><CODE>chomod (path, mode)</CODE>.  Analogous to the previous
function except for the fact that it sets up rights for all
other users.</LI>
</UL>
</P>

<H3>Miscellaneous functions</H3>

<P>There are the following miscellaneous functions in space <CODE>io</CODE>:
<UL>
<LI><CODE>sput (...), sputln (...), sputf (format, ...)</CODE> The
functions are analogous to functions put, putln, print, and
println but they return the result string instead of output of
the formed string into the standard output stream.</LI>
<LI><CODE>sprint (...), sprintln (...)</CODE>.  The functions are
analogous to functions print and println but they return the
result string instead of output of the formed string into the
standard output stream.</LI>
</UL>
</P>

<H2><A NAME="ss9.3">9.3</A> <A HREF="dino.html#toc9.3">Space <CODE>sys</CODE></A>
</H2>

<P>This space contains declarations to work work with underlying
execution environment (OS) and related exceptions.</P>

<H3>Exceptions in space <CODE>sys</CODE></H3>

<P>The space contains a lot of exceptions:
<UL>
<LI><CODE>signal</CODE>.  This class is sub-class of
class <CODE>error</CODE>.  Sub-classes of class <CODE>signal</CODE>
describe exceptions from receiving a signal from other OS
processes.  They are
<UL>
<LI><CODE>sigint</CODE>.  This class describes the exception
generated by the user's interrupt from the keyboard.</LI>
<LI><CODE>sigill</CODE>.  This class describes the exception
generated by illegal execution of an instruction .</LI>
<LI><CODE>sigabrt</CODE>.  This class describes the exception
generated by the signal abort.</LI>
<LI><CODE>sigfpe</CODE>.  This class describes floating point
exception.</LI>
<LI><CODE>sigterm</CODE>.  This class describes the exception
generated by the termination signal.</LI>
<LI><CODE>sigsegv</CODE>.  This class describes the exception
generated by an invalid memory reference.</LI>
</UL>
</LI>
<LI><CODE>invenv</CODE>.  This class is sub-class of
class <CODE>error</CODE>.  Class <CODE>invenv</CODE> describes
corruption of the Dino program environment (see predeclared
variable <CODE>env</CODE>).</LI>
<LI><CODE>syserror</CODE>.  This class is sub-class of
class <CODE>invcall</CODE>.  Sub-classes of class <CODE>syserror</CODE>
describe exceptions in predeclared functions which call OS
system functions.  Some exceptions are never generated but may
be generated in the future on some OSes.
<UL>
<LI><CODE>eaccess</CODE>.  This describes the system error
"Permission denied".</LI>
<LI><CODE>eagain</CODE>.  This describes the system error
"Resource temporarily unavailable".</LI>
<LI><CODE>ebadf</CODE>.  This describes the system error "Bad
file descriptor".</LI>
<LI><CODE>ebusy</CODE>.  This describes the system error
"Resource busy".</LI>
<LI><CODE>echild</CODE>.  This describes the system error "No
child processes".</LI>
<LI><CODE>edeadlk</CODE>.  This describes the system error
"Resource deadlock avoided".</LI>
<LI><CODE>edom</CODE>.  This describes the system error "Domain
error".</LI>
<LI><CODE>eexist</CODE>.  This describes the system error "File
exists".</LI>
<LI><CODE>efault</CODE>.  This describes the system error "Bad
address".</LI>
<LI><CODE>efbig</CODE>.  This describes the system error "File
too large".</LI>
<LI><CODE>eintr</CODE>.  This describes the system error
"Interrupted function call".</LI>
<LI><CODE>einval</CODE>.  This describes the system error
"Invalid argument".</LI>
<LI><CODE>eio</CODE>.  This describes the system error
"Input/output error".</LI>
<LI><CODE>eisdir</CODE>.  This describes the system error "Is a
directory".</LI>
<LI><CODE>emfile</CODE>.  This describes the system error "Too
many open files".</LI>
<LI><CODE>emlink</CODE>.  This describes the system error "Too
many links".</LI>
<LI><CODE>enametoolong</CODE>.  This describes the system error
"Filename too long".</LI>
<LI><CODE>enfile</CODE>.  This describes the system error "Too
many open files in system".</LI>
<LI><CODE>enodev</CODE>.  This describes the system error "No
such device".</LI>
<LI><CODE>enoent</CODE>.  This describes the system error "No
such file or directory".</LI>
<LI><CODE>enoexec</CODE>.  This describes the system error "Exec
format error".</LI>
<LI><CODE>enolck</CODE>.  This describes the system error "No
locks available".</LI>
<LI><CODE>enomem</CODE>.  This describes the system error "Not
enough space".</LI>
<LI><CODE>enospc</CODE>.  This describes the system error "No
space left on device".</LI>
<LI><CODE>enosys</CODE>.  This describes the system error
"Function not implemented".</LI>
<LI><CODE>enotdir</CODE>.  This describes the system error "Not a
directory".</LI>
<LI><CODE>enotempty</CODE>.  This describes the system error
"Directory not empty".</LI>
<LI><CODE>enotty</CODE>.  This describes the system error
"Inappropriate I/O control operation".</LI>
<LI><CODE>enxio</CODE>.  This describes the system error "No such
device or address".</LI>
<LI><CODE>eperm</CODE>.  This describes the system error
"Operation not permitted".</LI>
<LI><CODE>epipe</CODE>.  This describes the system error "Broken
pipe".</LI>
<LI><CODE>erange</CODE>.  This describes the system error "Result
too large".</LI>
<LI><CODE>erofs</CODE>.  This describes the system error
"Read-only file system".</LI>
<LI><CODE>espipe</CODE>.  This describes the system error
"Invalid seek".</LI>
<LI><CODE>esrch</CODE>.  This describes the system error "No such
process".</LI>
<LI><CODE>exdev</CODE>.  This describes the system error
"Improper link".</LI>
</UL>
</LI>
<LI><CODE>systemcall</CODE>.  This is a sub-class of
class <CODE>invcall</CODE>.  Sub-classes of
class <CODE>systemcall</CODE> describe exceptions in calling the
predeclared function <CODE>system</CODE>.
<UL>
<LI><CODE>noshell</CODE>.  This class describes the exception
that the function <CODE>system</CODE> can not find the OS command
interpreter (the shell).</LI>
<LI><CODE>systemfail</CODE>.  This class describes all remaining
exceptions in calling the OS function
<CODE>system</CODE>.</LI>
</UL>
</LI>
<LI><CODE>invextern</CODE>.  This is a sub-class of
class <CODE>invcall</CODE>.  Sub-classes of
class <CODE>invextern</CODE> describe exceptions in calling
external functions or in accessing an external variable.
<UL>
<LI><CODE>noextern</CODE>.  This class describes the exception
that the given external can not be find.</LI>
<LI><CODE>libclose</CODE>.  This class describes the exception
that there is an error in closing a shared library.</LI>
<LI><CODE>noexternsupp</CODE>.  This class describes an exception
in the usage of externals when they are not implemented under
this OS.</LI>
</UL>
</LI>
<LI><CODE>invenvar</CODE>.  This is a sub-class of
class <CODE>invcall</CODE>.  Class <CODE>invenvar</CODE> describes
corruption in the type of variables <CODE>split_regex</CODE> and
<CODE>time_format</CODE> (e.g. their values are not strings).</LI>
</UL>
</P>

<H3>Variable <CODE>time_format</CODE></H3>

<P>The variable value is a string which is the output format of time used
by the function <CODE>strtime</CODE> when it is called without parameters.
The initial value of the variable is the string <CODE>"%a %b %d %H:%M:%S
%Z %Y"</CODE>.</P>

<H3>Time functions</H3>

<P>The following functions from space <CODE>sys</CODE> can be used to get
information about real time.
<UL>
<LI><CODE>time ()</CODE>.  The function returns the time in seconds
since the fixed time (usually since January 1, 1970).</LI>
<LI><CODE>strtime ([format [, time]])</CODE>.  The function returns
a string representing the <CODE>time</CODE> (integer representing
time in seconds since the fixed time) according to the
<CODE>format</CODE> (string).  If the format is not given, the
value of variable <CODE>time_format</CODE> is used.  In this case
if the value of <CODE>time_format</CODE> is corrupted (it is not a
string), the function generates exception <CODE>invenvar</CODE>.
If the time is not given, the current time is used.  The format
is the same as in C library function <CODE>strftime</CODE>.  Here
is an extraction from the OS function documentation.  The
following format specifiers can be used in the format:
<UL>
<LI><CODE>%a</CODE> - the abbreviated weekday name according to
the current locale.</LI>
<LI><CODE>%A</CODE> - the full weekday name according to the
current locale.</LI>
<LI><CODE>%b</CODE> - the abbreviated month name according to
the current locale.</LI>
<LI><CODE>%B</CODE> - the full month name according to the
current locale.</LI>
<LI><CODE>%c</CODE> - the preferred date and time
representation for the current locale.</LI>
<LI><CODE>%d</CODE> - the day of the month as a decimal number
(range 01 to 31).</LI>
<LI><CODE>%H</CODE> - the hour as a decimal number using a
24-hour clock (range 00 to 23).</LI>
<LI><CODE>%I</CODE> - the hour as a decimal number using a
12-hour clock (range 01 to 12).</LI>
<LI><CODE>%j</CODE> - the day of the year as a decimal number
(range 001 to 366).</LI>
<LI><CODE>%m</CODE> - the month as a decimal number (range 01
to 12).</LI>
<LI><CODE>%M</CODE> - the minute as a decimal number.</LI>
<LI><CODE>%p</CODE> - either `am' or `pm' according to the given time
value, or the corresponding strings for the current locale.</LI>
<LI><CODE>%S</CODE> - the second as a decimal number.</LI>
<LI><CODE>%U</CODE> - the week number of the current year as a
decimal number, starting with the first Sunday as the first
day of the first week.</LI>
<LI><CODE>%W</CODE> - the week number of the current year as a
decimal number, starting with the first Monday as the first
day of the first week.</LI>
<LI><CODE>%w</CODE> - the day of the week as a decimal, Sunday
being 0.</LI>
<LI><CODE>%x</CODE> - the preferred date representation for
the current locale without the time.</LI>
<LI><CODE>%X</CODE> - the preferred time representation for
the current locale without the date.</LI>
<LI><CODE>%y</CODE> - the year as a decimal number without a
century (range 00 to 99).</LI>
<LI><CODE>%Y</CODE> - the year as a decimal number including
the century.</LI>
<LI><CODE>%Z</CODE> - the time zone or the name or an
abbreviation.</LI>
<LI><CODE>%%</CODE> - a literal `%' character.</LI>
</UL>
</LI>
</UL>
</P>

<H3>Functions for access to information about OS processes</H3>

<P>Space <CODE>sys</CODE> contains predeclared functions which are used to
get information about the current OS process (the Dino interpreter
which executes the program).  Each OS process has unique identifier
and usually OS processes are called by a concrete user and group and
are executed on behalf of the concrete user and group (so called
effective identifiers).  The following functions return such
information.  On some OSes the function may return string "Unknown" as
a name if there are notions of user and group identifiers.
<UL>
<LI><CODE>getpid ()</CODE>.  The function returns an integer value
which is the process ID of the current OS process.</LI>
<LI><CODE>getun ()</CODE>.  The function returns a new string which
is the user name for the current OS process.</LI>
<LI><CODE>geteun ()</CODE>.  The function returns a new string
which is the effective user name for the current OS process.</LI>
<LI><CODE>getgn ()</CODE>.  The function returns a new string which
is the group name for the current OS process.</LI>
<LI><CODE>getegn ()</CODE>.  The function returns a new string
which is the effective group name for the current OS process.</LI>
<LI><CODE>getgroups ()</CODE>.  The function returns a new vector
of strings (possibly the empty vector) representing
supplementary group names for the current OS process.</LI>
</UL>
</P>

<H3>Function <CODE>system (command)</CODE></H3>

<P>The function executes the command given by a string (the parameter
value) in the OS command interpreter.  Besides standard exceptions
<CODE>parnumber</CODE> and <CODE>partype</CODE> the function may generate
exceptions <CODE>noshell</CODE> and <CODE>systemfail</CODE>.</P>

<H2><A NAME="ss9.4">9.4</A> <A HREF="dino.html#toc9.4">Space <CODE>re</CODE></A>
</H2>

<P>This space contains declarations which can be useful for working with
regular expressions and for pattern matching -- see
also <EM>match-statements</EM>.</P>

<H3>Exception class <CODE>invregex</CODE></H3>

<P>This class describes exceptions specific for executing
<EM>pmatch-statement</EM> and for calling predeclared functions
implementing regular expression pattern matching.  Although there is
only one class for this, the messages which are the class parameter
can be different and explain more details.</P>

<H3>Variable <CODE>split_regex</CODE></H3>

<P>The variable value is a string which represents regular expression
which is used by the predeclared function <CODE>split</CODE> when the
second parameter is not given.  The initial value of the variable is
string <CODE>"[ \t]+"</CODE>.</P>

<H3>Pattern matching</H3>

<P>Space <CODE>re</CODE> contains predeclared functions which are used
for <EM>pattern matching</EM>.  The pattern is described
by <EM>regular expressions</EM> (<EM>regex</EM>) and actually a small
program describing a string matching.  The pattern
has <EM>default</EM> syntax of ONIGURUMA package for Unicode.  It is
hard to describe formally the pattern syntax.  Here is not a
completely strict description for full reference, please see OINGURUMA
package documentation.  The regular expressions have the following
syntax:
<BLOCKQUOTE><CODE>
<PRE>
          Regex = Branch {"|" Branch}
</PRE>
</CODE></BLOCKQUOTE>

A regex matches anything that matches one of the <EM>branches</EM>.
<BLOCKQUOTE><CODE>
<PRE>
          Branch = {Piece}
</PRE>
</CODE></BLOCKQUOTE>

A branch matches a match for the first <EM>piece</EM>, followed by a
match for the second piece, etc.  If the pieces are omitted, the
branch matches the null string.
<BLOCKQUOTE><CODE>
<PRE>
          Piece = Anchor | Unit

          Unit = Atom
               | Unit Quantifier

          Quantifier = Greedy
                     | Reluctant
                     | Possesive

          Greedy = "?"                 // 0 or 1 times
                 | "*"                 // 0 or more times
                 | "+"                 // 1 or more times
                 | Bound

          Bound = "{" Min "," Max "}" // from Min to Max times
                | "{" Min "," "}"     // at least Min times
                | "{" "," Max "}"     // equivalent to {0, Max}
                | "{" Min "}"         // given number times

          Reluctant = "??"
                    | "*?"
                    | "+?"
                    | Bound "?"

          Possesive : "?+"
                    | "*+"
                    | "++"

          Min = &lt;unsigned integer>

          Max = &lt;unsigned integer>
</PRE>
</CODE></BLOCKQUOTE>

An <EM>unit</EM> followed by <CODE>*</CODE> matches a sequence of 0 or
more matches of the unit.  An unit followed by <CODE>+</CODE> matches a
sequence of 1 or more matches of the unit.  An unit followed by
<CODE>?</CODE> matches a sequence of 0 or 1 matches of the unit.</P>
<P>There is a more general construction (a <EM>bound</EM>) for describing
repetitions of an unit.  An unit followed by a bound containing only
one integer <CODE>Min</CODE> matches a sequence of exactly <CODE>Min</CODE>
matches of the unit.  An unit followed by a bound containing one
integer <CODE>Min</CODE> and a comma matches a sequence of <CODE>Min</CODE> or
more matches of the unit.  An unit followed by a bound containing a
comma and one integer <CODE>Max</CODE> matches at most <CODE>Max</CODE>
repetitions of the unit.  An unit followed by a bound containing two
integers <CODE>Min</CODE> and <CODE>Max</CODE> matches a sequence of
<CODE>Min</CODE> through <CODE>Max</CODE> (inclusive) matches of the unit.</P>
<P>The described above qualifiers are <EM>greedy</EM> ones.  A gready
qualifier first matches as much as possible and can back-track in case
whole regex matching failure to try shorter sequence.  There
are <EM>reluctant</EM> qualifiers too.  They have additional
suffix <CODE>?</CODE> and first matches as little as possible.  The last
type of qualifiers is possesive.  Such qualifiers have additional
suffix <CODE>+</CODE> and behave like the corresponding greedy ones, but
they do not back-track.</P>
<P>Examples:
<BLOCKQUOTE><CODE>
<PRE>
          `.?foo` // matches first "xfoo" in "xfooxxxxfoo"
          `.*foo` // matches all "xfooxxxxfoo"
          `.+foo` // matches all "xfooxxxxfoo"
          `.{1,8}foo` // matches all "xfooxxxxfoo"
          `.*?foo` // matches first "xfoo" in "xfooxxxxfoo"
          `.+?foo` // Ditto
          `.{1,8}?foo` // Ditto
          `.*+foo` // fail to match in "xfooxxxxfoo"
          `.++foo` // fail to match in "xfooxxxxfoo"
</PRE>
</CODE></BLOCKQUOTE>

<BLOCKQUOTE><CODE>
<PRE>
         Atom =  Anchors
               | Character
               | CharacterType
               | CharacterProperty
               | CharacterClass
               | Group
               | BackReference
               | SubexpCall
         
          Character = "\t"     // horizontal tab (0x09)
                    | "\v"     // vertical tab (0x0B)
                    | "\n"     // newline tab (0x0A)
                    | "\r"     // return (0x0D)
                    | "\f"     // form feed (0x0C)
                    | "\a"     // bell (0x07)
                    | "\e"     // escape (0x1B)
                    | "\" OctalCode // char with given octal code
                    | "\x" HexCode  // char with given hexadecimal code
                    | &lt;any but special character \ ? * + ^ $ [ ( ) >
                    | "\" &lt;special character>
      
          OctalCode = &lt;3 octal digits>
        
          HexCode = &lt;2 heaxadecimal digits>
          
          CharacterType = '.'  // any character but newline
                        | "\w" // Unicode Letter, Mark, Number, or
                               //   Connector_Punctuation
                        | "\W" // opposite to the above 
                        | "\s" // Unicode Line_Separator, 
                               //   Paragraph_Separator, or
                               //   Space_Separator
                        | "\S" // opposite to the above 
                        | "\d" // Unicode decimal number 
                        | "\D" // opposite to the above 
                        | "\h" // hexadecimal digit char [0-9a-fA-F] 
                        | "\H" // opposite to the above 

          CharacterProperty = "\p{" PropertyName "}"
                            | "\p{^" PropertyName "}"
                            | "\P{" PropertyName "}"

         PropertyName = "Alnum" | "Alpha" | "Blank" | "Cntrl"
                      | "Digit" | "Graph" | "Lower" | "Print"
                      | "Punct" | "Space" | "Upper" | "XDigit"
                      | "Word" | "ASCII"
                      | "Any" | "Assigned" | "C" | "Cc" | "Cf"
                      | "Cn" | "Co" | "Cs" | "L" | "Ll" | "Lm"
                      | "Lo" | "Lt" | "Lu" | "M" | "Mc" | "Me"
                      | "Mn" | "N" | "Nd" | "Nl" | "No" | "P"
                      | "Pc" | "Pd" | "Pe" | "Pf" | "Pi" | "Po"
                      | "Ps" | "S" | "Sc" | "Sk" | "Sm" | "So"
                      | "Z" | "Zl" | "Zp" | "Zs" | "Arabic"
                      | "Armenian" | "Bengali" | "Bopomofo"
                      | "Braille" | "Buginese" |  "Buhid"
                      | "Canadian_Aboriginal" | "Cherokee"
                      | "Common" | "Coptic" | "Cypriot"
                      | "Cyrillic" | "Deseret" | "Devanagari"
                      | "Ethiopic" | "Georgian" |  "Glagolitic"
                      | "Gothic" | "Greek" | "Gujarati"
                      | "Gurmukhi" | "Han" | "Hangul" | "Hanunoo"
                      | "Hebrew" | "Hiragana" | "Inherited"
                      | "Kannada" | "Katakana" | "Kharoshthi"
                      | "Khmer" | "Lao" | "Latin" | "Limbu"
                      | "Linear_B" | "Malayalam" | "Mongolian"
                      | "Myanmar" | "New_Tai_Lue" | "Ogham"
                      | "Old_Italic" | "Old_Persian" | "Oriya"
                      | "Osmanya" | "Runic" | "Shavian" | "Sinhala"
                      | "Syloti_Nagri" | "Syriac" | "Tagalog"
                      | "Tagbanwa" | "Tai_Le" | "Tamil" | "Telugu"
                      | "Thaana" | "Thai" | "Tibetan" | "Tifinagh"
                      | "Ugaritic" | "Yi"

          Anchors = "^"           // beginning of the line
                  | "$"           // end of the line
                  | "\b"          // word boundary
                  | "\B"          // not word boundary
                  | "\A"          // beginning of string
                  | "\Z"          // end of string, or before newline
                                  //   at the end
                  | "\z"          // end of string
</PRE>
</CODE></BLOCKQUOTE>

The atom can be an character.  Some characters has a special meaning
in regex (see comments in the character syntax).  The rest characters
match the same character in matching string.  To match a special
character, use <CODE>\</CODE> before the character.  Some characters can
be represented by a sequence starting with <CODE>\</CODE> (see the syntax
comments).</P>
<P>Examples:
<BLOCKQUOTE><CODE>
<PRE>
          `\t`        // matches "\\t"
          `\x65`      // matches "e"
          `\p{Alpha}` // matches "a"
          `\w`        // matches "a"
          `b$`        // matches "b" in "b\na"
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>The atom can be an anchor.  Matching anchors succeed only their
positions correspond a specific place at the matching string (see
comments in the anchor syntax).</P>
<P>Examples:
<BLOCKQUOTE><CODE>
<PRE>
          `b$`        // matches "b" in "b\na"
          `abc\Z`     // matches "abc" in "abc"
          `abc\Z`     // matches "abc" in "abc\n"
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>The atom which is a character type matches a specific class of
character (see comments in the character type syntax).</P>
<P>The atom which is a character property matches a specific class of
character.  For meaning <CODE>Alnum</CODE> - <CODE>ASCII</CODE>, please see
the corresponding <CODE>BracketClass</CODE>.  For meaning <CODE>C</CODE>
- <CODE>Zs</CODE>, please see Unicode categories.  For
meaning <CODE>Armenian</CODE> - <CODE>Yi</CODE>, please see Unicode scripts
(alphabets). If the property contains <CODE>p</CODE> with <CODE>^</CODE>
or <CODE>P</CODE>, the match succeeds when the matching character is not
of the class.</P>
<P>Examples:
<BLOCKQUOTE><CODE>
<PRE>
          `\p{Alpha}` // matches "a"
          `\p{ASCII}` // matches ";"
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
          CharacterClass = "[" Intersections "]"
                         | "[^" Intersections "]"

          Intersections = Set
                        | Intersections "&amp;&amp;" Set

          Set = SetElement
              | Set SetElement
          
          SetElement = ElementChar ["-" ElementChar]
                     | "[:" BracketClass ":]"
                     | "[:^" BracketClass ":]"
                     | CharacterClass

          ElementChar = Character
                      | "\b"       // backspace 0x08

          BracketClass = "alnum"   // Unicode letter, mark,
                                   //   or decimal number
                       | "alpha"   // Unicode letter or mark
                       | "ascii"   // character in range 0 - 0x7f
                       | "blank"   // Unicode space separator
                                   //   or \t (0x09)
                       | "ctrl"    // Unicode control, format,
                                   //   unassigned, private use,
                                   //   or surrogate
                       | "digit"   // Unicode decimal number 
                       | "graph"   // not a space class and not an
                                   //   Unicode control, unassigned,
                                   //   or surrogate
                       | "lower"   // Unicode lower case letter
                       | "print"   // graph or space class
                       | "punct"   // any Unicode punctuation
                       | "space"   // any Unicode separator,
                                   //   \t (0x09), \n (0x0A), \v (0x0B),
                                   //   \f (0x0C), \r (0x0D),
                                   //   or 0x85 (next line)
                       | "upper"   // Unicode upper case letter
                       | "xdigit"  // ascii 0-9, a-f, or a-f
                       | "word"    // Unicode letter, mark, decimal
                                   //   number or punctuation connector
</PRE>
</CODE></BLOCKQUOTE>

An atom can be a bracket expression which is a <EM>list</EM> of
intersections of character sets separated by <CODE>&amp;&amp;</CODE> and enclosed
in <CODE>[]</CODE>.  If the character class contains <CODE>^</CODE> right
after <CODE>[</CODE>, it matches any character which does match the
corresponding character class without <CODE>^</CODE>.  A set is sequence
of set elements.</P>
<P>Element given by a character denotes the character itself.  Element
given by two characters in the list separated by <CODE>-</CODE> is
shorthand for the full <EM>range</EM> of characters between those two
(inclusive) in the sequence of unicode codes, e.g. <CODE>[0-9]</CODE>
matches any decimal digit.  Besides usual character representation you
can use here also <CODE>\b</CODE> which is a backspace representation.</P>
<P>Element given by a bracket class enclosed in <CODE>[[::]]</CODE> matches a
character from this class (see comments in BracketClass).  If
character <CODE>^</CODE> is present right after <CODE>[[:</CODE>, the match
succeeds if the character is not in this class.</P>
<P>Element can be given by a character class, in other words the
character clases can be nested.</P>
<P>If you need to use <CODE>[</CODE>, <CODE>-</CODE>, or <CODE>]</CODE> as a normal
character in a character class, you can use prefix <CODE>\</CODE> for
this.</P>
<P>Examples:
<BLOCKQUOTE><CODE>
<PRE>
          `[[:alpha:]]`  // matches "a"
          `[[[:lower:]]&amp;&amp;[^a-x]]` // matches "y" or "z"
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>An atom can be a group, a regular expression enclosed in <CODE>()</CODE>.
There are several types of groups:
<BLOCKQUOTE><CODE>
<PRE>
          Group = CapturedGroup
                | NonCapturedGroup
                | "(?#" &lt;any characters but )> ")" // comment
                | "(?" Options ")"
                | Context
          
          Options =
                  | Options Option

          Option = "-" | "i" | "m" | "x"

          CapturedGroup = "(" [Regex] ")"
                        | "(?&lt;" Name ">" [Regex] ")"
 
          Name = &lt;one or more word character>

          NonCapturedGroup = "(?" Options ":" [Regex] ")"
                           | "(?>" [Regex] ")" /* Atomic group */
                           
          Context = "(?=" [Regex] ")" // look ahead
                  | "(?!" [Regex] ")" // negative look ahead
                  | "(?&lt;=" [Regex] ")" // look behind
                  | "(?&lt;!" [Regex] ")" // negative look behind

          BackReference = "\" Number    // back ref. by group
                                        //   number
                        | "\k&lt;" Number ">" // back ref. by group
                                           //   number
                        | "\k&lt;-" Number ">" // back ref. by relative
                                            //   group number
                        | "\k&lt;" Name ">" // back ref. by group name
                        // back ref. by group name and nest level:
                        | "\k&lt;" Name "+" | "-" Number ">"

          Number = &lt;any integer >= 0>
                                    
</PRE>
</CODE></BLOCKQUOTE>

Some groups are captured groups.  It means that you can refer the
substrings they match (see back references) or get start and end
positions of the matched substrings by calling Dino regex match
functions.  A captured group may have a name which can be used in the
back references or subexp calls.</P>
<P>You can place comments not containing <CODE>)</CODE> in regex
betweeen <CODE>(?#</CODE> and <CODE>)</CODE>.</P>
<P>Options without regex always matches.  They just change how matching
works.  Option <CODE>i</CODE> switches on igoring letter cases during
matches.  Option <CODE>m</CODE> makes <CODE>.</CODE> to match newline too.
Option <CODE>x</CODE> switches on ignoring white spaces as character atom
and permits to add comments starting with <CODE>#</CODE> and ending at the
end of line.  Character <CODE>-</CODE> after the corresponding <CODE>?</CODE> and
before has an opposite effect, e.g. it makes a letter case important
in matching again etc.</P>
<P>You can define options in non captured groups.  These options affect
only this group.  Another form of non-captured group is an atomic
group.  Once regex in an atomic group mathes something, the matching
stays the same during back-tracking.</P>
<P>Examples:
<BLOCKQUOTE><CODE>
<PRE>
          `(?i:ab)`     // matches "Ab"
          `(?x: a a a)` // matches "aaa"
          `(?>.*)c`     // can not match "abc"
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>The atom can be a context.  A context match does not advance the
current position in a matching string.  A look ahead context succeeds
if the corresponding regex matches a sub-string starting from the
current positions.  A look behind context succeeds if the
corresponding regex matches a sub-string finishing right before the
current positions.  There are negative forms of context atom.  They
succeed when the corresponding regex does not match.</P>
<P>Examples:
<BLOCKQUOTE><CODE>
<PRE>
          `(?=bcd)bc`   // matches "bc" in "aabcd"
          `(?&lt;=aa)bc`   // matches "bc" in "aabc"
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>The atom can be a back reference.  It refers to the matched string of
the corresponding captured group.  The captured groups are counted by
their left parantheses starting from one going from left to right.
The negative number denotes relative order number, in other words, the
order is taken starting from the back reference going from right to
left.  If captured group has a name, its matched string can be
referenced by its name.  If several group has the same name, name in
the back reference corresponds to the last such group.  You can add
nest level to the name.  If the nest level is zero it is the same as
named back reference without nested level.  Back reference with
non-zero nest level never matches.</P>
<P>Examples:
<BLOCKQUOTE><CODE>
<PRE>
          `(a)\k&lt;1>`     // matches "aa"
          `(?&lt;p>a)\k&lt;p>` // Ditto
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Atom can be a subexp call:
<BLOCKQUOTE><CODE>
<PRE>
          SubexpCall = "\g&lt;" Name ">"
</PRE>
</CODE></BLOCKQUOTE>

Subexp call is actually another occurence of the group
it refers to.  But if the call is in the group it refers, it is a
recursive description.  Only left recursion is not permitted as this
results in never ending recursion.</P>
<P>Examples:
<BLOCKQUOTE><CODE>
<PRE>
          `(?&lt;p>cd)\g&lt;p>`   // matches "cdcd"
          `(?&lt;p>a|b\g&lt;p>c)` // matches "a", "bac", "bbacc" etc
          `(?&lt;p>a|b\g&lt;p>c)` // wrong left recursion.
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>There are the following pattern matching functions in
space <CODE>re</CODE>:
<UL>
<LI><CODE>match (regex, string)</CODE>.  The function searches for
the matching regular expression <CODE>regex</CODE> in
<CODE>string</CODE>.  The both parameters should be strings after
their implicit string conversion.  The matching is made
according to the standard POSIX 1003.2: The regular expression
matches the substring starting earliest in the string.  If the
regular expression could match more than one substring starting
at that point, it matches the longest.  Subexpressions also
match the longest possible substrings, subject to the
constraint that the whole match be as long as possible, with
subexpressions starting earlier in the regular expression
taking priority over ones starting later.  In other words,
higher-level subexpressions take priority over their component
subexpressions.  Match lengths are measured in characters, not
collating elements.  A null string is considered longer than no
match at all.  If there is no matching, the function returns
the value <CODE>nil</CODE>.  Otherwise, the function returns a new
mutable vector of integers.  The length of the vector is <CODE>2
* (N + 1)</CODE> where <CODE>N</CODE> is the number of atoms which
are regular expressions in parentheses.  The first two elements
are the index of the first character of the substring
corresponding to the whole regular expression and the index of
the last character matched plus one.  The subsequent two
elements are the index of the first character of the substring
corresponding to the first atom in the regular expression (the
atoms are ordered by their open parentheses) and the index of
the last character plus one, and so on.  If there is no
matching with a regular expression in parentheses, the
corresponding vector elements will have negative values.
<P>Example: The program
<BLOCKQUOTE><CODE>
<PRE>
          println (re.match (`\n()(a)((a)(a))`, "b\naaab"));
</PRE>
</CODE></BLOCKQUOTE>

outputs
<BLOCKQUOTE><CODE>
<PRE>
          [1, 5, 2, 2, 2, 3, 3, 5, 3, 4, 4, 5]
</PRE>
</CODE></BLOCKQUOTE>
</P>
</LI>
<LI><CODE>gmatch (regex, string[, flag])</CODE>.  The function
searches for different occurrences of regular expression
<CODE>regex</CODE> in <CODE>string</CODE>.  Both parameters should
be strings after their implicit string conversion.  The third
parameter is optional.  If it is present, it should be integer
after implicit integer conversion.  If its value is nonzero,
the substrings matched by regex can be overlapped.  Otherwise,
the substrings are never overlapped.  If the parameter is
absent, the function behaves as its value were zero.  The
function returns a new mutable vector of integers.  The length
of the vector is <CODE>2 * N</CODE> where <CODE>N</CODE> is number of
the found occurrences.  Pairs of the vector elements correspond
to the occurrences.  The first element of the pairs is index of
the first character of substring corresponding to all regular
expression in the corresponding occurrences and the second
element is index of the last character plus one.  If there is
no one occurrence, the function returns <CODE>nil</CODE>.
<P>Example: The program
<BLOCKQUOTE><CODE>
<PRE>
          println (re.gmatch (`aa`, "aaaaa"));
          println (re.gmatch (`aa`, "aaaaa", 1));
</PRE>
</CODE></BLOCKQUOTE>

outputs
<BLOCKQUOTE><CODE>
<PRE>
          [0, 2, 2, 4]
          [0, 2, 1, 3, 2, 4, 3, 5]
</PRE>
</CODE></BLOCKQUOTE>
</P>
</LI>
<LI><CODE>sub (regex, string, subst)</CODE>.  The function searches
for substrings matching the regular expression <CODE>regex</CODE>
in <CODE>string</CODE>.  All parameters should be string after
implicit string conversion.  If there is no matching, the
function returns the value <CODE>nil</CODE>.  Otherwise, the
function returns a new mutable vector of characters in which
the first substring matched has been changed to the string
<CODE>subst</CODE>.  Within the replacement string <CODE>subst</CODE>,
the sequence <CODE>\n</CODE>, where <CODE>n</CODE> is a digit from 1 to
9, may be used to indicate the text that matched the
<CODE>n</CODE>'th atom of the regex in parentheses.  The sequence
<CODE>\0</CODE> represents the entire matched text, as does the
character <CODE>&amp;</CODE>.</LI>
<LI><CODE>gsub (regex, string, subst)</CODE>.  The function is
analogous to the function <CODE>sub</CODE> except for the function
searches for all non-overlapping substrings matched with the
regular expression and returns a new mutable vector of
characters in which all matched substrings have been changed to
the string <CODE>subst</CODE>.</LI>
<LI><CODE>split (string [, regex])</CODE>.  The function splits
<CODE>string</CODE> into non-overlapped substrings separated by
strings matching the regular expression.  All parameters should
be strings after implicit string conversion.  If the second
parameter is omitted the value of the predeclared variable
<CODE>split_regex</CODE> is used instead of the second parameter
value.  In this case the function may generate the exception
<CODE>invenvar</CODE> (corrupted value of a predeclared variable).
The function returns a new mutable vector with elements which
are the separated substrings.  If the regular expression is the
null string, the function returns a new mutable vector with
elements which are strings each containing one character of
string.
<P>Examples: The program
<BLOCKQUOTE><CODE>
<PRE>
          println (re.split ("aaa bbb ccc       ddd"));
</PRE>
</CODE></BLOCKQUOTE>

outputs
<BLOCKQUOTE><CODE>
<PRE>
          ["aaa", "bbb", "ccc", "ddd"]
</PRE>
</CODE></BLOCKQUOTE>

The program
<BLOCKQUOTE><CODE>
<PRE>
          println (re.split ("abcdef", ``));
</PRE>
</CODE></BLOCKQUOTE>

outputs
<BLOCKQUOTE><CODE>
<PRE>
          ["a", "b", "c", "d", "e", "f"]
</PRE>
</CODE></BLOCKQUOTE>
</P>
</LI>
</UL>

If the regular expression is incorrect, the functions generate
exception <CODE>invregex</CODE> with a message explaining the error.</P>

<H2><A NAME="ss9.5">9.5</A> <A HREF="dino.html#toc9.5">Space <CODE>math</CODE></A>
</H2>

<P>The space contains mostly mathematical functions.</P>

<H3>Mathematical functions</H3>

<P>The following functions make implicit arithmetic conversion of the
parameters.  After the conversions the parameters are expected to be
of integer, long integer, or floating point type.  The result is
always a floating point number.
<UL>
<LI><CODE>sqrt (x)</CODE>.  The function returns the square root of
<CODE>x</CODE>.  The function generates the exception <CODE>edom</CODE>
if <CODE>x</CODE> is negative.</LI>
<LI><CODE>exp (x)</CODE>.  The function returns <CODE>e</CODE> (the
base of the natural logarithm) raised to the power of
<CODE>x</CODE>.</LI>
<LI><CODE>log (x)</CODE>.  The function returns the natural
logarithm of <CODE>x</CODE>.  The function generates the exception
<CODE>edom</CODE> if <CODE>x</CODE> is negative or may generate
<CODE>erange</CODE> if the value is zero.</LI>
<LI><CODE>log10 (x)</CODE>.  The function returns the decimal
logarithm of <CODE>x</CODE>.  The function generates the exception
<CODE>edom</CODE> if <CODE>x</CODE> is negative or may generate
<CODE>erange</CODE> if the value is zero.</LI>
<LI><CODE>pow (x, y)</CODE>.  The function returns <CODE>x</CODE>
raised to the power of <CODE>y</CODE>.  The function generates
exception <CODE>edom</CODE> if x is negative and y is not of
integral value.</LI>
<LI><CODE>sin (x)</CODE>.  The function returns the sine of
<CODE>x</CODE>.</LI>
<LI><CODE>cos (x)</CODE>.  The function returns the cosine of
<CODE>x</CODE>.</LI>
<LI><CODE>atan2 (x, y)</CODE>.  The function returns the arc
tangent of the two variables <CODE>x</CODE> and <CODE>y</CODE>.  It is
similar to calculating the arc tangent of <CODE>y / x</CODE>,
except that the signs of both arguments are used to determine
the quadrant of the result.</LI>
</UL>
</P>

<H3>Other space <CODE>math</CODE> functions</H3>

<P>There are the following miscellaneous functions:
<UL>
<LI><CODE>max (v1, v2, ...)</CODE>.  The function searches for and
returns the maximal value in all of its parameters.  The
parameters should be of integer, long integer, or floating
point type after implicit arithmetic conversion.  So the
function can return an integer, a long integer, or floating
point number depending on the type of the first maximal value
after the conversion.</LI>
<LI><CODE>min (v1, v2, ...)</CODE>.  The function is analogous to
the previous function, but searches for and returns the minimal
value.</LI>
<LI><CODE>srand ([seed])</CODE>.  The function sets the parameter
value (after implicit integer conversion) as the seed for a new
sequence of pseudo-random integers to be returned by
<CODE>rand</CODE>.  These sequences are repeatable by calling
<CODE>srand</CODE> with the same seed value.  If the parameter is
not given, the seed will be the result of calling function
<CODE>time</CODE>.</LI>
<LI><CODE>rand ()</CODE>.  The function returns a pseudo-random
floating point value between 0 and 1.  If the function
<CODE>srand</CODE> was not called before, 1 will be used as the
seed value.</LI>
</UL>
</P>

<H2><A NAME="ss9.6">9.6</A> <A HREF="dino.html#toc9.6">Space <CODE>yaep</CODE></A>
</H2>

<P>This space contains declarations to work with Yet Another Earley
Parser (YAEP).  YAEP is a very powerful tool to implement serious
language compilers, processors, or translators.  The implementation of
the Earley parser used in Dino has the following features:
<UL>
<LI>It is sufficiently fast and does not require much memory.
This is the fastest implementation of the Earley parser which I
know.  The main design goal is to achieve speed and memory
requirements which are necessary to use it in prototype
compilers and language processors.  It parses 30,000 lines of C
per second on 500 MHz Pentium III and allocates about
5Mb memory for a 10,000 line C program.</LI>
<LI>It makes simple syntax directed translation, so an
abstract tree is already the output of the Earley parser.</LI>
<LI>It can parse input described by an ambiguous grammar.  In
this case the parse result can be an abstract tree or all
possible abstract trees.  Moreover, it produces the compact
representation of all possible parse trees by using DAG instead
of real trees.  These features can be used to parse natural
language sentences.</LI>
<LI>It can make syntax error recovery.  Moreover its error
recovery algorithms find error recovery with a minimal number
of ignored tokens.  It permits implement-ion of parsers with
very good error recovery and reporting.</LI>
<LI>It has fast startup.  There is practically no delay between
processing of grammar and start of parsing.</LI>
<LI>It has a flexible interface.  The input grammar is given by
a YACC-like description.</LI>
<LI>It has a good debugging features.  It can print huge amount
of information about grammar, parsing, error recovery,
translation.  You can even get the result translation in a form
for a graphic visualization program.</LI>
</UL>
</P>

<H3>Exception classes of space <CODE>yaep</CODE></H3>

<P>The space yaep contains class <CODE>invparser</CODE> which is a sub-class
of <CODE>invcall</CODE>.  The following sub-classes of
class <CODE>invparser</CODE> describe exceptions specific for work with
YAEP.
<UL>
<LI><CODE>invgrammar</CODE>.  This class describes the exception
that the Earley parser got a bad grammar, e.g. without rules,
with loops in rules, with nonterminals unachievable from the
axiom, with nonterminals not deriving any terminal string etc.</LI>
<LI><CODE>invtoken</CODE>.  This class describes the exception that
the parser got an input token with unknown (undeclared) code.</LI>
<LI><CODE>pmemory</CODE>.  This class describes the exception that
there is not enough memory for internal parser data.</LI>
</UL>
</P>

<H3>Class parser</H3>

<P>Space <CODE>yaep</CODE> has predeclared final class <CODE>parser</CODE> which
implements the Earley parser.  The following public functions and
variables are declared in the class
<CODE>parser</CODE>:
<UL>
<LI><CODE>ambiguous_p</CODE>.  This public variable stores
information about the last parsing.  A nonzero variable value
means that during the last parsing on a given input the parser
found that the grammar is ambiguous.  The parser can find this
even if you asked for only one parser tree (see function
<CODE>set_one_parse</CODE>).
</LI>
<LI><CODE>set_grammar (descr, strict_p)</CODE>.  This function
tunes the parser to given grammar.  The grammar is given by
string <CODE>descr</CODE>.  Nonzero value of parameter
<CODE>strict_p</CODE> (after implicit integer conversion) means
more strict checking the grammar.  In this case, all
nonterminals will be checked on their ability to derive a
terminal string instead of only checking the axiom for this.
The function can generate exceptions <CODE>partype</CODE> (if the
parameters have wrong types) or <CODE>invgrammar</CODE> if the
description is a bad grammar.  The function can also generate
exception <CODE>pmemory</CODE> if there is no memory for internal
parser data.

The description is similiar to the <EM>YACC</EM> one.  It has
the following syntax:
<BLOCKQUOTE><CODE>
<PRE>
          file : file terms [';']
               | file rule
               | terms [';']
               | rule
       
          terms : terms IDENTIFIER ['=' NUMBER]
                | TERM
       
          rule : IDENTIFIER ':' rhs [';']
          
          rhs : rhs '|' sequence [translation]
              | sequence [translation]
          
          sequence :
                   | sequence IDENTIFIER
                   | sequence C_CHARACTER_CONSTANT
          
          translation : '#'
                      | '#' NUMBER
                      | '#' '-'
                      | '#' IDENTIFIER [NUMBER] '(' numbers ')'
          
          numbers :
                  | numbers NUMBER
                  | numbers '-'
       
</PRE>
</CODE></BLOCKQUOTE>

So the description consists of terminal declaration and
rule sections.
       
The terminal declaration section describes the name of
terminals and their codes.  The terminal code is optional.  If
it is omitted, the terminal code will the next free code
starting with 256.  You can declare a terminal several times
(the single condition is that its code should be the same).
       
A character constant present in the rules is a terminal
described by default.  Its code is always the ASCII code of the
character constant.
       
Rules syntax is the same as <EM>YACC</EM> rule syntax.  The
single difference is an optional translation construction
starting with <CODE>#</CODE> right after each alternative.  The
translation part could be a single number which means that the
translation of the alternative will be the translation of the
symbol with the given number (symbol number in the alternative
start is with 0).  Or the translation can be empty or
`<CODE>-</CODE>' which designates the value of the variable
<CODE>nil_anode</CODE>.  Or the translation can be an abstract node
with the given name, optional cost, and with fields whose
values are the translations of the alternative symbols with
numbers given in parentheses after the abstract node name.  You
can use `<CODE>-</CODE>' in an abstract node to show that the empty
node should be used in this place.  If the cost is absent it is
believed to be 1.  The cost of the terminal, error node, and
empty node is always zero.

There is a reserved terminal <CODE>error</CODE> which marks the
start point of error recovery.  The translation of the terminal
is the value of the variable <CODE>error_anode</CODE>.
 </LI>
<LI><CODE>set_debug (level)</CODE>.  This function sets up the
level of debugging information output to <CODE>stderr</CODE>.  The
higher the level, the more information is output.  The default
value is 0 (no output).  The debugging information includes
statistics, the result translation tree, the grammar, parser
sets, parser sets with all situations, situations with
contexts.  The function returns the previously set up debug
level.  Setting up a negative debug level results in output of
the translation for program <B>dot</B> of the graphic
visualization package <B>graphviz</B>.  The parameter should
be an integer after implicit integer conversion.  The function
will generate exception <CODE>partype</CODE> if it is not true.</LI>
<LI><CODE>set_one_parse (flag)</CODE>.  This function sets up a
flag whose nonzero value means building only one translation
tree (without any alternative nodes).  For an unambiguous
grammar the flag does not affect the result.  The function
returns the previously set up flag value.  The default value of
the flag is 1.  The parameter should be an integer after
implicit integer conversion.  The function will generate
exception <CODE>partype</CODE> if it is not true.</LI>
<LI><CODE>set_lookahead (flag)</CODE>.  This function sets up a
flag of of usage of look ahead in the parser work.  The usage
of lookahead gives the best results with the point of view of
space and speed.  The default value is 1 (the lookahead usage).
The function returns the previously set up flag.  No usage of
the lookahead is useful sometimes to get more understandable
debug output of the parser work (see function
<CODE>set_debug</CODE>).  The parameter should be an integer after
implicit integer conversion.  The function will generate the
exception <CODE>partype</CODE> if it is not true.</LI>
<LI><CODE>set_cost (flag)</CODE>.  This function sets up building
the only translation tree (trees if we set up one_parse_flag to
0) with minimal cost.  For an unambiguous grammar the flag does
not affect the result.  The default value is 0. The function
returns the previously set up flag value.  The default value of
the flag is 0.  The parameter should be an integer after
implicit integer conversion.  The function will generate
exception <CODE>partype</CODE> if it is not true.</LI>
<LI><CODE>set_recovery (flag)</CODE>.  This function sets up a flag
whose nonzero value means making error recovery if a syntax
error occurred.  Otherwise, a syntax error results in finishing
parsing (although the syntax error function passed to
<CODE>parse</CODE> is called once).  The function returns the
previously set up flag value.  The default value of the flag is
1.  The parameter should be an integer after implicit integer
conversion.  The function will generate exception
<CODE>partype</CODE> if it is not true.</LI>
<LI><CODE>set_recovery_match (n_toks)</CODE>.  This function sets
up an internal parser parameter meaning how much subsequent
tokens should be successfully shifted to finish error recovery.
The default value is 3.  The function returns the previously
set up value.  The parameter should be an integer after
implicit integer conversion.  The function will generate
exception <CODE>partype</CODE> if it is not true.
</LI>
<LI><CODE>parse (tokens, error_func)</CODE>. This function is the
major function of the class.  It makes translation according to
the previously set up grammar of input given by the parameter
<CODE>tokens</CODE> whose value should be an array of objects of
predeclared class <CODE>token</CODE> or its subtype.  If the parser
recognizes a syntax error it calls the function given through
parameter <CODE>error_func</CODE> with six parameters:
<UL>
<LI>index of the token (in array <CODE>tokens</CODE>) on which
the syntax error occured.</LI>
<LI>the error token itself.  It may be <CODE>nil</CODE> for
end of file.</LI>
<LI>index of the first token (in array <CODE>tokens</CODE>)
ignored due to error recovery.</LI>
<LI>the first ignored token itself.  It may be
<CODE>nil</CODE> for end of file.</LI>
<LI>index of the first token (in array <CODE>tokens</CODE>)
which is not ignored after error recovery.</LI>
<LI>the first not ignored token itself.  It may be
<CODE>nil</CODE> for end of file.</LI>
</UL>

If the parser works with switched off error recovery (see
function <CODE>set_recovery</CODE>, the third and fifth parameters
will be negative and forth and sixth parameter will be
<CODE>nil</CODE>.

The function returns an object of the predeclared class
<CODE>anode</CODE> which is the root of the abtsract tree
representing the translation of the parser input.  The function
returns <CODE>nil</CODE> only if syntax error was occurred and
error recovery was switched off.  The function can generate
exception <CODE>partype</CODE> if the parameter types are wrong or
exception <CODE>invtoken_decl</CODE> if any of the input tokens
have a wrong code.  The function also can generate exception
<CODE>pmemory</CODE> if there is no memory for internal parser
data.</LI>
</UL>
</P>
<P>The call of the class <CODE>parser</CODE> itself can generate exception
<CODE>pmemory</CODE> if there is no memory for internal parser
data.</P>

<H3>Class <CODE>token</CODE></H3>

<P>Dino has a predeclared class <CODE>token</CODE>.  Objects of this class
should be the input of the Earley parser (see function <CODE>parse</CODE>
in class <CODE>parser</CODE>).  The result abstract tree representing the
translation will have input tokens as leaves.  The class
<CODE>token</CODE> has one public variable <CODE>code</CODE> whose value
should be the code of the corresponding terminal described in the
grammar.  You could extend the class description e.g. by adding
variables whose values could be attributes of the token (e.g. source
line number, name of an identifier, or value for a number).</P>

<H3>Class <CODE>anode</CODE></H3>

<P>Dino has a predeclared class <CODE>anode</CODE> whose objects are nodes of
the abtract tree representing the translation (see function
<CODE>parse</CODE> of class <CODE>parser</CODE>).  Objects of this class are
generated by the Earley parser.  The class has two public variables
<CODE>name</CODE> whose value is string representing name of the abstract
node as it given in the grammar and <CODE>transl</CODE> whose value is
array with abstract node fields as the array elements.  There are a
few node types which have special meaning:</P>
<P>
<UL>
<LI>Terminal node which has reserved name <CODE>$term</CODE>.  The
value of the public variable <CODE>transl</CODE> for this node is
an object of class <CODE>token</CODE> representing the
corresponding input token which was an element of the array
passed as a parameter of function <CODE>parse</CODE> of function
<CODE>parser</CODE>.</LI>
<LI>Error node which has reserved name <CODE>$error</CODE>.  This
node exists in one exemplar (see description of variable
<CODE>error_anode</CODE>) and represents the translation of
reserved grammar symbol <CODE>error</CODE>.  The value is public
variable <CODE>transl</CODE> will be <CODE>nil</CODE> in this case.</LI>
<LI>The empty node which has the reserved name <CODE>$nil</CODE>.
This node also exists in one exemplar (see description of
variable <CODE>nil_anode</CODE>) and represents the translation of
a grammar symbol for which we did not describe a translation.
For example, in a grammar rule an abstract node refers for the
translation of a nonterminal for which we do not produce a
translation.  The value is public variable of such class object
will be <CODE>nil</CODE> in this case.</LI>
<LI>Alternative node which has the reserved name <CODE>$alt</CODE>.
It represents all possible alternatives in the translation of
the grammar nonterminal.  The value of the public variable
<CODE>transl</CODE> will be an array with elements whose values are
objects of class <CODE>anode</CODE> which represent all possible
translations.  Such nodes can be generated by the parser only
if the grammar is ambiguous and we did not ask it to produce
only one translation.</LI>
</UL>
</P>

<H3>Variables <CODE>nil_anode</CODE> and <CODE>error_anode</CODE></H3>

<P>There is only one instance of <CODE>anode</CODE> which represents empty
(nil) nodes.  The same is true for the error nodes.  The final
variables <CODE>nil_anode</CODE> and <CODE>error_anode</CODE> correspondingly
refer to these nodes.</P>

<H3>Example of Earley parser usage.</H3>

<P>Let us write a program which transforms an expression into postfix
polish form.  Please, read the program comments to understand what the
code does.  The program should output string <CODE>"abcda*+*+"</CODE>
which is the postfix polish form of input string
<CODE>"a+b*(c+d*a)"</CODE>.
<BLOCKQUOTE><CODE>
<PRE>
          expose yaep.*;
          // The following is the expression grammar:
          var grammar = "E : E '+' T   # plus (0 2)\n\
                           | T         # 0\n\
                           | error     # 0\n\
                         T : T '*' F   # mult (0 2)\n\
                           | F         # 0\n\
                         F : 'a'       # 0\n\
                           | 'b'       # 0\n\
                           | 'c'       # 0\n\
                           | 'd'       # 0\n\
                           | '(' E ')' # 1";
          // Create parser and set up grammar.
          var p = parser ();
          p.set_grammar (grammar, 1);

          // Add attribute repr to token:
          class our_token (code) { use token former code; var repr; }
          // The following code forms input tokens from string:
          var str = "a+b*(c+d*a)";
          var i, inp = [#str : nil];
          for (i = 0; i &lt; #str; i++) {
            inp [i] = our_token (str[i] + 0);
            inp [i].repr = str[i];
          }
          // The following function output messages about syntax errors
          // syntax error recovery:
          fun error (err_start, err_tok,
                      start_ignored_num, start_ignored_tok_attr,
                      start_recovered_num, start_recovered_tok) {
            put ("syntax error on token #", err_start,
                 " (" @ err_tok.code @ ")");
            putln (" -- ignore ", start_recovered_num - start_ignored_num,
                   " tokens starting with token #", start_ignored_num);
          }

          var root = p.parse (inp, error); // parse

          // Output translation in polish inverse form
          fun pr (r) {
            var i, n = r.name;

            if (n == "$term")
              put (r.transl.repr);
            else if (n == "mult" || n == "plus") {
              for (i = 0; i &lt; #r.transl; i++)
                pr (r.transl [i]);
              put (n == "mult" ? "*" : "+");
            }
            else if (n != "$error") {
              putln ("internal error");
              exit (1);
            }
          }

          pr (root);
          putln ();
</PRE>
</CODE></BLOCKQUOTE>
</P>


<HR>
<A HREF="dino-10.html">Next</A>
<A HREF="dino-8.html">Previous</A>
<A HREF="dino.html#toc9">Contents</A>
</BODY>
</HTML>
