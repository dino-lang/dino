/* This file contains execution byte code description.  */

/*
   Copyright (C) 1997-2015 Vladimir Makarov.

   Written by Vladimir Makarov <vmakarov@gcc.gnu.org>

   This file is part of interpreter of DINO.

   This is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This software is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GNU CC; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.

*/

%type position_t int_t rint_t gmp_t rfloat_t string_t ucodestr_t bool_t
      fun_mode_t implementation_fun_t ticker_t ER_hidden_node_t void_ptr_t

%import {

#include "d_common.h"

typedef int int_t;

typedef void *void_ptr_t;

typedef struct ER_node *ER_hidden_node_t;

typedef enum
{
  /* Regular function/class/thread: */
  BC_no_gen,
  /* Try to generate C code.  This can not be used for threads.
     If the generation failed, we mark it as BC_no_gen.  */
  BC_gen,
  /* Implementation function:  */
  BC_builtin
} fun_mode_t;

typedef void (*implementation_fun_t) (int pars_number);

}

%export {

#if defined(NDEBUG)
#define BC_mpz_ptr(s) (&BC_gmp_(s).mpz)
#else
#define BC_mpz_ptr(s) \
  (BC_gmp_(s), &((_BC_ldl *) s)->_BC_S_ldl.gmp_.mpz)
#endif

/* This is type definition of program counter.  All byte code nodes is
   chained by members (one or two) of such type.  Remember that func
   may suspend the process therefore any expr should be also be
   chained by program counter.  If it is needed to execute the
   following and its pc is NULL than it means that finishing current
   process is needed.  There is process for block corresponding all
   program and its finishing means that program exits.  */
typedef BC_node_t pc_t;

/* This is a trick (usage that BC_NODE_MODE is macro)!!!  Therefore
   the following macro must apply to node with the same structure as
   node with mode m. */
#define BC_SET_MODE(v, m) (BC_NODE_MODE (v) = (m))

typedef void (*implementation_fun_t) (int pars_number);

extern BC_node_t first_program_bc;

#define EXCEPT_NAME "except"
extern BC_node_t except_bc_decl;

#define ERROR_NAME "error"
extern BC_node_t error_bc_decl;

#define MSG_NAME "msg"
extern BC_node_t msg_bc_decl;

#define SIGNAL_NAME "signal"
extern BC_node_t signal_bc_decl;

#define SIGINT_NAME "sigint"
extern BC_node_t sigint_bc_decl;

#define SIGILL_NAME "sigill"
extern BC_node_t sigill_bc_decl;

#define SIGABRT_NAME "sigabrt"
extern BC_node_t sigabrt_bc_decl;

#define SIGFPE_NAME "sigfpe"
extern BC_node_t sigfpe_bc_decl;

#define SIGTERM_NAME "sigterm"
extern BC_node_t sigterm_bc_decl;

#define SIGSEGV_NAME "sigsegv"
extern BC_node_t sigsegv_bc_decl;

#define INVENV_NAME "invenv"
extern BC_node_t invenv_bc_decl;

#define INVOP_NAME "invop"
extern BC_node_t invop_bc_decl;

#define OPTYPE_NAME "optype"
extern BC_node_t optype_bc_decl;

#define OPVALUE_NAME "opvalue"
extern BC_node_t opvalue_bc_decl;

#define INVINDEX_NAME "invindex"
extern BC_node_t invindex_bc_decl;

#define INDEXTYPE_NAME "indextype"
extern BC_node_t indextype_bc_decl;

#define INDEXVALUE_NAME "indexvalue"
extern BC_node_t indexvalue_bc_decl;

#define INDEXOP_NAME "indexop"
extern BC_node_t indexop_bc_decl;

#define INVSLICE_NAME "invslice"
extern BC_node_t invslice_bc_decl;

#define SLICETYPE_NAME "slicetype"
extern BC_node_t slicetype_bc_decl;

#define SLICEFORM_NAME "sliceform"
extern BC_node_t sliceform_bc_decl;

#define INVECTOR_NAME "invector"
extern BC_node_t invector_bc_decl;

#define VECLEN_NAME "veclen"
extern BC_node_t veclen_bc_decl;

#define VECVALUE_NAME "vecform"
extern BC_node_t vecform_bc_decl;

#define MATRIXVALUE_NAME "matrixform"
extern BC_node_t matrixform_bc_decl;

#define INVKEY_NAME "invkey"
extern BC_node_t invkey_bc_decl;

#define KEYVALUE_NAME "keyvalue"
extern BC_node_t keyvalue_bc_decl;

#define KEYOP_NAME "keyop"
extern BC_node_t keyop_bc_decl;

#define INVCALL_NAME "invcall"
extern BC_node_t invcall_bc_decl;

#define ABSTRCALL_NAME "abstrcall"
extern BC_node_t abstrcall_bc_decl;

#define CALLOP_NAME "callop"
extern BC_node_t callop_bc_decl;

#define PARTYPE_NAME "partype"
extern BC_node_t partype_bc_decl;

#define PARVALUE_NAME "parvalue"
extern BC_node_t parvalue_bc_decl;

#define INVRESULT_NAME "invresult"
extern BC_node_t invresult_bc_decl;

#define INVINPUT_NAME "invinput"
extern BC_node_t invinput_bc_decl;

#define INVFMT_NAME "invfmt"
extern BC_node_t invfmt_bc_decl;

#define INVENCODING_NAME "invencoding"
extern BC_node_t invencoding_bc_decl;

#define EOF_NAME "eof"
extern BC_node_t eof_bc_decl;

#define PARNUMBER_NAME "parnumber"
extern BC_node_t parnumber_bc_decl;

#define SYNCTHREADCALL_NAME "syncthreadcall"
extern BC_node_t syncthreadcall_bc_decl;

#define SYSERROR_NAME "syserror"
extern BC_node_t syserror_bc_decl;

#define EACCESS_NAME "eaccess"
extern BC_node_t eaccess_bc_decl;

#define EAGAIN_NAME "eagain"
extern BC_node_t eagain_bc_decl;

#define EBADF_NAME "ebadf"
extern BC_node_t ebadf_bc_decl;

#define EBUSY_NAME "ebusy"
extern BC_node_t ebusy_bc_decl;

#define ECHILD_NAME "echild"
extern BC_node_t echild_bc_decl;

#define EDEADLK_NAME "edeadlk"
extern BC_node_t edeadlk_bc_decl;

#define EDOM_NAME "edom"
extern BC_node_t edom_bc_decl;

#define EEXIST_NAME "eexist"
extern BC_node_t eexist_bc_decl;

#define EFAULT_NAME "efault"
extern BC_node_t efault_bc_decl;

#define EFBIG_NAME "efbig"
extern BC_node_t efbig_bc_decl;

#define EINTR_NAME "eintr"
extern BC_node_t eintr_bc_decl;

#define EINVAL_NAME "einval"
extern BC_node_t einval_bc_decl;

#define EIO_NAME "eio"
extern BC_node_t eio_bc_decl;

#define EISDIR_NAME "eisdir"
extern BC_node_t eisdir_bc_decl;

#define EMFILE_NAME "emfile"
extern BC_node_t emfile_bc_decl;

#define EMLINK_NAME "emlink"
extern BC_node_t emlink_bc_decl;

#define ENAMETOOLONG_NAME "enametoolong"
extern BC_node_t enametoolong_bc_decl;

#define ENFILE_NAME "enfile"
extern BC_node_t enfile_bc_decl;

#define ENODEV_NAME "enodev"
extern BC_node_t enodev_bc_decl;

#define ENOENT_NAME "enoent"
extern BC_node_t enoent_bc_decl;

#define ENOEXEC_NAME "enoexec"
extern BC_node_t enoexec_bc_decl;

#define ENOLCK_NAME "enolck"
extern BC_node_t enolck_bc_decl;

#define ENOMEM_NAME "enomem"
extern BC_node_t enomem_bc_decl;

#define ENOSPC_NAME "enospc"
extern BC_node_t enospc_bc_decl;

#define ENOSYS_NAME "enosys"
extern BC_node_t enosys_bc_decl;

#define ENOTDIR_NAME "enotdir"
extern BC_node_t enotdir_bc_decl;

#define ENOTEMPTY_NAME "enotempty"
extern BC_node_t enotempty_bc_decl;

#define ENOTTY_NAME "enotty"
extern BC_node_t enotty_bc_decl;

#define ENXIO_NAME "enxio"
extern BC_node_t enxio_bc_decl;

#define EPERM_NAME "eperm"
extern BC_node_t eperm_bc_decl;

#define EPIPE_NAME "epipe"
extern BC_node_t epipe_bc_decl;

#define ERANGE_NAME "erange"
extern BC_node_t erange_bc_decl;

#define EROFS_NAME "erofs"
extern BC_node_t erofs_bc_decl;

#define ESPIPE_NAME "espipe"
extern BC_node_t espipe_bc_decl;

#define ESRCH_NAME "esrch"
extern BC_node_t esrch_bc_decl;

#define EXDEV_NAME "exdev"
extern BC_node_t exdev_bc_decl;

#define SYSTEMCALL_NAME "systemcall"
extern BC_node_t systemcall_bc_decl;

#define NOSHELL_NAME "noshell"
extern BC_node_t noshell_bc_decl;

#define SYSTEMFAIL_NAME "systemfail"
extern BC_node_t systemfail_bc_decl;

#define INVREGEX_NAME "invregex"
extern BC_node_t invregex_bc_decl;

#define INVPARSER_NAME "invparser"
extern BC_node_t invparser_bc_decl;

#define INVGRAMMAR_NAME "invgrammar"
extern BC_node_t invgrammar_bc_decl;

#define INVTOKEN_NAME "invtoken"
extern BC_node_t invtoken_bc_decl;

#define PMEMORY_NAME "pmemory"
extern BC_node_t pmemory_bc_decl;

#define INVEXTERN_NAME "invextern"
extern BC_node_t invextern_bc_decl;

#define NOEXTERN_NAME "noextern"
extern BC_node_t noextern_bc_decl;

#define LIBCLOSE_NAME "libclose"
extern BC_node_t libclose_bc_decl;

#define NOEXTERNSUPP_NAME "noexternsupp"
extern BC_node_t noexternsupp_bc_decl;

#define INVENVAR_NAME "invenvar"
extern BC_node_t invenvar_bc_decl;

#define INTERNAL_NAME "internal"
extern BC_node_t internal_bc_decl;

#define INVACCESS_NAME "invaccess"
extern BC_node_t invaccess_bc_decl;

#define ACCESSOP_NAME "accessop"
extern BC_node_t accessop_bc_decl;

#define ACCESSVALUE_NAME "accessvalue"
extern BC_node_t accessvalue_bc_decl;

#define IMMUTABLE_NAME "immutable"
extern BC_node_t immutable_bc_decl;

#define PATTERNMATCH_NAME "patternmatch"
extern BC_node_t patternmatch_bc_decl;

#define DEADLOCK_NAME "deadlock"
extern BC_node_t deadlock_bc_decl;

#define SYNCWAIT_NAME "syncwait"
extern BC_node_t syncwait_bc_decl;

#define ARGV_NAME "argv"
extern BC_node_t argv_bc_decl;

#define ENV_NAME "env"
extern BC_node_t env_bc_decl;

#define VERSION_NAME "version"
extern BC_node_t version_bc_decl;

#define MAIN_THREAD_NAME "main_thread"
extern BC_node_t main_thread_bc_decl;

#define CURR_THREAD_NAME "curr_thread"
extern BC_node_t curr_thread_bc_decl;

#define ANODE_NAME "anode"
extern BC_node_t anode_bc_decl;

#define TOKEN_NAME "token"
extern BC_node_t token_bc_decl;

#define CODE_NAME "code"
extern BC_node_t code_bc_decl;

#define NIL_ANODE_NAME "nil_anode"
extern BC_node_t nil_anode_bc_decl;

#define ERROR_ANODE_NAME "error_anode"
extern BC_node_t error_anode_bc_decl;

#define PARSER_NAME "parser"
extern BC_node_t parser_bc_decl;

#define AMBIGUOUS_P_NAME "ambiguous_p"
extern BC_node_t ambiguous_p_bc_decl;

#define INT_EARLEY_PARSE_GRAMMAR_NAME "int_earley_parse_grammar"
extern BC_node_t int_earley_parse_grammar_bc_decl;

#define INT_EARLEY_SET_DEBUG_LEVEL_NAME "int_earley_set_debug_level"
extern BC_node_t int_earley_set_debug_level_bc_decl;

#define INT_EARLEY_SET_ONE_PARSE_FLAG_NAME "int_earley_set_one_parse_flag"
extern BC_node_t int_earley_set_one_parse_flag_bc_decl;

#define INT_EARLEY_SET_LOOKAHEAD_LEVEL_NAME "int_earley_set_lookahead_level"
extern BC_node_t int_earley_set_lookahead_level_bc_decl;

#define INT_EARLEY_SET_COST_FLAG_NAME "int_earley_set_cost_flag"
extern BC_node_t int_earley_set_cost_flag_bc_decl;

#define INT_EARLEY_SET_ERROR_RECOVERY_FLAG_NAME \
  "int_earley_set_error_recovery_flag"
extern BC_node_t int_earley_set_error_recovery_flag_bc_decl;

#define INT_EARLEY_SET_RECOVERY_MATCH_NAME "int_earley_set_recovery_match"
extern BC_node_t int_earley_set_recovery_match_bc_decl;

#define INT_EARLEY_PARSE_NAME "int_earley_parse"
extern BC_node_t int_earley_parse_bc_decl;

#define INT_EARLEY_CREATE_GRAMMAR_NAME "int_earley_create_grammar"
extern BC_node_t int_earley_create_grammar_bc_decl;

#define FILE_NAME "file"
extern BC_node_t file_bc_decl;

#define FILE_PTR_NAME "file_ptr"
extern BC_node_t file_ptr_bc_decl;

#define UNGET_CHAR_NAME "unget_char"
extern BC_node_t unget_char_bc_decl;

#define FILE_ICD_NAME "file_icd"
extern BC_node_t file_icd_bc_decl;

#define FILE_BYTE_OCD_NAME "file_byte_ocd"
extern BC_node_t file_byte_ocd_bc_decl;

#define FILE_UCODE_OCD_NAME "file_ucode_ocd"
extern BC_node_t file_ucode_ocd_bc_decl;

#define FILE_ENCODING_NAME "file_encoding"
extern BC_node_t file_encoding_bc_decl;

#define FILE_ENCODING_TYPE_NAME "file_encoding_type"
extern BC_node_t file_encoding_type_bc_decl;

#define STDIN_NAME "stdin"
extern BC_node_t stdin_bc_decl;

#define STDOUT_NAME "stdout"
extern BC_node_t stdout_bc_decl;

#define STDERR_NAME "stderr"
extern BC_node_t stderr_bc_decl;

#define MAX_NAME "max"
extern BC_node_t max_bc_decl;

#define MIN_NAME "min"
extern BC_node_t min_bc_decl;

#define TOLOWER_NAME "tolower"
extern BC_node_t tolower_bc_decl;

#define TOUPPER_NAME "toupper"
extern BC_node_t toupper_bc_decl;

#define TRANSLIT_NAME "translit"
extern BC_node_t translit_bc_decl;

#define ELTYPE_NAME "eltype"
extern BC_node_t eltype_bc_decl;

#define KEYS_NAME "keys"
extern BC_node_t keys_bc_decl;

#define CLOSURE_NAME "closure"
extern BC_node_t closure_bc_decl;

#define CONTEXT_NAME "context"
extern BC_node_t context_bc_decl;

#define INSIDE_NAME "inside"
extern BC_node_t inside_bc_decl;

#define ISA_NAME "isa"
extern BC_node_t isa_bc_decl;

#define SUBV_NAME "subv"
extern BC_node_t subv_bc_decl;

#define CMPV_NAME "cmpv"
extern BC_node_t cmpv_bc_decl;

#define DEL_NAME "del"
extern BC_node_t del_bc_decl;

#define INS_NAME "ins"
extern BC_node_t ins_bc_decl;

#define INSV_NAME "insv"
extern BC_node_t insv_bc_decl;

#define REV_NAME "rev"
extern BC_node_t rev_bc_decl;

#define SORT_NAME "sort"
extern BC_node_t sort_bc_decl;

#define SQRT_NAME "sqrt"
extern BC_node_t sqrt_bc_decl;

#define EXP_NAME "exp"
extern BC_node_t exp_bc_decl;

#define LOG_NAME "log"
extern BC_node_t log_bc_decl;

#define LOG10_NAME "log10"
extern BC_node_t log10_bc_decl;

#define POW_NAME "pow"
extern BC_node_t pow_bc_decl;

#define SIN_NAME "sin"
extern BC_node_t sin_bc_decl;

#define COS_NAME "cos"
extern BC_node_t cos_bc_decl;

#define ATAN2_NAME "atan2"
extern BC_node_t atan2_bc_decl;

#define MATCH_NAME "match"
extern BC_node_t match_bc_decl;

#define GMATCH_NAME "gmatch"
extern BC_node_t gmatch_bc_decl;

#define SUB_NAME "sub"
extern BC_node_t sub_bc_decl;

#define GSUB_NAME "gsub"
extern BC_node_t gsub_bc_decl;

#define SPLIT_NAME "split"
extern BC_node_t split_bc_decl;

#define SPLIT_REGEX_NAME "split_regex"
extern BC_node_t split_regex_bc_decl;

#define SRAND_NAME "srand"
extern BC_node_t srand_bc_decl;

#define RAND_NAME "rand"
extern BC_node_t rand_bc_decl;

#define PROCESS_ERRNO_NAME "__process_errno__"
extern BC_node_t process_errno_bc_decl;

#define READDIR_NAME "readdir"
extern BC_node_t readdir_bc_decl;

#define FTYPE_NAME "ftype"
extern BC_node_t ftype_bc_decl;

#define FUIDN_NAME "fuidn"
extern BC_node_t fun_bc_decl;

#define FGRPN_NAME "fgrpn"
extern BC_node_t fgrpn_bc_decl;

#define FSIZE_NAME "fsize"
extern BC_node_t fsize_bc_decl;

#define FATIME_NAME "fatime"
extern BC_node_t fatime_bc_decl;

#define FMTIME_NAME "fmtime"
extern BC_node_t fmtime_bc_decl;

#define FCTIME_NAME "fctime"
extern BC_node_t fctime_bc_decl;

#define FUMODE_NAME "fumode"
extern BC_node_t fumode_bc_decl;

#define FGMODE_NAME "fgmode"
extern BC_node_t fgmode_bc_decl;

#define FOMODE_NAME "fomode"
extern BC_node_t fomode_bc_decl;

#define TIME_NAME "time"
extern BC_node_t time_bc_decl;

#define STRTIME_NAME "strtime"
extern BC_node_t strtime_bc_decl;

#define TIME_FORMAT_NAME "time_format"
extern BC_node_t time_format_bc_decl;

#define CLOCK_NAME "clock"
extern BC_node_t clock_bc_decl;

#define GC_NAME "gc"
extern BC_node_t gc_bc_decl;

#define RENAME_NAME "rename"
extern BC_node_t rename_bc_decl;

#define REMOVE_NAME "remove"
extern BC_node_t remove_bc_decl;

#define MKDIR_NAME "mkdir"
extern BC_node_t mkdir_bc_decl;

#define RMDIR_NAME "rmdir"
extern BC_node_t rmdir_bc_decl;

#define GETCWD_NAME "getcwd"
extern BC_node_t getcwd_bc_decl;

#define CHDIR_NAME "chdir"
extern BC_node_t chdir_bc_decl;

#define CHUMOD_NAME "chumod"
extern BC_node_t chumod_bc_decl;

#define CHGMOD_NAME "chgmod"
extern BC_node_t chgmod_bc_decl;

#define CHOMOD_NAME "chomod"
extern BC_node_t chomod_bc_decl;

#define ISATTY_NAME "isatty"
extern BC_node_t isatty_bc_decl;

#define OPEN_NAME "open"
extern BC_node_t open_bc_decl;

#define CLOSE_NAME "close"
extern BC_node_t close_bc_decl;

#define FLUSH_NAME "flush"
extern BC_node_t flush_bc_decl;

#define POPEN_NAME "popen"
extern BC_node_t popen_bc_decl;

#define PCLOSE_NAME "pclose"
extern BC_node_t pclose_bc_decl;

#define TELL_NAME "tell"
extern BC_node_t tell_bc_decl;

#define SEEK_NAME "seek"
extern BC_node_t seek_bc_decl;

#define PUT_NAME "put"
extern BC_node_t put_bc_decl;

#define PUTLN_NAME "putln"
extern BC_node_t putln_bc_decl;

#define FPUT_NAME "fput"
extern BC_node_t fput_bc_decl;

#define FPUTLN_NAME "fputln"
extern BC_node_t fputln_bc_decl;

#define SPUT_NAME "sput"
extern BC_node_t sput_bc_decl;

#define SPUTLN_NAME "sputln"
extern BC_node_t sputln_bc_decl;

#define PUTF_NAME "putf"
extern BC_node_t putf_bc_decl;

#define FPUTF_NAME "fputf"
extern BC_node_t fputf_bc_decl;

#define SPUTF_NAME "sputf"
extern BC_node_t sputf_bc_decl;

#define PRINT_NAME "print"
extern BC_node_t print_bc_decl;

#define PRINTLN_NAME "println"
extern BC_node_t println_bc_decl;

#define FPRINT_NAME "fprint"
extern BC_node_t fprint_bc_decl;

#define FPRINTLN_NAME "fprintln"
extern BC_node_t fprintln_bc_decl;

#define SPRINT_NAME "sprint"
extern BC_node_t sprint_bc_decl;

#define SPRINTLN_NAME "sprintln"
extern BC_node_t sprintln_bc_decl;

#define GET_NAME "get"
extern BC_node_t get_bc_decl;

#define GETLN_NAME "getln"
extern BC_node_t getln_bc_decl;

#define GETF_NAME "getf"
extern BC_node_t getf_bc_decl;

#define FGET_NAME "fget"
extern BC_node_t fget_bc_decl;

#define FGETLN_NAME "fgetln"
extern BC_node_t fgetln_bc_decl;

#define FGETF_NAME "fgetf"
extern BC_node_t fgetf_bc_decl;

#define SCAN_NAME "scan"
extern BC_node_t scan_bc_decl;

#define SCANLN_NAME "scanln"
extern BC_node_t scanln_bc_decl;

#define FSCAN_NAME "fscan"
extern BC_node_t fscan_bc_decl;

#define FSCANLN_NAME "fscanln"
extern BC_node_t fscanln_bc_decl;

#define GETPID_NAME "getpid"
extern BC_node_t getpid_bc_decl;

#define GETPGID_NAME "getpgid"
extern BC_node_t getpgid_bc_decl;

#define GETUN_NAME "getun"
extern BC_node_t getun_bc_decl;

#define GETEUN_NAME "geteun"
extern BC_node_t geteun_bc_decl;

#define GETGN_NAME "getgn"
extern BC_node_t getgn_bc_decl;

#define GETEGN_NAME "getegn"
extern BC_node_t getegn_bc_decl;

#define GETGROUPS_NAME "getgroups"
extern BC_node_t getgroups_bc_decl;

#define SYSTEM_NAME "system"
extern BC_node_t system_bc_decl;

#define EXIT_NAME "exit"
extern BC_node_t exit_bc_decl;

#define FOLD_NAME "fold"
extern BC_node_t fold_bc_decl;

#define FILTER_NAME "filter"
extern BC_node_t filter_bc_decl;

#define MAP_NAME "map"
extern BC_node_t map_bc_decl;

#define TRANSPOSE_NAME "transpose"
extern BC_node_t transpose_bc_decl;

#define SET_ENCODING_NAME "set_encoding"
extern BC_node_t set_encoding_bc_decl;

#define GET_ENCODING_NAME "get_encoding"
extern BC_node_t get_encoding_bc_decl;

#define SET_FILE_ENCODING_NAME "set_file_encoding"
extern BC_node_t set_file_encoding_bc_decl;

#define GET_FILE_ENCODING_NAME "get_file_encoding"
extern BC_node_t get_file_encoding_bc_decl;

#define INIT_NAME "__init__"
extern BC_node_t init_bc_decl;

extern BC_node_t attach_info (BC_node_t);
extern void enumerate_infoed_bcode (BC_node_t, int *, int *);
extern void init_env_decl_processing (void);
extern int all_env_decls_processed_p (void);
extern void process_env_decl (BC_node_t);
extern void prepare_block (BC_node_t);
extern void *gen_cfblock (BC_node_t fblock);

}

%%

/* This node should be first.  As we assume that its code is zero.  */
%abstract
icode :: %root /* A common node for evaluation */
;

vdecl :: decl /* var decl */
%other
        var_num : int_t
;
fdecl :: decl /* fblock decl */
%other
	fblock : fblock
;
evdecl, efdecl :: edecl
;

/* !!!For any change here, corresponding changes in d_bcread.c,
   d_bc[fn].shilka, and d_context.c::copy_fun_bc_block should be also
   done.  */

/* Remember: alsways use right abstract node when operands are immediate.  */

/* The block flow in except presence is the following:

              excepts                              next_except
   try block ----------> class expr -->  except ---------> class expr...
       |                                   | next                   ....
       |                                   V
       |                                catch block                 ....
       |                                   | next                     |
       |                                   V                          |
        ------------------------------->  nop  <----------------------
          next                             | next
                                           V
                                       
*/
block :: bcode
%other
	scope : block
        block_number : int_t /* defined at the start of evaluation */
	excepts : bcode  /* exception list */
        decls : decl {$ = NULL;}
        friends : friend
        uses : use
        vars_num : int_t /* if it is negative than it is a simple block */
        tvars_num : int_t
        ext_life_p : bool_t
        /* The following fields are used and defined only during evaluation  */
        saved_sync_p : bool_t
	/* Used to suppress multiple messages about calling undefined
	   destroy function.  */ 
        undef_destroy_p : bool_t {$ = FALSE;}
        /* The following field is cached address of container for the
           current block.  The cached value is not defined if
           cached_container_tick is not equal to the current value. */
	cached_container_address : string_t
	cached_container_tick : int_t {$ = -1;}
        /* The following fields is setup during Bcode preparation for
	   its evaluation.  They describe table: fldid -> the
	   corresponding decl in the block.  */
 	fld_table_len : int_t {$ = 0;}
 	fld_table : string_t {$ = NULL;}
        /* The following fields are used and defined only during evaluation  */
        calls_number : int_t {$ = 0;}
	free_stacks : ER_hidden_node_t {$ = NULL;}
;
fblock :: block
%other
        /* For forward decl fun without definition the field `next' is
	   always NULL.  */
        fdecl : fdecl
        fun_p, class_p, thread_p, args_p : bool_t
        simple_p, pure_fun_p, forward_p : bool_t
        pars_num, min_pars_num : int_t
        fmode : fun_mode_t {$ = BC_no_gen;}
        /* The following fields are used and defined only during evaluation  */
        implementation_fun : implementation_fun_t {$ = NULL;}
	/* Time of function (class body) execution.  Defined if the
	   previous field is not zero. */
        exec_time : ticker_t
        interrupts_number : int_t
;

/* Setup ctop top op1 + op3 - 1 vars, making vars from [op2, op1 +
   op3 - 1] undef. */
stinc :: op3i;
/* Move op2 to op1, setup ctop just below op1. */
stdecm :: op2;
/* Make op1 is undef, setup ctop just below op1.  Nonzero op2 means
   the last inlined bc. */
stdecu :: op2i;

ldnil, ldthis :: op1; /* result place */
flat :: op1; /* operand and result place */
ldch, ldi, ldtp :: op2i; /* result place, value as int  */

/* Load integer which can not be presented by int.  */
ldbi :: op1
%other
        bi : rint_t
;

ldl :: op1 /* result place */
%other
	/* Don't use directly gmp_ for performance reasons.  Only use
	   BC_mpz_ptr instead.  */
        gmp_ : gmp_t
;

ldf :: op1 /* result place */
%other
        f : rfloat_t
;

lds :: op1 /* result place */
%other
        str : string_t;
;

ldus :: op1 /* unicode string */
%other
        ustr : ucodestr_t;
;

/* non-local / external var value / reference [and value].
   Decl is vdecl (var, lvar, lvarv), evdecl (evar, levar, levarv)  */
var, lvar, lvarv, evar, levar, levarv :: op1_decl; /* result place */

fun, efun, class :: op1_decl; /* result place, fdecl/efdecl */

/* op1 is result place; op2 and op3 are container place and index/key place
   or dim for slice.  */ 
ind :: op3;
sl, lslv :: op3i;

/* Matrix element indexing.  op1 is result place, op2 is container,
   op3 and op4 are indexes.  */
ind2 :: op4;

/* op1 is result place; op2 is container place and op3 is block decl
   ident number */	
fld, lfld, lfldv :: field;

const, new, not, plus, minus, bnot, length,
  tpof, chof, iof, lof, fof, vecof, tabof :: op2; /* result and operand places */

/* integer variants of some above insns.  */
inot, iplus, iminus, ibnot :: op2;

/* fp variants: */
fplus, fminus :: op2;

/* vector folding operation (info is source2: pos2 is an operand one): */
fold_add, fold_mult, fold_and, fold_or, fold_xor, fold_concat :: fold_op
;

/* result and two operand places.  */
fmtvecof, in, or, xor, and, eq, ne, id, unid, lt, gt, le, ge,
  lsh, rsh, ash, concat, add, sub, mult, div, mod :: op3;
addi, multi, eqi, nei, lti, gti, lei, gei :: op3i; /* non-slice insns */

/* op1 = op2 * op3 + op4.  */
madd :: op4;

/* integer variants of most above insns.  */
ior, ixor, iand, ieq, ine, ilt, igt, ile, ige,
  ilsh, irsh, iash, iadd, isub, imult, idiv, imod :: op3;
iaddi, imulti, ieqi, inei, ilti, igti, ilei, igei :: op3i;

/* fp variants: */
fadd, fsub, fmult, fdiv, fmodop :: op3;

/* integer-fp variants: */
ifadd, ifsub, fisub, ifmult, ifdiv, fidiv :: op3;
faddi, fmulti :: op3i;

b :: bcode; /* unconditional branch to next */

btdef :: br;  /* skip if op1 is defined.  */

/* Branch when true, false, false (non-interrupt) and non-nil.
   bt info is for_stmt, bf is if_stmt, bfni is cond,
   btdef is par_assign.  */
bt, bf, bfni :: br; /* operand place and goto byte code ref.  */

/* Integer variants of above insns */
ibt, ibf, ibfni :: br;

/* Branch and set: res <= op; goto (op or !op ? pc : next).
   Created logical_or (brts) or logical_and (brfs).  */
brts, brfs :: brs;

/* combined for non-slice comparison: goto pc if(not) op1 cmp? bcmp_op2.
   bcmp_res can be used as temporary.  */
bteq, btne, btge, btlt, btle, btgt :: bcmp;

/* integer variants */
ibteq, ibtne, ibtge, ibtlt, ibtle, ibtgt :: bcmp;

/* fp variants */
fbteq, fbtne, fbtge, fbtlt, fbtle, fbtgt :: bcmp;

bteqi, btnei, btgei, btlti, btlei, btgti :: bcmpi;

/* integer variants */
ibteqi, ibtnei, ibtgei, ibtlti, ibtlei, ibtgti :: bcmpi;

/* op1 = op1 + inc; bcmp_res = op1 cmp bcmp_op2; bt bcmp_res
   Inc is int.  All others are places.  */
bteqinc, btneinc, btgeinc, btltinc, btleinc, btgtinc :: binc;

/* Integer variants */
ibteqinc, ibtneinc, ibtgeinc, ibtltinc, ibtleinc, ibtgtinc :: binc;

/* Logical conversion created from a number.  */
lconv :: op2; /* result and operand places.  */

/* This node serves as test loop expr in the interpreter.  The pc flows as
   following

  pushi 0 ->foreach designator(s) calculation->table calc.->foreach->
               ^                                            |
               |                                            |: body_pc
             pushi 1<-------------foreach_stmts<------------
*/

/* Table, foreach search start, local/global var  places.
   Info is source2 (pos is position of foreach-stmt, pos2
   is the index designator position).  */
foreach :: op3
%other
	body_pc : bcode
;

/* Table, foreach search start, key container and container element
   places.  Info is source2 (pos is position of foreach-stmt, pos2 is
   the index designator position).  */
foreach2 :: foreach
%other
        element : int_t
;

vec, tab :: op3i; /* result place, element parts start place, parts number */

move :: op2 /* destination/source places.  */
%other
        /* rhs variable/function or lsh var if rhs is not variable/function. */
        move_decl : decl
;
imove, fmove :: move
;
/* Assignments: */
/* vec or tab, stack, external store: container, element, value places */
stvt, sts, ste :: op3;
/* analogous to above ones but the assigned value may be undef */
stvtu, stsu, steu :: op3;
slst :: op3i2; /* vector place, slice dimension as int, value place  */


/* Assignment with operations: */
/* container, element, expr, lvalue val places */
mult_st, div_st, mod_st,
  add_st, sub_st, concat_st, lsh_st,
  rsh_st, ash_st, and_st, xor_st, or_st :: op4;

mult_slst, div_slst, mod_slst,
  add_slst, sub_slst, concat_slst, lsh_slst,
  rsh_slst, ash_slst, and_slst, xor_slst, or_slst :: op_slst;

out :: op1i; /* # of surrounding blocks as int */

/* general calls: params start place, params number as int.
   Letter t means tail call.  */
call, tcall :: op2i;

/* immediate calls: params start place, params number as int, fun
   decl.  Immidiate implementation function call is ibcall.  For
   others: first letter t or c means top stack or current stack
   context, tcall means tail call.  */
ibcall, icall, itcall, ticall, titcall, cicall, citcall:: imcall;

/* method call: params start place, params number as int, object, and
   method ident number.  */
mcall :: op4i24
%other
	mid : string_t  /* method identifier  */
        /* Set up during evaluation for quicker access.  */
        mhint : decl { $ = NULL; }
;

leave:: bcode; /* Return without value.  */

/* stpop is used for inlined block leave.  Position is block end.  Pop
   op1 stack elements.  Nonzero op2 means the last inlined bcode.  */
stpop :: op2i12;

/* Analogous to leave but it is always the last code in the block
   statement chain. */
bend :: bcode
%other
	block : block
;

/* Function block end.  */
fbend :: bend
;

ret :: op1  /* return with result: ret value place */
%other
        ret_decl : decl /* no-null if ident in the return. */
;
throw :: op1;
wait :: br;
waitend :: bcode;

except :: op2 /* except instance and class places */
%other
	next_except : bcode
;

/* Patterns:  */
chvec :: check; /* check that op1 is a vector */
chvend :: check2; /* check that op2 at the end of vector op1 */
/* Increase op2 by op3 and check that op2 is not outside vector op1.  */
chvlen :: check3;
/* Depending on the op5 value. If it is nonzero, assign op2 element of
   vector op1 to op4, increase op2 by op3, and check that op2 is not
   outside the vector and (op3 - 1) elements are equal to op4 element.
   If op5 is zero, skip assigning and check op3 elements on
   equality.  */
chvel :: check5i;
chtab :: check; /* check that op1 is a table */
chtend :: check2i; /* check that #op1 == immed op2 */
/* Depending on the op5 value. If it is 1, assign element with key op2
   of table op1 to op3, fail if there is no such element.  If op4 is
   zero, skip assigning and check the element on equality with op3.
   If it is 2, don't assign or check equality (op3 is ignored in this
   case). */
chtel :: check4i;
chst :: check2; /* check that op1 is a stack and is of fun/class op2 */
chstend :: check2i; /* check that stack op1 has immed op2 params */
/* Depending on the op5 value.  If it is 1, check that there is immed
   op4 param of class/fun op2 in stack op1 and assign it to op3.  If
   it is zero, check on equality with op3 instead of assigning.  If it
   is 2, don't assign or check equality (op3 is ignored in this
   case). */
chstel :: check5i45;

/* Check that string ch_op2 matches regexp ch_op3.  The result of
   matching (array of indexes) is put into op.  */
rmatch :: check3;

/* As above but regexp is given as string  */
rmatchs :: check2
%other
     rm_str : string_t
;

/* These codes represent printing expr in REPL.  It is never output or
   input.  Code rpr_def never prints undefined values (e.g. proc call
   results).  */
rpr, rpr_def :: op1
;

/* This byte code should be last.  The byte code is used only during
   code generation.  Info is info of the corresponding cond, for-stmt,
   foreach-stmt, if-stmt, par_assign, block for end of exceptions.  It
   is removed before the execution.  */
nop :: bcode;

/* Nodes used for code generation purposes only: put such nodes here
   to keep executed node number < 256.  */

/* Abstract nodes.  Put it here to keep executed node number < 256.  */

/* Declarations. */
%abstract
decl :: source
%other
        decl_num : int_t /* unique decl number */
        fldid_num : int_t {$ = -1;}
        public_p : bool_t
        ident : string_t
	decl_scope : block
        next_decl : decl /* next decl in the same scope */
;
%abstract
edecl :: decl /* external decl */
%other
	address : string_t {$ = NULL;} /* defined during evaluation only.  */
;
%abstract
bcode :: icode
%other
        next : bcode
        /* It is an info node before evaluation and source node during
	   the evaluation.  */
        info : %root
;
%abstract
op1 :: bcode
%other
        op1 : int_t
;
%abstract
op1_decl :: op1
%other
        decl : decl
;
%abstract
op1i :: op1 /* op1 is int const */
;
%abstract
op2 :: op1
%other
        op2 : int_t
;
%abstract
op2i :: op2 /* op2 is int const */
;
%abstract
op2i12 :: op2 /* op1 and op2 are int const */
;
%abstract
op3 :: op2
%other
        op3 : int_t
;
%abstract
op3i :: op3 /* op3 is int const */
;
%abstract
op3i2 :: op3 /* op2 is int const */
;
%abstract
op4 :: op3
%other
        op4 : int_t
;
%abstract
op4i2 :: op4 /* op2 is int const */
;
%abstract
op4i24 :: op4i2 /* op2 and op4 are int const */
;
%abstract
br :: op1
%other
        pc : bcode
;
%abstract
brs :: br
%other
	res : int_t
;
%abstract
bcmp :: br
%other
	bcmp_op2, bcmp_res : int_t
;
%abstract  /* bcmp_op2 as int const.  */
bcmpi :: bcmp
;
%abstract
binc :: bcmp
%other
	binc_inc : int_t
;
%abstract
check :: op1
%other
        fail_pc : bcode
;
%abstract
check2 :: check
%other
        ch_op2 : int_t
;
%abstract
check2i :: check2  /* ch_op2 is int const */
;
%abstract
check3 :: check2
%other
        ch_op3 : int_t
;
%abstract
check3i2 :: check3 /* ch_op2 is int const */
;
%abstract
check4 :: check3
%other
        ch_op4 : int_t
;
%abstract
check4i :: check4 /* ch_op4 is int const */
;
%abstract
check5 :: check4
%other
        ch_op5 : int_t
;
%abstract
check5i :: check5 /* ch_op5 is int const */
;
%abstract
check5i45 :: check5i /* ch_op4 and ch_op5 are int consts */
;
%abstract
imcall :: op2i
%other
	cfblock : fblock
;
%abstract
field :: op3i
%other
	fldid : string_t  /* field identifier  */
        /* Set up during evaluation for quicker access.  */
        hint : decl { $ = NULL; }
;
%abstract
fold_op :: op2
;
/* Slice assignments: */
/* container place, slice dimension as int, expr place, lvalue val place */
%abstract
op_slst :: op4i2
;
/* Declarations nodes: */

/* Positions:  */
source :: icode
%other
        pos : position_t
;
source2 :: source
%other
        /* alternative position, e.g. variable position for a store or
	   operand position for an operator.  */
        pos2 : position_t
;
source3 :: source2
%other
        /* another alternative position, e.g. 2nd operand position for
	   an operator.  */
        pos3 : position_t
;
friend :: icode
%other
	friend : block
        next_friend : friend
;
use :: icode
%other
	use : block
        next_use : use
;

/* ---- Nodes used only for generation and optimizations ---- */
/* Before interpretation itself we use the following node for storing
   info about byte code for different optimizations.  Infos chain all
   byte code (icode) for each fdecl and the top block.  */
info :: %root
%other
        source : source /* The corresponding byte code source node */
        next_info : info {$ = NULL;}
        prev_info : info {$ = NULL;}
        bc : icode /* The corresponding byte code */
        subst : icode /* used for optimizations  */
	aux : void_ptr_t /* used for type inference  */
        idn : int_t /* Info identifier number */
	reachable_p : bool_t
	inline_p : bool_t {$ = FALSE;}
;


/* Used during C code generation.  */
gen_info :: %root
%other
        origin_info : source
        /* Label number, negative if no label is neccesary */
        label_num : int_t
;

%%

#include "d_built.h"
#include "d_runtab.h"

/* Remember that first program byetcode is always block. */
BC_node_t first_program_bc;

/* Create and add info to NODE.  It can be done only once.  Return the
   info node. */
BC_node_t
attach_info (BC_node_t node)
{
  BC_node_t info = BC_create_node (BC_NM_info);
  
  BC_set_source (info, BC_info (node));
  d_assert (BC_info (node) != NULL
	    && BC_IS_OF_TYPE (BC_info (node), BC_NM_source));
  BC_set_info (node, info);
  BC_set_bc (info, node);
  BC_set_prev_info (info, NULL);
  BC_set_next_info (info, NULL);
  return info;
}

/* Enumerate infos of BLOCK starting with *CURR_IDN and decls starting
   with *CURR_DECL_NUM.  Update *CURR_IDN and *CURR_DECL_NUM. */
void
enumerate_infoed_bcode (BC_node_t block, int *curr_idn, int *curr_decl_num)
{
  BC_node_t bc_decl, info, bc;
  int info_p;

  info = BC_info (block);
  d_assert (BC_IS_OF_TYPE (block, BC_NM_block)
	    && BC_IS_OF_TYPE (info, BC_NM_info));
  info_p = BC_IS_OF_TYPE (block, BC_NM_fblock) || BC_scope (block) == NULL;
  if (info_p)
    {
      BC_set_idn (info, *curr_idn);
      (*curr_idn)++;
    }
  for (bc_decl = BC_decls (block);
       bc_decl != NULL;
       bc_decl = BC_next_decl (bc_decl))
    {
      d_assert (BC_ident (bc_decl) != NULL);
      BC_set_decl_num (bc_decl, *curr_decl_num);
      (*curr_decl_num)++;
      if (BC_IS_OF_TYPE (bc_decl, BC_NM_fdecl))
	enumerate_infoed_bcode (BC_fblock (bc_decl), curr_idn, curr_decl_num);
    }
  if (info_p)
    for (info = BC_next_info (info); info != NULL; info = BC_next_info (info))
      {
	bc = BC_bc (info);
	if (BC_NODE_MODE (bc) == BC_NM_block)
	  enumerate_infoed_bcode (bc, curr_idn, curr_decl_num);
	BC_set_idn (info, *curr_idn);
	(*curr_idn)++;
      }
}

/* See comments for ENVIRONMENT. */
BC_node_t except_bc_decl;
BC_node_t error_bc_decl;
BC_node_t msg_bc_decl;
BC_node_t signal_bc_decl;
BC_node_t sigint_bc_decl;
BC_node_t sigill_bc_decl;
BC_node_t sigabrt_bc_decl;
BC_node_t sigfpe_bc_decl;
BC_node_t sigterm_bc_decl;
BC_node_t sigsegv_bc_decl;
BC_node_t invenv_bc_decl;
BC_node_t invop_bc_decl;
BC_node_t optype_bc_decl;
BC_node_t opvalue_bc_decl;
BC_node_t invindex_bc_decl;
BC_node_t indextype_bc_decl;
BC_node_t indexvalue_bc_decl;
BC_node_t indexop_bc_decl;
BC_node_t invslice_bc_decl;
BC_node_t slicetype_bc_decl;
BC_node_t sliceform_bc_decl;
BC_node_t invector_bc_decl;
BC_node_t veclen_bc_decl;
BC_node_t vecform_bc_decl;
BC_node_t matrixform_bc_decl;
BC_node_t invkey_bc_decl;
BC_node_t keyvalue_bc_decl;
BC_node_t keyop_bc_decl;
BC_node_t invcall_bc_decl;
BC_node_t abstrcall_bc_decl;
BC_node_t callop_bc_decl;
BC_node_t partype_bc_decl;
BC_node_t parvalue_bc_decl;
BC_node_t invresult_bc_decl;
BC_node_t invinput_bc_decl;
BC_node_t invfmt_bc_decl;
BC_node_t invencoding_bc_decl;
BC_node_t eof_bc_decl;
BC_node_t parnumber_bc_decl;
BC_node_t syncthreadcall_bc_decl;
BC_node_t syserror_bc_decl;
BC_node_t eaccess_bc_decl;
BC_node_t eagain_bc_decl;
BC_node_t ebadf_bc_decl;
BC_node_t ebusy_bc_decl;
BC_node_t echild_bc_decl;
BC_node_t edeadlk_bc_decl;
BC_node_t edom_bc_decl;
BC_node_t eexist_bc_decl;
BC_node_t efault_bc_decl;
BC_node_t efbig_bc_decl;
BC_node_t eintr_bc_decl;
BC_node_t einval_bc_decl;
BC_node_t eio_bc_decl;
BC_node_t eisdir_bc_decl;
BC_node_t emfile_bc_decl;
BC_node_t emlink_bc_decl;
BC_node_t enametoolong_bc_decl;
BC_node_t enfile_bc_decl;
BC_node_t enodev_bc_decl;
BC_node_t enoent_bc_decl;
BC_node_t enoexec_bc_decl;
BC_node_t enolck_bc_decl;
BC_node_t enomem_bc_decl;
BC_node_t enospc_bc_decl;
BC_node_t enosys_bc_decl;
BC_node_t enotdir_bc_decl;
BC_node_t enotempty_bc_decl;
BC_node_t enotty_bc_decl;
BC_node_t enxio_bc_decl;
BC_node_t eperm_bc_decl;
BC_node_t epipe_bc_decl;
BC_node_t erange_bc_decl;
BC_node_t erofs_bc_decl;
BC_node_t espipe_bc_decl;
BC_node_t esrch_bc_decl;
BC_node_t exdev_bc_decl;
BC_node_t invextern_bc_decl;
BC_node_t noextern_bc_decl;
BC_node_t libclose_bc_decl;
BC_node_t noexternsupp_bc_decl;
BC_node_t invenvar_bc_decl;
BC_node_t internal_bc_decl;
BC_node_t systemcall_bc_decl;
BC_node_t noshell_bc_decl;
BC_node_t systemfail_bc_decl;
BC_node_t invregex_bc_decl;
BC_node_t invparser_bc_decl;
BC_node_t invgrammar_bc_decl;
BC_node_t invtoken_bc_decl;
BC_node_t pmemory_bc_decl;
BC_node_t invaccess_bc_decl;
BC_node_t accessop_bc_decl;
BC_node_t accessvalue_bc_decl;
BC_node_t immutable_bc_decl;
BC_node_t patternmatch_bc_decl;
BC_node_t deadlock_bc_decl;
BC_node_t syncwait_bc_decl;
BC_node_t argv_bc_decl;
BC_node_t env_bc_decl;
BC_node_t version_bc_decl;
BC_node_t main_thread_bc_decl;
BC_node_t curr_thread_bc_decl;
BC_node_t anode_bc_decl;
BC_node_t token_bc_decl;
BC_node_t code_bc_decl;
BC_node_t nil_anode_bc_decl;
BC_node_t error_anode_bc_decl;
BC_node_t parser_bc_decl;
BC_node_t ambiguous_p_bc_decl;
BC_node_t int_earley_parse_grammar_bc_decl;
BC_node_t int_earley_set_debug_level_bc_decl;
BC_node_t int_earley_set_one_parse_flag_bc_decl;
BC_node_t int_earley_set_lookahead_level_bc_decl;
BC_node_t int_earley_set_cost_flag_bc_decl;
BC_node_t int_earley_set_error_recovery_flag_bc_decl;
BC_node_t int_earley_set_recovery_match_bc_decl;
BC_node_t int_earley_parse_bc_decl;
BC_node_t int_earley_create_grammar_bc_decl;
BC_node_t file_bc_decl;
BC_node_t file_ptr_bc_decl;
BC_node_t unget_char_bc_decl;
BC_node_t file_icd_bc_decl;
BC_node_t file_byte_ocd_bc_decl;
BC_node_t file_ucode_ocd_bc_decl;
BC_node_t file_encoding_bc_decl;
BC_node_t file_encoding_type_bc_decl;
BC_node_t stdin_bc_decl;
BC_node_t stdout_bc_decl;
BC_node_t stderr_bc_decl;
BC_node_t min_bc_decl;
BC_node_t max_bc_decl;
BC_node_t tolower_bc_decl;
BC_node_t toupper_bc_decl;
BC_node_t translit_bc_decl;
BC_node_t eltype_bc_decl;
BC_node_t keys_bc_decl;
BC_node_t closure_bc_decl;
BC_node_t context_bc_decl;
BC_node_t inside_bc_decl;
BC_node_t isa_bc_decl;
BC_node_t subv_bc_decl;
BC_node_t cmpv_bc_decl;
BC_node_t del_bc_decl;
BC_node_t ins_bc_decl;
BC_node_t insv_bc_decl;
BC_node_t rev_bc_decl;
BC_node_t sort_bc_decl;
BC_node_t sqrt_bc_decl;
BC_node_t exp_bc_decl;
BC_node_t log_bc_decl;
BC_node_t log10_bc_decl;
BC_node_t pow_bc_decl;
BC_node_t sin_bc_decl;
BC_node_t cos_bc_decl;
BC_node_t atan2_bc_decl;
BC_node_t match_bc_decl;
BC_node_t gmatch_bc_decl;
BC_node_t sub_bc_decl;
BC_node_t gsub_bc_decl;
BC_node_t split_bc_decl;
BC_node_t split_regex_bc_decl;
BC_node_t srand_bc_decl;
BC_node_t rand_bc_decl;
BC_node_t process_errno_bc_decl;
BC_node_t readdir_bc_decl;
BC_node_t ftype_bc_decl;
BC_node_t fuidn_bc_decl;
BC_node_t fgrpn_bc_decl;
BC_node_t fsize_bc_decl;
BC_node_t fatime_bc_decl;
BC_node_t fmtime_bc_decl;
BC_node_t fctime_bc_decl;
BC_node_t fumode_bc_decl;
BC_node_t fgmode_bc_decl;
BC_node_t fomode_bc_decl;
BC_node_t time_bc_decl;
BC_node_t strtime_bc_decl;
BC_node_t time_format_bc_decl;
BC_node_t clock_bc_decl;
BC_node_t gc_bc_decl;
BC_node_t rename_bc_decl;
BC_node_t remove_bc_decl;
BC_node_t mkdir_bc_decl;
BC_node_t rmdir_bc_decl;
BC_node_t getcwd_bc_decl;
BC_node_t chdir_bc_decl;
BC_node_t chumod_bc_decl;
BC_node_t chgmod_bc_decl;
BC_node_t chomod_bc_decl;
BC_node_t isatty_bc_decl;
BC_node_t open_bc_decl;
BC_node_t close_bc_decl;
BC_node_t flush_bc_decl;
BC_node_t popen_bc_decl;
BC_node_t pclose_bc_decl;
BC_node_t tell_bc_decl;
BC_node_t seek_bc_decl;
BC_node_t put_bc_decl;
BC_node_t putln_bc_decl;
BC_node_t fput_bc_decl;
BC_node_t fputln_bc_decl;
BC_node_t sput_bc_decl;
BC_node_t sputln_bc_decl;
BC_node_t putf_bc_decl;
BC_node_t fputf_bc_decl;
BC_node_t sputf_bc_decl;
BC_node_t print_bc_decl;
BC_node_t println_bc_decl;
BC_node_t fprint_bc_decl;
BC_node_t fprintln_bc_decl;
BC_node_t sprint_bc_decl;
BC_node_t sprintln_bc_decl;
BC_node_t get_bc_decl;
BC_node_t getln_bc_decl;
BC_node_t getf_bc_decl;
BC_node_t fget_bc_decl;
BC_node_t fgetln_bc_decl;
BC_node_t fgetf_bc_decl;
BC_node_t scan_bc_decl;
BC_node_t scanln_bc_decl;
BC_node_t fscan_bc_decl;
BC_node_t fscanln_bc_decl;
BC_node_t getpid_bc_decl;
BC_node_t getpgid_bc_decl;
BC_node_t getun_bc_decl;
BC_node_t geteun_bc_decl;
BC_node_t getgn_bc_decl;
BC_node_t getegn_bc_decl;
BC_node_t getgroups_bc_decl;
BC_node_t system_bc_decl;
BC_node_t exit_bc_decl;
BC_node_t fold_bc_decl;
BC_node_t filter_bc_decl;
BC_node_t map_bc_decl;
BC_node_t transpose_bc_decl;
BC_node_t set_encoding_bc_decl;
BC_node_t get_encoding_bc_decl;
BC_node_t set_file_encoding_bc_decl;
BC_node_t get_file_encoding_bc_decl;
BC_node_t init_bc_decl;

struct bc_decl_entry
{
  BC_node_t *decl_ptr;
  const char *name;
  BC_node_t *scope_ptr;
  implementation_fun_t fun_ptr;
};


/* The table should contains entries ordered as corresponding decls in
   ENVIRONMENT (see file d_ir.sprut).  Otherwise, we will have
   corrupted byte code message.  */
static struct bc_decl_entry bc_decls_table [] =
{
  {&except_bc_decl, EXCEPT_NAME, NULL, NULL},
  {&error_bc_decl, ERROR_NAME, NULL, NULL},
  {&msg_bc_decl, MSG_NAME, &error_bc_decl, NULL},
  {&signal_bc_decl, SIGNAL_NAME, NULL, NULL},
  {&sigint_bc_decl, SIGINT_NAME, NULL, NULL},
  {&sigill_bc_decl, SIGILL_NAME, NULL, NULL},
  {&sigabrt_bc_decl, SIGABRT_NAME, NULL, NULL},
  {&sigfpe_bc_decl, SIGFPE_NAME, NULL, NULL},
  {&sigterm_bc_decl, SIGTERM_NAME, NULL, NULL},
  {&sigsegv_bc_decl, SIGSEGV_NAME, NULL, NULL},
  {&invenv_bc_decl, INVENV_NAME, NULL, NULL},
  {&invop_bc_decl, INVOP_NAME, NULL, NULL},
  {&optype_bc_decl, OPTYPE_NAME, NULL, NULL},
  {&opvalue_bc_decl, OPVALUE_NAME, NULL, NULL},
  {&invindex_bc_decl, INVINDEX_NAME, NULL, NULL},
  {&indextype_bc_decl, INDEXTYPE_NAME, NULL, NULL},
  {&indexvalue_bc_decl, INDEXVALUE_NAME, NULL, NULL},
  {&indexop_bc_decl, INDEXOP_NAME, NULL, NULL},
  {&invslice_bc_decl, INVSLICE_NAME, NULL, NULL},
  {&slicetype_bc_decl, SLICETYPE_NAME, NULL, NULL},
  {&sliceform_bc_decl, SLICEFORM_NAME, NULL, NULL},
  {&invector_bc_decl, INVECTOR_NAME, NULL, NULL},
  {&veclen_bc_decl, VECLEN_NAME, NULL, NULL},
  {&vecform_bc_decl, VECVALUE_NAME, NULL, NULL},
  {&matrixform_bc_decl, MATRIXVALUE_NAME, NULL, NULL},
  {&invkey_bc_decl, INVKEY_NAME, NULL, NULL},
  {&keyvalue_bc_decl, KEYVALUE_NAME, NULL, NULL},
  {&keyop_bc_decl, KEYOP_NAME, NULL, NULL},
  {&invcall_bc_decl, INVCALL_NAME, NULL, NULL},
  {&abstrcall_bc_decl, ABSTRCALL_NAME, NULL, NULL},
  {&callop_bc_decl, CALLOP_NAME, NULL, NULL},
  {&partype_bc_decl, PARTYPE_NAME, NULL, NULL},
  {&parvalue_bc_decl, PARVALUE_NAME, NULL, NULL},
  {&invresult_bc_decl, INVRESULT_NAME, NULL, NULL},
  {&invinput_bc_decl, INVINPUT_NAME, NULL, NULL},
  {&invfmt_bc_decl, INVFMT_NAME, NULL, NULL},
  {&invencoding_bc_decl, INVENCODING_NAME, NULL, NULL},
  {&eof_bc_decl, EOF_NAME, NULL, NULL},
  {&parnumber_bc_decl, PARNUMBER_NAME, NULL, NULL},
  {&syncthreadcall_bc_decl, SYNCTHREADCALL_NAME, NULL, NULL},
  {&syserror_bc_decl, SYSERROR_NAME, NULL, NULL},
  {&eaccess_bc_decl, EACCESS_NAME, NULL, NULL},
  {&eagain_bc_decl, EAGAIN_NAME, NULL, NULL},
  {&ebadf_bc_decl, EBADF_NAME, NULL, NULL},
  {&ebusy_bc_decl, EBUSY_NAME, NULL, NULL},
  {&echild_bc_decl, ECHILD_NAME, NULL, NULL},
  {&edeadlk_bc_decl, EDEADLK_NAME, NULL, NULL},
  {&edom_bc_decl, EDOM_NAME, NULL, NULL},
  {&eexist_bc_decl, EEXIST_NAME, NULL, NULL},
  {&efault_bc_decl, EFAULT_NAME, NULL, NULL},
  {&efbig_bc_decl, EFBIG_NAME, NULL, NULL},
  {&eintr_bc_decl, EINTR_NAME, NULL, NULL},
  {&einval_bc_decl, EINVAL_NAME, NULL, NULL},
  {&eio_bc_decl, EIO_NAME, NULL, NULL},
  {&eisdir_bc_decl, EISDIR_NAME, NULL, NULL},
  {&emfile_bc_decl, EMFILE_NAME, NULL, NULL},
  {&emlink_bc_decl, EMLINK_NAME, NULL, NULL},
  {&enametoolong_bc_decl, ENAMETOOLONG_NAME, NULL, NULL},
  {&enfile_bc_decl, ENFILE_NAME, NULL, NULL},
  {&enodev_bc_decl, ENODEV_NAME, NULL, NULL},
  {&enoent_bc_decl, ENOENT_NAME, NULL, NULL},
  {&enoexec_bc_decl, ENOEXEC_NAME, NULL, NULL},
  {&enolck_bc_decl, ENOLCK_NAME, NULL, NULL},
  {&enomem_bc_decl, ENOMEM_NAME, NULL, NULL},
  {&enospc_bc_decl, ENOSPC_NAME, NULL, NULL},
  {&enosys_bc_decl, ENOSYS_NAME, NULL, NULL},
  {&enotdir_bc_decl, ENOTDIR_NAME, NULL, NULL},
  {&enotempty_bc_decl, ENOTEMPTY_NAME, NULL, NULL},
  {&enotty_bc_decl, ENOTTY_NAME, NULL, NULL},
  {&enxio_bc_decl, ENXIO_NAME, NULL, NULL},
  {&eperm_bc_decl, EPERM_NAME, NULL, NULL},
  {&epipe_bc_decl, EPIPE_NAME, NULL, NULL},
  {&erange_bc_decl, ERANGE_NAME, NULL, NULL},
  {&erofs_bc_decl, EROFS_NAME, NULL, NULL},
  {&espipe_bc_decl, ESPIPE_NAME, NULL, NULL},
  {&esrch_bc_decl, ESRCH_NAME, NULL, NULL},
  {&exdev_bc_decl, EXDEV_NAME, NULL, NULL},
  {&systemcall_bc_decl, SYSTEMCALL_NAME, NULL, NULL},
  {&noshell_bc_decl, NOSHELL_NAME, NULL, NULL},
  {&systemfail_bc_decl, SYSTEMFAIL_NAME, NULL, NULL},
  {&invregex_bc_decl, INVREGEX_NAME, NULL, NULL},
  {&invparser_bc_decl, INVPARSER_NAME, NULL, NULL},
  {&invgrammar_bc_decl, INVGRAMMAR_NAME, NULL, NULL},
  {&invtoken_bc_decl, INVTOKEN_NAME, NULL, NULL},
  {&pmemory_bc_decl, PMEMORY_NAME, NULL, NULL},
  {&invextern_bc_decl, INVEXTERN_NAME, NULL, NULL},
  {&noextern_bc_decl, NOEXTERN_NAME, NULL, NULL},
  {&libclose_bc_decl, LIBCLOSE_NAME, NULL, NULL},
  {&noexternsupp_bc_decl, NOEXTERNSUPP_NAME, NULL, NULL},
  {&invenvar_bc_decl, INVENVAR_NAME, NULL, NULL},
  {&internal_bc_decl, INTERNAL_NAME, NULL, NULL},
  {&invaccess_bc_decl, INVACCESS_NAME, NULL, NULL},
  {&accessop_bc_decl, ACCESSOP_NAME, NULL, NULL},
  {&accessvalue_bc_decl, ACCESSVALUE_NAME, NULL, NULL},
  {&immutable_bc_decl, IMMUTABLE_NAME, NULL, NULL},
  {&patternmatch_bc_decl, PATTERNMATCH_NAME, NULL, NULL},
  {&deadlock_bc_decl, DEADLOCK_NAME, NULL, NULL},
  {&syncwait_bc_decl, SYNCWAIT_NAME, NULL, NULL},
  {&argv_bc_decl, ARGV_NAME, NULL, NULL},
  {&env_bc_decl, ENV_NAME, NULL, NULL},
  {&version_bc_decl, VERSION_NAME, NULL, NULL},
  {&main_thread_bc_decl, MAIN_THREAD_NAME, NULL, NULL},
  {&curr_thread_bc_decl, CURR_THREAD_NAME, NULL, NULL},
  {&anode_bc_decl, ANODE_NAME, NULL, NULL},
  {&token_bc_decl, TOKEN_NAME, NULL, NULL},
  {&code_bc_decl, CODE_NAME, &token_bc_decl, NULL},
  {&nil_anode_bc_decl, NIL_ANODE_NAME, NULL, NULL},
  {&error_anode_bc_decl, ERROR_ANODE_NAME, NULL, NULL},
  {&parser_bc_decl, PARSER_NAME, NULL, NULL},
  {&ambiguous_p_bc_decl, AMBIGUOUS_P_NAME, &parser_bc_decl, NULL},
  {&int_earley_parse_grammar_bc_decl, INT_EARLEY_PARSE_GRAMMAR_NAME,
   &parser_bc_decl, int_earley_parse_grammar},
  {&int_earley_set_debug_level_bc_decl, INT_EARLEY_SET_DEBUG_LEVEL_NAME,
   &parser_bc_decl, int_earley_set_debug_level},
  {&int_earley_set_one_parse_flag_bc_decl, INT_EARLEY_SET_ONE_PARSE_FLAG_NAME,
   &parser_bc_decl, int_earley_set_one_parse_flag},
  {&int_earley_set_lookahead_level_bc_decl, INT_EARLEY_SET_LOOKAHEAD_LEVEL_NAME,
   &parser_bc_decl, int_earley_set_lookahead_level},
  {&int_earley_set_cost_flag_bc_decl, INT_EARLEY_SET_COST_FLAG_NAME,
   &parser_bc_decl, int_earley_set_cost_flag},
  {&int_earley_set_error_recovery_flag_bc_decl,
   INT_EARLEY_SET_ERROR_RECOVERY_FLAG_NAME, &parser_bc_decl,
   int_earley_set_error_recovery_flag},
  {&int_earley_set_recovery_match_bc_decl, INT_EARLEY_SET_RECOVERY_MATCH_NAME,
   &parser_bc_decl, int_earley_set_recovery_match},
  {&int_earley_parse_bc_decl, INT_EARLEY_PARSE_NAME,
   &parser_bc_decl, int_earley_parse},
  {&int_earley_create_grammar_bc_decl, INT_EARLEY_CREATE_GRAMMAR_NAME,
   &parser_bc_decl, int_earley_create_grammar},
  {&file_bc_decl, FILE_NAME, NULL, NULL},
  {&file_ptr_bc_decl, FILE_PTR_NAME, &file_bc_decl, NULL},
  {&unget_char_bc_decl, UNGET_CHAR_NAME, &file_bc_decl, NULL},
  {&file_icd_bc_decl, FILE_ICD_NAME, &file_bc_decl, NULL},
  {&file_byte_ocd_bc_decl, FILE_BYTE_OCD_NAME, &file_bc_decl, NULL},
  {&file_ucode_ocd_bc_decl, FILE_UCODE_OCD_NAME, &file_bc_decl, NULL},
  {&file_encoding_bc_decl, FILE_ENCODING_NAME, &file_bc_decl, NULL},
  {&file_encoding_type_bc_decl, FILE_ENCODING_TYPE_NAME, &file_bc_decl, NULL},
  {&stdin_bc_decl, STDIN_NAME, NULL, NULL},
  {&stdout_bc_decl, STDOUT_NAME, NULL, NULL},
  {&stderr_bc_decl, STDERR_NAME, NULL, NULL},
  {&max_bc_decl, MAX_NAME, NULL, max_call},
  {&min_bc_decl, MIN_NAME, NULL, min_call},
  {&tolower_bc_decl, TOLOWER_NAME, NULL, tolower_call},
  {&toupper_bc_decl, TOUPPER_NAME, NULL, toupper_call},
  {&translit_bc_decl, TRANSLIT_NAME, NULL, translit_call},
  {&eltype_bc_decl, ELTYPE_NAME, NULL, eltype_call},
  {&keys_bc_decl, KEYS_NAME, NULL, keys_call},
  {&closure_bc_decl, CLOSURE_NAME, NULL, closure_call},
  {&context_bc_decl, CONTEXT_NAME, NULL, context_call},
  {&inside_bc_decl, INSIDE_NAME, NULL, inside_call},
  {&isa_bc_decl, ISA_NAME, NULL, isa_call},
  {&subv_bc_decl, SUBV_NAME, NULL, subv_call},
  {&cmpv_bc_decl, CMPV_NAME, NULL, cmpv_call},
  {&del_bc_decl, DEL_NAME, NULL, del_call},
  {&ins_bc_decl, INS_NAME, NULL, ins_call},
  {&insv_bc_decl, INSV_NAME, NULL, insv_call},
  {&rev_bc_decl, REV_NAME, NULL, rev_call},
  {&sort_bc_decl, SORT_NAME, NULL, sort_call},
  {&sqrt_bc_decl, SQRT_NAME, NULL, sqrt_call},
  {&exp_bc_decl, EXP_NAME, NULL, exp_call},
  {&log_bc_decl, LOG_NAME, NULL, log_call},
  {&log10_bc_decl, LOG10_NAME, NULL, log10_call},
  {&pow_bc_decl, POW_NAME, NULL, pow_call},
  {&sin_bc_decl, SIN_NAME, NULL, sin_call},
  {&cos_bc_decl, COS_NAME, NULL, cos_call},
  {&atan2_bc_decl, ATAN2_NAME, NULL, atan2_call},
  {&match_bc_decl, MATCH_NAME, NULL, match_call},
  {&gmatch_bc_decl, GMATCH_NAME, NULL, gmatch_call},
  {&sub_bc_decl, SUB_NAME, NULL, sub_call},
  {&gsub_bc_decl, GSUB_NAME, NULL, gsub_call},
  {&split_bc_decl, SPLIT_NAME, NULL, split_call},
  {&split_regex_bc_decl, SPLIT_REGEX_NAME, NULL, NULL},
  {&srand_bc_decl, SRAND_NAME, NULL, srand_call},
  {&rand_bc_decl, RAND_NAME, NULL, rand_call},
  {&process_errno_bc_decl, PROCESS_ERRNO_NAME, NULL, process_errno_call},
  {&readdir_bc_decl, READDIR_NAME, NULL, readdir_call},
  {&ftype_bc_decl, FTYPE_NAME, NULL, ftype_call},
  {&fuidn_bc_decl, FUIDN_NAME, NULL, fuidn_call},
  {&fgrpn_bc_decl, FGRPN_NAME, NULL, fgrpn_call},
  {&fsize_bc_decl, FSIZE_NAME, NULL, fsize_call},
  {&fatime_bc_decl, FATIME_NAME, NULL, fatime_call},
  {&fmtime_bc_decl, FMTIME_NAME, NULL, fmtime_call},
  {&fctime_bc_decl, FCTIME_NAME, NULL, fctime_call},
  {&fumode_bc_decl, FUMODE_NAME, NULL, fumode_call},
  {&fgmode_bc_decl, FGMODE_NAME, NULL, fgmode_call},
  {&fomode_bc_decl, FOMODE_NAME, NULL, fomode_call},
  {&time_bc_decl, TIME_NAME, NULL, time_call},
  {&strtime_bc_decl, STRTIME_NAME, NULL, strtime_call},
  {&time_format_bc_decl, TIME_FORMAT_NAME, NULL, NULL},
  {&clock_bc_decl, CLOCK_NAME, NULL, clock_call},
  {&gc_bc_decl, GC_NAME, NULL, gc_call},
  {&rename_bc_decl, RENAME_NAME, NULL, rename_call},
  {&remove_bc_decl, REMOVE_NAME, NULL, remove_call},
  {&mkdir_bc_decl, MKDIR_NAME, NULL, mkdir_call},
  {&rmdir_bc_decl, RMDIR_NAME, NULL, rmdir_call},
  {&getcwd_bc_decl, GETCWD_NAME, NULL, getcwd_call},
  {&chdir_bc_decl, CHDIR_NAME, NULL, chdir_call},
  {&chumod_bc_decl, CHUMOD_NAME, NULL, chumod_call},
  {&chgmod_bc_decl, CHGMOD_NAME, NULL, chgmod_call},
  {&chomod_bc_decl, CHOMOD_NAME, NULL, chomod_call},
  {&isatty_bc_decl, ISATTY_NAME, NULL, isatty_call},
  {&open_bc_decl, OPEN_NAME, NULL, open_call},
  {&close_bc_decl, CLOSE_NAME, NULL, close_call},
  {&flush_bc_decl, FLUSH_NAME, NULL, flush_call},
  {&popen_bc_decl, POPEN_NAME, NULL, popen_call},
  {&pclose_bc_decl, PCLOSE_NAME, NULL, pclose_call},
  {&tell_bc_decl, TELL_NAME, NULL, tell_call},
  {&seek_bc_decl, SEEK_NAME, NULL, seek_call},
  {&put_bc_decl, PUT_NAME, NULL, put_call},
  {&putln_bc_decl, PUTLN_NAME, NULL, putln_call},
  {&fput_bc_decl, FPUT_NAME, NULL, fput_call},
  {&fputln_bc_decl, FPUTLN_NAME, NULL, fputln_call},
  {&sput_bc_decl, SPUT_NAME, NULL, sput_call},
  {&sputln_bc_decl, SPUTLN_NAME, NULL, sputln_call},
  {&putf_bc_decl, PUTF_NAME, NULL, putf_call},
  {&fputf_bc_decl, FPUTF_NAME, NULL, fputf_call},
  {&sputf_bc_decl, SPUTF_NAME, NULL, sputf_call},
  {&print_bc_decl, PRINT_NAME, NULL, print_call},
  {&println_bc_decl, PRINTLN_NAME, NULL, println_call},
  {&fprint_bc_decl, FPRINT_NAME, NULL, fprint_call},
  {&fprintln_bc_decl, FPRINTLN_NAME, NULL, fprintln_call},
  {&sprint_bc_decl, SPRINT_NAME, NULL, sprint_call},
  {&sprintln_bc_decl, SPRINTLN_NAME, NULL, sprintln_call},
  {&get_bc_decl, GET_NAME, NULL, get_call},
  {&getln_bc_decl, GETLN_NAME, NULL, getln_call},
  {&getf_bc_decl, GETF_NAME, NULL, getf_call},
  {&fget_bc_decl, FGET_NAME, NULL, fget_call},
  {&fgetln_bc_decl, FGETLN_NAME, NULL, fgetln_call},
  {&fgetf_bc_decl, FGETF_NAME, NULL, fgetf_call},
  {&scan_bc_decl, SCAN_NAME, NULL, scan_call},
  {&scanln_bc_decl, SCANLN_NAME, NULL, scanln_call},
  {&fscan_bc_decl, FSCAN_NAME, NULL, fscan_call},
  {&fscanln_bc_decl, FSCANLN_NAME, NULL, fscanln_call},
  {&getpid_bc_decl, GETPID_NAME, NULL, getpid_call},
  {&getun_bc_decl, GETUN_NAME, NULL, getun_call},
  {&geteun_bc_decl, GETEUN_NAME, NULL, geteun_call},
  {&getgn_bc_decl, GETGN_NAME, NULL, getgn_call},
  {&getegn_bc_decl, GETEGN_NAME, NULL, getegn_call},
  {&getgroups_bc_decl, GETGROUPS_NAME, NULL, getgroups_call},
  {&system_bc_decl, SYSTEM_NAME, NULL, system_call},
  {&exit_bc_decl, EXIT_NAME, NULL, exit_call},
  {&fold_bc_decl, FOLD_NAME, NULL, fold_call},
  {&filter_bc_decl, FILTER_NAME, NULL, filter_call},
  {&map_bc_decl, MAP_NAME, NULL, map_call},
  {&transpose_bc_decl, TRANSPOSE_NAME, NULL, transpose_call},
  {&set_encoding_bc_decl, SET_ENCODING_NAME, NULL, set_encoding_call},
  {&get_encoding_bc_decl, GET_ENCODING_NAME, NULL, get_encoding_call},
  {&set_file_encoding_bc_decl, SET_FILE_ENCODING_NAME, NULL, set_file_encoding_call},
  {&get_file_encoding_bc_decl, GET_FILE_ENCODING_NAME, NULL, get_file_encoding_call},
  {&init_bc_decl, INIT_NAME, NULL, init_call}
};

static int curr_decl_entry_num;

void
init_env_decl_processing (void)
{
  curr_decl_entry_num = 0;
}

int
all_env_decls_processed_p (void)
{
  return (curr_decl_entry_num
	  >= sizeof (bc_decls_table) / sizeof (bc_decls_table [0]));
}

void
process_env_decl (BC_node_t decl)
{
  string_t ident;
  BC_node_t *scope_ptr;

  if (all_env_decls_processed_p ())
    return;
  if ((ident = BC_ident (decl)) == NULL
      || strcmp (ident, bc_decls_table[curr_decl_entry_num].name) != 0)
    return;
  scope_ptr = bc_decls_table[curr_decl_entry_num].scope_ptr;
  /* NULL ptr means uppest level block.  */
  if (scope_ptr == NULL && BC_decl_scope (decl) != first_program_bc)
    return;
  if (scope_ptr != NULL && BC_decl_scope (decl) != *scope_ptr)
    return;
  if (BC_IS_OF_TYPE (decl, BC_NM_fdecl))
    {
      decl = BC_fblock (decl);
      d_assert (decl != NULL);
    }
  *bc_decls_table[curr_decl_entry_num].decl_ptr = decl;
  if (BC_IS_OF_TYPE (decl, BC_NM_fblock))
    {
      BC_set_fmode (decl, BC_builtin);
      BC_set_implementation_fun (decl, bc_decls_table[curr_decl_entry_num].fun_ptr);
    }
  curr_decl_entry_num++;
}

/* Prepare infoed block for execution: set up block decl and
   environment declaration in BLOCK and remove info nodes. */
void
prepare_block (BC_node_t block)
{
  BC_node_t bc_decl, info, bc, next_info;

  d_assert (BC_IS_OF_TYPE (block, BC_NM_block));
  set_block_number (block);
  for (bc_decl = BC_decls (block);
       bc_decl != NULL;
       bc_decl = BC_next_decl (bc_decl))
    {
      d_assert (BC_ident (bc_decl) != NULL);
      define_block_decl (bc_decl, block);
      process_env_decl (bc_decl);
      if (BC_IS_OF_TYPE (bc_decl, BC_NM_fdecl))
	prepare_block (BC_fblock (bc_decl));
    }
  if (BC_IS_OF_TYPE (block, BC_NM_fblock) || BC_scope (block) == NULL)
    for (info = BC_info (block); info != NULL; info = next_info)
      {
	bc = BC_bc (info);
	if (BC_NODE_MODE (bc) == BC_NM_block && bc != block)
	  prepare_block (bc);
	next_info = BC_next_info (info);
	BC_set_info (bc, BC_source (info));
      }
}



#if defined(HAVE_DLOPEN)

static void
print_op (FILE *f, int comma_p, int nop)
{
  if (comma_p)
    fprintf (f, ", ");
  if (nop >= 0)
    fprintf (f, "get_var (cv, %d)", nop);
  else
    fprintf (f, "get_var (tv, %d)", -nop - 1);
}

static void
print_node (FILE *f, BC_node_t bc)
{
  int tcall_p = (BC_IS_OF_TYPE (bc, BC_NM_tcall)
		 || BC_IS_OF_TYPE (bc, BC_NM_itcall)
		 || BC_IS_OF_TYPE (bc, BC_NM_titcall)
		 || BC_IS_OF_TYPE (bc, BC_NM_citcall));
  fprintf (f, "  cpc = (BC_node_t) 0x%lx;\n", (long unsigned) bc);
  fprintf (f, "  ");
  if (BC_IS_OF_TYPE (bc, BC_NM_br) || BC_IS_OF_TYPE (bc, BC_NM_foreach)
      || (BC_IS_OF_TYPE (bc, BC_NM_check) && BC_fail_pc (bc) != NULL)
      || tcall_p)
    fprintf (f, "if (");
  if (BC_IS_OF_TYPE (bc, BC_NM_fold_op))
    fprintf (f, "foldop (");
  else if (BC_IS_OF_TYPE (bc, BC_NM_const))
    fprintf (f, "constop (");
  else if (BC_IS_OF_TYPE (bc, BC_NM_div))
    fprintf (f, "divop (");
  else if (BC_IS_OF_TYPE (bc, BC_NM_op_slst))
    fprintf (f, "op_slst (");
  else if (BC_IS_OF_TYPE (bc, BC_NM_fun) || BC_IS_OF_TYPE (bc, BC_NM_class))
    fprintf (f, "funclass (");
  else
    fprintf (f, "%s (", BC_node_name[BC_NODE_MODE (bc)]);
  if (BC_IS_OF_TYPE (bc, BC_NM_op1))
    {
      if (BC_IS_OF_TYPE (bc, BC_NM_op1i) || BC_IS_OF_TYPE (bc, BC_NM_op2i12))
	fprintf (f, "%d", BC_op1 (bc));
      else
	print_op (f, FALSE, BC_op1 (bc));
    }
  if (BC_IS_OF_TYPE (bc, BC_NM_op2))
    {
      if (BC_IS_OF_TYPE (bc, BC_NM_op2i)
	  || BC_IS_OF_TYPE (bc, BC_NM_op2i12)
	  || BC_IS_OF_TYPE (bc, BC_NM_op3i2)
	  || BC_IS_OF_TYPE (bc, BC_NM_op4i2))
	fprintf (f, ", %d", BC_op2 (bc));
      else
	print_op (f, TRUE, BC_op2 (bc));
    }
  if (BC_IS_OF_TYPE (bc, BC_NM_op3))
    {
      if (BC_IS_OF_TYPE (bc, BC_NM_op3i))
	fprintf (f, ", %d", BC_op3 (bc));
      else
	print_op (f, TRUE, BC_op3 (bc));
    }
  if (BC_IS_OF_TYPE (bc, BC_NM_op4))
    {
      if (BC_IS_OF_TYPE (bc, BC_NM_op4i24))
	fprintf (f, ", %d", BC_op4 (bc));
      else
	print_op (f, TRUE, BC_op4 (bc));
    }
  if (BC_IS_OF_TYPE (bc, BC_NM_brs))
    print_op (f, TRUE, BC_res (bc));
  if (BC_IS_OF_TYPE (bc, BC_NM_bcmp))
    {
      if (BC_IS_OF_TYPE (bc, BC_NM_bcmpi))
	fprintf (f, ", %d", BC_bcmp_op2 (bc));
      else
	print_op (f, TRUE, BC_bcmp_op2 (bc));
      fprintf (f, ", %d", BC_bcmp_res (bc));
    }
  if (BC_IS_OF_TYPE (bc, BC_NM_binc))
    fprintf (f, ", %d", BC_binc_inc (bc));
  if (BC_IS_OF_TYPE (bc, BC_NM_foreach2))
    fprintf (f, ", %d", BC_element (bc));
  if (BC_IS_OF_TYPE (bc, BC_NM_imcall)
      && BC_NODE_MODE (bc) != BC_NM_ibcall)
    fprintf (f, ", %d", BC_vars_num (BC_cfblock (bc))); /* vars num */
  if (BC_IS_OF_TYPE (bc, BC_NM_imcall)
      || BC_IS_OF_TYPE (bc, BC_NM_call)
      || BC_IS_OF_TYPE (bc, BC_NM_tcall)
      || BC_IS_OF_TYPE (bc, BC_NM_mcall))
    fprintf (f, ", 1"); /* from_c_code_p argument  */

  if (BC_IS_OF_TYPE (bc, BC_NM_check2))
    {
      if (BC_IS_OF_TYPE (bc, BC_NM_check2i)
	  || BC_IS_OF_TYPE (bc, BC_NM_check3i2))
	fprintf (f, ", %d", BC_ch_op2 (bc));
      else
	print_op (f, TRUE, BC_ch_op2 (bc));
    }
  if (BC_IS_OF_TYPE (bc, BC_NM_check3))
    print_op (f, TRUE, BC_ch_op3 (bc));
  if (BC_IS_OF_TYPE (bc, BC_NM_check4))
    {
      if (BC_IS_OF_TYPE (bc, BC_NM_check4i)
	  || BC_IS_OF_TYPE (bc, BC_NM_check5i45))
	fprintf (f, ", %d", BC_ch_op4 (bc));
      else
	print_op (f, TRUE, BC_ch_op4 (bc));
    }
  if (BC_IS_OF_TYPE (bc, BC_NM_check5))
    {
      if (BC_IS_OF_TYPE (bc, BC_NM_check5i))
	fprintf (f, ", %d", BC_ch_op5 (bc));
      else
	print_op (f, TRUE, BC_ch_op5 (bc));
    }
  if (BC_IS_OF_TYPE (bc, BC_NM_check)
      && BC_NODE_MODE (bc) != BC_NM_rmatch
      && BC_NODE_MODE (bc) != BC_NM_rmatchs)
    fprintf (f, ", (pc_t) 0x%lx", BC_fail_pc (bc));
  if (BC_IS_OF_TYPE (bc, BC_NM_br))
    fprintf (f, ")) goto l%d;\n", BC_label_num (BC_info (BC_pc (bc))));
  else if (BC_IS_OF_TYPE (bc, BC_NM_foreach))
    fprintf (f, ")) goto l%d;\n", BC_label_num (BC_info (BC_body_pc (bc))));
  else if (BC_IS_OF_TYPE (bc, BC_NM_check) && BC_fail_pc (bc) != NULL)
    fprintf (f, ")) goto l%d;\n", BC_label_num (BC_info (BC_fail_pc (bc))));
  else if (tcall_p)
    fprintf (f, ")) return;\n");
  else
    fprintf (f, ");\n");
  if (BC_IS_OF_TYPE (bc, BC_NM_ret) || BC_IS_OF_TYPE (bc, BC_NM_leave))
    fprintf (f, "  return;\n");
    
}

static int curr_label_num;
static vlo_t fbcode;

static void
traverse_bcode (BC_node_t bc)
{
  int first_p;
  BC_node_t info, gen_info;
  vlo_t stack;

  VLO_CREATE (stack, 0);
  VLO_ADD_MEMORY (stack, &bc, sizeof (bc));
  while (VLO_LENGTH (stack) != 0)
    {
      bc = ((BC_node_t *) VLO_BOUND (stack)) [-1];
      VLO_SHORTEN (stack, sizeof (bc));
      for (first_p = TRUE; bc != NULL; bc = BC_next (bc), first_p = FALSE)
	{
	  info = BC_info (bc);
	  if (! BC_IS_OF_TYPE (info, BC_NM_source))
	    {
	      if (BC_label_num (info) < 0)
		{
		  BC_set_label_num (info, curr_label_num);
		  curr_label_num++;
		}
	      break;
	    }
	  gen_info = BC_create_node (BC_NM_gen_info);
	  BC_set_origin_info (gen_info, info);
	  if (! first_p)
	    BC_set_label_num (gen_info, -1);
	  else
	    {
	      BC_set_label_num (gen_info, curr_label_num);
	      curr_label_num++;
	    }
	  BC_set_info (bc, gen_info);
	  VLO_ADD_MEMORY (fbcode, &bc, sizeof (bc));
	  if (BC_IS_OF_TYPE (bc, BC_NM_br))
	    {
	      BC_node_t n = BC_pc (bc);
	      
	      VLO_ADD_MEMORY (stack, &n, sizeof (n));
	    }
	  if (BC_IS_OF_TYPE (bc, BC_NM_foreach))
	    {
	      BC_node_t n = BC_body_pc (bc);
	      
	      VLO_ADD_MEMORY (stack, &n, sizeof (n));
	    }
	  if (BC_IS_OF_TYPE (bc, BC_NM_check))
	    {
	      BC_node_t n = BC_fail_pc (bc);
	      
	      if (n != NULL)
		VLO_ADD_MEMORY (stack, &n, sizeof (n));
	    }
	}
    }
  VLO_DELETE (stack);
}

#define GEN_DIR "/tmp/"
#define GEN_FUN_PREFIX "dg_"
#define CC_OPTIONS  " -O2 -fPIC -shared -fpreprocessed -pipe -g"
#define CC_OPTIONS2 " -O2 -fPIC -shared -fpreprocessed -pipe -xc -"

static void
form_fun_name (vlo_t *fun_name, BC_node_t fdecl)
{
  char str[70];

  VLO_ADD_STRING (*fun_name, GEN_FUN_PREFIX);
  VLO_ADD_STRING (*fun_name, BC_ident (fdecl));
  sprintf (str, "%lx", (unsigned long) fdecl);
  VLO_ADD_STRING (*fun_name, str);
}

static void
form_fname (vlo_t *fname, BC_node_t fdecl, const char *suffix)
{
  char str[70];

  VLO_ADD_STRING (*fname, GEN_DIR);
  form_fun_name (fname, fdecl);
  VLO_ADD_STRING (*fname, "p");
  sprintf (str, "%d", (unsigned long) getpid ());
  VLO_ADD_STRING (*fname, str);
  VLO_ADD_STRING (*fname, suffix);
}

/* Copy the generation file into F.  Return FALSE if any error on the
   generation file op occurs.  */
static int
copy_gen_file (FILE *f)
{
  int res;
  size_t len;
  FILE *genf;
  char block[512];
  vlo_t gen_fname;

  VLO_CREATE (gen_fname, 0);
  VLO_ADD_STRING (gen_fname, "./");
  VLO_ADD_STRING (gen_fname, STANDARD_DINO_GEN_FILE_NAME);
  genf = fopen (VLO_BEGIN (gen_fname), "r");
  if (genf == NULL)
    {
      VLO_NULLIFY (gen_fname);
      VLO_ADD_STRING (gen_fname, STANDARD_DINO_INCLUDE_DIRECTORY);
      VLO_ADD_STRING (gen_fname, "/");
      VLO_ADD_STRING (gen_fname, STANDARD_DINO_GEN_FILE_NAME);
      genf = fopen (VLO_BEGIN (gen_fname), "r");
      if (genf == NULL)
	{
	  VLO_DELETE (gen_fname);
	  return FALSE;
	}
    }
  VLO_DELETE (gen_fname);
  while ((len = fread (block, 1, sizeof (block), genf)) > 0)
    fwrite (block, 1, len, f);
  fflush (f);
  res = ferror (genf) == 0;
  if (fclose (genf))
    return FALSE;
  return res;
}
#endif

void *
gen_cfblock (BC_node_t fblock)
{
#if !defined(HAVE_DLOPEN)
  return NULL;
#else
  BC_node_t *bc_ptr, info;
  FILE *f;
  vlo_t fname, objname, command, fun_name;
  void *addr;
  int error_p, tcall_p;

  VLO_CREATE (fname, 0);
  form_fname (&fname, BC_fdecl (fblock), ".c");
  VLO_CREATE (objname, 0);
  form_fname (&objname, BC_fdecl (fblock), ".so");
  VLO_CREATE (command, 0);
  VLO_ADD_STRING (command, CC);
  if (! save_temps_flag)
    VLO_ADD_STRING (command, CC_OPTIONS2);
  else
    {
      VLO_ADD_STRING (command, CC_OPTIONS);
      VLO_ADD_STRING (command, " ");
      VLO_ADD_STRING (command, VLO_BEGIN (fname));
    }
  VLO_ADD_STRING (command, " -o ");
  VLO_ADD_STRING (command, VLO_BEGIN (objname));
  if (save_temps_flag)
    f = fopen (VLO_BEGIN (fname), "w");
  else
    f = popen (VLO_BEGIN (command), "w");
  if (f == NULL)
    {
      VLO_DELETE (command);
      VLO_DELETE (objname);
      VLO_DELETE (fname);
      return NULL;
    }
  VLO_CREATE (fbcode, 0);
  curr_label_num = 0;
  traverse_bcode (BC_next (fblock));
  error_p = TRUE;
  VLO_CREATE (fun_name, 0);
  if (copy_gen_file (f))
    {
      form_fun_name (&fun_name, BC_fdecl (fblock));
      fprintf (f, "void %s (struct ER_node *__restrict__ cv, ",
	       (const char *) VLO_BEGIN (fun_name));
      fprintf (f, "struct ER_node *__restrict__ tv) {\n");
      fprintf (f, "  set_c_code_p ();\n");
      for (bc_ptr = (BC_node_t *) VLO_BEGIN (fbcode);
	   bc_ptr < (BC_node_t *) VLO_BOUND (fbcode);
	   bc_ptr++)
	{
	  info = BC_info (*bc_ptr);
	  if (BC_label_num (info) >= 0)
	    fprintf (f, "l%d:\n", BC_label_num (info));
	  print_node (f, *bc_ptr);
	  if (BC_IS_OF_TYPE (*bc_ptr, BC_NM_fbend))
	    fprintf (f, "  return;\n");
	  else if (BC_IS_OF_TYPE (*bc_ptr, BC_NM_block)
		   || BC_IS_OF_TYPE (*bc_ptr, BC_NM_bend))
	    fprintf (f, "  cv = cvars;\n");
	  else if (bc_ptr + 1 >= (BC_node_t *) VLO_BOUND (fbcode)
		   || BC_next (*bc_ptr) != bc_ptr[1])
	    {
	      if (BC_next (*bc_ptr) == NULL)
		{
		  fprintf (f, "  return;\n");
		  d_assert (BC_IS_OF_TYPE (*bc_ptr, BC_NM_fbend));
		}
	      else
		{
		  info = BC_info (BC_next (*bc_ptr));
		  d_assert (BC_label_num (info) >= 0);
		  fprintf (f, "  goto l%d;\n", BC_label_num (info));
		}
	    }
	}
      fprintf (f, "}\n");
      /* Restore original info */
      for (bc_ptr = (BC_node_t *) VLO_BEGIN (fbcode);
	   bc_ptr < (BC_node_t *) VLO_BOUND (fbcode);
	   bc_ptr++)
	{
	  info = BC_info (*bc_ptr);
	  BC_set_info (*bc_ptr, BC_origin_info (info));
	  /* BC_FREE (info); ???*/
	}
      VLO_DELETE (fbcode);
      error_p = ferror (f) != 0;
      if (fclose (f))
	{
	  if (! save_temps_flag)
	    remove (VLO_BEGIN (fname));
	  VLO_DELETE (fun_name);
	  VLO_DELETE (command);
	  VLO_DELETE (objname);
	  VLO_DELETE (fname);
	  return NULL;
	}
    }
  addr = NULL;
  if (!error_p)
    {
      if (! save_temps_flag || system (VLO_BEGIN (command)) == 0)
	{
	  void *handle = dlopen (VLO_BEGIN (objname), RTLD_NOW | RTLD_GLOBAL);
	  if (handle != NULL)
	    {
	      addr = dlsym (handle, VLO_BEGIN (fun_name));
	      if (dlerror () != NULL)
		addr = NULL;
	    }
	}
      if (! save_temps_flag)
	remove (VLO_BEGIN (objname));
    }
  VLO_DELETE (fun_name);
  VLO_DELETE (command);
  VLO_DELETE (objname);
  if (! save_temps_flag)
    remove (VLO_BEGIN (fname));
  VLO_DELETE (fname);
  return addr;
#endif
}

/*
Local Variables:
mode:c
End:
*/
