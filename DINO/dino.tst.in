#!/bin/sh

#
# Script to test of DINO.
#
# Copyright (C) 1997-2015 Vladimir Makarov.
# 
# Written by Vladimir Makarov <vmakarov@gcc.gnu.org>
# 
# This file is part of interpreter of DINO.
# 
# This is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
# 
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with GNU CC; see the file COPYING.  If not, write to the Free
# Software Foundation, 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.
#
#
# Usage: dino.tst [start_test_number [build by MSVC]] 
#
# The script outputs self-explanatory messages and returns zero exit code if 
# it is all ok.
#

DINO=./dino
script_file=$0
test_file=test.d
test_file_1=test1.d
stderr=_stderr.out
stdout=_stdout.out
ftemp=_temp.out
ftemp2=_temp2.out
tempdir=__tempdir
result=ok

if uname | fgrep CYGWIN; then
   CMP="eval sh -c 'tr -d \\\\r <\$0 >__tmp && mv __tmp \$0 && tr -d \\\\r <\$1 >__tmp && mv __tmp \$1 && cmp \$0 \$1'"
   SCMP="eval sh -c 'tr -d \\\\r <\$0 >__tmp && mv __tmp \$0 && cmp \$0 \$1'"
else
   CMP=cmp
   SCMP=cmp
fi

if test x$1 = x
then
    start_test_number=1
else
    if expr $1 + 0 >/dev/null
    then
        start_test_number=`expr $1 + 0`
    else
        echo $script_file:invalid argument $1 2>&1
        exit 1
    fi
fi

if test x$2 = x
then
    msvc=
else
    msvc=yes
fi

# Test 1.
if test $result = ok -a $start_test_number -le 1; then
	echo test 1
        cat >$test_file <<'TEST1'
var i;
i = 0;
i++;
TEST1
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        else
                result=fail
        fi
fi


# Test 2.
if test $result = ok -a $start_test_number -le 2; then
	echo test 2
        cat >$test_file <<'TEST2'
var i;
for (i = 0; i < 100000; i++);
TEST2
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        else
                result=fail
        fi
fi

# Test 3.
if test $result = ok -a $start_test_number -le 3; then
	echo test 3
        cat >$test_file <<'TEST3'
fun f {}
var i;
for (i = 0; i < 100000;i++)
 f ();
TEST3
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        else
                result=fail
        fi
fi

# Test 4.
if test $result = ok -a $start_test_number -le 4; then
	echo test 4
        cat >$test_file <<'TEST4'
fun f {
  {
    return 10;
  }
}

var i;
i = f ();
println (i);
TEST4
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT4' && $CMP $stdout $ftemp2; then
10
OUTPUT4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 5.
if test $result = ok -a $start_test_number -le 5; then
	echo test 5
        cat >$test_file <<'TEST5'
fun f {}
class c {}

putln ("0:", "abc" === "abc");
putln ("1:", 'c' === 'c');
putln ("1:", 10 === 10);
putln ("1:", 10.5 === 10.5);
	   
putln ("1:", f === f);
putln ("0:", f === c);
putln ("1:", c === c);
putln ("0:", c() === c());
	   
putln ("0:", 10 === "10");
putln ("0:", 10.5 === "10.5");
putln ("0:", 'c' === "c");

var op;
op = "abc";
putln ("0:", op === "abc");
op = 'c';
putln ("1:", op === 'c');
op = 10;
putln ("1:", op === 10);
op = 10.5;
putln ("1:", op === 10.5);

op = f;
putln ("1:", op === f);
putln ("0:", f === c);
op = c();
putln ("0:", op === c());
putln ("1:", op === op);

op = 10;
putln ("0:", op === "10");
op = 10.5;
putln ("0:", op === "10.5");
op = 'c';
putln ("0:", op === "c");
op = "abc";
putln ("0:", op === "abc");
TEST5
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT5' && $CMP $stdout $ftemp2; then
0:0
1:1
1:1
1:1
1:1
0:0
1:1
0:0
0:0
0:0
0:0
0:0
1:1
1:1
1:1
1:1
0:0
0:0
1:1
0:0
0:0
0:0
0:0
OUTPUT5
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 6.
if test $result = ok -a $start_test_number -le 6; then
	echo test 6
        cat >$test_file <<'TEST6'
fun f {}
putln ("0:", f === 10);
TEST6
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT6' && $CMP $stdout $ftemp2; then
0:0
OUTPUT6
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 7.
if test $result = ok -a $start_test_number -le 7; then
	echo test 7
        cat >$test_file <<'TEST7'
class c {}
putln ("0:", c === 10);
TEST7
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT7' && $CMP $stdout $ftemp2; then
0:0
OUTPUT7
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 8.
if test $result = ok -a $start_test_number -le 8; then
	echo test 8
        cat >$test_file <<'TEST8'
class c {}
putln ("0:", c () === 10);
TEST8
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT8' && $CMP $stdout $ftemp2; then
0:0
OUTPUT8
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 9.
if test $result = ok -a $start_test_number -le 9; then
	echo test 9
        cat >$test_file <<'TEST9'
var i = nil;
putln ("1:", i == nil);
putln ("0:", i != nil);
putln ("1:", i === nil);
putln ("0:", i !== nil);
fun f {}
try {putln ("1:", f () == nil);}
catch (optype) {putln ("1:1");}
fun g {return;}
try {putln ("1:", f () == nil);}
catch (optype) {putln ("1:1");}
var t;
t = tab ["e"];
putln ("1:", t["e"] == nil);
TEST9
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT9' && $CMP $stdout $ftemp2; then
1:1
0:0
1:1
0:0
1:1
1:1
1:1
OUTPUT9
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 10.
if test $result = ok -a $start_test_number -le 10; then
	echo test 10
        cat >$test_file <<'TEST10'
var i;
i = 10 + "aaa";
i = 10 @ "aaa";
i = 10 == "aaa";
TEST10
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST10-1'; then
test.d:2:8: run time error - invalid types of operands of operator "+"
TEST10-1
                result=ok
        else
                result=fail
        fi
fi

# Test 11.
if test $result = ok -a $start_test_number -le 11; then
	echo test 11
        cat >$test_file <<'TEST11'
fun f {putln ("eval false");return 0;}
fun t {putln ("eval true");return 1;}

var i;
putln ("++test false and true");
i = f() && t ();
putln ("++test true and true");
i = t() && t ();
putln ("++test true or true");
i = t() || t ();
putln ("++test false or true");
i = f() || t ();
putln ("++conditional: f ? t : f");
i = f() ? t () : f ();
putln ("++conditional: t ? t : f");
i = t() ? t () : f ();
TEST11
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT11' && $CMP $stdout $ftemp2; then
++test false and true
eval false
++test true and true
eval true
eval true
++test true or true
eval true
++test false or true
eval false
eval true
++conditional: f ? t : f
eval false
eval false
++conditional: t ? t : f
eval true
eval true
OUTPUT11
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 12.
if test $result = ok -a $start_test_number -le 12; then
	echo test 12
        cat >$test_file <<'TEST12'
fun fact (x)
{
  if (x <= 1)
    return 1;
  return x * fact (x-1);
}

var i, x;

for (i = 0; i < 1000; i++)
  x = fact (12);

putln (x);
TEST12
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT12' && $CMP $stdout $ftemp2; then
479001600
OUTPUT12
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 13.
if test $result = ok -a $start_test_number -le 13; then
	echo test 13
        cat >$test_file <<'TEST13'
putln ("length of abcd - ", #"abcd");
TEST13
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT13' && $CMP $stdout $ftemp2; then
length of abcd - 4
OUTPUT13
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 14.
if test $result = ok -a $start_test_number -le 14; then
	echo test 14
        cat >$test_file <<'TEST14'
var s, ns, t;
s = "aaaa";
ns = new s;
ns[1] = "b";
println (s,ns);

s = tab ["a"];
ns = new s;
ns["a"] = "b";
println (s,ns);

s = ['a'];
t = tab [s:"a"];
ns = new s;
ns[0] = 'b';
println (s, ns);

class c()
{
  var i = nil;
}
var o, no;
o = final c ();
no = new o;
no.i = 10;
println (o.i, no.i);

s = "10" @ new "10";
s[0] = 'c';
TEST14
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT14' && $CMP $stdout $ftemp2; then
"aaaa"['a', "b", 'a', 'a']
tab ["a":nil]tab ["a":"b"]
"a""b"
nil10
OUTPUT14
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 15.
if test $result = ok -a $start_test_number -le 15; then
	echo test 15
        cat >$test_file <<'TEST15'
var i;
for (i = 0.0; i < 100000.0; i = i + 1.0);
TEST15
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT15' && $CMP $stdout $ftemp2; then
OUTPUT15
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 16.
if test $result = ok -a $start_test_number -le 16; then
	echo test 16
        cat >$test_file <<'TEST16'
fun tak (x, y, z)
  {
    if (y >= x)
        return z;
    else
        return tak (tak (x-1, y, z), tak (y-1, z, x), tak (z-1, x, y));
  }
putln (tak(18, 12, 6));
TEST16
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT16' && $CMP $stdout $ftemp2; then
7
OUTPUT16
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 17.
if test $result = ok -a $start_test_number -le 17; then
	echo test 17
        cat >$test_file <<'TEST17'
var i, t;
t = tab ["e":10, 10:11];
putln (t["e"]);
putln (t[10]);
putln ("e in t - 1:", "e" in t);
putln ("10 in t - 1:", 10 in t);
putln ("11 in t - 0:", 11 in t);
t = tab ["e":10, "f":11, "g":12, "h":13];
for (i in t) putln (i);
t = tab ["e", "f", "g", "h"];
for (i in t) putln (i);
TEST17
        echo '      ' $DINO $test_file "2>$stderr" ">$ftemp2" '&&' sort $ftemp2 ">$stdout"
        if $DINO $test_file 2>$stderr >$ftemp2 && sort $ftemp2 >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT17' && $CMP $stdout $ftemp2; then
10
10 in t - 1:1
11
11 in t - 0:0
e
e
e in t - 1:1
f
f
g
g
h
h
OUTPUT17
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 18.
if test $result = ok -a $start_test_number -le 18; then
	echo test 18
        cat >$test_file <<'TEST18'
var t;
t = tab [];
t["e"] = 10;
t[10] = 11;
putln (t["e"]);
putln (t[10]);
TEST18
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT18' && $CMP $stdout $ftemp2; then
10
11
OUTPUT18
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 19.
if test $result = ok -a $start_test_number -le 19; then
	echo test 19
        cat >$test_file <<'TEST19'
var i, v, pv;

v = [100:0, 100:'c'];
for (i = 0; i < 1000;i++)
{
  v = [100:10.0];
  v[50] = 'c';
  v[50] = 10.0;
  pv = v;
}
TEST19
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT19' && $CMP $stdout $ftemp2; then
OUTPUT19
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 20.
if test $result = ok -a $start_test_number -le 20; then
	echo test 20
        cat >$test_file <<'TEST20'
class c(p) {
  var i;
  i = 1;
  fun f {putln ("i=", i);}
  fun g {putln ("p=", p);}
  fun f1 (i) {putln ("i=", i);}
  fun g1 (p) {putln ("p=", p);}
}
var i;
i = c(10);
i.f();
i.g();
i.f1(100);
i.g1(1000);
TEST20
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT20' && $CMP $stdout $ftemp2; then
i=1
p=10
i=100
p=1000
OUTPUT20
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 21.
if test $result = ok -a $start_test_number -le 21; then
	echo test 21
        cat >$test_file <<'TEST21'
class c(p) {
  var i;
  class cc(p) {
    fun f {putln (p);}
  }
  i = 10;
}
var j,k;
j = c(10);
k = j.cc(100);
k.f();


TEST21
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT21' && $CMP $stdout $ftemp2; then
100
OUTPUT21
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 22.
if test $result = ok -a $start_test_number -le 22; then
	echo test 22
        cat >$test_file <<'TEST22'
var a, i;
for (i = 0; i < 10; i++)
  a = [5:2];
TEST22
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT22' && $CMP $stdout $ftemp2; then
OUTPUT22
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 23.
if test $result = ok -a $start_test_number -le 23; then
	echo test 23
        cat >$test_file <<'TEST23'
var v;
var i;
i = 3;
v = [5 : 7, i:8];
for (i = 0; i< #v; i = i + 1)
  putln (v[i]);
TEST23
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT23' && $CMP $stdout $ftemp2; then
7
7
7
7
7
8
8
8
OUTPUT23
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 24.
if test $result = ok -a $start_test_number -le 24; then
	echo test 24
        cat >$test_file <<'TEST24'
putln ("0:", '\n' === 10.0);
putln ("0:", 10 === 10.0);
putln ("0:", "10" === 10.0);
putln ("0:", "10.0" === 10.0);
putln ("0:", "aaaaa" === [5:'a', '\0']);
TEST24
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT24' && $CMP $stdout $ftemp2; then
0:0
0:0
0:0
0:0
0:0
OUTPUT24
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 25.
if test $result = ok -a $start_test_number -le 25; then
	echo test 25
        cat >$test_file <<'TEST25'
fun f (args)
{
}

fun g (a)
{
  var args;
}

fun t (a, ...)
{
  var i;

  putln ("****");
  if (a !== nil)
    putln ("a = ", a);
  for (i = 0; i<#args;i++)
    putln ("args[", i, "]=", args[i]);
}

t (10);
t (10, 1);
t (10, 1, 2);
t (10, 1, 2, 3);
TEST25
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT25' && $CMP $stdout $ftemp2; then
****
a = 10
****
a = 10
args[0]=1
****
a = 10
args[0]=1
args[1]=2
****
a = 10
args[0]=1
args[1]=2
args[2]=3
OUTPUT25
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 26.
if test $result = ok -a $start_test_number -le 26; then
	echo test 26
        cat >$test_file <<'TEST26'
fun f {}
class c {}

putln ("1:", "10" == "10");
putln ("1:", 10 == 10);
putln ("1:", 10.5 == 10.5);
putln ("1:", 'c' == 'c');
	  
putln ("1:", 10 == 10.0);
putln ("1:", 99 == 'c');
putln ("1:", 99.0 == 'c');
	  
putln ("1:", 10 == "10");
putln ("1:", 10.5 == "10.5");
putln ("1:", 'c' == "c");
	  
putln ("1:", f == f);
putln ("1:", c == c);
putln ("1:", c() == c());

var op;
op = 10;
putln ("1:", op == "10");
op = 10.5;
putln ("1:", op == "10.5");
op = 'c';
putln ("1:", op == "c");
TEST26
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT26' && $CMP $stdout $ftemp2; then
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
OUTPUT26
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 27.
if test $result = ok -a $start_test_number -le 27; then
	echo test 27
        cat >$test_file <<'TEST27'
fun f {}
var r;
r = f == 10;
putln ("0:", r);
TEST27
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT27' && $CMP $stdout $ftemp2; then
0:0
OUTPUT27
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 28.
if test $result = ok -a $start_test_number -le 28; then
	echo test 28
        cat >$test_file <<'TEST28'
class c {}
var r;
r = c == 10;
putln ("0:", r);
TEST28
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT28' && $CMP $stdout $ftemp2; then
0:0
OUTPUT28
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 29.
if test $result = ok -a $start_test_number -le 29; then
	echo test 29
        cat >$test_file <<'TEST29'
class c {}
var r;
r = c () == 10;
putln ("0:", r);
TEST29
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT29' && $CMP $stdout $ftemp2; then
0:0
OUTPUT29
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 30.
if test $result = ok -a $start_test_number -le 30; then
	echo test 30
        cat >$test_file <<'TEST30'
class c (p) {
  putln ("p = ", p);
};

c(10);
TEST30
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT30' && $CMP $stdout $ftemp2; then
p = 10
OUTPUT30
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 31.
if test $result = ok -a $start_test_number -le 31; then
	echo test 31
        cat >$test_file <<'TEST31'
class c (p, ...)
{
  var i;
  putln ("p = ", p);
  for (i = 0; i < #args; i++)
    putln (args[i]);
}

c (10, 11, 12, 13);
TEST31
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT31' && $CMP $stdout $ftemp2; then
p = 10
11
12
13
OUTPUT31
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 32.
if test $result = ok -a $start_test_number -le 32; then
	echo test 32
        cat >$test_file_1 <<'TEST32'
var i;
i = 8;
TEST32
        cat >$test_file <<'TEST32-1'
include "test1";
putln (i);
TEST32-1
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT32' && $CMP $stdout $ftemp2; then
8
OUTPUT32
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 33.
if test $result = ok -a $start_test_number -le 33; then
	echo test 33
        cat >$test_file <<'TEST33'
// vector
var v;
// pack
v = [1, 2, 3, 5, 6]; ins (v, 4, 3); println (v);
v = [2, 3, 4, 5, 6]; ins (v, 1); println (v);
v = [1, 2, 3, 4, 5]; ins (v, 6, -1); println (v);
v = [2, 3, 4, 5, 6]; ins (v, 1, 0); println (v);
// unpack
v = [1.0, 2, 3, 5, 6]; ins (v, 4, 3); println (v);
v = [2.0, 3, 4, 5, 6]; ins (v, 1); println (v);
v = [1.0, 2, 3, 4, 5]; ins (v, 6, -1); println (v);
v = [2.0, 3, 4, 5, 6]; ins (v, 1, 0); println (v);
// empty
v = []; ins (v, nil); println (v);
v = []; ins (v, nil, -1); println (v);
v = []; ins (v, nil, 0); println (v);
v = []; ins (v, nil, 10); println (v);
// string
v = new "123456"; ins (v, 2); println (v);
v = new "123456"; ins (v, "+++"); println (v);
v = new "123456"; ins (v, "+++", -1); println (v);
v = new "123456"; ins (v, "+++", 100); println (v);
//
var i, iter;
for (iter = 0; iter < 10000; iter++)
  { 
    v = [];
    for (i = 0; i < 100; i++)
      ins (v, 1);
    for (i = 0; i < 100; i++)
      del (v, 0);
  }
println (v);
TEST33
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT33' && $CMP $stdout $ftemp2; then
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[nil]
[nil]
[nil]
[nil]
[2, '1', '2', '3', '4', '5', '6']
["+++", '1', '2', '3', '4', '5', '6']
['1', '2', '3', '4', '5', '6', "+++"]
['1', '2', '3', '4', '5', '6', "+++"]
[]
OUTPUT33
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 34.
if test $result = ok -a $start_test_number -le 34; then
	echo test 34
        cat >$test_file <<'TEST34'
// vector
var v;
// pack & pack
v = [1, 2, 3, 5, 6]; insv (v, [4], 3); println (v);
v = [2, 3, 4, 5, 6]; insv (v, [1]); println (v);
v = [1, 2, 3, 4, 5]; insv (v, [6], -1); println (v);
v = [2, 3, 4, 5, 6]; insv (v, [1], 0); println (v);
// unpack & pack
v = [1.0, 2, 3, 5, 6]; insv (v, [4], 3); println (v);
v = [2.0, 3, 4, 5, 6]; insv (v, [1]); println (v);
v = [1.0, 2, 3, 4, 5]; insv (v, [6], -1); println (v);
v = [2.0, 3, 4, 5, 6]; insv (v, [1], 0); println (v);
// unpack & unpack
v = [1.0, 2, 3, 6]; insv (v, [4, 5.0], 3); println (v);
v = [3.0, 4, 5, 6]; insv (v, [1.0, 2]); println (v);
v = [1.0, 2, 3, 4, 5]; insv (v, [6, 7.0], -1); println (v);
v = [3, 4, 5, 6]; insv (v, [1, 2.0], 0); println (v);
// empty
v = []; insv (v, [10]); println (v);
v = []; insv (v, [10], -1); println (v);
v = []; insv (v, [10], 0); println (v);
v = []; insv (v, [10], 10); println (v);
v = [10]; insv (v, []); println (v);
v = [10]; insv (v, [], -1); println (v);
v = [10]; insv (v, [], 0); println (v);
v = [10]; insv (v, [], 10); println (v);
// string
v = new "123456"; insv (v, "+++"); putln (v);
v = new "123456"; insv (v, "+++", -1); putln (v);
v = new "123456"; insv (v, "+++", 100); putln (v);
//
var i, iter;
for (iter = 0; iter < 10000; iter++)
  { 
    v = [];
    for (i = 0; i < 100; i++)
      insv (v, [1]);
    for (i = 0; i < 100; i++)
      del (v, 0);
  }
println (v);
TEST34
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT34' && $CMP $stdout $ftemp2; then
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6, 7]
[1, 2, 3, 4, 5, 6]
[10]
[10]
[10]
[10]
[10]
[10]
[10]
[10]
+++123456
123456+++
123456+++
[]
OUTPUT34
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 35.
if test $result = ok -a $start_test_number -le 35; then
	echo test 35
        cat >$test_file <<'TEST35'
print (nil);put (" ");
print (10);put (" ");
print (10.2e10);put (" ");
print ('c');put (" ");
println ("ssss");
println (["aaa", "bbb", "ccc"]);
println (["v1", tab ["key":"val", tab ["key1":"val1"]]]);
fun f {}
println (f);
class c {}
println (c);
println (c ());
var stop;
stop = 0;
thread t {wait (stop);}
println (t());
wait (1) stop = 1;

TEST35
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT35' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+11 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", tab ["key":"val", tab ["key1":"val1"]:nil]]
fun f
class c
instance c()
thread 1 t()
OUTPUT35
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT35-1' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+011 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", tab ["key":"val", tab ["key1":"val1"]:nil]]
fun f
class c
instance c()
thread 1 t()
OUTPUT35-1
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT35-2' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+11 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", tab [tab ["key1":"val1"]:nil, "key":"val"]]
fun f
class c
instance c()
thread 1 t()
OUTPUT35-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT35-3' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+011 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", tab [tab ["key1":"val1"]:nil, "key":"val"]]
fun f
class c
instance c()
thread 1 t()
OUTPUT35-3
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 36.
if test $result = ok -a $start_test_number -le 36; then
	echo test 36
        cat >$test_file <<'TEST36'
var s, t;
s = new "aaaa";
s[1] = "b";
TEST36
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT36' && $CMP $stdout $ftemp2; then
OUTPUT36
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 37.
if test $result = ok -a $start_test_number -le 37; then
	echo test 37
        cat >$test_file <<'TEST37'
thread t1 {
  var i;
  for (i = 0; i < 1000; i++)
     if (i % 100 == 0)
       putln ("thread 1 ", i);
}

thread t2 {
  var i;
  for (i = 0; i < 1000; i++)
     if (i % 100 == 0)
       putln ("thread 2 ", i);
}

t1 ();
putln ("after t1()");
t2 ();
putln ("after t2()");
TEST37
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT37' && $CMP $stdout $ftemp2; then
after t1()
after t2()
thread 1 0
thread 1 100
thread 1 200
thread 1 300
thread 2 0
thread 2 100
thread 2 200
thread 2 300
thread 1 400
thread 1 500
thread 1 600
thread 2 400
thread 2 500
thread 2 600
thread 1 700
thread 1 800
thread 1 900
thread 2 700
thread 2 800
thread 2 900
OUTPUT37
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 38.
if test $result = ok -a $start_test_number -le 38; then
	echo test 38
        cat >$test_file <<'TEST38'
class c(){
thread f (start, iter) {var i;
  for (; iter >= 0; iter--){
    println (start);
    start++;
  }
}
}
var o;
o = c();
o.f (0, 5);
o.f (10, 5);
TEST38
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT38' && $CMP $stdout $ftemp2; then
0
1
2
3
4
5
10
11
12
13
14
15
OUTPUT38
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 39.
if test $result = ok -a $start_test_number -le 39; then
	echo test 39
        cat >$test_file <<'TEST39'
wait (1);
TEST39
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT39' && $CMP $stdout $ftemp2; then
OUTPUT39
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 40.
if test $result = ok -a $start_test_number -le 40; then
	echo test 40
        cat >$test_file <<'TEST40'
var i;
for (i = 0; i < #argv; i++)
  putln (argv[i]);
TEST40
        echo '      ' $DINO $test_file "2>$stderr -- aaaa bbbb"
        if $DINO $test_file 2>$stderr >$stdout -- aaaa bbbb; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT40' && $CMP $stdout $ftemp2; then
aaaa
bbbb
OUTPUT40
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 41.
if test $result = ok -a $start_test_number -le 41; then
	echo test 41
        cat >$test_file <<'TEST41'
// vector
var v;
// pack
v = [1, 2, 3, 4, 5, 6]; del (v, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; del (v, -2, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; del (v, 2, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; del (v, 2, -1); println (v);
v = [1, 2, 3, 4, 5, 6]; del (v, 2, 0); println (v);
// unpack
v = [1, 2.0, 3.0, 4, 5, 6]; del (v, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; del (v, -2, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; del (v, 2, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; del (v, 2, -1); println (v);
v = [1.0, 2, 3, 4, 5, 6]; del (v, 2, 0); println (v);
// empty
v = []; del (v, 0); println (v);
v = []; del (v, -2, 1); println (v);
v = []; del (v, 0, 1); println (v);
v = []; del (v, 1, 0); println (v);
v = []; del (v, 0, -1); println (v);
// string
v = new "123456"; del (v, 2, 2); putln (v);
v = new "123456"; del (v, -2, 2); putln (v);
// table
var t;
t = tab [1:1, 2:2, 3:3, 4:4, 5:5, 6:6]; del (t, 2); println (t);
//
var i, iter;
for (iter = 0; iter < 1000; iter++)
  { 
    v = [1000:1];
    for (i = 0; i < 1000; i++)
      del (v, 0);
  }
println (v);
TEST41
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT41' && $CMP $stdout $ftemp2; then
[1, 2, 4, 5, 6]
[3, 4, 5, 6]
[1, 2, 5, 6]
[1, 2]
[1, 2, 3, 4, 5, 6]
[1, 2, 4, 5, 6]
[3, 4, 5, 6]
[1, 2, 5, 6]
[1, 2]
[1, 2, 3, 4, 5, 6]
[]
[]
[]
[]
[]
1256
3456
tab [1:1, 3:3, 4:4, 5:5, 6:6]
[]
OUTPUT41
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 42.
if test $result = ok -a $start_test_number -le 42; then
	echo test 42
        cat >$test_file <<'TEST42'
println (system ("echo test"));
TEST42
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT42' && $CMP $stdout $ftemp2; then
test
0
OUTPUT42
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 43.
if test $result = ok -a $start_test_number -le 43; then
	echo test 43
        cat >$test_file <<'TEST43'
var i,j;
j = 0;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
TEST43
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT43' && $CMP $stdout $ftemp2; then
OUTPUT43
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 44.
if test $result = ok -a $start_test_number -le 44; then
	echo test 44
        cat >$test_file <<'TEST44'
println (cos (3.14));
println (cos ("3.14"));
println (cos (3));
println (cos ('\3'));
TEST44
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT44' && $CMP $stdout $ftemp2; then
-0.999999
-0.999999
-0.989992
-0.989992
OUTPUT44
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 45.
if test $result = ok -a $start_test_number -le 45; then
	echo test 45
        cat >$test_file <<'TEST45'
println (sin (3.14));
println (sin ("3.14"));
println (sin (3));
println (sin ('\3'));
TEST45
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT45' && $CMP $stdout $ftemp2; then
0.00159265
0.00159265
0.14112
0.14112
OUTPUT45
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 46.
if test $result = ok -a $start_test_number -le 46; then
	echo test 46
        cat >$test_file <<'TEST46'
println (atan2 (3.14, 0));
println (atan2 ("3.14", 0));
println (atan2 (3, 0));
println (atan2 ('\3', 0));
//
println (atan2 (1.0, 0));
println (atan2 ("1.0", 0));
println (atan2 (1, 0));
println (atan2 ('\1', 0));
TEST46
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT46' && $CMP $stdout $ftemp2; then
1.5708
1.5708
1.5708
1.5708
1.5708
1.5708
1.5708
1.5708
OUTPUT46
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 47.
if test $result = ok -a $start_test_number -le 47; then
	echo test 47
        cat >$test_file <<'TEST47'
var SieveSize, i, prime, k, count, iter, flags;
SieveSize = 8190;

for (iter = 0; iter < 10; iter++;)
  {
    flags = [SieveSize + 1 : 0];
    count = 0;
    for (i = 0; i <= SieveSize; i++)
      flags[i] = 1;
    for (i = 0; i <= SieveSize; i++;)
      if (flags[i])
        {
          prime = i + i + 3;
          k = i + prime;
          for (;1;;)
            {
	      if (k > SieveSize)
                break;
              flags[k] = 0;
              k += prime;
            }
          count++;
        }
  }
println (count);
TEST47
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT47' && $CMP $stdout $ftemp2; then
1899
OUTPUT47
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 48.
if test $result = ok -a $start_test_number -le 48; then
	echo test 48
        cat >$test_file <<'TEST48'
var SieveSize, i, prime, k, count, iter, flags;
SieveSize = 8190;

for (iter = 0; iter < 10; iter++;)
  {
    flags = tab [];
    count = 0;
    for (i = 0; i <= SieveSize; i++)
      flags[i] = 1;
    for (i = 0; i <= SieveSize; i++;)
      if (flags[i])
        {
          prime = i + i + 3;
          k = i + prime;
          for (;1;;)
            {
	      if (k > SieveSize)
                break;
              flags[k] = 0;
              k += prime;
            }
          count++;
        }
  }
println (count);
TEST48
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT48' && $CMP $stdout $ftemp2; then
1899
OUTPUT48
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 49.
if test $result = ok -a $start_test_number -le 49; then
	echo test 49
        cat >$test_file <<'TEST49'
var m1, m2;

fun mmult (m1, m2)
{
  var i, j, k, m1rows, m1cols, m2rows, m2cols, result;

  m1rows = #m1; m2rows = #m2;
  m1cols = #m1[0]; m2cols = #m2[0];
  if (m2cols != m2rows)
    {
       println ("matrices don't match");
       return;
    }
  result = [m1rows:[m2cols:0]];
  for (i=0; i < m1rows; i++)
    for (j=0; j < m2cols; j++)
      for (k=0; k < m1cols; k++)
        result[i][j] += m1[i][k]*m2[k][j];
  return result;
}

m1 = [100:[100:1]];
m2 = [100:[100:1]];
mmult (m1, m2);
TEST49
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT49' && $CMP $stdout $ftemp2; then
OUTPUT49
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 50.
if test $result = ok -a $start_test_number -le 50; then
	echo test 50
        cat >$test_file <<'TEST50'
var m1, m2;

fun mmult (m1, m2)
{
  var i, j, k, m1rows, m1cols, m2rows, m2cols, result;

  m1rows = #m1; m2rows = #m2;
  m1cols = #m1[0]; m2cols = #m2[0];
  if (m2cols != m2rows)
    {
       println ("matrices don't match");
       return;
    }
  result = tab [];
  for (i=0; i < m1rows; i++) {
    result[i] = tab [];
    for (j=0; j < m2cols; j++) {
      result[i][j] = 0;
      for (k=0; k < m1cols; k++)
        result[i][j] += m1[i][k]*m2[k][j];
    }
  }
  return result;
}

var i, j;

m1 = tab [];
for (i = 0;i < 100; i++) {
  m1[i] = tab [];
  for (j = 0;j < 100; j++)
    m1[i][j] = 2;
}
m2 = m1;
mmult (m1, m2);
TEST50
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT50' && $CMP $stdout $ftemp2; then
OUTPUT50
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 51.
if test $result = ok -a $start_test_number -le 51; then
	echo test 51
        cat >$test_file <<'TEST51'
var i;
i = 0;
fun f
{
   var i;

   fun g {i = 20; return i;}
   i = 10;
   return g;
}
println (f ()());
TEST51
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT51' && $CMP $stdout $ftemp2; then
20
OUTPUT51
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 52.
if test $result = ok -a $start_test_number -le 52; then
	echo test 52
        cat >$test_file <<'TEST52'
var i;
i = 0;
class c ()
{
   var i;

   class sc ()
   {
     class scc ()
     {
       println (i);
     }
     i = 30;
   }
   i = 10;
}
var ssc, ssci;
ssc = c().sc().scc;
ssci = ssc ();
TEST52
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT52' && $CMP $stdout $ftemp2; then
30
OUTPUT52
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 53.
if test $result = ok -a $start_test_number -le 53; then
	echo test 53
        cat >$test_file <<'TEST53'
class c {
  class sc {
     class ssc {
     }
  }
}
fun f {
  class sc {
    fun g {}
  }
  return sc ();
}
println (c().sc().ssc);
println (f().g);
TEST53
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT53' && $CMP $ftemp $ftemp2; then
class c().sc().ssc
fun f().sc().g
OUTPUT53
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 54.
if test $result = ok -a $start_test_number -le 54; then
	echo test 54
        cat >$test_file <<'TEST54'
// Recursive function to compute Fibonacci numbers
fun fibonacci (n)
  {
     if (n <= 1) return 1;
     return (fibonacci(n-1) + fibonacci(n-2));
  }

var i, fibnum;

fibnum = 0;
for (i = 0; i <= 24; i++) 
  {
    fibnum = fibonacci(i);
    putln (i @ " " @ fibnum); 
  }
TEST54
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT54' && $CMP $stdout $ftemp2; then
0 1
1 1
2 2
3 3
4 5
5 8
6 13
7 21
8 34
9 55
10 89
11 144
12 233
13 377
14 610
15 987
16 1597
17 2584
18 4181
19 6765
20 10946
21 17711
22 28657
23 46368
24 75025
OUTPUT54
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 55.
if test $result = ok -a $start_test_number -le 55; then
	echo test 55: Use with before
        cat >$test_file <<'TEST55'
//----------------------- before -----------------
class c {
  fun me {putln ("c");}
  fun pr {me ();}
};

class sc {
   fun me {putln ("sc");}
   use c former me;
};

var co = c (), sco = sc ();
co.pr ();
sco.pr ();
TEST55
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT55' && $CMP $stdout $ftemp2; then
c
sc
OUTPUT55
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 56.
if test $result = ok -a $start_test_number -le 56; then
	echo test 56: Nested uses
        cat >$test_file <<'TEST56'
//----------------nested uses ------------
class c {
  fun me;
  fun pr {me ();}
  fun me {putln ("c");}
};

class sc {
  use c later me;
  fun me {putln ("sc");}
};

class ssc {
  use sc later me;
  fun me {putln ("ssc");}
};

var ssco = ssc ();
ssco.pr ();
//----------------nested uses ------------
class c {
  fun me;
  fun me {putln ("c");}
  fun pr {me ();}
};

class sc {
  use c later me;
  fun me;
  fun me {putln ("sc");}
};

class ssc {
  use sc later me;
  fun me;
  fun me {putln ("ssc");}
};

var ssco = ssc ();
ssco.pr ();
TEST56
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT56' && $CMP $stdout $ftemp2; then
ssc
ssc
OUTPUT56
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 57.
if test $result = ok -a $start_test_number -le 57; then
	echo test 57: Two uses
        cat >$test_file <<'TEST57'
//---------- two uses ----------------------
class c {
  fun me;
  fun me {putln ("c");}
  fun pr {me ();}
};

class sc {
  use c later me;
  use c former pr;
};

var sco = sc ();
sco.pr ();
TEST57
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT57' && $CMP $stdout $ftemp2; then
c
OUTPUT57
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 58.
if test $result = ok -a $start_test_number -le 58; then
	echo test 58: Use with later
        cat >$test_file <<'TEST58'
//--------------------- later --------------
class c {
  fun me {putln ("c");}
  fun pr {me ();}
};

class sc {
  use c later me;
  fun me {putln ("sc");}
};

var co = c (), sco = sc ();
co.pr ();
sco.pr ();
TEST58
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT58' && $CMP $stdout $ftemp2; then
c
sc
OUTPUT58
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 59.
if test $result = ok -a $start_test_number -le 59; then
	echo test 59
        cat >$test_file <<'TEST59'
var ff;
{
  var i;
  i = 10;
  fun f {return i;}
  ff = f;
}
println (ff ());
TEST59
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT59' && $CMP $stdout $ftemp2; then
10
OUTPUT59
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 60.
if test $result = ok -a $start_test_number -le 60; then
	echo test 60
        cat >$test_file <<'TEST60'
println (type (nil));
println (type ('a'));
println (type (10));
println (type (10.0));
println (type ([]));
println (type (tab []));
fun f ()
{
}
println (type (f));
var flag;
thread t ()
{
  wait (flag != nil);
}
println (type (t));
class c ()
{
}
println (type (c));
var i;
i = c ();
println (type (i));
println (type (t ()));
try {wait (1) flag = 1;}
println (type (context (i)));
println (type (type (1)));
TEST60
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT60' && $CMP $stdout $ftemp2; then
type (nil)
char
int
float
vector
table
fun
thread
class
obj
process
obj
type
OUTPUT60
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 61.
if test $result = ok -a $start_test_number -le 61; then
	echo test 61
        cat >$test_file <<'TEST61'
println (closure ('c'));
println (closure (10));
println (closure (10l));
println (closure (10.));
println (closure ([]));
println (closure (tab []));
fun f {}
println (closure (f));
thread t {}
println (closure (t));
class c {}
println (closure (c ()));
TEST61
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT61' && $CMP $stdout $ftemp2; then
nil
nil
nil
nil
nil
nil
nil
nil
class c
OUTPUT61
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 63.
if test $result = ok -a $start_test_number -le 63; then
	echo test 63: closure params number
        cat >$test_file <<'TEST63'
closure ();
TEST63
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT63' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - unexpected number of parameters for `closure'
OUTPUT63
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 63.
if test $result = ok -a $start_test_number -le 63; then
	echo test 63: closure params number
        cat >$test_file <<'TEST63'
closure (1, 2);
TEST63
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT63' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - unexpected number of parameters for `closure'
OUTPUT63
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 64.
if test $result = ok -a $start_test_number -le 64; then
	echo test 64
        cat >$test_file <<'TEST64'
println (main_thread);
TEST64
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT64' && $CMP $ftemp $ftemp2; then
main thread
OUTPUT64
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 65.
if test $result = ok -a $start_test_number -le 65; then
	echo test 65
        cat >$test_file <<'TEST65'
{
  var i;
  fun f {
     class c (){
       class c (){
       }
     }

     i = c ().c();
  }
  f ();
  println (context (i));
  println (context (context (i)));
  println (context (context (context (i))));
  println (context (context (context (context (i)))));
  println (context (context (context (context (context (i))))));
}
TEST65
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT65' && $CMP $ftemp $ftemp2; then
instance {}.f().c()
stack {}.f()
stack {}
stack 
nil
OUTPUT65
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 66.
if test $result = ok -a $start_test_number -le 66; then
	echo test 66
        cat >$test_file <<'TEST66'
var i;

{
  pub var l;
  class c {};
  i = c();
  l = 10;
}

println (context (i).l);

fun f ()
{
  pub var l;
  class c {};
  i = c();
  l = 20;
}

f ();
println (context (i).l);

fun fp (pub l)
{
  class c {};
  i = c();
}

fp (30);
println (context (i).l);

class c ()
{
  var l;
  class cc {};
  i = cc();
  l = 40;
}

c ();
println (context (i).l);

class cp (l)
{
  class cc {};
  i = cc();
}

cp (50);
println (context (i).l);

{
  pub var l;
  fun f {};
  i = f;
  l = 60;
}

println (context (i).l);

{
  pub var l;
  class c {};
  i = c;
  l = 70;
}

println (context (i).l);

{
  pub var l;
  thread t { wait (l);};
  i = t ();
  try {wait (1) l = 0;}
}

println (context (i).l);
context (i).l = 1;
TEST66
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT66' && $CMP $ftemp $ftemp2; then
10
20
30
40
50
60
70
0
OUTPUT66
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 67.
if test $result = ok -a $start_test_number -le 67; then
	echo test 67
        cat >$test_file <<'TEST67'
var ci;
{
  pub var i;
  class c {
  }
  ci = c ();
  i = 0;
}

println (context(ci).i);
context(ci).i = 1;
println (context(ci).i);
TEST67
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT67' && $CMP $stdout $ftemp2; then
0
1
OUTPUT67
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 68.
if test $result = ok -a $start_test_number -le 68; then
	echo test 68
        cat >$test_file <<'TEST68'
var i = 10, j = i, k;
i = 0;
k = 5;
putln (i, " ", j, " ", k);
TEST68
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT68' && $CMP $stdout $ftemp2; then
0 10 5
OUTPUT68
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 69.
if test $result = ok -a $start_test_number -le 69; then
	echo test 69
        cat >$test_file <<'TEST69'
fun e {putln ("e");return 100;}
fun f (i, p = e ()) {
  putln (p, " ", i);
}

var i;
for (i = 0; i < 10; i++) {
  f (20, i);
  f (20);
}
TEST69
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT69' && $CMP $stdout $ftemp2; then
0 20
e
100 20
1 20
e
100 20
2 20
e
100 20
3 20
e
100 20
4 20
e
100 20
5 20
e
100 20
6 20
e
100 20
7 20
e
100 20
8 20
e
100 20
9 20
e
100 20
OUTPUT69
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 70.
if test $result = ok -a $start_test_number -le 70; then
	echo test 70
        cat >$test_file <<'TEST70'
fun e {putln ("e");return 100;}
class c (i, p = e ()) {
  putln (p, " ", i);
}

var i;
for (i = 0; i < 10; i++) {
  c (20, i);
  c (20);
}
TEST70
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT70' && $CMP $stdout $ftemp2; then
0 20
e
100 20
1 20
e
100 20
2 20
e
100 20
3 20
e
100 20
4 20
e
100 20
5 20
e
100 20
6 20
e
100 20
7 20
e
100 20
8 20
e
100 20
9 20
e
100 20
OUTPUT70
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 71.
if test $result = ok -a $start_test_number -le 71; then
	echo test 71
        cat >$test_file <<'TEST71'
var fp, c;
{
  class cc {
    class c1 {
    }
    fun f {
    }
    {
      fun f {}
      fp = f;
    }
  }
  c = cc;
}
println (inside (c(), c, 1));
println (inside (c().c1, c, 1));
println (inside (c().c1(), c, 1));
println (inside (c().f, c, 1));
println (inside (fp, c, 1));
println (inside (context (fp), c, 1));
println (inside (c().c1 (), c().c1, 1));
println (inside (fp, c().c1, 1));
println (inside (c(), c().c1, 1));
println (inside (c().c1, c().c1, 1));
//
putln ();
println (inside (c(), c, "1"));
println (inside (c().c1, c, '1'));
println (inside (c().c1(), c, "1.0"));
println (inside (c().f, c, 1.0));
println (inside (fp, c, "1"));
println (inside (context (fp), c, "1"));
println (inside (c().c1 (), c().c1, "1"));
println (inside (fp, c().c1, "1"));
println (inside (c(), c().c1, "1"));
println (inside (c().c1, c().c1, "1"));
//
putln ();
println (inside (c(), c, 0));
println (inside (c().c1, c, 0));
println (inside (c().c1(), c, 0));
println (inside (c().f, c, 0));
println (inside (fp, c, 0));
println (inside (context (fp), c, 0));
println (inside (c().c1 (), c().c1, 0));
println (inside (fp, c().c1, 0));
println (inside (c(), c().c1, 0));
println (inside (c().c1, c().c1, 0));
//
putln ();
println (inside (c(), c, "0"));
println (inside (c().c1, c, '0'));
println (inside (c().c1(), c, 0.5));
println (inside (c().f, c, "0"));
println (inside (fp, c, "0"));
println (inside (context (fp), c, "0"));
println (inside (c().c1 (), c().c1, "0"));
println (inside (fp, c().c1, "0"));
println (inside (c(), c().c1, "0"));
println (inside (c().c1, c().c1, "0"));
//
putln ();
println (inside (c(), c));
println (inside (c().c1, c));
println (inside (c().c1(), c));
println (inside (c().f, c));
println (inside (fp, c));
println (inside (context (fp), c));
println (inside (c().c1 (), c().c1));
println (inside (fp, c().c1));
println (inside (c(), c().c1));
println (inside (c().c1, c().c1));
TEST71
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT71' && $CMP $stdout $ftemp2; then
1
1
1
1
1
1
0
0
0
0

1
1
1
1
1
1
0
0
0
0

1
1
1
1
1
1
1
0
0
1

1
1
1
1
1
1
1
0
0
1

1
1
1
1
1
1
1
0
0
1
OUTPUT71
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 72.
if test $result = ok -a $start_test_number -le 72; then
	echo test 72
        cat >$test_file <<'TEST72'
println (match ("aaa", "baaab"));
println (match ("(a)(a)(a)", "baaab"));
println (match ("aba", "baaab"));                 // no matching
println (match ("ab.", "baaab\n"));               // matching with NL
println (match ("[:alpha:]", "p"));
println (match ("^.aa", "baaab"));
println (match ("1", 10));
println (match ("1", 0));
println (match ("1", '1'));
println (match ("()aaa", "baaab"));
TEST72
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT72' && $CMP $stdout $ftemp2; then
[1, 4]
[1, 4, 1, 2, 2, 3, 3, 4]
nil
[3, 6]
[0, 1]
[0, 3]
[0, 1]
nil
[0, 1]
[1, 4, 1, 1]
OUTPUT72
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 73.
if test $result = ok -a $start_test_number -le 73; then
	echo test 73
        cat >$test_file <<'TEST73'
println (split ("aaa bbb ccc	ddd"));
println (split ("aaa bbb ccc	ddd", split_regex));
println (split ("aaa   bbb   ccc	  ddd"));
println (split ("  aaa   bbb   ccc	  ddd  "));
println (split ("abcdef", ""));
println (split ("  aaa   bbb   ccc ddd  ", " "));
println (split ("aaabbbcccddd"));
println (split (""));
println (split ("", ""));
println (split (10));
println (split ('c'));
println (split (10.0));
TEST73
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT73' && $CMP $stdout $ftemp2; then
["aaa", "bbb", "ccc", "ddd"]
["aaa", "bbb", "ccc", "ddd"]
["aaa", "bbb", "ccc", "ddd"]
["aaa", "bbb", "ccc", "ddd"]
["a", "b", "c", "d", "e", "f"]
["aaa", "bbb", "ccc", "ddd"]
["aaabbbcccddd"]
[""]
[""]
["10"]
["c"]
["10"]
OUTPUT73
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 74.
if test $result = ok -a $start_test_number -le 74; then
	echo test 74
        cat >$test_file <<'TEST74'
putln (sub ("aa", "abaabbaaaa", "11"));
putln (gsub ("aa", "abaabbaaaa", "11"), "\n");

putln (sub ("aa", "abaabbaaaa", "d&d"));
putln (gsub ("aa", "abaabbaaaa", "d&d"), "\n");

putln (sub ("(a)a", "abaabbaaaa", "d\\1d"));
putln (gsub ("(a)a", "abaabbaaaa", "d\\1d"), "\n");

putln (sub ("aa", "abaabbaaaa", "d\\2d"));
putln (gsub ("aa", "abaabbaaaa", "d\\2d"), "\n");

putln (sub ("aa", "abaabbaaaa", "d\\&d"));
putln (gsub ("aa", "abaabbaaaa", "d\\&d"), "\n");

putln (sub ("aa", "abaabbaaaa", "d\\\\d"));
putln (gsub ("aa", "abaabbaaaa", "d\\\\d"), "\n");

putln (sub ("", "abc", "d"));
putln (gsub ("", "abc", "d"), "\n");

putln (sub ("", "", "d"));
putln (gsub ("", "", "d"), "\n");

putln (sub ("a", "a", 10));
putln (sub ("a", "a", 'c'));
putln (sub ("a", "a", 10.0));
putln (sub ("8", 8, 10));
TEST74
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT74' && $CMP $stdout $ftemp2; then
ab11bbaaaa
ab11bb1111

abdaadbbaaaa
abdaadbbdaaddaad

abdadbbaaaa
abdadbbdaddad

abddbbaaaa
abddbbdddd

abd&dbbaaaa
abd&dbbd&dd&d

abd\dbbaaaa
abd\dbbd\dd\d

dabc
dadbdc

d
d

10
c
10
10
OUTPUT74
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 75.
if test $result = ok -a $start_test_number -le 75; then
	echo test 75
        cat >$test_file <<TEST75
println (sort (readdir ("__tempdir"), cmpv));

try {
println (readdir ("abracadabra"));
} catch (enoent) {
  putln ("abracadabra: no such directory");
}

try {
println (readdir (1000022));
} catch (enoent) {
  putln ("1000022: no such directory");
}
TEST75
        rm -rf $tempdir
        mkdir $tempdir
        echo > $tempdir/a
        echo > $tempdir/b
        echo > $tempdir/c
        echo > $tempdir/d
        echo > $tempdir/e
        echo > $tempdir/f
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT75' && $CMP $stdout $ftemp2; then
[".", "..", "a", "b", "c", "d", "e", "f"]
abracadabra: no such directory
1000022: no such directory
OUTPUT75
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 76.
if test $result = ok -a $start_test_number -le 76; then
	echo test 76
        cat >$test_file <<'TEST76'
var i = 0;
i[10]=0;
TEST76
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT76' && $CMP $stderr $ftemp2; then
test.d:2:2: run time error - index operation for non vector or table
OUTPUT76
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 77.
if test $result = ok -a $start_test_number -le 77; then
	echo test 77
        cat >$test_file <<'TEST77'
try {
  var i = 0;
  i[10]=0;
} catch (error) {
  putln ("got it: ", e.msg);
}
TEST77
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT77' && $CMP $stdout $ftemp2; then
got it: run time error - index operation for non vector or table
OUTPUT77
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 78.
if test $result = ok -a $start_test_number -le 78; then
	echo test 78
	cat >$test_file <<'TEST78'
var i = 0 / 0;
TEST78
	echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
	    if test `uname` = AIX && $CMP - $stderr <<'OUTPUT78'; then
OUTPUT78
		    result=ok
	    elif uname -a|fgrep Linux|fgrep ppc && $CMP - $stderr <<'OUTPUT78a'; then
OUTPUT78a
		    result=ok
	    elif uname -a|fgrep Linux|fgrep ia64 && $CMP - $stderr <<'OUTPUT78b'; then
OUTPUT78b
		    result=ok
	    elif uname -a|fgrep Linux|fgrep aarch64 && $CMP - $stderr <<'OUTPUT78c'; then
OUTPUT78c
		    result=ok
	    else
		    result=fail
	    fi
	else
	    echo '      ' $CMP - $stderr
	    if cat >$ftemp2 <<'OUTPUT78-1' && $CMP $stderr $ftemp2; then
test.d:1:11: floating point exception
OUTPUT78-1
		    result=ok
	    else
                    result=fail
	    fi
        fi
fi

# Test 79.
if test $result = ok -a $start_test_number -le 79; then
	echo test 79
        if uname | fgrep CYGWIN; then
	    echo skip the test
	    result=ok
        else
	    cat >$test_file <<'TEST79'
for (var i = 0; i < 10; i++)
try {
  var i = 0 / 0;
} catch (error) {
  putln ("got it: ", e.msg);
}
TEST79
	    echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr >$stdout; then
		    echo '      ' $CMP $stdout $ftemp2
		    if cat >$ftemp2 <<'OUTPUT79' && $CMP $stdout $ftemp2; then
OUTPUT79
			result=ok
		    elif cat >$ftemp2 <<'OUTPUT79-1' && $CMP $stdout $ftemp2; then
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
OUTPUT79-1
			    result=ok
		    else
			    result=fail
		    fi
	    else
		    result=fail
	    fi
        fi
fi

# Test 80.
if test $result = ok -a $start_test_number -le 80; then
	echo test 80: Forward and matched declarations
	cat >$test_file <<'TEST80'
fun f;
class f () {}
TEST80
	echo '      ' $DINO $test_file "2>$stderr"
	if $DINO $test_file 2>$stderr >$stdout; then
	    result=fail
	else
	    echo '      ' $CMP - $stderr
	    if cat >$ftemp2 <<'OUTPUT80' && $CMP $stderr $ftemp2; then
test.d:2:7: forward and matched declarations of `f' are different entities
test.d:1:5: (previous declaration of identifier `f')
OUTPUT80
		    result=ok
	    else
		    result=fail
	    fi
        fi
fi

# Test 81.
if test $result = ok -a $start_test_number -le 81; then
	echo test 81
        if uname | fgrep CYGWIN; then
	    echo skip the test
	    result=ok
        else
	    cat >$test_file <<'TEST81'
for (var i = 0; i < 10; i++)
try {
  var i = 0 / 0;
} catch (sigfpe) {
  putln ("got it: ", e.msg);
}
TEST81
	    echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr >$stdout; then
		    echo '      ' $CMP $stdout $ftemp2
		    if cat >$ftemp2 <<'OUTPUT81' && $CMP $stdout $ftemp2; then
OUTPUT81
			result=ok
		    elif cat >$ftemp2 <<'OUTPUT81-1' && $CMP $stdout $ftemp2; then
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
OUTPUT81-1
			    result=ok
		    else
			    result=fail
		    fi
	    else
		    result=fail
	    fi
        fi
fi

# Test 82.
if test $result = ok -a $start_test_number -le 82; then
	echo test 82
        cat >$test_file <<'TEST82'
match ("[a", "");
TEST82
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT82' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unmatched bracket list operators in regexp
OUTPUT82
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 83.
if test $result = ok -a $start_test_number -le 83; then
	echo test 83
        cat >$test_file <<'TEST83'
match ("[z-a]", "");
TEST83
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT83' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid use of the range operator in regexp
OUTPUT83
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 84.
if test $result = ok -a $start_test_number -le 84; then
	echo test 84
        cat >$test_file <<'TEST84'
match ("[[:foo:]]", "");
TEST84
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT84' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unknown character class name in regexp
OUTPUT84
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 85.
if test $result = ok -a $start_test_number -le 85; then
	echo test 85
        cat >$test_file <<'TEST85'
match ("(a", "");
TEST85
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT85' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unmatched parenthesis group operators in regexp
OUTPUT85
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 86.
if test $result = ok -a $start_test_number -le 86; then
	echo test 86
        cat >$test_file <<'TEST86'
match ("(a)\\2", "");
TEST86
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT86' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid back reference to a subexpr. in regexp
OUTPUT86
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 87.
if test $result = ok -a $start_test_number -le 87; then
	echo test 87
        cat >$test_file <<'TEST87'
match ("a\\", "");
TEST87
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT87' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid escape sequence in regexp
OUTPUT87
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 88.
if test $result = ok -a $start_test_number -le 88; then
	echo test 88
        cat >$test_file <<'TEST88'
val i;
i = 10;
putln(i);
TEST88
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT88' && $CMP $stderr $ftemp2; then
test.d:2:1: constant `i' in assignment statement
OUTPUT88
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 89.
if test $result = ok -a $start_test_number -le 89; then
	echo test 89
        cat >$test_file <<'TEST89'
fun f (val i)
{
  i = 10;
  putln(i);
}
f (1);
TEST89
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT89' && $CMP $stderr $ftemp2; then
test.d:3:3: constant `i' in assignment statement
OUTPUT89
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 90.
if test $result = ok -a $start_test_number -le 90; then
	echo test 90
        cat >$test_file <<'TEST90'
val i = 10; putln(i);
fun f (val i = 10)
{
  putln(i);
}
f (1);
f ();
class c (val i = 100)
{
  putln(i);
}
c (1);
c ();
TEST90
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT90' && $CMP $stdout $ftemp2; then
10
1
10
1
100
OUTPUT90
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 91.
if test $result = ok -a $start_test_number -le 91; then
	echo test 91
        cat >$test_file <<'TEST91'
final fun f {putln ("hello, world # 0");}
f();
TEST91
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT91' && $CMP $stdout $ftemp2; then
hello, world # 0
OUTPUT91
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 92.
if test $result = ok -a $start_test_number -le 92; then
	echo test 92
        cat >$test_file <<'TEST92'
final class c (p)
{
  var i;
  i = 10;
  putln (i);
}

c (20);
TEST92
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT92' && $CMP $stdout $ftemp2; then
10
OUTPUT92
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 93.
if test $result = ok -a $start_test_number -le 93; then
	echo test 93: use with later and forward
        cat >$test_file <<'TEST93'
//--------------------- later with forward --------------
class c {
  fun me;
  fun pr {me ();}
  fun me {putln ("c");}
};

class sc {
  use c later me;
  fun me {putln ("sc");}
};

var co = c (), sco = sc ();
co.pr ();
sco.pr ();
TEST93
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT93' && $CMP $stdout $ftemp2; then
c
sc
OUTPUT93
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 94.
if test $result = ok -a $start_test_number -le 94; then
	echo test 94
        cat >$test_file <<'TEST94'
class c {
  use c;
}
TEST94
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT94' && $CMP $stderr $ftemp2; then
test.d:2:7: use of fun/class `c' inside the fun/class
OUTPUT94
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 95.
if test $result = ok -a $start_test_number -le 95; then
	echo test 95
        cat >$test_file <<'TEST95'
class sc {
  use c;
}

class c {
}
TEST95
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT95' && $CMP $stderr $ftemp2; then
test.d:2:7: undeclared identifier `c'
OUTPUT95
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 96.
if test $result = ok -a $start_test_number -le 96; then
	echo test 96
        cat >$test_file <<'TEST96'
class c;

class sc {
  use c;
}

class c {
}
TEST96
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT96' && $CMP $stderr $ftemp2; then
test.d:4:7: use of forward declaration of fun/class `c'
OUTPUT96
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 97.
if test $result = ok -a $start_test_number -le 97; then
	echo test 97
        cat >$test_file <<'TEST97'
var i;

class sc {
  use i;
}
TEST97
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT97' && $CMP $stderr $ftemp2; then
test.d:4:7: use of non fun/class `i'
OUTPUT97
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 98.
if test $result = ok -a $start_test_number -le 98; then
	echo test 98
        cat >$test_file <<'TEST98'
final class c {}

class sc {
  use c;
}
TEST98
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT98' && $CMP $stderr $ftemp2; then
test.d:4:7: use of final fun/class `c'
OUTPUT98
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 99.
if test $result = ok -a $start_test_number -le 99; then
	echo test 99
        cat >$test_file <<'TEST99'
seek (stdout, 10, 10);
TEST99
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT99' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `seek'
OUTPUT99
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 100.
if test $result = ok -a $start_test_number -le 100; then
	echo test 100
        if uname | fgrep Linux || uname | fgrep linux; then
	    cat >$test_file <<'TEST100'
seek (stdout, 10000, 'C');
TEST100
	    echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr; then
		    result=fail
	    else
		    echo '      ' $CMP - $stderr
		    if cat >$ftemp2 <<'OUTPUT100' && $CMP $stderr $ftemp2; then
test.d:1:6: system error - invalid seek: `seek'
OUTPUT100
			    result=ok
		    else
			    result=fail
		    fi
	    fi
        else
	    echo skip the test
	    result=ok
        fi
fi

# Test 101.
if test $result = ok -a $start_test_number -le 101; then
	echo test 101
        if uname | fgrep Linux || uname | fgrep linux; then
	    cat >$test_file <<'TEST101'
seek (stdout, 10, "c");
TEST101
	    echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr; then
		    result=fail
	    else
		    echo '      ' $CMP - $stderr
		    if cat >$ftemp2 <<'OUTPUT101' && $CMP $stderr $ftemp2; then
test.d:1:6: system error - invalid seek: `seek'
OUTPUT101
			    result=ok
		    else
			    result=fail
		    fi
	    fi
        else
	    echo skip the test
	    result=ok
        fi
fi

# Test 102.
if test $result = ok -a $start_test_number -le 102; then
	echo test 102
        cat >$test_file <<'TEST102'
seek (stdout, 10, "t");
TEST102
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT102' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `seek'
OUTPUT102
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 103.
if test $result = ok -a $start_test_number -le 103; then
	echo test 103
        cat >$test_file <<'TEST103'
seek (stdout, "aaa", 's');
TEST103
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT103' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `seek'
OUTPUT103
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT103' && $CMP $stderr $ftemp2; then
test.d:1:6: system error - invalid argument: `string-to-float conversion'
OUTPUT103
                        result=ok

                else
                        result=fail
                fi
        fi
fi

# Test 104.
if test $result = ok -a $start_test_number -le 104; then
	echo test 104
        cat >$test_file <<'TEST104'
seek (10, 10, 'e');
TEST104
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT104' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `seek'
OUTPUT104
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 105.
if test $result = ok -a $start_test_number -le 105; then
	echo test 105
        cat >$test_file <<'TEST105'
var f = open ("test.d", "r");
putln (tell (f));
seek (f, 10, 's');
putln (tell (f));
seek (f, -10, 'c');
putln (tell (f));
seek (f, 0, 'e');
putln (tell (f));
TEST105
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT105'\
		   && wc -c $test_file|awk '{print $1}' >>$ftemp2\
		   && $CMP $stdout $ftemp2; then
0
10
0
OUTPUT105
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 106.
if test $result = ok -a $start_test_number -le 106; then
	echo test 106
        cat >$test_file <<'TEST106'
putln (time ());
TEST106
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-9][0-9][0-9][0-9][0-9]*$' $stdout
                if egrep '^[0-9][0-9][0-9][0-9][0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 107.
if test $result = ok -a $start_test_number -le 107; then
	echo test 107
        cat >$test_file <<'TEST107'
time (10);
TEST107
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT107' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - unexpected number of parameters for `time'
OUTPUT107
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 108.
if test $result = ok -a $start_test_number -le 108; then
	echo test 108
        cat >$test_file <<'TEST108'
strtime (10, nil, nil);
TEST108
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT108' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - unexpected number of parameters for `strtime'
OUTPUT108
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 109.
if test $result = ok -a $start_test_number -le 109; then
	echo test 109
        cat >$test_file <<'TEST109'
strtime (nil);
TEST109
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT109' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `strtime'
OUTPUT109
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 110.
if test $result = ok -a $start_test_number -le 110; then
	echo test 110
        cat >$test_file <<'TEST110'
strtime (10, nil);
TEST110
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT110' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `strtime'
OUTPUT110
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 111.
if test $result = ok -a $start_test_number -le 111; then
	echo test 111
        cat >$test_file <<'TEST111'
time_format = nil;
strtime ();
TEST111
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT111' && $CMP $stderr $ftemp2; then
test.d:2:9: run time error - bad value of environment variable `time_format'
OUTPUT111
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 112.
if test $result = ok -a $start_test_number -le 112; then
	echo test 112
        cat >$test_file <<'TEST112'
put (strtime ("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa "));
put (strtime ("%Y ", time()));
put (strtime (time_format, time()));
put (strtime (" %d "));
put (strtime ());
putln (strtime (" aa"));
TEST112
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa [0-9][0-9][0-9][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Z]* [0-9][0-9][0-9][0-9] [0-3][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Z]* [0-9][0-9][0-9][0-9] aa$' $stdout
                if egrep '^aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa [0-9][0-9][0-9][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Z]* [0-9][0-9][0-9][0-9] [0-3][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Z]* [0-9][0-9][0-9][0-9] aa$' $stdout; then
                        result=ok
                elif egrep '^aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa [0-9][0-9][0-9][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Za-z]* [A-Za-z]* [A-Za-z]* [0-9][0-9][0-9][0-9] [0-3][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Za-z]* [A-Za-z]* [A-Za-z]* [0-9][0-9][0-9][0-9] aa$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 113.
if test $result = ok -a $start_test_number -le 113; then
	echo test 113
        cat >$test_file <<'TEST113'
clock (nil);
TEST113
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT113' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unexpected number of parameters for `clock'
OUTPUT113
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 114.
if test $result = ok -a $start_test_number -le 114; then
	echo test 114
        cat >$test_file <<'TEST114'
putln (clock ());
TEST114
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-1]\.?[0-9]*$' $stdout
                if egrep '^[0-1]\.?[0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 115.
if test $result = ok -a $start_test_number -le 115; then
	echo test 115
        cat >$test_file <<'TEST115'
split_regex = nil;
println (split ("aaa bbb ccc	ddd"));
TEST115
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT115' && $CMP $stderr $ftemp2; then
test.d:2:16: run time error - bad value of environment variable `split_regex'
OUTPUT115
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 116.
if test $result = ok -a $start_test_number -le 116; then
	echo test 116
        cat >$test_file <<'TEST116'
throw except ();
TEST116
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT116' && $CMP $stderr $ftemp2; then
test.d:1:1: run time error - exception except has not been processed
OUTPUT116
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 117.
if test $result = ok -a $start_test_number -le 117; then
	echo test 117
        cat >$test_file <<'TEST117'
throw  error ("Error111");
TEST117
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT117' && $CMP $stderr $ftemp2; then
test.d:1:1: Error111
OUTPUT117
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 118.
if test $result = ok -a $start_test_number -le 118; then
	echo test 118
        cat >$test_file <<'TEST118'
for (var i = 0; i < 50;i++)
{
  try {
    putln ("in try");
    throw except ();
    putln ("after throw");
  } catch (except) {
    putln ("in catch");
  } 
  putln ("finish");
}
TEST118
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT118' && $CMP $stdout $ftemp2; then
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
OUTPUT118
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 119.
if test $result = ok -a $start_test_number -le 119; then
	echo test 119
        cat >$test_file <<'TEST119'
try {
  put ("Good");
} catch (except) {
}
putln (" and good");
TEST119
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT119' && $CMP $stdout $ftemp2; then
Good and good
OUTPUT119
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 120.
if test $result = ok -a $start_test_number -le 120; then
	echo test 120
        cat >$test_file <<'TEST120'
var f = open ("test.d", "r"), f1;
f1 = f;
println (f == f1);
println (type (f));
println (type (hide));
println (hide);
println (type (hideblock));
println (hideblock);
TEST120
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT120' && $CMP $stdout $ftemp2; then
1
obj
type
hide
type
hideblock
OUTPUT120
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 121.
if test $result = ok -a $start_test_number -le 121; then
	echo test 121
        cat >$test_file <<'TEST121'
var v = [4, 2, 1, 3]; println (sort (v)); println (v);
v = [4.0, 2.0, 1.0, 3.0]; println (sort (v)); println (v);
v = ['4', '2', '1', '3']; println (sort (v)); println (v);
v = "5132"; println (sort (v)); println (v);

fun c(i,j) {
  if (i < j)
    return -1;
  else if (i == j)
    return 0;
  else
    return 1;
}
v = [4, 2, 1, 3.5];
println (sort (v, c)); println (v);
TEST121
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT121' && $CMP $stdout $ftemp2; then
[1, 2, 3, 4]
[4, 2, 1, 3]
[1, 2, 3, 4]
[4, 2, 1, 3]
"1234"
"4213"
"1235"
"5132"
[1, 2, 3.5, 4]
[4, 2, 1, 3.5]
OUTPUT121
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 122.
if test $result = ok -a $start_test_number -le 122; then
	echo test 122
        cat >$test_file <<'TEST122'
var v = "5132"; println (sort ());
TEST122
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT122' && $CMP $stderr $ftemp2; then
test.d:1:31: run time error - unexpected number of parameters for `sort'
OUTPUT122
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 123.
if test $result = ok -a $start_test_number -le 123; then
	echo test 123
        cat >$test_file <<'TEST123'
var v = "5132"; println (sort (nil, nil, nil));
TEST123
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT123' && $CMP $stderr $ftemp2; then
test.d:1:31: run time error - unexpected number of parameters for `sort'
OUTPUT123
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 124.
if test $result = ok -a $start_test_number -le 124; then
	echo test 124
        cat >$test_file <<'TEST124'
println (sort (nil));
TEST124
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT124' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid parameter type of `sort'
OUTPUT124
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 125.
if test $result = ok -a $start_test_number -le 125; then
	echo test 125
        cat >$test_file <<'TEST125'
var v = [4.0, 2.0, 1.0, 3]; println (sort (v));
TEST125
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT125' && $CMP $stderr $ftemp2; then
test.d:1:43: run time error - invalid parameter type of `sort'
OUTPUT125
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 126.
if test $result = ok -a $start_test_number -le 126; then
	echo test 126
        cat >$test_file <<'TEST126'
var v = [nil, nil]; println (sort (v));
TEST126
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT126' && $CMP $stderr $ftemp2; then
test.d:1:35: run time error - invalid parameter type of `sort'
OUTPUT126
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 127.
if test $result = ok -a $start_test_number -le 127; then
	echo test 127
        cat >$test_file <<'TEST127'
var v = [2, 1]; println (sort (v, v));
TEST127
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT127' && $CMP $stderr $ftemp2; then
test.d:1:31: run time error - invalid parameter type of `sort'
OUTPUT127
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 128.
if test $result = ok -a $start_test_number -le 128; then
	echo test 128
        cat >$test_file <<'TEST128'
fun c (i, j) {return nil;}
var v = [2, 1]; println (sort (v, c));
TEST128
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT128' && $CMP $stderr $ftemp2; then
test.d:2:31: run time error - invalid function result used by function `sort'
OUTPUT128
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 129.
if test $result = ok -a $start_test_number -le 129; then
	echo test 129
        cat >$test_file <<'TEST129'
putln (getpid (), " ", getun (), " ", geteun (), " ", getgn (), " ", getegn ());
TEST129
        echo '      ' $DINO $test_file "2>$stderr"
        if uname | fgrep CYGWIN; then
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^-?[0-9][0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]*$' $stdout
                if egrep '^-?[0-9][0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-9][0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]*$' $stdout
                if egrep '^[0-9][0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	fi
fi

# Test 130.
if test $result = ok -a $start_test_number -le 130; then
	echo test 130
        cat >$test_file <<'TEST130'
getpid (1);
TEST130
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT130' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unexpected number of parameters for `getpid'
OUTPUT130
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 131.
if test $result = ok -a $start_test_number -le 130; then
	echo test 131
        cat >$test_file <<'TEST131'
getppid (1);
TEST131
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT131' && $CMP $stderr $ftemp2; then
test.d:1:1: undeclared identifier `getppid'
OUTPUT131
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 132.
if test $result = ok -a $start_test_number -le 132; then
	echo test 132
        cat >$test_file <<'TEST132'
getun (1);
TEST132
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT132' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unexpected number of parameters for `getun'
OUTPUT132
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 133.
if test $result = ok -a $start_test_number -le 133; then
	echo test 133
        cat >$test_file <<'TEST133'
geteun (1);
TEST133
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT133' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unexpected number of parameters for `geteun'
OUTPUT133
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 134.
if test $result = ok -a $start_test_number -le 134; then
	echo test 134
        cat >$test_file <<'TEST134'
getgn (1);
TEST134
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT134' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unexpected number of parameters for `getgn'
OUTPUT134
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 135.
if test $result = ok -a $start_test_number -le 135; then
	echo test 135
        cat >$test_file <<'TEST135'
getegn (1);
TEST135
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT135' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unexpected number of parameters for `getegn'
OUTPUT135
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 136.
if test $result = ok -a $start_test_number -le 136; then
	echo test 136
        cat >$test_file <<'TEST136'
putln (ftype ("test.d"));
putln (ftype ("."));
putln (ftype (stdin));
putln (ftype (stdout));
TEST136
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT136' && $CMP $stdout $ftemp2; then
f
d
c
f
OUTPUT136
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 137.
if test $result = ok -a $start_test_number -le 137; then
	echo test 137
        cat >$test_file <<'TEST137'
ftype ();
TEST137
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT137' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unexpected number of parameters for `ftype'
OUTPUT137
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 138.
if test $result = ok -a $start_test_number -le 138; then
	echo test 138
        cat >$test_file <<'TEST138'
ftype (nil, nil);
TEST138
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT138' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unexpected number of parameters for `ftype'
OUTPUT138
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 139.
if test $result = ok -a $start_test_number -le 139; then
	echo test 139
        cat >$test_file <<'TEST139'
ftype (nil);
TEST139
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT139' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `ftype'
OUTPUT139
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 140.
if test $result = ok -a $start_test_number -le 140; then
	echo test 140
        cat >$test_file <<'TEST140'
println (getgroups ());
TEST140
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                regex="^\[(\"[-_a-zA-Z0-9][-_a-zA-Z0-9]*\"(, \"[-_a-zA-Z0-9][-_a-zA-Z0-9]*\")*)?\]$"
                echo '      ' egrep \'$regex\' $stdout
                if egrep "$regex" $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 141.
if test $result = ok -a $start_test_number -le 141; then
	echo test 141
        cat >$test_file <<'TEST141'
getgroups (nil);
TEST141
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT141' && $CMP $stderr $ftemp2; then
test.d:1:11: run time error - unexpected number of parameters for `getgroups'
OUTPUT141
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 142.
if test $result = ok -a $start_test_number -le 142; then
	echo test 142
        cat >$test_file <<'TEST142'
var i, j;
for (i=0;i<10000;i++)
  {
    j=0;
  }
putln (gc());
TEST142
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-9][0-9][0-9][0-9][0-9][0-9]*$' $stdout
                if egrep '^[0-9][0-9][0-9][0-9][0-9][0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 143.
if test $result = ok -a $start_test_number -le 143; then
	echo test 143
        cat >$test_file <<'TEST143'
gc (nil);
TEST143
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT143' && $CMP $stderr $ftemp2; then
test.d:1:4: run time error - unexpected number of parameters for `gc'
OUTPUT143
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 144.
if test $result = ok -a $start_test_number -le 144; then
	echo test 144
        cat >$test_file <<'TEST144'
put (fuidn ("test.d"));
put (" ", fgrpn ("test.d"));
putln (" ", fsize ("test.d"));
TEST144
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		regex="^[a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* "
		regex=$regex`wc -c $test_file|awk '{print $1}'`\$
                echo '      \'$regex\' $stdout
                if egrep "$regex" $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 145.
if test $result = ok -a $start_test_number -le 145; then
	echo test 145
        cat >$test_file <<'TEST145'
put (fatime ("test.d"));
put (" ", fmtime ("test.d"));
putln (" ", fctime ("test.d"));
TEST145
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*( [0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*)*$' $stdout
                if egrep '^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*( [0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*)*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 146.
if test $result = ok -a $start_test_number -le 146; then
	echo test 146
        cat >$test_file <<'TEST146'
put (fumode ("test.d"));
put (" ", fgmode ("test.d"));
putln (" ", fomode ("test.d"));
TEST146
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^s?r?w?x? r?w?x? r?w?x?$' $stdout
                if egrep '^s?r?w?x? r?w?x? r?w?x?$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 147.
if test $result = ok -a $start_test_number -le 147; then
	echo test 147
        cat >$test_file <<'TEST147'
fatime ();
TEST147
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT147' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unexpected number of parameters for `fatime'
OUTPUT147
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 148.
if test $result = ok -a $start_test_number -le 148; then
	echo test 148
        cat >$test_file <<'TEST148'
fatime (nil);
TEST148
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT148' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `fatime'
OUTPUT148
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 149.
if test $result = ok -a $start_test_number -le 149; then
	echo test 149
        cat >$test_file <<'TEST149'
var i,t;
t = tab [];
for (i = 0; i < 10000; i++)
  t [i] = -i;
TEST149
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT149' && $CMP $stdout $ftemp2; then
OUTPUT149
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 150.
if test $result = ok -a $start_test_number -le 150; then
	echo test 150
        cat >$test_file <<'TEST150'
var c, i;
for (i = 0; i < 5; i++)
{
  c = get ();
  putln (c);
}
TEST150
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT150' && $CMP $stdout $ftemp2; then
a
b
c
d


OUTPUT150
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 151.
if test $result = ok -a $start_test_number -le 151; then
	echo test 151
        cat >$test_file <<'TEST151'
var c;
for (;1;)
{
  try {c = get ();} catch (eof) {break;}
  putln (c);
}
TEST151
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT151' && $CMP $stdout $ftemp2; then
a
b
c
d


OUTPUT151
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 152.
if test $result = ok -a $start_test_number -le 152; then
	echo test 152
        cat >$test_file <<'TEST152'
var c, f = open ("test.d", "r");
for (;1;)
{
  try {c = fget (f);} catch (eof) {break;}
  put (c);
}
TEST152
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT152' && $CMP $stdout $ftemp2; then
var c, f = open ("test.d", "r");
for (;1;)
{
  try {c = fget (f);} catch (eof) {break;}
  put (c);
}
OUTPUT152
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 153.
if test $result = ok -a $start_test_number -le 153; then
	echo test 153
        cat >$test_file <<'TEST153'
var c;
for (;1;)
{
  c = get ();
  putln (c);
}
TEST153
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT153' && $CMP $stderr $ftemp2; then
test.d:4:11: run time error - EOF occured in `get'
OUTPUT153
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 154.
if test $result = ok -a $start_test_number -le 154; then
	echo test 154
        cat >$test_file <<'TEST154'
var c, f=open ("test.d", "r");
for (;1;)
{
  c = fget (f);
  put (c);
}
TEST154
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT154' && $CMP $stderr $ftemp2; then
test.d:4:12: run time error - EOF occured in `fget'
OUTPUT154
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 155.
if test $result = ok -a $start_test_number -le 155; then
	echo test 155
        cat >$test_file <<'TEST155'
var c = get (nil);
TEST155
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT155' && $CMP $stderr $ftemp2; then
test.d:1:13: run time error - unexpected number of parameters for `get'
OUTPUT155
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 156.
if test $result = ok -a $start_test_number -le 156; then
	echo test 156
        cat >$test_file <<'TEST156'
var c = fget ();
TEST156
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT156' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - unexpected number of parameters for `fget'
OUTPUT156
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 157.
if test $result = ok -a $start_test_number -le 157; then
	echo test 157
        cat >$test_file <<'TEST157'
var c = fget (nil);
TEST157
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT157' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid parameter type of `fget'
OUTPUT157
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 158.
if test $result = ok -a $start_test_number -le 158; then
	echo test 158
        cat >$test_file <<'TEST158'
putln (getln());
TEST158
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT158' && $CMP $stdout $ftemp2; then
abcd
OUTPUT158
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 159.
if test $result = ok -a $start_test_number -le 159; then
	echo test 159
        cat >$test_file <<'TEST159'
var c, f = open ("test.d", "r");
for (;1;)
{
  try {putln (fgetln (f));} catch (eof) {break;}
}
TEST159
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT159' && $CMP $stdout $ftemp2; then
var c, f = open ("test.d", "r");
for (;1;)
{
  try {putln (fgetln (f));} catch (eof) {break;}
}
OUTPUT159
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 160.
if test $result = ok -a $start_test_number -le 160; then
	echo test 160
        cat >$test_file <<'TEST160'
putln (getln ());
putln (getln ());
TEST160
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT160' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - EOF occured in `getln'
OUTPUT160
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 161.
if test $result = ok -a $start_test_number -le 161; then
	echo test 161
        cat >$test_file <<'TEST161'
var c, f=open ("test.d", "r");
for (;1;)
  putln (fgetln (f));
TEST161
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT161' && $CMP $stderr $ftemp2; then
test.d:3:17: run time error - EOF occured in `fgetln'
OUTPUT161
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 162.
if test $result = ok -a $start_test_number -le 162; then
	echo test 162
        cat >$test_file <<'TEST162'
var c = getln (nil);
TEST162
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT162' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - unexpected number of parameters for `getln'
OUTPUT162
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 163.
if test $result = ok -a $start_test_number -le 163; then
	echo test 163
        cat >$test_file <<'TEST163'
var c = fgetln ();
TEST163
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT163' && $CMP $stderr $ftemp2; then
test.d:1:16: run time error - unexpected number of parameters for `fgetln'
OUTPUT163
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 164.
if test $result = ok -a $start_test_number -le 164; then
	echo test 164
        cat >$test_file <<'TEST164'
var c = fgetln (nil);
TEST164
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT164' && $CMP $stderr $ftemp2; then
test.d:1:16: run time error - invalid parameter type of `fgetln'
OUTPUT164
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 165.
if test $result = ok -a $start_test_number -le 165; then
	echo test 165
        cat >$test_file <<'TEST165'
putln (nil);
TEST165
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT165' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `putln'
OUTPUT165
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 166.
if test $result = ok -a $start_test_number -le 166; then
	echo test 166
        cat >$test_file <<'TEST166'
put ([10]);
TEST166
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT166' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `put'
OUTPUT166
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 167.
if test $result = ok -a $start_test_number -le 167; then
	echo test 167
        cat >$test_file <<'TEST167'
fputln (nil);
TEST167
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT167' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `fputln'
OUTPUT167
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 168.
if test $result = ok -a $start_test_number -le 168; then
	echo test 168
        cat >$test_file <<'TEST168'
fput ([10]);
TEST168
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT168' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `fput'
OUTPUT168
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 169.
if test $result = ok -a $start_test_number -le 169; then
	echo test 169
        cat >$test_file <<'TEST169'
for (;1;)
{
  try {
    println (scanln ());
  } catch (eof) {putln ("eof"); break;}
    catch (invinput) {putln ("catch invalid input");}
}
TEST169
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout <<'INPUT169' ; then
'c'
"aaaaa"
1000
-1000
10e+10
-10e+10
[]
[2]
[2:2]
[2:[2]]
[2,2.2, 2:[10, 'c', "aaa", 10.7]]
tab []
tab [10, 2:"10"]
tab [[2,5]:tab [1:5, 5], 10:[10, 'c']]
[2,3] [3,2]
[2, a
[3,3]
INPUT169
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT169' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
-1000
1e+11
-1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab []
tab [10:10, 2:"10"]
tab [10:[10, 'c'], [2, 5]:tab [1:5, 5:5]]
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT169
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT169-2' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
-1000
1e+011
-1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab []
tab [10:10, 2:"10"]
tab [10:[10, 'c'], [2, 5]:tab [1:5, 5:5]]
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT169-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT169-3' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
-1000
1e+11
-1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab []
tab [10:10, 2:"10"]
tab [[2, 5]:tab [1:5, 5:5], 10:[10, 'c']]
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT169-3
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT169-4' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
-1000
1e+011
-1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab []
tab [10:10, 2:"10"]
tab [[2, 5]:tab [1:5, 5:5], 10:[10, 'c']]
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT169-4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 170.
if test $result = ok -a $start_test_number -le 170; then
	echo test 170
        cat >$test_file <<'TEST170'
scan (nil);
TEST170
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT170' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - unexpected number of parameters for `scan'
OUTPUT170
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 171.
if test $result = ok -a $start_test_number -le 171; then
	echo test 171
        cat >$test_file <<'TEST171'
scanln (nil);
TEST171
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT171' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unexpected number of parameters for `scanln'
OUTPUT171
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 172.
if test $result = ok -a $start_test_number -le 172; then
	echo test 172
        cat >$test_file <<'TEST172'
fscan ();
TEST172
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT172' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unexpected number of parameters for `fscan'
OUTPUT172
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 173.
if test $result = ok -a $start_test_number -le 173; then
	echo test 173
        cat >$test_file <<'TEST173'
fscanln ();
TEST173
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT173' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - unexpected number of parameters for `fscanln'
OUTPUT173
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 174.
if test $result = ok -a $start_test_number -le 174; then
	echo test 174
        cat >$test_file <<'TEST174'
fscan ([10]);
TEST174
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT174' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `fscan'
OUTPUT174
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 175.
if test $result = ok -a $start_test_number -le 175; then
	echo test 175
        cat >$test_file <<'TEST175'
fscanln ([10]);
TEST175
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT175' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `fscanln'
OUTPUT175
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 176.
if test $result = ok -a $start_test_number -le 176; then
	echo test 176
        cat >$test_file <<'TEST176'
for (;1;)
{
  try {
    println (scan ());
  } catch (eof) {putln ("eof"); break;}
}
TEST176
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout <<'INPUT176' ; then
'c'"aaaaa"1000 10e+10[][2][2:2][2:[2]][2,2.2, 2:[10, 'c', "aaa", 10.7]]
tab [10, 2:"10"]tab [[2,5]:tab [1:5, 5], 10:[10, 'c']][2,3] [3,2] [3,3]
INPUT176
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT176' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [10:10, 2:"10"]
tab [10:[10, 'c'], [2, 5]:tab [1:5, 5:5]]
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT176
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT176-2' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [10:10, 2:"10"]
tab [10:[10, 'c'], [2, 5]:tab [1:5, 5:5]]
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT176-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT176-3' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [10:10, 2:"10"]
tab [[2, 5]:tab [1:5, 5:5], 10:[10, 'c']]
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT176-3
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT176-4' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [10:10, 2:"10"]
tab [[2, 5]:tab [1:5, 5:5], 10:[10, 'c']]
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT176-4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 177.
if test $result = ok -a $start_test_number -le 177; then
	echo test 177
        cat >$test_file <<'TEST177'
var f = open ("_temp.out", "r");
for (;1;)
{
  try {
    println (fscanln (f));
  } catch (eof) {putln ("eof"); break;}
    catch (invinput) {putln ("catch invalid input");}
}
TEST177
        echo '      ' "$DINO $test_file 2>$stderr"
	cat >$ftemp  <<'INPUT177'
'c'
"aaaaa"
1000
10e+10
[]
[2]
[2:2]
[2:[2]]
[2,2.2, 2:[10, 'c', "aaa", 10.7]]
tab [10, 2:"10"]
tab [[2,5]:tab [1:5, 5], 10:[10, 'c']]
[2,3] [3,2]
[2, a
[3,3]
INPUT177
        if $DINO $test_file 2>$stderr >$stdout ; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT177' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [10:10, 2:"10"]
tab [10:[10, 'c'], [2, 5]:tab [1:5, 5:5]]
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT177
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT177-2' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [10:10, 2:"10"]
tab [10:[10, 'c'], [2, 5]:tab [1:5, 5:5]]
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT177-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT177-3' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [10:10, 2:"10"]
tab [[2, 5]:tab [1:5, 5:5], 10:[10, 'c']]
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT177-3
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT177-4' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [10:10, 2:"10"]
tab [[2, 5]:tab [1:5, 5:5], 10:[10, 'c']]
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT177-4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 178.
if test $result = ok -a $start_test_number -le 178; then
	echo test 178
        cat >$test_file <<'TEST178'
var f = open ("_temp.out", "r");
for (;1;)
{
  try {
    println (fscan (f));
  } catch (eof) {putln ("eof"); break;}
    catch (invinput) {putln ("catch invalid input");}
}
TEST178
        echo '      ' "$DINO $test_file 2>$stderr"
	cat >$ftemp  <<'INPUT178'
'c'"aaaaa"1000 10e+10[][2][2:2][2:[2]][2,2.2, 2:[10, 'c', "aaa", 10.7]]
tab [10, 2:"10"]tab [[2,5]:tab [1:5, 5], 10:[10, 'c']][2,3] [3,2] [3,3]
INPUT178
        if $DINO $test_file 2>$stderr >$stdout ; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT178' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [10:10, 2:"10"]
tab [10:[10, 'c'], [2, 5]:tab [1:5, 5:5]]
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT178
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT178-2' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [10:10, 2:"10"]
tab [10:[10, 'c'], [2, 5]:tab [1:5, 5:5]]
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT178-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT178-3' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [10:10, 2:"10"]
tab [[2, 5]:tab [1:5, 5:5], 10:[10, 'c']]
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT178-3
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT178-4' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [10:10, 2:"10"]
tab [[2, 5]:tab [1:5, 5:5], 10:[10, 'c']]
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT178-4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 179.
if test $result = ok -a $start_test_number -le 179; then
	echo test 179
        cat >$test_file <<'TEST179'
println (scanln ());
TEST179
        echo '      ' "echo 1000000000000000000000000|$DINO $test_file 2>$stderr"
        if echo 1000000000000000000000000|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT179' && $CMP $stderr $ftemp2; then
test.d:1:17: system error - result too big (small): `string-to-int conversion'
OUTPUT179
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 180.
if test $result = ok -a $start_test_number -le 180; then
	echo test 180
        cat >$test_file <<'TEST180'
println (scanln ());
TEST180
        echo '      ' "echo 1000000000000e1000|$DINO $test_file 2>$stderr"
        if echo 1000000000000e1000|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT180' && $CMP $stderr $ftemp2; then
test.d:1:17: system error - result too big (small): `string-to-float conversion'
OUTPUT180
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 181.
if test $result = ok -a $start_test_number -le 181; then
	echo test 181
        cat >$test_file <<'TEST181'
println (scanln ());
TEST181
        echo '      ' "echo 1000000000000e-1000|$DINO $test_file 2>$stderr"
        if echo 1000000000000e-1000|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT181' && $CMP $stderr $ftemp2; then
test.d:1:17: system error - result too big (small): `string-to-float conversion'
OUTPUT181
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 182.
if test $result = ok -a $start_test_number -le 182; then
	echo test 182
        cat >$test_file <<'TEST182'
var i=100000000000000000000000;
TEST182
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT182' && $CMP $stderr $ftemp2; then
test.d:1:7: too big integer value
OUTPUT182
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 183.
if test $result = ok -a $start_test_number -le 183; then
	echo test 183
        cat >$test_file <<'TEST183'
var i=-100000000000000000000000;
TEST183
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT183' && $CMP $stderr $ftemp2; then
test.d:1:8: too big integer value
OUTPUT183
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 184.
if test $result = ok -a $start_test_number -le 184; then
	echo test 184
        cat >$test_file <<'TEST184'
var f=1000000000000e1000;
TEST184
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT184' && $CMP $stderr $ftemp2; then
test.d:1:7: too big or too small floating point value
OUTPUT184
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 185.
if test $result = ok -a $start_test_number -le 185; then
	echo test 185
        cat >$test_file <<'TEST185'
var f=1000000000000e-1000;
TEST185
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT185' && $CMP $stderr $ftemp2; then
test.d:1:7: too big or too small floating point value
OUTPUT185
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 186.
if test $result = ok -a $start_test_number -le 186; then
	echo test 186
        cat >$test_file <<'TEST186'
var f=-1000000000000e1000;
TEST186
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT186' && $CMP $stderr $ftemp2; then
test.d:1:8: too big or too small floating point value
OUTPUT186
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 187.
if test $result = ok -a $start_test_number -le 187; then
	echo test 187
        cat >$test_file <<'TEST187'
var i="1000000000000000000000000" + 0;
TEST187
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT187' && $CMP $stderr $ftemp2; then
test.d:1:35: system error - result too big (small): `string-to-int conversion'
OUTPUT187
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 188.
if test $result = ok -a $start_test_number -le 188; then
	echo test 188
        cat >$test_file <<'TEST188'
var f="1000000000000e1000" + 0.0;
TEST188
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT188' && $CMP $stderr $ftemp2; then
test.d:1:28: system error - result too big (small): `string-to-float conversion'
OUTPUT188
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 189.
if test $result = ok -a $start_test_number -le 189; then
	echo test 189
        cat >$test_file <<'TEST189'
thread t1 {
  put ("thread 1: ");print (curr_thread); put (" "); println (main_thread);
}

thread t2 {
  put ("thread 2: ");print (curr_thread); put (" "); println (main_thread);
}

put ("thread 2: ");print (curr_thread); put (" "); println (main_thread);

t1 ();
t2 ();
TEST189
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT189' && $CMP $ftemp $ftemp2; then
thread 2: main thread main thread
thread 1: thread 1 t1() main thread
thread 2: thread 2 t2() main thread
OUTPUT189
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 190.
if test $result = ok -a $start_test_number -le 190; then
	echo test 190
        cat >$test_file <<'TEST190'
var i;
for(i=0;;i++) {
  if (i == 10)
    break;
  putln (i);
}
TEST190
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout ; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT190' && $CMP $stdout $ftemp2; then
0
1
2
3
4
5
6
7
8
9
OUTPUT190
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 191.
if test $result = ok -a $start_test_number -le 191; then
	echo test 191
        cat >$test_file <<'TEST191'
var f = open ("1000000000000e1000", "r");
TEST191
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT191' && $CMP $stderr $ftemp2; then
test.d:1:14: system error - no such file or directory: `open'
OUTPUT191
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 192.
if test $result = ok -a $start_test_number -le 192; then
	echo test 192
        cat >$test_file <<'TEST192'
var f;
try {
 f = open ("1000000000000e1000", "r");
} catch (invcall) {}
close (f);
TEST192
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT192' && $CMP $stderr $ftemp2; then
test.d:5:8: run time error - undefined `f' value access
OUTPUT192
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 193.
if test $result = ok -a $start_test_number -le 193; then
	echo test 193
        cat >$test_file <<'TEST193'
var f = open ("1000000000000e1000");
TEST193
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT193' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - unexpected number of parameters for `open'
OUTPUT193
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 194.
if test $result = ok -a $start_test_number -le 194; then
	echo test 194
        cat >$test_file <<'TEST194'
var f = open ("1000000000000e1000", "k");
TEST194
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT194' && $CMP $stderr $ftemp2; then
test.d:1:14: system error - invalid argument: `open'
OUTPUT194
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 195.
if test $result = ok -a $start_test_number -le 195; then
	echo test 195
        cat >$test_file <<'TEST195'
var f = open ("1000000000000e1000", nil);
TEST195
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT195' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid parameter type of `open'
OUTPUT195
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 196.
if test $result = ok -a $start_test_number -le 196; then
	echo test 196
        cat >$test_file <<'TEST196'
close ();
TEST196
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT196' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unexpected number of parameters for `close'
OUTPUT196
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 197.
if test $result = ok -a $start_test_number -le 197; then
	echo test 197
        cat >$test_file <<'TEST197'
close (nil);
TEST197
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT197' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `close'
OUTPUT197
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 198.
if test $result = ok -a $start_test_number -le 198; then
	echo test 198
        cat >$test_file <<'TEST198'
flush ();
TEST198
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT198' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unexpected number of parameters for `flush'
OUTPUT198
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 199.
if test $result = ok -a $start_test_number -le 199; then
	echo test 199
        cat >$test_file <<'TEST199'
flush (nil);
TEST199
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT199' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `flush'
OUTPUT199
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 200.
if test $result = ok -a $start_test_number -le 200; then
	echo test 200
        cat >$test_file <<'TEST200'
put ("aaaaaa");
fputln (stderr, "end of output");
flush (stdout);
fputln (stderr, "end of output");
TEST200
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT200' && $CMP $stdout $ftemp2; then
end of output
aaaaaaend of output
OUTPUT200
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT200-2' && $CMP $stdout $ftemp2; then
aaaaaaend of output
end of output
OUTPUT200-2
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 201.
if test $result = ok -a $start_test_number -le 201; then
	echo test 201
        cat >$test_file <<'TEST201'
var f = popen ("1000000000000e1000");
TEST201
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT201' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - unexpected number of parameters for `popen'
OUTPUT201
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 202.
if test $result = ok -a $start_test_number -le 202; then
	echo test 202
        cat >$test_file <<'TEST202'
var f=popen("cat test.d", "r"), l;
for (;;)
{
  try {l = fgetln (f);} catch (eof) {break;}
  putln (l);
}
pclose (f);
TEST202
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT202' && $CMP $stdout $ftemp2; then
var f=popen("cat test.d", "r"), l;
for (;;)
{
  try {l = fgetln (f);} catch (eof) {break;}
  putln (l);
}
pclose (f);
OUTPUT202
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 203.
if test $result = ok -a $start_test_number -le 203; then
	echo test 203
        cat >$test_file <<'TEST203'
var f=popen("cat >_temp.out", "w"), l;
fputln (f, "tests ");
fputln (f, "tests #1");
pclose (f);
TEST203
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT203' && $CMP $ftemp $ftemp2; then
tests 
tests #1
OUTPUT203
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 204.
if test $result = ok -a $start_test_number -le 204; then
	echo test 204
        cat >$test_file <<'TEST204'
var f = popen ("cat test.d", "rw");
TEST204
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT204' && $CMP $stderr $ftemp2; then
test.d:1:15: system error - invalid argument: `popen'
OUTPUT204
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 205.
if test $result = ok -a $start_test_number -le 205; then
	echo test 205
        cat >$test_file <<'TEST205'
var f = popen ("1000000000000e1000", nil);
TEST205
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT205' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid parameter type of `popen'
OUTPUT205
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 206.
if test $result = ok -a $start_test_number -le 206; then
	echo test 206
        cat >$test_file <<'TEST206'
pclose ();
TEST206
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT206' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unexpected number of parameters for `pclose'
OUTPUT206
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 207.
if test $result = ok -a $start_test_number -le 207; then
	echo test 207
        cat >$test_file <<'TEST207'
pclose (nil);
TEST207
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT207' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `pclose'
OUTPUT207
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 208.
if test $result = ok -a $start_test_number -le 208; then
	echo test 208
        cat >$test_file <<'TEST208'
println (eltype ([1,2,3]));
println (eltype ([1.0,2,'c']));
println (eltype ([]));
TEST208
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT208' && $CMP $stdout $ftemp2; then
int
nil
type (nil)
OUTPUT208
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 209.
if test $result = ok -a $start_test_number -le 209; then
	echo test 209
        cat >$test_file <<'TEST209'
eltype ();
TEST209
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT209' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unexpected number of parameters for `eltype'
OUTPUT209
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 210.
if test $result = ok -a $start_test_number -le 210; then
	echo test 210
        cat >$test_file <<'TEST210'
eltype (1);
TEST210
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT210' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `eltype'
OUTPUT210
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 211.
if false; then
# Removed deprecated operations.
	echo test 211
        cat >$test_file <<'TEST211'
class c {
var i = 10;
}
var i=c();
putln (("i")->i);
("i")->i = 20;
putln (("i")->i);
("i")->i = 30;
putln (("i")->i);
("i")->i = 40;
putln (("i")->i);
("i")->i = 50;
putln (("i")->i);
TEST211
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT211' && $CMP $stdout $ftemp2; then
10
20
30
40
50
OUTPUT211
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 212.
if false; then
# Removed deprecated operations.
	echo test 212
        cat >$test_file <<'TEST212'
class c {
var i = 10;
}
var i=c();
putln ((10)->i);
TEST212
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT212' && $CMP $stderr $ftemp2; then
test.d:5:13: left operand of arrow must be of string type
OUTPUT212
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 213.
if false; then
# Removed deprecated operations.
	echo test 213
        cat >$test_file <<'TEST213'
class c {
var i = 10;
}
var i=c();
var j=[];
putln ((j)->i);
TEST213
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT213' && $CMP $stderr $ftemp2; then
test.d:6:12: run time error - decl name is not string (operation "->" or "*")
OUTPUT213
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 214.
if false; then
# Removed deprecated operations.
	echo test 214
        cat >$test_file <<'TEST214'
class c {
var i = 10;
}
var i=c();
var j=10;
putln (("i")->k);
TEST214
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT214' && $CMP $stderr $ftemp2; then
test.d:6:14: there is no such declaration in a block
OUTPUT214
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 215.
if false; then
# Removed deprecated operations.
	echo test 215
        cat >$test_file <<'TEST215'
class c {
var i = 10;
}
var i=c();
var j=10;
putln (("i")->j);
TEST215
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT215' && $CMP $stderr $ftemp2; then
test.d:6:14: run time error - there is no such declaration in given class
OUTPUT215
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 216.
if test $result = ok -a $start_test_number -le 216; then
	echo test 216
        cat >$test_file <<'TEST216'
var f=open ("_temp2.out", "w");
close(f);
putln (ftype ("_temp2.out"));
remove ("_temp2.out");
TEST216
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT216' && $CMP $stdout $ftemp2; then
f
OUTPUT216
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 217.
if test $result = ok -a $start_test_number -le 217; then
	echo test 217
        cat >$test_file <<'TEST217'
remove ();
TEST217
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT217' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unexpected number of parameters for `remove'
OUTPUT217
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 218.
if test $result = ok -a $start_test_number -le 218; then
	echo test 218
        cat >$test_file <<'TEST218'
remove (nil);
TEST218
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT218' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `remove'
OUTPUT218
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 219.
if test $result = ok -a $start_test_number -le 219; then
	echo test 219
        cat >$test_file <<'TEST219'
var f=open ("_temp.out", "w");
close(f);
putln (ftype ("_temp.out"));
rename ("_temp.out", "_temp2.out");
putln (ftype ("_temp2.out"));
remove ("_temp2.out");
TEST219
	rm -f $ftemp2
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT219' && $CMP $stdout $ftemp2; then
f
f
OUTPUT219
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 220.
if test $result = ok -a $start_test_number -le 220; then
	echo test 220
        cat >$test_file <<'TEST220'
rename (nil);
TEST220
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT220' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unexpected number of parameters for `rename'
OUTPUT220
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 221.
if test $result = ok -a $start_test_number -le 221; then
	echo test 221
        cat >$test_file <<'TEST221'
rename ("aaa", nil);
TEST221
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT221' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `rename'
OUTPUT221
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 222.
if test $result = ok -a $start_test_number -le 222; then
	echo test 222
        cat >$test_file <<TEST222
mkdir ("__tempdir");
putln (ftype ("__tempdir"));
TEST222
        rm -rf $tempdir
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT222' && $CMP $stdout $ftemp2; then
d
OUTPUT222
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 223.
if test $result = ok -a $start_test_number -le 223; then
	echo test 223
        cat >$test_file <<'TEST223'
mkdir ();
TEST223
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT223' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unexpected number of parameters for `mkdir'
OUTPUT223
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 224.
if test $result = ok -a $start_test_number -le 224; then
	echo test 224
        cat >$test_file <<'TEST224'
mkdir (nil);
TEST224
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT224' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `mkdir'
OUTPUT224
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 225.
if test $result = ok -a $start_test_number -le 225; then
	echo test 225
        cat >$test_file <<TEST225
mkdir ("__tempdir");
putln (ftype ("__tempdir"));
rmdir ("__tempdir");
TEST225
        rm -rf $tempdir
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT225' && $CMP $stdout $ftemp2 && test ! -d $tempdir; then
d
OUTPUT225
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 226.
if test $result = ok -a $start_test_number -le 226; then
	echo test 226
        cat >$test_file <<'TEST226'
rmdir ();
TEST226
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT226' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unexpected number of parameters for `rmdir'
OUTPUT226
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 227.
if test $result = ok -a $start_test_number -le 227; then
	echo test 227
        cat >$test_file <<'TEST227'
rmdir (nil);
TEST227
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT227' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `rmdir'
OUTPUT227
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 228.
if test $result = ok -a $start_test_number -le 228; then
	echo test 228
        cat >$test_file <<TEST228
putln (getcwd ());
TEST228
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/^[A-Za-z]://' $stdout|sed 's,\\,/,g' >$ftemp
                echo '      ' egrep "$ftemp2" $ftemp
                if uname | fgrep CYGWIN && test x$msvc != x;then
                   echo `pwd`| sed 's%/cygdrive/[a-z]%%' >$ftemp2
                else
                   echo `pwd` >$ftemp2
                fi
                echo '      ' $CMP $ftemp2 $ftemp
                if $CMP $ftemp $ftemp2; then
                        result=ok
                else
                        result=ok
			echo difference in the expected and result:
                        diff -c $ftemp2 $ftemp
                fi
        else
                result=fail
        fi
fi

# Test 229.
if test $result = ok -a $start_test_number -le 229; then
	echo test 229
        cat >$test_file <<'TEST229'
getcwd (1);
TEST229
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT229' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unexpected number of parameters for `getcwd'
OUTPUT229
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 230.
if test $result = ok -a $start_test_number -le 230; then
	echo test 230
        cat >$test_file <<TEST230
chdir ("__tempdir");
putln (getcwd ());
TEST230
        rm -rf $tempdir
        mkdir $tempdir
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/^[A-Za-z]://' $stdout|sed 's,\\,/,g' >$ftemp
                if uname | fgrep CYGWIN && test x$msvc != x;then
                   echo `pwd`/$tempdir| sed 's%/cygdrive/[a-z]%%' >$ftemp2
                else
                   echo `pwd`/$tempdir >$ftemp2
                fi
                echo '      ' $CMP $ftemp $ftemp2
                if  $CMP $ftemp $ftemp2; then
                        result=ok
                else
                        result=ok
			echo difference in the expected and result:
                        diff -c $ftemp2 $ftemp
                fi
        else
                result=fail
        fi
fi

# Test 231.
if test $result = ok -a $start_test_number -le 231; then
	echo test 231
        cat >$test_file <<'TEST231'
chdir ();
TEST231
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT231' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unexpected number of parameters for `chdir'
OUTPUT231
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 232.
if test $result = ok -a $start_test_number -le 232; then
	echo test 232
        cat >$test_file <<'TEST232'
chdir (nil);
TEST232
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT232' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `chdir'
OUTPUT232
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 233.
if test $result = ok -a $start_test_number -le 233; then
	echo test 233
        cat >$test_file <<'TEST233'
chdir ("abracadabra");
TEST233
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT233' && $CMP $stderr $ftemp2; then
test.d:1:7: system error - no such file or directory: `chdir'
OUTPUT233
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 234.
if test $result = ok -a $start_test_number -le 234; then
	echo test 234
        cat >$test_file <<'TEST234'
rmdir ("abracadabra");
TEST234
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT234' && $CMP $stderr $ftemp2; then
test.d:1:7: system error - no such file or directory: `rmdir'
OUTPUT234
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 235.
if test $result = ok -a $start_test_number -le 235; then
	echo test 235
        cat >$test_file <<'TEST235'
mkdir ("abracadabra/abaraca");
TEST235
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT235' && $CMP $stderr $ftemp2; then
test.d:1:7: system error - no such file or directory: `mkdir'
OUTPUT235
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 236.
if test $result = ok -a $start_test_number -le 236; then
	echo test 236
        cat >$test_file <<TEST236
putln (isatty (open ("test.d", "r")));
TEST236
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT236' && $CMP $stdout $ftemp2; then
0
OUTPUT236
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 237.
if test $result = ok -a $start_test_number -le 237; then
	echo test 237
        cat >$test_file <<'TEST237'
isatty ();
TEST237
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT237' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unexpected number of parameters for `isatty'
OUTPUT237
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 238.
if test $result = ok -a $start_test_number -le 238; then
	echo test 238
        cat >$test_file <<'TEST238'
isatty (nil);
TEST238
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT238' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `isatty'
OUTPUT238
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 239.
if test $result = ok -a $start_test_number -le 239; then
	echo test 239
        cat >$test_file <<TEST239
chumod ("test.d", "rwx");
putln (fumode ("test.d"));
TEST239
        if uname | fgrep CYGWIN; then
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT239' && $CMP $stdout $ftemp2; then
rwx
OUTPUT239
                        result=ok
                elif  cat >$ftemp2 <<'OUTPUT239-1' && $CMP $stdout $ftemp2; then
rw
OUTPUT239-1
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT239-2' && $CMP $stdout $ftemp2; then
rwx
OUTPUT239-2
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	fi
fi

# Test 240.
if test $result = ok -a $start_test_number -le 240; then
	echo test 240
        cat >$test_file <<'TEST240'
chumod (nil);
TEST240
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT240' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unexpected number of parameters for `chumod'
OUTPUT240
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 241.
if test $result = ok -a $start_test_number -le 241; then
	echo test 241
        cat >$test_file <<'TEST241'
chumod (nil, "aaa");
TEST241
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT241' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `chumod'
OUTPUT241
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 242.
if test $result = ok -a $start_test_number -le 242; then
	echo test 242
        cat >$test_file <<'TEST242'
chumod ("abracadabra", "r");
TEST242
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT242' && $CMP $stderr $ftemp2; then
test.d:1:8: system error - no such file or directory: `chumod'
OUTPUT242
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 243.
if test $result = ok -a $start_test_number -le 243; then
	echo test 243
        cat >$test_file <<TEST243
chgmod ("test.d", "rwx");
putln (fgmode ("test.d"));
TEST243
        if uname | fgrep CYGWIN; then
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT243' && $CMP $stdout $ftemp2; then

OUTPUT243
                        result=ok
		elif cat >$ftemp2 <<'OUTPUT243-1' && $CMP $stdout $ftemp2; then
r
OUTPUT243-1
                        result=ok
		elif cat >$ftemp2 <<'OUTPUT243-11' && $CMP $stdout $ftemp2; then
rw
OUTPUT243-11
                        result=ok
		elif cat >$ftemp2 <<'OUTPUT243-12' && $CMP $stdout $ftemp2; then
rwx
OUTPUT243-12
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT243-2' && $CMP $stdout $ftemp2; then
rwx
OUTPUT243-2
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	fi
fi

# Test 244.
if test $result = ok -a $start_test_number -le 244; then
	echo test 244
        cat >$test_file <<'TEST244'
chgmod (nil);
TEST244
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT244' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unexpected number of parameters for `chgmod'
OUTPUT244
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 241.
if test $result = ok -a $start_test_number -le 245; then
	echo test 245
        cat >$test_file <<'TEST245'
chgmod (nil, "aaa");
TEST245
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT245' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `chgmod'
OUTPUT245
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 246.
if test $result = ok -a $start_test_number -le 246; then
	echo test 246
        cat >$test_file <<'TEST246'
chgmod ("abracadabra", "r");
TEST246
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT246' && $CMP $stderr $ftemp2; then
test.d:1:8: system error - no such file or directory: `chgmod'
OUTPUT246
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 247.
if test $result = ok -a $start_test_number -le 247; then
	echo test 247
        cat >$test_file <<TEST247
chomod ("test.d", "rwx");
putln (fomode ("test.d"));
TEST247
        if uname | fgrep CYGWIN; then
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT247' && $CMP $stdout $ftemp2; then

OUTPUT247
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT247-1' && $CMP $stdout $ftemp2; then
r
OUTPUT247-1
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT247-11' && $CMP $stdout $ftemp2; then
rw
OUTPUT247-11
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT247-12' && $CMP $stdout $ftemp2; then
rwx
OUTPUT247-12
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT247-2' && $CMP $stdout $ftemp2; then
rwx
OUTPUT247-2
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	fi
fi

# Test 248.
if test $result = ok -a $start_test_number -le 248; then
	echo test 248
        cat >$test_file <<'TEST248'
chomod (nil);
TEST248
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT248' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unexpected number of parameters for `chomod'
OUTPUT248
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 241.
if test $result = ok -a $start_test_number -le 249; then
	echo test 249
        cat >$test_file <<'TEST249'
chomod (nil, "aaa");
TEST249
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT249' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `chomod'
OUTPUT249
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 250.
if test $result = ok -a $start_test_number -le 250; then
	echo test 250
        cat >$test_file <<'TEST250'
chomod ("abracadabra", "r");
TEST250
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT250' && $CMP $stderr $ftemp2; then
test.d:1:8: system error - no such file or directory: `chomod'
OUTPUT250
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 251.
if false; then
# Removed deprecated operations.
	echo test 251
        cat >$test_file <<'TEST251'
fun f ()
{
  putln ("call f");
}
class c ()
{
  putln ("call c");
}
var i = 10;
putln (*("i"));
*("i") = 20;
putln (*("i"));
*("i") = 30;
putln (*("i"));
*("i") = 40;
putln (*("i"));
*("i") = 50;
putln (*("i"));
*("f") ();
*("c") ();
TEST251
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT251' && $CMP $stdout $ftemp2; then
10
20
30
40
50
call f
call c
OUTPUT251
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 252.
if false; then
# Removed deprecated operations.
	echo test 252
        cat >$test_file <<'TEST252'
var i=10;
putln (*(10));
TEST252
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT252' && $CMP $stderr $ftemp2; then
test.d:2:8: operand of unary `*' must be of string type
OUTPUT252
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 253.
if false; then
# Removed deprecated operations.
	echo test 253
        cat >$test_file <<'TEST253'
var i=10;
var j={};
putln (*(j));
TEST253
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT253' && $CMP $stderr $ftemp2; then
test.d:3:8: run time error - decl name is not string (operation "->" or "*")
OUTPUT253
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 254.
if false; then
# Removed deprecated operations.
	echo test 254
        cat >$test_file <<'TEST254'
fun f {}
*("f") = 10;
TEST254
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT254' && $CMP $stderr $ftemp2; then
test.d:2:1: run time error - usage function as variable
OUTPUT254
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 255.
if false; then
# Removed deprecated operations.
	echo test 255
        cat >$test_file <<'TEST255'
class c {}
*("c") = 10;
TEST255
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT255' && $CMP $stderr $ftemp2; then
test.d:2:1: run time error - usage class as variable
OUTPUT255
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 256.
if false; then
# Removed deprecated operations.
	echo test 256
        cat >$test_file <<'TEST256'
class c()
{
    fun f {}
}
var i = c();
("i")->f = 10;
TEST256
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT256' && $CMP $stderr $ftemp2; then
test.d:6:7: run time error - usage function as variable
OUTPUT256
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 257.
if false; then
# Removed deprecated operations.
	echo test 257
        cat >$test_file <<'TEST257'
class c()
{
    class c {}
}
var i = c();
("i")->c = 10;
TEST257
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT257' && $CMP $stderr $ftemp2; then
test.d:6:7: run time error - usage class as variable
OUTPUT257
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 258.
if test $result = ok -a $start_test_number -le 258; then
	echo test 258: mpi package
        cat >$test_file <<'TEST258'
include "mpi";

var mpi1 = mpis.from_string(1, "10");
var mpi2 = mpis.from_string(1, "5");
putln (mpis.to_string (mpis.add (mpi1, mpi2)));
putln (mpis.to_string (mpis.subtract (mpi1, mpi2)));
putln (mpis.to_string (mpis.subtract (mpi2, mpi1)));
putln (mpis.to_string (mpis.multiply (mpi1, mpi2)));
putln (mpis.to_string (mpis.divide (mpi1, mpi2)));
putln (mpis.to_string (mpis.remainder (mpi1, mpi2)));
putln (mpis.eq (mpi1, mpi2));
putln (mpis.ne (mpi1, mpi2));
putln (mpis.lt (mpi1, mpi2));
putln (mpis.le (mpi1, mpi2));
putln (mpis.gt (mpi1, mpi2));
putln (mpis.ge (mpi1, mpi2));

try {
  mpis.multiply (mpis.multiply (mpi1, mpi2), mpis.multiply (mpi1, mpi2));
} catch (mpi_overflow_except) {
  putln ("got overflow 1");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.to_string (mpis.multiply (mpis.multiply (mpi1, mpi2), mpis.multiply (mpi1, mpi2))));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
mpi2 = mpis.from_string(2, "300");
try {
  mpis.change_size (mpi2, 1);
} catch (mpi_overflow_except) {
  putln ("got overflow 2");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.to_string (mpis.change_size (mpi2, 1)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;

mpi1 = mpis.unsigned_from_string(1, "10");
mpi2 = mpis.unsigned_from_string(1, "5");
putln (mpis.unsigned_to_string (mpis.unsigned_add (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi1, mpi2)));
try {
  putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi2, mpi1)));
} catch (mpi_overflow_except) {
  putln ("got overflow 3");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi2, mpi1)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
putln (mpis.unsigned_to_string (mpis.unsigned_multiply (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_divide (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_remainder (mpi1, mpi2)));
putln (mpis.unsigned_eq (mpi1, mpi2));
putln (mpis.unsigned_ne (mpi1, mpi2));
putln (mpis.unsigned_lt (mpi1, mpi2));
putln (mpis.unsigned_le (mpi1, mpi2));
putln (mpis.unsigned_gt (mpi1, mpi2));
putln (mpis.unsigned_ge (mpi1, mpi2));

try {
  mpis.unsigned_multiply (mpis.unsigned_multiply (mpi1, mpi2), mpis.unsigned_multiply (mpi1, mpi2));
} catch (mpi_overflow_except) {
  putln ("got overflow 4");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_multiply (mpis.unsigned_multiply (mpi1, mpi2), mpis.unsigned_multiply (mpi1, mpi2))));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
mpi2 = mpis.unsigned_from_string(2, "300");
try {
  mpis.unsigned_change_size (mpi2, 1);
} catch (mpi_overflow_except) {
  putln ("got overflow 5");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_change_size (mpi2, 1)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;

mpi1 = mpis.from_string(50, "10000000000000000000000000000000000000000000000");
mpi2 = mpis.from_string(50, "5000000000000000000000000000000000000000000000");
putln (mpis.to_string (mpis.add (mpi1, mpi2)));
putln (mpis.to_string (mpis.subtract (mpi1, mpi2)));
putln (mpis.to_string (mpis.subtract (mpi2, mpi1)));
putln (mpis.to_string (mpis.multiply (mpi1, mpi2)));
putln (mpis.to_string (mpis.divide (mpi1, mpi2)));
putln (mpis.to_string (mpis.remainder (mpi1, mpi2)));
putln (mpis.eq (mpi1, mpi2));
putln (mpis.ne (mpi1, mpi2));
putln (mpis.lt (mpi1, mpi2));
putln (mpis.le (mpi1, mpi2));
putln (mpis.gt (mpi1, mpi2));
putln (mpis.ge (mpi1, mpi2));
try {
  mpis.multiply (mpis.multiply (mpi1, mpi2), mpis.multiply (mpi1, mpi2));
} catch (mpi_overflow_except) {
  putln ("got overflow 6");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.to_string (mpis.multiply (mpis.multiply (mpi1, mpi2), mpis.multiply (mpi1, mpi2))));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
try {
  mpis.change_size (mpi2, 2);
} catch (mpi_overflow_except) {
  putln ("got overflow 7");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.to_string (mpis.change_size (mpi2, 2)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;

mpi1 = mpis.unsigned_from_string(50, "10000000000000000000000000000000000000000000000");
mpi2 = mpis.unsigned_from_string(50, "5000000000000000000000000000000000000000000000");
putln (mpis.unsigned_to_string (mpis.unsigned_add (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi1, mpi2)));
try {
  putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi2, mpi1)));
} catch (mpi_overflow_except) {
  putln ("got overflow 8");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi2, mpi1)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
putln (mpis.unsigned_to_string (mpis.unsigned_multiply (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_divide (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_remainder (mpi1, mpi2)));
putln (mpis.unsigned_eq (mpi1, mpi2));
putln (mpis.unsigned_ne (mpi1, mpi2));
putln (mpis.unsigned_lt (mpi1, mpi2));
putln (mpis.unsigned_le (mpi1, mpi2));
putln (mpis.unsigned_gt (mpi1, mpi2));
putln (mpis.unsigned_ge (mpi1, mpi2));
try {
  mpis.unsigned_multiply (mpis.unsigned_multiply (mpi1, mpi2), mpis.unsigned_multiply (mpi1, mpi2));
} catch (mpi_overflow_except) {
  putln ("got overflow 9");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_multiply (mpis.unsigned_multiply (mpi1, mpi2), mpis.unsigned_multiply (mpi1, mpi2))));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
try {
  mpis.unsigned_change_size (mpi2, 2);
} catch (mpi_overflow_except) {
  putln ("got overflow 10");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_change_size (mpi2, 2)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
TEST258
        if uname | fgrep CYGWIN; then
            echo '      ' $DINO -L./d_mpi.dll -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -Lmpi.dll -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT258' && $CMP $stdout $ftemp2; then
15
5
-5
50
2
0
0
1
0
0
1
1
got overflow 1
-60
ovfw=1
got overflow 2
44
ovfw=1
15
5
got overflow 3
251
ovfw=1
50
2
0
0
1
0
0
1
1
got overflow 4
196
ovfw=1
got overflow 5
44
ovfw=1
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
-5000000000000000000000000000000000000000000000
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
0
1
0
0
1
1
got overflow 6
867904737743324110893126166364363704770614348168184133037106651590308130409865771824596108187979317115712568128322928640
ovfw=1
got overflow 7
0
ovfw=1
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
got overflow 8
2582249878086908589655919172003011874329705792829223512830659356540647622011841194629645353280137831435903171972747493376
ovfw=1
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
0
1
0
0
1
1
got overflow 9
867904737743324110893126166364363704770614348168184133037106651590308130409865771824596108187979317115712568128322928640
ovfw=1
got overflow 10
0
ovfw=1
OUTPUT258
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
            echo '      ' $DINO -L./d_mpi.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -L./d_mpi.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT258' && $CMP $stdout $ftemp2; then
15
5
-5
50
2
0
0
1
0
0
1
1
got overflow 1
-60
ovfw=1
got overflow 2
44
ovfw=1
15
5
got overflow 3
251
ovfw=1
50
2
0
0
1
0
0
1
1
got overflow 4
196
ovfw=1
got overflow 5
44
ovfw=1
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
-5000000000000000000000000000000000000000000000
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
0
1
0
0
1
1
got overflow 6
867904737743324110893126166364363704770614348168184133037106651590308130409865771824596108187979317115712568128322928640
ovfw=1
got overflow 7
0
ovfw=1
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
got overflow 8
2582249878086908589655919172003011874329705792829223512830659356540647622011841194629645353280137831435903171972747493376
ovfw=1
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
0
1
0
0
1
1
got overflow 9
867904737743324110893126166364363704770614348168184133037106651590308130409865771824596108187979317115712568128322928640
ovfw=1
got overflow 10
0
ovfw=1
OUTPUT258
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
        fi
fi

# Test 259.
if test $result = ok -a $start_test_number -le 259; then
	echo test 259: Redefinitions
        cat >$test_file <<'TEST259'
val i = 10;
fun f { return i;}
val i = 20;
putln (f ());
fun f { return i;}
putln (f ());
TEST259
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT259' && $CMP $stdout $ftemp2; then
10
20
OUTPUT259
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 260.
if test $result = ok -a $start_test_number -le 260; then
	echo test 260: Redefinitions
        cat >$test_file <<'TEST260'
val i = 10;
fun f { return 10;}
val i = 20;
fun f2 { return i + f ();}
putln (f2 ());
TEST260
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT260' && $CMP $stdout $ftemp2; then
30
OUTPUT260
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 261.
if test $result = ok -a $start_test_number -le 261; then
	echo test 261
        cat >$test_file <<'TEST261'
class c {
  priv var i;
  i = 0;
}

var i;
i = c ();
i.i = 1;
TEST261
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT261' && $CMP $stderr $ftemp2; then
test.d:8:2: run time error - access to private decl `i' from outside
OUTPUT261
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 262.
if test $result = ok -a $start_test_number -le 262; then
	echo test 262
        cat >$test_file <<'TEST262'
var ci;
{
  var i;
  class c {
  }
  ci = c ();
  i = 0;
}

context(ci).i = 1;
TEST262
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT262' && $CMP $stderr $ftemp2; then
test.d:10:12: run time error - access to private decl `i' from outside
OUTPUT262
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 263.
if test $result = ok -a $start_test_number -le 263; then
	echo test 263: Forward and matched decl access
        cat >$test_file <<'TEST263'
fun f;
pub fun f () {}
TEST263
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT263' && $CMP $stderr $ftemp2; then
test.d:2:9: forward and matched decls of `f' have different access/final attributes
test.d:1:5: (previous declaration of identifier `f')
OUTPUT263
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 264.
if test $result = ok -a $start_test_number -le 264; then
	echo test 264: Forward and matched decl final
        cat >$test_file <<'TEST264'
final class c;
class c () {}
TEST264
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT264' && $CMP $stderr $ftemp2; then
test.d:2:7: forward and matched decls of `c' have different access/final attributes
test.d:1:13: (previous declaration of identifier `c')
OUTPUT264
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 265.
if test $result = ok -a $start_test_number -le 265; then
	echo test 265
        cat >$test_file <<'TEST265'
fun f;
pub fun f;
fun f() {}
TEST265
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT265' && $CMP $stderr $ftemp2; then
test.d:2:9: forward and matched decls of `f' have different access/final attributes
test.d:1:5: (previous declaration of identifier `f')
OUTPUT265
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 266.
if test $result = ok -a $start_test_number -le 266; then
	echo test 266
        cat >$test_file <<'TEST266'
argv[0] = 1;
TEST266
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT266' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - attempt to modify immutable vector
OUTPUT266
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 267.
if test $result = ok -a $start_test_number -le 267; then
	echo test 267
        cat >$test_file <<'TEST267'
atan2 (10);
TEST267
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT267' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unexpected number of parameters for `atan2'
OUTPUT267
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 268.
if test $result = ok -a $start_test_number -le 268; then
	echo test 268
        cat >$test_file <<'TEST268'
atan2 (tab [], 10);
TEST268
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT268' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `atan2'
OUTPUT268
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 269.
if test $result = ok -a $start_test_number -le 269; then
	echo test 269
        cat >$test_file <<'TEST269'
atan2 (10, 10, 10);
TEST269
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT269' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unexpected number of parameters for `atan2'
OUTPUT269
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 270.
if test $result = ok -a $start_test_number -le 270; then
	echo test 270
        cat >$test_file <<'TEST270'
atan2 ();
TEST270
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT270' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unexpected number of parameters for `atan2'
OUTPUT270
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 271.
if test $result = ok -a $start_test_number -le 271; then
	echo test 271
        cat >$test_file <<'TEST271'
class c () {
  return 10;
}

var i;

i = c ();
TEST271
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT271' && $CMP $stderr $ftemp2; then
test.d:2:3: statement return with result is in class
OUTPUT271
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 272.
if test $result = ok -a $start_test_number -le 272; then
	echo test 272
        cat >$test_file <<'TEST272'
class c {
  {
    return 10;
  }
}

var i;

i = c ();
TEST272
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT272' && $CMP $stderr $ftemp2; then
test.d:3:5: statement return with result is in class
OUTPUT272
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 273.
if test $result = ok -a $start_test_number -le 273; then
	echo test 273
        cat >$test_file <<'TEST273'
cos ();
TEST273
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT273' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - unexpected number of parameters for `cos'
OUTPUT273
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 274.
if test $result = ok -a $start_test_number -le 274; then
	echo test 274
        cat >$test_file <<'TEST274'
cos (tab []);
TEST274
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT274' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `cos'
OUTPUT274
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 275.
if test $result = ok -a $start_test_number -le 275; then
	echo test 275
        cat >$test_file <<'TEST275'
del ();
TEST275
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT275' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - unexpected number of parameters for `del'
OUTPUT275
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 276.
if test $result = ok -a $start_test_number -le 276; then
	echo test 276
        cat >$test_file <<'TEST276'
var v;
v = "123456"; del (v, 1);
TEST276
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT276' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - attempt to modify immutable vector
OUTPUT276
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 277.
if test $result = ok -a $start_test_number -le 277; then
	echo test 277
        cat >$test_file <<'TEST277'
var t;
t = final tab [1, 2, 3, 4, 5, 6]; del (t, 1);
TEST277
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT277' && $CMP $stderr $ftemp2; then
test.d:2:39: run time error - attempt to modify immutable table
OUTPUT277
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 278.
if test $result = ok -a $start_test_number -le 278; then
	echo test 278
        cat >$test_file <<'TEST278'
del (10);
TEST278
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT278' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - unexpected number of parameters for `del'
OUTPUT278
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 279.
if test $result = ok -a $start_test_number -le 279; then
	echo test 279
        cat >$test_file <<'TEST279'
del (10, 10);
TEST279
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT279' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `del'
OUTPUT279
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 280.
if test $result = ok -a $start_test_number -le 280; then
	echo test 280
        cat >$test_file <<'TEST280'
del (10,10,10,10);
TEST280
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT280' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - unexpected number of parameters for `del'
OUTPUT280
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 281.
if test $result = ok -a $start_test_number -le 281; then
	echo test 281
        cat >$test_file <<'TEST281'
var t;
t = tab [10]; del (t, 10, 10);
TEST281
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT281' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - unexpected number of parameters for `del'
OUTPUT281
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 282.
if test $result = ok -a $start_test_number -le 282; then
	echo test 282
        cat >$test_file <<'TEST282'
var v;
v = []; del (v, tab []);
TEST282
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT282' && $CMP $stderr $ftemp2; then
test.d:2:13: run time error - invalid parameter type of `del'
OUTPUT282
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 283.
if test $result = ok -a $start_test_number -le 283; then
	echo test 283
        cat >$test_file <<'TEST283'
var v;
v = []; del (v, 0, tab []);
TEST283
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT283' && $CMP $stderr $ftemp2; then
test.d:2:13: run time error - invalid parameter type of `del'
OUTPUT283
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 284.
if test $result = ok -a $start_test_number -le 284; then
	echo test 284: Repeated idents in use
        cat >$test_file <<'TEST284'
class c {
  val i;
}

class sc {
  val i;
  use c former i later i;
}
TEST284
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT284' && $CMP $stderr $ftemp2; then
test.d:7:7: used decl redefines previous `i' and is not mentioned in former item
test.d:6:7: (previous declaration of identifier `i')
test.d:7:16: repeated occurrence of identifier `i' in use items
test.d:7:24: (previous occurrence of identifier `i')
test.d:7:24: `i' mentioned in later item is not declared after the use-clause
OUTPUT284
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 285.
if test $result = ok -a $start_test_number -le 285; then
	echo test 285
        cat >$test_file <<'TEST285'
env ["PATH"] = "abracadabra";
TEST285
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT285' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - attempt to modify immutable table
OUTPUT285
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 286.
if test $result = ok -a $start_test_number -le 286; then
	echo test 286
        cat >$test_file <<'TEST286'
ins ();
TEST286
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT286' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - unexpected number of parameters for `ins'
OUTPUT286
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 287.
if test $result = ok -a $start_test_number -le 287; then
	echo test 287
        cat >$test_file <<'TEST287'
var v;
v = "123456"; ins (v, 1);
TEST287
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT287' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - attempt to modify immutable vector
OUTPUT287
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 288.
if test $result = ok -a $start_test_number -le 288; then
	echo test 288
        cat >$test_file <<'TEST288'
ins (10);
TEST288
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT288' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - unexpected number of parameters for `ins'
OUTPUT288
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 289.
if test $result = ok -a $start_test_number -le 289; then
	echo test 289
        cat >$test_file <<'TEST289'
ins (10, 10);
TEST289
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT289' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `ins'
OUTPUT289
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 290.
if test $result = ok -a $start_test_number -le 290; then
	echo test 290
        cat >$test_file <<'TEST290'
ins (10,10,10,10);
TEST290
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT290' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - unexpected number of parameters for `ins'
OUTPUT290
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 291.
if test $result = ok -a $start_test_number -le 291; then
	echo test 291
        cat >$test_file <<'TEST291'
var v;
v = []; ins (v, 1, tab []);
TEST291
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT291' && $CMP $stderr $ftemp2; then
test.d:2:13: run time error - invalid parameter type of `ins'
OUTPUT291
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 292.
if test $result = ok -a $start_test_number -le 292; then
	echo test 292
        cat >$test_file <<'TEST292'
insv ();
TEST292
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT292' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - unexpected number of parameters for `insv'
OUTPUT292
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 293.
if test $result = ok -a $start_test_number -le 293; then
	echo test 293
        cat >$test_file <<'TEST293'
var v;
v = "123456"; insv (v, [1]);
TEST293
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT293' && $CMP $stderr $ftemp2; then
test.d:2:20: run time error - attempt to modify immutable vector
OUTPUT293
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 294.
if test $result = ok -a $start_test_number -le 294; then
	echo test 294
        cat >$test_file <<'TEST294'
insv (10);
TEST294
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT294' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - unexpected number of parameters for `insv'
OUTPUT294
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 295.
if test $result = ok -a $start_test_number -le 295; then
	echo test 295
        cat >$test_file <<'TEST295'
insv (10, 10);
TEST295
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT295' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `insv'
OUTPUT295
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 296.
if test $result = ok -a $start_test_number -le 296; then
	echo test 296
        cat >$test_file <<'TEST296'
insv (10,10,10,10);
TEST296
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT296' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - unexpected number of parameters for `insv'
OUTPUT296
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 297.
if test $result = ok -a $start_test_number -le 297; then
	echo test 297
        cat >$test_file <<'TEST297'
var v;
v = []; insv (v, [1], tab []);
TEST297
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT297' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - invalid parameter type of `insv'
OUTPUT297
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 298.
if test $result = ok -a $start_test_number -le 298; then
	echo test 298
        cat >$test_file <<'TEST298'
var v;
v = []; insv (v, 1);
TEST298
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT298' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - invalid parameter type of `insv'
OUTPUT298
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 299.
if test $result = ok -a $start_test_number -le 299; then
	echo test 299
        cat >$test_file <<'TEST299'
class c {
  val i;
}

class sc {
  use c former i;
}
TEST299
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT299' && $CMP $stderr $ftemp2; then
test.d:6:16: `i' mentioned in former item is not declared before the use-clause
OUTPUT299
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 300.
if test $result = ok -a $start_test_number -le 300; then
	echo test 300
        cat >$test_file <<'TEST300'
fput ();
TEST300
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT300' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - unexpected number of parameters for `fput'
OUTPUT300
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 301.
if test $result = ok -a $start_test_number -le 301; then
	echo test 301
        cat >$test_file <<'TEST301'
fput ("AAAA");
TEST301
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT301' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `fput'
OUTPUT301
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 302.
if test $result = ok -a $start_test_number -le 302; then
	echo test 302: More one used
        cat >$test_file <<'TEST302'
class c {
  fun me {putln ("c1");}
  fun me {putln ("c2");}
  fun pr {me ();}
};

class sc {
   fun me {putln ("sc");}
   use c former me;
};

var co = c (), sco = sc ();
co.pr ();
sco.pr ();
TEST302
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT302' && $CMP $stdout $ftemp2; then
c2
sc
OUTPUT302
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 303.
if test $result = ok -a $start_test_number -le 303; then
	echo test 303: More one use with later
        cat >$test_file <<'TEST303'
class c {
  fun me {putln ("c1");}
  fun me {putln ("c2");}
  fun pr {me ();}
};

class sc {
   use c later me;
   fun me {putln ("sc");}
};

var co = c (), sco = sc ();
co.pr ();
sco.pr ();
TEST303
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT303' && $CMP $stdout $ftemp2; then
c2
sc
OUTPUT303
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 304.
if test $result = ok -a $start_test_number -le 304; then
	echo test 304: Forward declaration for recursion
        cat >$test_file <<'TEST304'
fun even;
fun odd (i) { if (i == 0) return 0; return even (i - 1);}
fun even (i) { if (i == 0) return 1; return odd (i - 1);}
putln (odd (10));
TEST304
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT304' && $CMP $stdout $ftemp2; then
0
OUTPUT304
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 305.
if test $result = ok -a $start_test_number -le 305; then
	echo test 305
        cat >$test_file <<'TEST305'
inside ("");
TEST305
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT305' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unexpected number of parameters for `inside'
OUTPUT305
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 306.
if test $result = ok -a $start_test_number -le 306; then
	echo test 306
        cat >$test_file <<'TEST306'
class c {}
inside ("", c);
TEST306
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT306' && $CMP $stderr $ftemp2; then
test.d:2:8: run time error - invalid parameter type of `inside'
OUTPUT306
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 307.
if test $result = ok -a $start_test_number -le 307; then
	echo test 307
        cat >$test_file <<'TEST307'
class c {}
inside (c,"");
TEST307
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT307' && $CMP $stderr $ftemp2; then
test.d:2:8: run time error - invalid parameter type of `inside'
OUTPUT307
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 308.
if test $result = ok -a $start_test_number -le 308; then
	echo test 308
        cat >$test_file <<'TEST308'
match ("");
TEST308
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT308' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unexpected number of parameters for `match'
OUTPUT308
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 309.
if test $result = ok -a $start_test_number -le 309; then
	echo test 309
        cat >$test_file <<'TEST309'
match (nil, 10);
TEST309
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT309' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `match'
OUTPUT309
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 310.
if test $result = ok -a $start_test_number -le 310; then
	echo test 310
        cat >$test_file <<'TEST310'
match ("", nil);
TEST310
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT310' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `match'
OUTPUT310
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 311.
if test $result = ok -a $start_test_number -le 311; then
	echo test 311
        cat >$test_file <<'TEST311'
var s;
s = "aaaa";
s[1] = "b";
TEST311
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT311' && $CMP $stderr $ftemp2; then
test.d:3:2: run time error - attempt to modify immutable vector
OUTPUT311
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 312.
if test $result = ok -a $start_test_number -le 312; then
	echo test 312
        cat >$test_file <<'TEST312'
var s;
s = final tab["a"];
s["a"] = "b";
TEST312
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT312' && $CMP $stderr $ftemp2; then
test.d:3:2: run time error - attempt to modify immutable table
OUTPUT312
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 313.
if test $result = ok -a $start_test_number -le 313; then
	echo test 313
        cat >$test_file <<'TEST313'
var s, t;
s = ['a'];
t = tab [s:"a"];
s[0] = 'b';
TEST313
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT313' && $CMP $stderr $ftemp2; then
test.d:4:2: run time error - attempt to modify immutable vector
OUTPUT313
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 314.
if test $result = ok -a $start_test_number -le 314; then
	echo test 314
        cat >$test_file <<'TEST314'
class c()
{
  var i;
}
var o;
o = final c ();
o.i = 10;
TEST314
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT314' && $CMP $stderr $ftemp2; then
test.d:7:2: run time error - attempt to modify immutable instance
OUTPUT314
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 315.
if test $result = ok -a $start_test_number -le 315; then
	echo test 315
        cat >$test_file <<'TEST315'
var i;
i = nil;
i++;
TEST315
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT315' && $CMP $stderr $ftemp2; then
test.d:3:2: run time error - invalid types of operands of operator "+"
OUTPUT315
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 316.
if test $result = ok -a $start_test_number -le 316; then
	echo test 316
        cat >$test_file <<'TEST316'
rand (10);
TEST316
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT316' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - unexpected number of parameters for `rand'
OUTPUT316
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 317.
if test $result = ok -a $start_test_number -le 317; then
	echo test 317
        cat >$test_file <<'TEST317'
rand (10, 10);
TEST317
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT317' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - unexpected number of parameters for `rand'
OUTPUT317
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 318.
if test $result = ok -a $start_test_number -le 318; then
	echo test 318
        cat >$test_file <<'TEST318'
readdir ();
TEST318
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT318' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - unexpected number of parameters for `readdir'
OUTPUT318
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 319.
if test $result = ok -a $start_test_number -le 319; then
	echo test 319
        cat >$test_file <<'TEST319'
readdir ("1", "");
TEST319
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT319' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - unexpected number of parameters for `readdir'
OUTPUT319
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 320.
if test $result = ok -a $start_test_number -le 320; then
	echo test 320
        cat >$test_file <<'TEST320'
readdir (nil);
TEST320
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT320' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `readdir'
OUTPUT320
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 321.
if test $result = ok -a $start_test_number -le 321; then
	echo test 321
        cat >$test_file <<'TEST321'
fun f {putln ("aa";return 1;}
fun g {putln ("aa";return 1;}
TEST321
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT321' && $CMP $stderr $ftemp2; then
test.d:1:19: syntax error
test.d:2:19: syntax error
OUTPUT321
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 322.
if test $result = ok -a $start_test_number -le 322; then
	echo test 322
        cat >$test_file <<'TEST322'
fun f {}
f = 1;
TEST322
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT322' && $CMP $stderr $ftemp2; then
test.d:2:1: non variable in assignment statement
OUTPUT322
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 323.
if test $result = ok -a $start_test_number -le 323; then
	echo test 323
        cat >$test_file <<'TEST323'
fun f {}
var t;
t = tab [];
for (f in t);
TEST323
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT323' && $CMP $stderr $ftemp2; then
test.d:4:6: non variable in foreach-stmt index designator
OUTPUT323
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 324.
if test $result = ok -a $start_test_number -le 324; then
	echo test 324
        cat >$test_file <<'TEST324'
class c {
  fun f {}
}
var o;
o = c();
o.f = 1;
TEST324
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT324' && $CMP $stderr $ftemp2; then
test.d:6:2: run time error - usage function as variable
OUTPUT324
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 325.
if test $result = ok -a $start_test_number -le 325; then
	echo test 325
        cat >$test_file <<'TEST325'
class c {
  fun f {}
}
var o, t;
o = c();
t = tab [];
for (o.f in t);
TEST325
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT325' && $CMP $stderr $ftemp2; then
test.d:7:7: run time error - usage function as variable
OUTPUT325
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 326.
if test $result = ok -a $start_test_number -le 326; then
	echo test 326
        cat >$test_file <<'TEST326'
class c {
  class f {}
}
var o;
o = c();
o.f = 1;
TEST326
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT326' && $CMP $stderr $ftemp2; then
test.d:6:2: run time error - usage class as variable
OUTPUT326
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 327.
if test $result = ok -a $start_test_number -le 327; then
	echo test 327
        cat >$test_file <<'TEST327'
class c {
  class f {}
}
var o, t;
o = c();
t = tab [];
for (o.f in t);
TEST327
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT327' && $CMP $stderr $ftemp2; then
test.d:7:7: run time error - usage class as variable
OUTPUT327
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 328.
if test $result = ok -a $start_test_number -le 328; then
	echo test 328
        cat >$test_file <<'TEST328'
sin ();
TEST328
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT328' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - unexpected number of parameters for `sin'
OUTPUT328
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 329.
if test $result = ok -a $start_test_number -le 329; then
	echo test 329
        cat >$test_file <<'TEST329'
sin (tab []);
TEST329
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT329' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `sin'
OUTPUT329
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 330.
if test $result = ok -a $start_test_number -le 330; then
	echo test 330
        cat >$test_file <<'TEST330'
split ("a", "A", "A");
TEST330
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT330' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unexpected number of parameters for `split'
OUTPUT330
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 331.
if test $result = ok -a $start_test_number -le 331; then
	echo test 331
        cat >$test_file <<'TEST331'
split ();
TEST331
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT331' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unexpected number of parameters for `split'
OUTPUT331
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 332.
if test $result = ok -a $start_test_number -le 332; then
	echo test 332
        cat >$test_file <<'TEST332'
split ("aaa", nil);
TEST332
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT332' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `split'
OUTPUT332
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 333.
if test $result = ok -a $start_test_number -le 333; then
	echo test 333
        cat >$test_file <<'TEST333'
split (nil);
TEST333
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT333' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `split'
OUTPUT333
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 334.
if test $result = ok -a $start_test_number -le 334; then
	echo test 334
        cat >$test_file <<'TEST334'
srand (10, 10);
TEST334
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT334' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unexpected number of parameters for `srand'
OUTPUT334
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 335.
if test $result = ok -a $start_test_number -le 335; then
	echo test 335
        cat >$test_file <<'TEST335'
srand (tab []);
TEST335
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT335' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `srand'
OUTPUT335
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 336.
if test $result = ok -a $start_test_number -le 336; then
	echo test 336
        cat >$test_file <<'TEST336'
sub ();
TEST336
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT336' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - unexpected number of parameters for `sub'
OUTPUT336
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 337.
if test $result = ok -a $start_test_number -le 337; then
	echo test 337
        cat >$test_file <<'TEST337'
sub ("", "", "", "");
TEST337
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT337' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - unexpected number of parameters for `sub'
OUTPUT337
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 338.
if test $result = ok -a $start_test_number -le 338; then
	echo test 338
        cat >$test_file <<'TEST338'
sub (nil, "", "");
TEST338
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT338' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `sub'
OUTPUT338
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 339.
if test $result = ok -a $start_test_number -le 339; then
	echo test 339
        cat >$test_file <<'TEST339'
sub (nil, "", "");
TEST339
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT339' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `sub'
OUTPUT339
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 340.
if test $result = ok -a $start_test_number -le 340; then
	echo test 340
        cat >$test_file <<'TEST340'
putln (system (10));
TEST340
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT340' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid parameter type of `system'
OUTPUT340
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 341.
if test $result = ok -a $start_test_number -le 341; then
	echo test 341
        cat >$test_file <<'TEST341'
putln (system ());
TEST341
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT341' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - unexpected number of parameters for `system'
OUTPUT341
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 342.
if test $result = ok -a $start_test_number -le 342; then
	echo test 342
        cat >$test_file <<'TEST342'
var t;
t = tab [];
putln (t[10]);
TEST342
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT342' && $CMP $stderr $ftemp2; then
test.d:3:9: run time error - no such key in table
OUTPUT342
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 343.
if test $result = ok -a $start_test_number -le 343; then
	echo test 343
        cat >$test_file <<'TEST343'
var t;
t = 10;
putln (10 in t);
TEST343
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT343' && $CMP $stderr $ftemp2; then
test.d:3:11: run time error - non table right to `in'
OUTPUT343
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 344.
if test $result = ok -a $start_test_number -le 344; then
	echo test 344
        cat >$test_file <<'TEST344'
var t;
t = [];
putln (t[10]);
TEST344
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT344' && $CMP $stderr $ftemp2; then
test.d:3:9: run time error - index is greater than array bound
OUTPUT344
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 345.
if test $result = ok -a $start_test_number -le 345; then
	echo test 345
        cat >$test_file <<'TEST345'
var i,t;
t = [];
for (i in t) putln ("wrong");
TEST345
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT345' && $CMP $stderr $ftemp2; then
test.d:3:1: run time error - non table right to `in'
OUTPUT345
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 346.
if test $result = ok -a $start_test_number -le 346; then
	echo test 346
        cat >$test_file <<'TEST346'
thread f {
  return 10;
}

var t;

t = f ();
TEST346
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT346' && $CMP $stderr $ftemp2; then
test.d:2:3: statement return with result is in thread
OUTPUT346
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 347.
if test $result = ok -a $start_test_number -le 347; then
	echo test 347
        cat >$test_file <<'TEST347'
thread f {
  {
    return 10;
  }
}

var t;

t = f ();
TEST347
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT347' && $CMP $stderr $ftemp2; then
test.d:3:5: statement return with result is in thread
OUTPUT347
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 348.
if test $result = ok -a $start_test_number -le 348; then
	echo test 348
        cat >$test_file <<'TEST348'
wait (0);
TEST348
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT348' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - process deadlock
OUTPUT348
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 349.
if test $result = ok -a $start_test_number -le 349; then
	echo test 349
        cat >$test_file <<'TEST349'
thread t { wait (0);}
var p;
p = t ();
wait (0);
TEST349
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT349' && $CMP $stderr $ftemp2; then
test.d:4:7: run time error - process deadlock
OUTPUT349
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT349-1' && $CMP $stderr $ftemp2; then
test.d:1:18: run time error - process deadlock
OUTPUT349-1
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 350.
if test $result = ok -a $start_test_number -le 350; then
	echo test 350
        cat >$test_file <<'TEST350'
thread t { wait (0);}
var p;
p = t ();
TEST350
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT350' && $CMP $stderr $ftemp2; then
test.d:1:18: run time error - process deadlock
OUTPUT350
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 351.
if test $result = ok -a $start_test_number -le 351; then
	echo test 351
        cat >$test_file <<'TEST351'
fun f() {return 1;}
wait (f());
TEST351
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT351' && $CMP $stderr $ftemp2; then
test.d:2:7: function call is present in wait statement
OUTPUT351
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 352.
if test $result = ok -a $start_test_number -le 352; then
	echo test 352
        cat >$test_file <<'TEST352'
class c(){}
if (tab []) {}
var i;
for (i=0;c;i++) {}
wait (c);
for (i in 10) {}
try {
  throw 1;
}
catch 10 {
}
TEST352
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT352' && $CMP $stderr $ftemp2; then
test.d:2:5: invalid type of operand in logical operation
test.d:4:10: invalid type of operand in logical operation
test.d:5:7: invalid type of wait-expr
test.d:6:11: invalid type of foreach-table
test.d:8:3: invalid type of throw-expr
test.d:10:7: syntax error
OUTPUT352
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 353.
if test $result = ok -a $start_test_number -le 353; then
	echo test 353
        cat >$test_file <<'TEST353'
i := 10;
TEST353
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT353' && $CMP $stderr $ftemp2; then
test.d:1:3: syntax error
OUTPUT353
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 354.
if test $result = ok -a $start_test_number -le 354; then
	echo test 354
        cat >$test_file <<'TEST354'
var i;
for (i:=0; i<1000000; i:=i+1;)
 ;
TEST354
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT354' && $CMP $stderr $ftemp2; then
test.d:2:7: syntax error
test.d:2:23: syntax error
OUTPUT354
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 355.
if test $result = ok -a $start_test_number -le 355; then
	echo test 355
        cat >$test_file <<'TEST355'
var ctime;
ctime = 0.0;

fun waitfor (n, t){
  var cont;
  wait (1) cont = 1;
  putln (n, " waitfor ", t, " ctime ", ctime);
  for (; cont;)
    try {
      wait (ctime == t) cont = 0;
    } catch (deadlock) {
      wait (1) ctime++;
      putln ("tick ", ctime); 
    }
}

thread output {
  waitfor ("output", 2.0);
  putln ("output 1");
  waitfor ("output", 4.0);
  putln ("output 2");
}

thread move {
   waitfor ("move", 1.0);
   putln ("move 1");
   waitfor ("move", 3.0);
   putln ("move 2");
}

move ();
output ();
TEST355
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT355' && $CMP $stdout $ftemp2; then
move waitfor 1 ctime 0
output waitfor 2 ctime 0
tick 1
move 1
move waitfor 3 ctime 1
tick 2
output 1
output waitfor 4 ctime 2
tick 3
move 2
tick 4
output 2
OUTPUT355
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 356.
if test $result = ok -a $start_test_number -le 356; then
	echo test 356
        cat >$test_file <<'TEST356'
var ctime;
ctime = 0.0;
var X,Y,Z;
X = [1.0,0.0,0.0];
Y = [0.0,1.0,0.0];
Z = [0.0,0.0,1.0];
fun fulfill (){ putln ("FULFILL");}
fun publish (){ putln ("PUBLISH");}
fun rotate (what, axis, angle){
  putln ("ROTATE ", what, " ",
         axis [0], " ", axis [1], " ", axis [2], " ", angle);
}

fun waitfor (n, t){
  var cont;
  wait (1) cont = 1;
  putln ("waitfor ", n, " ", t, " ctime ", ctime);
  for (; cont;)
    try {
      wait (ctime == t) cont = 0;
    } catch (deadlock) {
      wait (1) ctime++;
      putln ("tick ", ctime); 
    }
}

class back_leg(side){
  var angle;
  angle = 1.0;

  fun step {
    var start;
    putln ("step ", ctime);
    start = ctime;
    rotate (side @ "_back_hoof", Z, -angle);
    waitfor (side, start+1);
    rotate (side @ "_back_hoof", Z, -angle);
    waitfor (side, start+2);
    rotate (side @ "_back_hoof", Z, angle);
    waitfor (side, start+3);
    rotate (side @ "_back_hoof", Z, angle);
  }

  thread move (start_ctime, steps_number) {
    waitfor (side, start_ctime);
    var i;
    for (i=0; i<steps_number; i = i+1)
	step ();
  }
}     

thread output(interval) {
  var i, cont;
  for (i=0; i<interval; i=i+1) {
    waitfor ("output", i + 0.0);
    fulfill ();
    publish ();
  }
}

var left_back_leg, right_back_leg;

left_back_leg = back_leg("left");
right_back_leg = back_leg("right");

left_back_leg.move (ctime, 10.0);
right_back_leg.move (ctime+1.0, 10.0);
output (32);
TEST356
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT356' && $CMP $stdout $ftemp2; then
waitfor left 0 ctime 0
step 0
ROTATE left_back_hoof 0 0 1 -1
waitfor left 1 ctime 0
waitfor right 1 ctime 0
waitfor output 0 ctime 0
FULFILL
PUBLISH
waitfor output 1 ctime 0
tick 1
ROTATE left_back_hoof 0 0 1 -1
waitfor left 2 ctime 1
step 1
ROTATE right_back_hoof 0 0 1 -1
waitfor right 2 ctime 1
FULFILL
PUBLISH
waitfor output 2 ctime 1
tick 2
ROTATE left_back_hoof 0 0 1 1
waitfor left 3 ctime 2
ROTATE right_back_hoof 0 0 1 -1
waitfor right 3 ctime 2
FULFILL
PUBLISH
waitfor output 3 ctime 2
tick 3
ROTATE left_back_hoof 0 0 1 1
ROTATE right_back_hoof 0 0 1 1
waitfor right 4 ctime 3
FULFILL
PUBLISH
waitfor output 4 ctime 3
tick 4
ROTATE right_back_hoof 0 0 1 1
FULFILL
PUBLISH
waitfor output 5 ctime 4
tick 5
FULFILL
PUBLISH
waitfor output 6 ctime 5
tick 6
FULFILL
PUBLISH
waitfor output 7 ctime 6
tick 7
FULFILL
PUBLISH
waitfor output 8 ctime 7
tick 8
FULFILL
PUBLISH
waitfor output 9 ctime 8
tick 9
FULFILL
PUBLISH
waitfor output 10 ctime 9
tick 10
FULFILL
PUBLISH
waitfor output 11 ctime 10
tick 11
FULFILL
PUBLISH
waitfor output 12 ctime 11
tick 12
FULFILL
PUBLISH
waitfor output 13 ctime 12
tick 13
FULFILL
PUBLISH
waitfor output 14 ctime 13
tick 14
FULFILL
PUBLISH
waitfor output 15 ctime 14
tick 15
FULFILL
PUBLISH
waitfor output 16 ctime 15
tick 16
FULFILL
PUBLISH
waitfor output 17 ctime 16
tick 17
FULFILL
PUBLISH
waitfor output 18 ctime 17
tick 18
FULFILL
PUBLISH
waitfor output 19 ctime 18
tick 19
FULFILL
PUBLISH
waitfor output 20 ctime 19
tick 20
FULFILL
PUBLISH
waitfor output 21 ctime 20
tick 21
FULFILL
PUBLISH
waitfor output 22 ctime 21
tick 22
FULFILL
PUBLISH
waitfor output 23 ctime 22
tick 23
FULFILL
PUBLISH
waitfor output 24 ctime 23
tick 24
FULFILL
PUBLISH
waitfor output 25 ctime 24
tick 25
FULFILL
PUBLISH
waitfor output 26 ctime 25
tick 26
FULFILL
PUBLISH
waitfor output 27 ctime 26
tick 27
FULFILL
PUBLISH
waitfor output 28 ctime 27
tick 28
FULFILL
PUBLISH
waitfor output 29 ctime 28
tick 29
FULFILL
PUBLISH
waitfor output 30 ctime 29
tick 30
FULFILL
PUBLISH
waitfor output 31 ctime 30
tick 31
FULFILL
PUBLISH
OUTPUT356
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 357.
if test $result = ok -a $start_test_number -le 357; then
	echo test 357
        cat >$test_file <<'TEST357'
var k;
//putln ("#env=", #env);
for (k in env)
  putln (k, "=", env [k]);
TEST357
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sort $stdout | awk '/^(HOSTNAME|USER|MACHTYPE|TERMCAP|LANG|DISPLAY|LOGNAME|COLUMNS|TERM|OSTYPE)/ && length != 0' >$ftemp
		sh -c 'env' | sort | awk '/^(HOSTNAME|USER|MACHTYPE|TERMCAP|LANG|DISPLAY|LOGNAME|COLUMNS|TERM|OSTYPE)/ && length != 0' >$ftemp2
                echo '      ' $CMP $ftemp $ftemp2
                if $CMP $ftemp $ftemp2; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 358.
if test $result = ok -a $start_test_number -le 358; then
	echo test 358
        cat >$test_file <<'TEST358'
putln (log (-1.0));
TEST358
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT358' && $CMP $stderr $ftemp2; then
test.d:1:12: system error - domain error: `log'
OUTPUT358
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT358a' && $CMP $stderr $ftemp2; then
test.d:1:12: system error - result too big (small): `log'
OUTPUT358a
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 359.
if test $result = ok -a $start_test_number -le 359; then
	echo test 359
        cat >$test_file <<'TEST359'
putln (pow (-10, 1000));
TEST359
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT359' && $CMP $stderr $ftemp2; then
test.d:1:12: system error - result too big (small): `pow'
OUTPUT359
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 360.
if test $result = ok -a $start_test_number -le 360; then
	echo test 360
        cat >$test_file <<'TEST360'
putln (sqrt (-10.0));
TEST360
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT360' && $CMP $stderr $ftemp2; then
test.d:1:13: system error - domain error: `sqrt'
OUTPUT360
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT360a' && $CMP $stderr $ftemp2; then
test.d:1:13: system error - result too big (small): `sqrt'
OUTPUT360a
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 361.
if test $result = ok -a $start_test_number -le 361; then
	echo test 361
        cat >$test_file <<'TEST361'
putln (rand ());
putln (rand ());
srand ();
putln (rand ());
putln (rand ());
srand ();
putln (rand ());
putln (rand ());
srand (10);
putln (rand ());
putln (rand ());
srand (10.0);
putln (rand ());
putln (rand ());
srand ("10.0");
putln (rand ());
putln (rand ());
TEST361
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		awk '!/^0\.[0-9]+$/' $stdout >$ftemp
                echo '      ' $CMP $ftemp $ftemp2
                if cat >$ftemp2 <<'OUTPUT361' && $CMP $ftemp $ftemp2; then
OUTPUT361
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 362.
if test $result = ok -a $start_test_number -le 362; then
	echo test 362
        cat >$test_file <<'TEST362'
println (tab ([]));
println (tab ([5:10]));
println (tab (101));
println (tab ('c'));
println (tab (10.25));
println (tab ([5:10, "c"]));
println (tab (tab []));
println (tab (tab ["a":10.0, 10:5]));
println (vec (tab []));
println (vec (tab ["e":5, "g": 6]));
println (vec (101));
println (vec ('c'));
println (vec (10.25));
println (vec ([]));
println (vec ("abcd"));
println (vec ([3:3]));
TEST362
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT362' && $CMP $stdout $ftemp2; then
tab []
tab [0:10, 1:10, 2:10, 3:10, 4:10]
tab [0:'1', 1:'0', 2:'1']
tab [0:'c']
tab [0:'1', 1:'0', 2:'.', 3:'2', 4:'5']
tab [0:10, 1:10, 2:10, 3:10, 4:10, 5:"c"]
tab []
tab ["a":10, 10:5]
[]
["e", 5, "g", 6]
"101"
"c"
"10.25"
[]
"abcd"
[3, 3, 3]
OUTPUT362
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 363.
if test $result = ok -a $start_test_number -le 363; then
	echo test 363
        cat >$test_file <<'TEST363'
fun f {}
var v = tab (f);
TEST363
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT363' && $CMP $stderr $ftemp2; then
test.d:2:14: invalid operand type tab (...)
OUTPUT363
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 364.
if test $result = ok -a $start_test_number -le 364; then
	echo test 364
        cat >$test_file <<'TEST364'
var v = tab (nil);
TEST364
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT364' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid type of operand of tab (...)
OUTPUT364
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 365.
if test $result = ok -a $start_test_number -le 365; then
	echo test 365
        cat >$test_file <<'TEST365'
fun f {}
var v = vec (f);
TEST365
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT365' && $CMP $stderr $ftemp2; then
test.d:2:14: invalid operand type vec (...)
OUTPUT365
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 366.
if test $result = ok -a $start_test_number -le 366; then
	echo test 366
        cat >$test_file <<'TEST366'
var v = vec (nil);
TEST366
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT366' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid type of operand of vec (...)
OUTPUT366
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 367.
if test $result = ok -a $start_test_number -le 367; then
	echo test 367
        cat >$test_file <<'TEST367'
println (keys (tab []));
println (keys (tab [8:5, 7:7]));
println (keys (tab ["a":5, "ha":7]));
TEST367
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT367' && $CMP $stdout $ftemp2; then
[]
[8, 7]
["a", "ha"]
OUTPUT367
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 368.
if test $result = ok -a $start_test_number -le 368; then
	echo test 368
        cat >$test_file <<'TEST368'
var v = keys ([]);
TEST368
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT368' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid parameter type of `keys'
OUTPUT368
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 369.
if test $result = ok -a $start_test_number -le 369; then
	echo test 369
        cat >$test_file <<'TEST369'
var v = keys ();
TEST369
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT369' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - unexpected number of parameters for `keys'
OUTPUT369
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 370.
if test $result = ok -a $start_test_number -le 370; then
	echo test 370
        cat >$test_file <<'TEST370'
println (cmpv ("var", "if"));
println (cmpv ([10, 12], [10, 11, nil]));
println (cmpv ([10.0, 12.0], [10.0]));
println (cmpv ([10.0, 12], [10.0, 11, 13.0]));
println (cmpv ([10.0, 12.0], [10.0, 12.0]));
println (cmpv (10, 'c'));
println (cmpv ([], []));
println (cmpv ([], [10]));
TEST370
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT370' && $CMP $stdout $ftemp2; then
1
1
1
1
0
-1
0
-1
OUTPUT370
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 371.
if test $result = ok -a $start_test_number -le 371; then
	echo test 371
        cat >$test_file <<'TEST371'
cmpv ();
TEST371
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT371' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - unexpected number of parameters for `cmpv'
OUTPUT371
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 372.
if test $result = ok -a $start_test_number -le 372; then
	echo test 372
        cat >$test_file <<'TEST372'
cmpv ([], nil);
TEST372
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT372' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `cmpv'
OUTPUT372
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 373.
if test $result = ok -a $start_test_number -le 373; then
	echo test 373
        cat >$test_file <<'TEST373'
cmpv ([10, 11], [10, 'c']);
TEST373
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT373' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `cmpv'
OUTPUT373
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 374.
if test $result = ok -a $start_test_number -le 374; then
	echo test 374
        cat >$test_file <<'TEST374'
var i, key, voc = tab [];
for (;;)
  try {
    var ln, a;

    ln = getln ();
    if (ln == "")
      continue;
    a = split (ln, "[^[:alnum:]]");
    for (i = 0; i < #a; i++)
      voc [a[i]] = (a[i] in voc ? voc [a[i]] + 1 : 1);
  } catch (eof) {
    break;
  }
key = sort (keys (voc), cmpv);
for (i = 0; i < #key; i++)
  putln (key[i], " : ", voc[key[i]]);
TEST374
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout <<'INPUT374' ; then

var i, prime, k, count, iter, flags;
val SieveSize = 8190;

flags = [SieveSize + 1 : 0];
for (iter = 0; iter < 10; iter++;)
  {
    count = 0;
    for (i = 0; i <= SieveSize; i++)
      flags[i] = 1;
    for (i = 0; i <= SieveSize; i++;)
      if (flags[i])
        {
          prime = i + i + 3;
          k = i + prime;
          for (;1;;)
            {
	      if (k > SieveSize)
                break;
              flags[k] = 0;
              k += prime;
            }
          count++;
        }
  }
putln (count);
INPUT374
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT374' && $CMP $stdout $ftemp2; then
0 : 6
1 : 3
10 : 1
3 : 1
8190 : 1
SieveSize : 5
break : 1
count : 4
flags : 5
for : 4
i : 12
if : 2
iter : 4
k : 5
prime : 4
putln : 1
val : 1
var : 1
OUTPUT374
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 375.
if test $result = ok -a $start_test_number -le 375; then
	echo test 375
        cat >$test_file <<'TEST375'
putln (tolower ("abcd"));
putln (tolower ("ABCD"));
putln (tolower (10));
putln (tolower (10e20));
putln (tolower ('c'));
putln (tolower ('C'));
//
putln (toupper ("abcd"));
putln (toupper ("ABCD"));
putln (toupper (10));
putln (toupper (10e20));
putln (toupper ('c'));
putln (toupper ('C'));
TEST375
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout ; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT375' && $CMP $stdout $ftemp2; then
abcd
abcd
10
1e+21
c
c
ABCD
ABCD
10
1E+21
C
C
OUTPUT375
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT375-1' && $CMP $stdout $ftemp2; then
abcd
abcd
10
1e+021
c
c
ABCD
ABCD
10
1E+021
C
C
OUTPUT375-1
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 376.
if test $result = ok -a $start_test_number -le 376; then
	echo test 376
        cat >$test_file <<'TEST376'
tolower ();
TEST376
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT376' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - unexpected number of parameters for `tolower'
OUTPUT376
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 377.
if test $result = ok -a $start_test_number -le 377; then
	echo test 377
        cat >$test_file <<'TEST377'
tolower (nil);
TEST377
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT377' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `tolower'
OUTPUT377
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 378.
if test $result = ok -a $start_test_number -le 378; then
	echo test 378
        cat >$test_file <<'TEST378'
tolower ();
TEST378
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT378' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - unexpected number of parameters for `tolower'
OUTPUT378
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 379.
if test $result = ok -a $start_test_number -le 379; then
	echo test 379
        cat >$test_file <<'TEST379'
tolower (nil);
TEST379
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT379' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `tolower'
OUTPUT379
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 380.
if test $result = ok -a $start_test_number -le 380; then
	echo test 380
        cat >$test_file <<'TEST380'
a
TEST380
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT380' && $CMP $stderr $ftemp2; then
test.d:2:1: syntax error
OUTPUT380
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 381.
if test $result = ok -a $start_test_number -le 381; then
	echo test 381
        cat >$test_file <<'TEST381'
// vector
var v;
// pack
v = [1, 2, 3, 4, 5, 6]; v = subv (v, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; v = subv (v, -2, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; v = subv (v, 2, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; v = subv (v, 2, -1); println (v);
v = [1, 2, 3, 4, 5, 6]; v = subv (v, 2, 0); println (v);
// unpack
v = [1, 2.0, 3.0, 4, 5, 6]; v = subv (v, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; v = subv (v, -2, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; v = subv (v, 2, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; v = subv (v, 2, -1); println (v);
v = [1.0, 2, 3, 4, 5, 6]; v = subv (v, 2, 0); println (v);
// empty
v = []; v = subv (v, 0); println (v);
v = []; v = subv (v, -2, 1); println (v);
v = []; v = subv (v, 0, 1); println (v);
v = []; v = subv (v, 1, 0); println (v);
v = []; v = subv (v, 0, -1); println (v);
// string
v = new "123456"; v = subv (v, 2, 2); putln (v);
v = new "123456"; v = subv (v, -2, 2); putln (v);
v = new "123456"; v = subv (v, 2, 0); println (v);
var i, iter, t;
for (iter = 0; iter < 1000; iter++)
  { 
    v = [1000:1];
    for (i = 0; i < 1000; i++)
      t = subv (v, 2, 2);
  }
println (t);
TEST381
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT381' && $CMP $stdout $ftemp2; then
[3, 4, 5, 6]
[1, 2]
[3, 4]
[3, 4, 5, 6]
[]
[3, 4, 5, 6]
[1, 2]
[3, 4]
[3, 4, 5, 6]
[]
[]
[]
[]
[]
[]
34
12
""
[1, 1]
OUTPUT381
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 382.
if test $result = ok -a $start_test_number -le 382; then
	echo test 382
        cat >$test_file <<'TEST382'
subv ();
TEST382
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT382' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - unexpected number of parameters for `subv'
OUTPUT382
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 383.
if test $result = ok -a $start_test_number -le 383; then
	echo test 383
        cat >$test_file <<'TEST383'
subv (10);
TEST383
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT383' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - unexpected number of parameters for `subv'
OUTPUT383
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 384.
if test $result = ok -a $start_test_number -le 384; then
	echo test 384
        cat >$test_file <<'TEST384'
subv (nil, 10);
TEST384
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT384' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `subv'
OUTPUT384
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 385.
if test $result = ok -a $start_test_number -le 385; then
	echo test 385
        cat >$test_file <<'TEST385'
subv (10,10,10,10);
TEST385
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT385' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - unexpected number of parameters for `subv'
OUTPUT385
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 386.
if test $result = ok -a $start_test_number -le 386; then
	echo test 386
        cat >$test_file <<'TEST386'
var t;
t = tab [10]; subv (t, 10, 10);
TEST386
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT386' && $CMP $stderr $ftemp2; then
test.d:2:20: run time error - invalid parameter type of `subv'
OUTPUT386
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 387.
if test $result = ok -a $start_test_number -le 387; then
	echo test 387
        cat >$test_file <<'TEST387'
var v;
v = []; subv (v, tab []);
TEST387
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT387' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - invalid parameter type of `subv'
OUTPUT387
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 388.
if test $result = ok -a $start_test_number -le 388; then
	echo test 388
        cat >$test_file <<'TEST388'
var v;
v = []; subv (v, 0, tab []);
TEST388
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT388' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - invalid parameter type of `subv'
OUTPUT388
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 389.
if test $result = ok -a $start_test_number -le 389; then
	echo test 389
        cat >$test_file <<'TEST389'
exit (1);
putln (stderr, "ahaha");
TEST389
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT389' && $CMP $stderr $ftemp2; then
OUTPUT389
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 390.
if test $result = ok -a $start_test_number -le 390; then
	echo test 390
        cat >$test_file <<'TEST390'
exit (0);
putln ("ahaha");
TEST390
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT390' && $CMP $stdout $ftemp2; then
OUTPUT390
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 391.
if test $result = ok -a $start_test_number -le 391; then
	echo test 391
        cat >$test_file <<'TEST391'
exit ();
TEST391
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT391' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - unexpected number of parameters for `exit'
OUTPUT391
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 392.
if test $result = ok -a $start_test_number -le 392; then
	echo test 392
        cat >$test_file <<'TEST392'
exit (1, 1);
TEST392
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT392' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - unexpected number of parameters for `exit'
OUTPUT392
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 393.
if test $result = ok -a $start_test_number -le 393; then
	echo test 393
        cat >$test_file <<'TEST393'
exit (nil);
TEST393
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT393' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `exit'
OUTPUT393
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 394.
if test $result = ok -a $start_test_number -le 394; then
	echo test 394
        cat >$test_file <<'TEST394'
putln (max (1.5, 2));
putln (min (1.5, 2));
putln (max (1.5, 2, "3.0"));
putln (min (1.5, 2, "3.0"));
putln (min (1.5, 2, 'a'));
putln (max (1.5, 2, 'a'));
putln (min (1.5, 2, 'a'));
TEST394
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT394' && $CMP $stdout $ftemp2; then
2
1.5
3
1.5
1.5
97
1.5
OUTPUT394
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 395.
if test $result = ok -a $start_test_number -le 395; then
	echo test 395
        cat >$test_file <<'TEST395'
max (1);
TEST395
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT395' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - unexpected number of parameters for `max'
OUTPUT395
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 396.
if test $result = ok -a $start_test_number -le 396; then
	echo test 396
        cat >$test_file <<'TEST396'
min (1);
TEST396
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT396' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - unexpected number of parameters for `min'
OUTPUT396
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 397.
if test $result = ok -a $start_test_number -le 397; then
	echo test 397
        cat >$test_file <<'TEST397'
max ();
TEST397
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT397' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - unexpected number of parameters for `max'
OUTPUT397
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 398.
if test $result = ok -a $start_test_number -le 398; then
	echo test 398
        cat >$test_file <<'TEST398'
min ();
TEST398
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT398' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - unexpected number of parameters for `min'
OUTPUT398
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 399.
if test $result = ok -a $start_test_number -le 399; then
	echo test 399
        cat >$test_file <<'TEST399'
max (nil, nil);
TEST399
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT399' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `max'
OUTPUT399
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 400.
if test $result = ok -a $start_test_number -le 400; then
	echo test 400
        cat >$test_file <<'TEST400'
min (nil, nil);
TEST400
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT400' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `min'
OUTPUT400
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 401.
if test $result = ok -a $start_test_number -le 401; then
	echo test 401
        cat >$test_file <<'TEST401'
class c (par) {
  class sc (i) {
  }
}

var i=c(10).sc(20);
putln (i.par, " ", i.i);
i.par = 15;
putln (i.par, " ", i.i);
TEST401
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT401' && $CMP $stdout $ftemp2; then
10 20
15 20
OUTPUT401
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 402.
if test $result = ok -a $start_test_number -le 402; then
	echo test 402
        cat >$test_file <<'TEST402'
fun f (par) {
  class sc (i) {
  }
  return sc;
}

var i=f(10)(20);
putln (i.par);
TEST402
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT402' && $CMP $stderr $ftemp2; then
test.d:8:9: run time error - there is no such declaration in given class
OUTPUT402
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 403.
if test $result = ok -a $start_test_number -le 403; then
	echo test 403
        cat >$test_file <<'TEST403'
var c;
{
  class sc (i) {
  }
  c = sc;
}

var i=c(20);
putln (i.par);
TEST403
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT403' && $CMP $stderr $ftemp2; then
test.d:9:8: there is no such declaration in a block
OUTPUT403
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 404.
if test $result = ok -a $start_test_number -le 404; then
	echo test 404
        cat >$test_file <<'TEST404'
var i = 0;
include "../DINO/../DINO/test1";
i = 1;
include +"../DINO/..//////DINO/test1";
i = 2;
{
  include "../DINO/../DINO/test1";
  i = 3;
  include "../DINO/..//////DINO/test1";
  i = 4;
  include +"../DINO/../DINO/test1";
}
i = 5;
include "../DINO/../DINO/test1";
i = 6;
include +"../DINO/..//////DINO/test1";
TEST404
        cat >$test_file_1 <<'TEST404-1'
putln (i);
TEST404-1
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT404' && $CMP $stdout $ftemp2; then
0
1
2
4
6
OUTPUT404
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 406.
if test $result = ok -a $start_test_number -le 406; then
	echo test 406
        cat >$test_file <<'TEST406'
inside (nil);
TEST406
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT406' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unexpected number of parameters for `inside'
OUTPUT406
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 407.
if test $result = ok -a $start_test_number -le 407; then
	echo test 407
        cat >$test_file <<'TEST407'
inside (nil, nil, nil, nil);
TEST407
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT407' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unexpected number of parameters for `inside'
OUTPUT407
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 408.
if test $result = ok -a $start_test_number -le 408; then
	echo test 408
        cat >$test_file <<'TEST408'
class c {}
inside (c, c, nil);
TEST408
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT408' && $CMP $stderr $ftemp2; then
test.d:2:8: run time error - invalid parameter type of `inside'
OUTPUT408
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 409.
if test $result = ok -a $start_test_number -le 409; then
	echo test 409
        cat >$test_file <<'TEST409'
class c {}
inside (c, c());
TEST409
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT409' && $CMP $stderr $ftemp2; then
test.d:2:8: run time error - invalid parameter type of `inside'
OUTPUT409
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 410.
if test $result = ok -a $start_test_number -le 410; then
	echo test 410: Parsing expression
        cat >$test_file <<'TEST410'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (p.ambiguous_p);
TEST410
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT410' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      $term(97, 5)
      mult(
        $term(97, 7)
        $term(97, 9)
      )
    )
  )
)
OUTPUT410
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 411.
if test $result = ok -a $start_test_number -le 411; then
	echo test 411: Undefined grammar
        cat >$test_file <<'TEST411'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST411
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT411' && $CMP $stderr $ftemp2; then
test.d:32:20: run time error (parse) -- undefined or bad grammar
OUTPUT411
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 412.
if test $result = ok -a $start_test_number -le 412; then
	echo test 412: Already defined grammar.
        cat >$test_file <<'TEST412'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);
p.set_grammar (g, 1);

var str = "a+a*(a+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST412
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT412' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      $term(97, 5)
      mult(
        $term(97, 7)
        $term(97, 9)
      )
    )
  )
)
OUTPUT412
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 413.
if test $result = ok -a $start_test_number -le 413; then
	echo test 413: Description syntax error.
        cat >$test_file <<'TEST413'
var g = "TERM 1\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST413
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT413' && $CMP $stderr $ftemp2; then
test.d:16:15: run time error (set_grammar) -- description syntax error on ln 1
OUTPUT413
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 414.
if test $result = ok -a $start_test_number -le 414; then
	echo test 414: error in the left side of the rule.
        cat >$test_file <<'TEST414'
var g = "TERM;\n\
         error : T         # 0\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST414
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT414' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error (set_grammar) -- term `error' in the left hand side of rule
OUTPUT414
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 415.
if test $result = ok -a $start_test_number -le 415; then
	echo test 415: The same code for terminals.
        cat >$test_file <<'TEST415'
var g = "TERM ident=10 i=10;\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST415
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT415' && $CMP $stderr $ftemp2; then
test.d:16:15: run time error (set_grammar) -- repeated code 10 in term `i'
OUTPUT415
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 416.
if test $result = ok -a $start_test_number -le 416; then
	echo test 416: No rules.
        cat >$test_file <<'TEST416'
var g = "TERM ident=10;\n";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST416
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT416' && $CMP $stderr $ftemp2; then
test.d:9:15: run time error (set_grammar) -- grammar does not contains rules
OUTPUT416
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 417.
if test $result = ok -a $start_test_number -le 417; then
	echo test 417: Term in the left hand side of rule.
        cat >$test_file <<'TEST417'
var g = "TERM ident=10;\n\
         ident : 'a'\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST417
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT417' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error (set_grammar) -- term `ident' in the left hand side of rule
OUTPUT417
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 418.
if test $result = ok -a $start_test_number -le 418; then
	echo test 418: Incorrect translation number.
        cat >$test_file <<'TEST418'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 1\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST418
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT418' && $CMP $stderr $ftemp2; then
test.d:15:15: run time error (set_grammar) -- translation symbol number 1 in rule for `E' is out of range
OUTPUT418
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 419.
if test $result = ok -a $start_test_number -le 419; then
	echo test 419: Repeated translation symbol number.
        cat >$test_file <<'TEST419'
var g = "E : E '+' T # plus (0 0)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST419
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT419' && $CMP $stderr $ftemp2; then
test.d:15:15: run time error (set_grammar) -- repeated translation symbol number 0 in rule for `E'
OUTPUT419
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 420.
if test $result = ok -a $start_test_number -le 420; then
	echo test 420: No derivations.
        cat >$test_file <<'TEST420'
var g = "E : 'a' E\n\
           | E '+'";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST420
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT420' && $CMP $stderr $ftemp2; then
test.d:10:15: run time error (set_grammar) -- nonterm `E' does not derive any term string
OUTPUT420
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 421.
if test $result = ok -a $start_test_number -le 421; then
	echo test 421: Grammar loops.
        cat >$test_file <<'TEST421'
var g = "E : A O O\n\
           | E 'a'\n\
           | 'b'\n\
           |\n\
         A : O O N\n\
         N : O E E O\n\
         O :\n";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST421
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT421' && $CMP $stderr $ftemp2; then
test.d:15:15: run time error (set_grammar) -- nonterm `E' can derive only itself (grammar with loops)
OUTPUT421
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 422.
if test $result = ok -a $start_test_number -le 422; then
	echo test 422: Invalid token code.
        cat >$test_file <<'TEST422'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*b)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST422
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT422' && $CMP $stderr $ftemp2; then
test.d:33:20: run time error (parse) -- invalid token code 98
OUTPUT422
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 423.
if test $result = ok -a $start_test_number -le 423; then
	echo test 423: Unaccessible nonterm.
        cat >$test_file <<'TEST423'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         G : 'a'       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*b)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST423
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT423' && $CMP $stderr $ftemp2; then
test.d:16:15: run time error (set_grammar) -- nonterm `G' is not accessible from axiom
OUTPUT423
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 424.
if test $result = ok -a $start_test_number -le 424; then
	echo test 424: Fixed name error.
        cat >$test_file <<'TEST424'
var g = "TERM error=10;\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*b)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST424
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT424' && $CMP $stderr $ftemp2; then
test.d:16:15: run time error (set_grammar) -- do not use fixed name `error'
OUTPUT424
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 425.
if test $result = ok -a $start_test_number -le 425; then
	echo test 425: Error recovery.
        cat >$test_file <<'TEST425'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a*+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST425
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT425' && $CMP $stdout $ftemp2; then
syntax error on token #7 (43) -- ignore 10 tokens starting with token #0
$nil
OUTPUT425
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 426.
if test $result = ok -a $start_test_number -le 426; then
	echo test 426: More error recovery.
        cat >$test_file <<'TEST426'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a*+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST426
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT426' && $CMP $stdout $ftemp2; then
syntax error on token #7 (43) -- ignore 4 tokens starting with token #5
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    $error
  )
)
OUTPUT426
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 427.
if test $result = ok -a $start_test_number -le 427; then
	echo test 427: More error recovery.
        cat >$test_file <<'TEST427'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST427
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT427' && $CMP $stdout $ftemp2; then
syntax error on token #5 (42) -- ignore 4 tokens starting with token #5
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    $error
  )
)
OUTPUT427
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 428.
if test $result = ok -a $start_test_number -le 428; then
	echo test 428: Ambiguous grammar.
        cat >$test_file <<'TEST428'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (1);
p.set_grammar (g, 1);

var str = "a+a*(a*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (!p.ambiguous_p);
TEST428
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT428' && $CMP $stdout $ftemp2; then
mult(
  plus(
    $term(97, 0)
    $term(97, 2)
  )
  plus(
    mult(
      $term(97, 5)
      $term(97, 7)
    )
    $term(97, 9)
  )
)
OUTPUT428
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 429.
if test $result = ok -a $start_test_number -le 429; then
	echo test 429: More ambiguous grammar.
        cat >$test_file <<'TEST429'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST429
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT429' && $CMP $stdout $ftemp2; then
$alt(
  plus(
    $term(97, 0)
    mult(
      $term(97, 2)
      $alt(
        mult(
          $term(97, 5)
          plus(
            $term(97, 7)
            $term(97, 9)
          )
        )
        plus(
          mult(
            $term(97, 5)
            $term(97, 7)
          )
          $term(97, 9)
        )
      )
    )
  )
  mult(
    plus(
      $term(97, 0)
      $term(97, 2)
    )
    $alt(
      mult(
        $term(97, 5)
        plus(
          $term(97, 7)
          $term(97, 9)
        )
      )
      plus(
        mult(
          $term(97, 5)
          $term(97, 7)
        )
        $term(97, 9)
      )
    )
  )
)
OUTPUT429
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 430.
if test $result = ok -a $start_test_number -le 430; then
	echo test 430: Ambiguous grammar with error recovery
        cat >$test_file <<'TEST430'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (1);
p.set_grammar (g, 1);

var str = "a+a*(*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST430
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT430' && $CMP $stdout $ftemp2; then
syntax error on token #5 (42) -- ignore 10 tokens starting with token #0
$nil
OUTPUT430
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 431.
if test $result = ok -a $start_test_number -le 431; then
	echo test 431: More ambiguous grammar with error recovery
        cat >$test_file <<'TEST431'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1\n";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (1);
p.set_grammar (g, 1);

var str = "a+a*(*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST431
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT431' && $CMP $stdout $ftemp2; then
syntax error on token #5 (42) -- ignore 4 tokens starting with token #5
mult(
  plus(
    $term(97, 0)
    $term(97, 2)
  )
  $error
)
OUTPUT431
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 432.
if test $result = ok -a $start_test_number -le 432; then
	echo test 432: More ambiguous grammar with error recovery
        cat >$test_file <<'TEST432'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1\n";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST432
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT432' && $CMP $stdout $ftemp2; then
syntax error on token #5 (42) -- ignore 4 tokens starting with token #5
$alt(
  plus(
    $term(97, 0)
    mult(
      $term(97, 2)
      $error
    )
  )
  mult(
    plus(
      $term(97, 0)
      $term(97, 2)
    )
    $error
  )
)
OUTPUT432
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 433.
if test $result = ok -a $start_test_number -le 433; then
	echo test 433: Error recovery with 2 
        cat >$test_file <<'TEST433'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a*)+(*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST433
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT433' && $CMP $stdout $ftemp2; then
syntax error on token #7 (41) -- ignore 2 tokens starting with token #5
syntax error on token #10 (42) -- ignore 2 tokens starting with token #10
plus(
  plus(
    $term(97, 0)
    mult(
      $term(97, 2)
      $error
    )
  )
  $error
)
OUTPUT433
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 434.
if test $result = ok -a $start_test_number -le 434; then
	echo test 434: More error recovery with 2 
        cat >$test_file <<'TEST434'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_recovery_match (4);
p.set_grammar (g, 1);

var str = "a+a*(a*)+(*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (p.ambiguous_p);
TEST434
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT434' && $CMP $stdout $ftemp2; then
syntax error on token #7 (41) -- ignore 4 tokens starting with token #5
plus(
  plus(
    $term(97, 0)
    mult(
      $term(97, 2)
      $error
    )
  )
  $error
)
OUTPUT434
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 435.
if test $result = ok -a $start_test_number -le 435; then
	echo test 435: More ambiguous grammar.
        cat >$test_file <<'TEST435'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | 'b' # 0\n\
           | 'c' # 0\n\
           | 'd' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+b*c+d";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST435
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT435' && $CMP $stdout $ftemp2; then
$alt(
  plus(
    $term(97, 0)
    $alt(
      mult(
        $term(98, 2)
        plus(
          $term(99, 4)
          $term(100, 6)
        )
      )
      plus(
        mult(
          $term(98, 2)
          $term(99, 4)
        )
        $term(100, 6)
      )
    )
  )
  mult(
    plus(
      $term(97, 0)
      $term(98, 2)
    )
    plus(
      $term(99, 4)
      $term(100, 6)
    )
  )
  plus(
    $alt(
      plus(
        $term(97, 0)
        mult(
          $term(98, 2)
          $term(99, 4)
        )
      )
      mult(
        plus(
          $term(97, 0)
          $term(98, 2)
        )
        $term(99, 4)
      )
    )
    $term(100, 6)
  )
)
OUTPUT435
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 436.
if test $result = ok -a $start_test_number -le 436; then
	echo test 436: More ambiguous grammar and GC.
        cat >$test_file <<'TEST436'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | 'b' # 0\n\
           | 'c' # 0\n\
           | 'd' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+b*c+a";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);

var v, iter;

for (iter = 0; iter < 1000; iter++) { 
  v = [];
  for (i = 0; i < 100; i++)
    insv (v, [1]);
  for (i = 0; i < 100; i++)
    del (v, 0);
}

println (v);

pr (root, 0);

exit (!p.ambiguous_p);
TEST436
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT436' && $CMP $stdout $ftemp2; then
$alt(
  plus(
    $term(97, 0)
    $alt(
      mult(
        $term(98, 2)
        plus(
          $term(99, 4)
          $term(97, 6)
        )
      )
      plus(
        mult(
          $term(98, 2)
          $term(99, 4)
        )
        $term(97, 6)
      )
    )
  )
  mult(
    plus(
      $term(97, 0)
      $term(98, 2)
    )
    plus(
      $term(99, 4)
      $term(97, 6)
    )
  )
  plus(
    $alt(
      plus(
        $term(97, 0)
        mult(
          $term(98, 2)
          $term(99, 4)
        )
      )
      mult(
        plus(
          $term(97, 0)
          $term(98, 2)
        )
        $term(99, 4)
      )
    )
    $term(97, 6)
  )
)
[]
$alt(
  plus(
    $term(97, 0)
    $alt(
      mult(
        $term(98, 2)
        plus(
          $term(99, 4)
          $term(97, 6)
        )
      )
      plus(
        mult(
          $term(98, 2)
          $term(99, 4)
        )
        $term(97, 6)
      )
    )
  )
  mult(
    plus(
      $term(97, 0)
      $term(98, 2)
    )
    plus(
      $term(99, 4)
      $term(97, 6)
    )
  )
  plus(
    $alt(
      plus(
        $term(97, 0)
        mult(
          $term(98, 2)
          $term(99, 4)
        )
      )
      mult(
        plus(
          $term(97, 0)
          $term(98, 2)
        )
        $term(99, 4)
      )
    )
    $term(97, 6)
  )
)
OUTPUT436
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 437.
if test $result = ok -a $start_test_number -le 437; then
	echo test 437: Debugging information.
        cat >$test_file <<'TEST437'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (1);
p.set_one_parse (0);
p.set_recovery_match (4);
p.set_grammar (g, 1);

var str = "a+a*(a*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (p.ambiguous_p);
TEST437
        echo '      ' "$DINO $test_file 2>&1 | fgrep -v '#' >$stdout"
        if $DINO $test_file 2>&1 | fgrep -v '#' >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT437' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      mult(
        $term(97, 5)
        $term(97, 7)
      )
      $term(97, 9)
    )
  )
)
OUTPUT437
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT437' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      mult(
        $term(97, 5)
        $term(97, 7)
      )
      $term(97, 9)
    )
  )
)
OUTPUT437
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 438.
if test $result = ok -a $start_test_number -le 438; then
	echo test 438: Debugging information.
        cat >$test_file <<'TEST438'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (2);
p.set_one_parse (0);
p.set_recovery_match (4);
p.set_grammar (g, 1);

var str = "a+a*(a*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (p.ambiguous_p);
TEST438
        echo '      ' "$DINO $test_file 2>&1 | fgrep -v '#' >$stdout"
        if $DINO $test_file 2>&1 | fgrep -v '#' >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT438' && $CMP $stdout $ftemp2; then
Translation:
      0: ABSTRACT: plus ( 1 2 )
      1: TERMINAL: code=97, repr='a'
      2: ABSTRACT: mult ( 3 4 )
      3: TERMINAL: code=97, repr='a'
      4: ABSTRACT: plus ( 5 6 )
      5: ABSTRACT: mult ( 7 8 )
      7: TERMINAL: code=97, repr='a'
      8: TERMINAL: code=97, repr='a'
      6: TERMINAL: code=97, repr='a'

plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      mult(
        $term(97, 5)
        $term(97, 7)
      )
      $term(97, 9)
    )
  )
)
OUTPUT438
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT438' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      mult(
        $term(97, 5)
        $term(97, 7)
      )
      $term(97, 9)
    )
  )
)
Translation:
      0: ABSTRACT: plus ( 1 2 )
      1: TERMINAL: code=97, repr='a'
      2: ABSTRACT: mult ( 3 4 )
      3: TERMINAL: code=97, repr='a'
      4: ABSTRACT: plus ( 5 6 )
      5: ABSTRACT: mult ( 7 8 )
      7: TERMINAL: code=97, repr='a'
      8: TERMINAL: code=97, repr='a'
      6: TERMINAL: code=97, repr='a'

OUTPUT438
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 439.
if test $result = ok -a $start_test_number -le 439; then
	echo test 439: Parameter exception.
        cat >$test_file <<'TEST439'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (nil);
p.set_one_parse ("0");

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST439
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT439' && $CMP $stderr $ftemp2; then
test.d:12:13: run time error - invalid parameter type of `set_debug'
OUTPUT439
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 440.
if test $result = ok -a $start_test_number -le 440; then
	echo test 440: More parameter exception.
        cat >$test_file <<'TEST440'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse (nil);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST440
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT440' && $CMP $stderr $ftemp2; then
test.d:13:17: run time error - invalid parameter type of `set_one_parse'
OUTPUT440
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 441.
if test $result = ok -a $start_test_number -le 441; then
	echo test 441: More parameter exception.
        cat >$test_file <<'TEST441'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery (nil);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST441
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT441' && $CMP $stderr $ftemp2; then
test.d:14:16: run time error - invalid parameter type of `set_recovery'
OUTPUT441
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 442.
if test $result = ok -a $start_test_number -le 442; then
	echo test 442: More parameter exception.
        cat >$test_file <<'TEST442'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match (nil);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST442
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT442' && $CMP $stderr $ftemp2; then
test.d:15:22: run time error - invalid parameter type of `set_recovery_match'
OUTPUT442
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 443.
if test $result = ok -a $start_test_number -le 443; then
	echo test 443: More parameter exception.
        cat >$test_file <<'TEST443'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (['T', 'E', 'R', 'M'], nil);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST443
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT443' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error - invalid parameter type of `set_grammar'
OUTPUT443
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 444.
if test $result = ok -a $start_test_number -le 444; then
	echo test 444: More parameter exception.
        cat >$test_file <<'TEST444'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (nil, 0);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST444
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT444' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error - invalid parameter type of `set_grammar'
OUTPUT444
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 445.
if test $result = ok -a $start_test_number -le 445; then
	echo test 445: More parameter exception.
        cat >$test_file <<'TEST445'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (0, 0);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST445
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT445' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error - invalid parameter type of `set_grammar'
OUTPUT445
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 446.
if test $result = ok -a $start_test_number -le 446; then
	echo test 446: More parameter exception.
        cat >$test_file <<'TEST446'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, 0);
exit (0);
TEST446
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT446' && $CMP $stderr $ftemp2; then
test.d:35:20: run time error - invalid parameter type of `parse'
OUTPUT446
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 447.
if test $result = ok -a $start_test_number -le 447; then
	echo test 447: More parameter exception.
        cat >$test_file <<'TEST447'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (nil, error);
exit (0);
TEST447
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT447' && $CMP $stderr $ftemp2; then
test.d:35:20: run time error - invalid parameter type of `parse'
OUTPUT447
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 447.
if test $result = ok -a $start_test_number -le 447; then
	echo test 447: More parameter exception.
        cat >$test_file <<'TEST447'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (['a', 'b'], error);
exit (0);
TEST447
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT447' && $CMP $stderr $ftemp2; then
test.d:35:20: run time error - invalid parameter type of `parse'
OUTPUT447
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 448.
if test $result = ok -a $start_test_number -le 448; then
	echo test 448: More parameter exception.
        cat >$test_file <<'TEST448'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

{
 class token (c) {}
 var root = p.parse ([token ('a'), token ('b')], error);
}
exit (0);
TEST448
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT448' && $CMP $stderr $ftemp2; then
test.d:37:21: run time error (parse) -- invalid token #0
OUTPUT448
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 449.
if test $result = ok -a $start_test_number -le 449; then
	echo test 449: More parameter exception.
        cat >$test_file <<'TEST449'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 0);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse ([tok ('a'), tok ('b')], error);
exit (0);
TEST449
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT449' && $CMP $stderr $ftemp2; then
test.d:35:20: run time error (parse) -- invalid code of token #0
OUTPUT449
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 450.
if test $result = ok -a $start_test_number -le 450; then
	echo test 450: More parameter exception.
        cat >$test_file <<'TEST450'
class c1 {friend g; priv var a;}
TEST450
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT450' && $CMP $stderr $ftemp2; then
test.d:1:18: there is no declaration for identifier `g' in friend list
OUTPUT450
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 451.
if test $result = ok -a $start_test_number -le 451; then
	echo test 451: More parameter exception.
        cat >$test_file <<'TEST451'
var g;
class c1 {friend g; priv var a;}
TEST451
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT451' && $CMP $stderr $ftemp2; then
test.d:2:18: friend identifier `g' is neither function nor class
OUTPUT451
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 452.
if test $result = ok -a $start_test_number -le 452; then
	echo test 452
        cat >$test_file <<'TEST452'
class c2;
class c1 {friend c2; priv var a = 10;}
var i1 = c1 ();
class c2 {var a; a = i1.a;}
var i2 = c2 ();
putln (i2.a);
TEST452
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT452' && $CMP $stdout $ftemp2; then
10
OUTPUT452
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 453.
if test $result = ok -a $start_test_number -le 453; then
	echo test 453: IEEE package
        cat >$test_file <<'TEST453'
// There is no goal to test IEEE package we simply testing all
// functions of ieee.d

include "ieee";

var s1 = ieees.single(), s2 = ieees.single();
putln ("*******IEEE singles:**********");

putln ("pzero s1 (2, 4, 8, 16)=", s1.to_binary_string (2), ", ",
       s1.to_binary_string (4), ", ", s1.to_binary_string (8), ", ",
       s1.to_binary_string (16));
putln ("pzero s1=", s1.to_string ());
putln ("pzero s2 (2, 4, 8, 16)=", s2.to_binary_string (2), ", ",
       s2.to_binary_string (4), ", ", s2.to_binary_string (8), ", ",
       s2.to_binary_string (16));
putln ("pzero s2=", s2.to_string ());

s1 = ieees.single("0");
s2 = ieees.single("0");

s1.nzero();
putln ("-zero s1=", s1.to_string (), " s1 is -zero = ", s1.is_nzero ());
s1.nan();
putln ("nan s1=", s1.to_string (), " s1 is nan = ", s1.is_nan ());
s1.trap_nan();
putln ("trap nan s1=", s1.to_string (),
       " s1 is trap nan = ", s1.is_trap_nan ());
s1.pinfinity();
putln ("+infinity s1=", s1.to_string (),
       " s1 is +infinity = ", s1.is_pinfinity ());
s1.ninfinity();
putln ("-infinity s1=", s1.to_string (),
       " s1 is -infinity = ", s1.is_ninfinity ());
s1.pmax();
putln ("+max s1 (10, 16)=", s1.to_string (), ", ", s1.to_binary_string (16),
       " s1 is norm = ", s1.is_normalized ());
s1.nmax();
putln ("-max s1 (10, 16)=", s1.to_string (), ", ", s1.to_binary_string (16),
       " s1 is norm = ", s1.is_normalized ());
s1.pmin();
putln ("+min s1 (10, 16)=", s1.to_string (), ", ", s1.to_binary_string (16),
       " s1 is denorm = ", s1.is_denormalized ());
s1.nmin();
putln ("-min s1 (10,16)=", s1.to_string (), ", ", s1.to_binary_string (16),
       " s1 is denorm = ", s1.is_denormalized ());

s1.from_float(5.0);
s2.from_float(10.0);
putln ("s1 (10,2,4,8,16)= ", s1.to_string (), ", ", s1.to_binary_string (2),
       ", ", s1.to_binary_string (4), ", ", s1.to_binary_string (8),
       ", ", s1.to_binary_string (16));
putln ("s2 = ", s2.to_string ());

s1.from_string("5.0");
s2.from_string("10.0");
putln ("s1 = ", s1.to_string ());
putln ("s2 = ", s2.to_string ());

s1.from_binary_string("5.0", 16);
s2.from_binary_string("2.8p2", 16);
putln ("s1 = ", s1.to_string ());
putln ("s2 = ", s2.to_string ());

putln ("s1 + s2 = ", s1.add (s2).to_string ());
putln ("s1 - s2 = ", s1.subtract (s2).to_string ());
putln ("s2 - s1 = ", s2.subtract (s1).to_string ());
putln ("s1 * s2 = ", s1.multiply (s2).to_string ());
putln ("s1 / s2 = ", s1.divide (s2).to_string ());
putln ("s1 == s2 = ", s1.eq (s2));
putln ("s1 != s2 = ", s1.ne (s2));
putln ("s1 < s2 = ", s1.lt (s2));
putln ("s1 <= s2 = ", s1.le (s2));
putln ("s1 > s2 = ", s1.gt (s2));
putln ("s1 >= s2 = ", s1.ge (s2));

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

try {
  var s3 = ieees.single ();
  put (s1.to_string (), " / ", s3.to_string (), " ...");
  s1.divide (s3);
} catch (ieee_zero_division_except) {
  putln ("  got zero_division");
}

{
  var s3 = ieees.single (), st, res;
  ieees.ignore_excepts = 1;
  put (s1.to_string (), " / ", s3.to_string (), " = ");
  res = s1.divide (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.dz);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ("3");
  put (s1.to_string (), " / ", s3.to_string (), " ...");
  s1.divide (s3);
} catch (ieee_imprecise_result_except) {
  putln ("  got imprecise result");
}

{
  var s3 = ieees.single ("3"), st, res;
  ieees.ignore_excepts = 1;
  put (s1.to_string (), " / ", s3.to_string (), " = ");
  res = s1.divide (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.imp);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ();
  s3.pmax ();
  put (s3.to_string (), " + ", s3.to_string (), " ...");
  s3.add (s3);
} catch (ieee_overflow_except) {
  putln ("  got overflow");
}

{
  var s3 = ieees.single (), st, res;
  ieees.ignore_excepts = 1;
  s3.pmax ();
  put (s3.to_string (), " + ", s3.to_string (), " = ");
  res = s3.add (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ofl);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ();
  s3.pmin ();
  put (s3.to_string (), " / 10 ...");
  s3.divide (ieees.single ("10"));
} catch (ieee_underflow_except) {
  putln ("  got underflow");
}

{
  var s3 = ieees.single (), st, res;
  s3.pmin ();
  ieees.ignore_excepts = 1;
  put (s3.to_string (), " / 10 = ");
  res = s3.divide (ieees.single ("10"));
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ufl);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ("SNaN");
  put (s3.to_string (), " + ", s3.to_string (), " ...");
  s3.add (s3);
} catch (ieee_invalid_operation_except) {
  putln ("  got invalid operation");
}

{
  var s3 = ieees.single ("SNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (s3.to_string (), " + ", s3.to_string (), " = ");
  res = s3.add (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.inv);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ("QNaN");
  put (s3.to_string (), " + ", s3.to_string (), " ...");
  s3.add (s3);
} catch (ieee_reserved_operand_except) {
  putln ("  got reserved operand");
}

{
  var s3 = ieees.single ("QNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (s3.to_string (), " + ", s3.to_string (), " = ");
  res = s3.add (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ro);
  ieees.ignore_excepts = 0;
}

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("trap mask = ", ieees.get_trap_mask ());

ieees.set_trap_mask (ieees.inv|ieees.ro|ieees.ofl
		     |ieees.ufl|ieees.imp|ieees.dz);
putln ("trap mask = ", ieees.get_trap_mask ());

var s3 = ieees.single ();
put (s1.to_string (), " / ", s3.to_string (), " = ");
putln (s1.divide (s3).to_string ());

s3 = ieees.single ("3");
put (s1.to_string (), " / ", s3.to_string (), " = ");
putln (s1.divide (s3).to_string ());

s3 = ieees.single ();
s3.pmax ();
put (s3.to_string (), " + ", s3.to_string (), " = ");
putln (s3.add (s3).to_string ());

s3 = ieees.single ();
s3.pmin ();
put (s3.to_string (), " / 10 = ");
putln (s3.divide (ieees.single ("10")).to_string ());

s3 = ieees.single ("SNaN");
put (s3.to_string (), " + ", s3.to_string (), " = ");
putln (s3.add (s3).to_string ());

s3 = ieees.single ("QNaN");
put (s3.to_string (), " + ", s3.to_string (), " = ");
putln (s3.add (s3).to_string ());

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("round = ", ieees.get_round ());

s3 = ieees.single ("1.23456788");
s1 = ieees.single ("0.00000001");
putln (s3.to_string (), " + ", s1.to_string (), " = ",
       s3.add (s1).to_string ());

ieees.set_round (ieees.rni);
putln ("round = ", ieees.get_round ());

s3 = ieees.single ("1.23456788");
s1 = ieees.single ("0.00000001");
putln (s3.to_string (), " + ", s1.to_string (), " = ",
       s3.add (s1).to_string ());

ieees.set_round (ieees.rpi);
putln ("round = ", ieees.get_round ());

s3 = ieees.single ("1.23456788");
s1 = ieees.single ("0.00000001");
putln (s3.to_string (), " + ", s1.to_string (), " = ",
       s3.add (s1).to_string ());

ieees.set_round (ieees.rz);
putln ("round = ", ieees.get_round ());

s3 = ieees.single ("1.23456788");
s1 = ieees.single ("0.00000001");
putln (s3.to_string (), " + ", s1.to_string (), " = ",
       s3.add (s1).to_string ());

try {
  ieees.set_round (6);
} catch (ieee_round_value_except) {
  putln ("  got invalid round value");
}

s1 = ieees.single ("5");
var ms = s1.to_mpi (4);
putln ("ms (from s1) = ", mpis.to_string (ms));
s1.from_mpi (ms);
putln ("s1 (from ms) = ", s1.to_string ());

//////////////////////////////////////////////////////////////

ieees.reset ();
var d1 = ieees.double(), d2 = ieees.double();
putln ("*******IEEE doubles:**********");

putln ("pzero d1 (2, 4, 8, 16)=", d1.to_binary_string (2), ", ",
       d1.to_binary_string (4), ", ", d1.to_binary_string (8), ", ",
       d1.to_binary_string (16));
putln ("pzero d1=", d1.to_string ());
putln ("pzero d2 (2, 4, 8, 16)=", d2.to_binary_string (2), ", ",
       d2.to_binary_string (4), ", ", d2.to_binary_string (8), ", ",
       d2.to_binary_string (16));
putln ("pzero d2=", d2.to_string ());

d1 = ieees.double("0");
d2 = ieees.double("0");

d1.nzero();
putln ("-zero d1=", d1.to_string (), " d1 is -zero = ", d1.is_nzero ());
d1.nan();
putln ("nan d1=", d1.to_string (), " d1 is nan = ", d1.is_nan ());
d1.trap_nan();
putln ("trap nan d1=", d1.to_string (),
       " d1 is trap nan = ", d1.is_trap_nan ());
d1.pinfinity();
putln ("+infinity d1=", d1.to_string (),
       " d1 is +infinity = ", d1.is_pinfinity ());
d1.ninfinity();
putln ("-infinity d1=", d1.to_string (),
       " d1 is -infinity = ", d1.is_ninfinity ());
d1.pmax();
putln ("+max d1 (10, 16)=", d1.to_string (), ", ", d1.to_binary_string (16),
       " d1 is norm = ", d1.is_normalized ());
d1.nmax();
putln ("-max d1 (10, 16)=", d1.to_string (), ", ", d1.to_binary_string (16),
       " d1 is norm = ", d1.is_normalized ());
d1.pmin();
putln ("+min d1 (10, 16)=", d1.to_string (), ", ", d1.to_binary_string (16),
       " d1 is denorm = ", d1.is_denormalized ());
d1.nmin();
putln ("-min d1 (10,16)=", d1.to_string (), ", ", d1.to_binary_string (16),
       " d1 is denorm = ", d1.is_denormalized ());

d1.from_float(5.0);
d2.from_float(10.0);
putln ("d1 (10,2,4,8,16)= ", d1.to_string (), ", ", d1.to_binary_string (2),
       ", ", d1.to_binary_string (4), ", ", d1.to_binary_string (8),
       ", ", d1.to_binary_string (16));
putln ("d2 = ", d2.to_string ());

d1.from_string("5.0");
d2.from_string("10.0");
putln ("d1 = ", d1.to_string ());
putln ("d2 = ", d2.to_string ());

d1.from_binary_string("5.0", 16);
d2.from_binary_string("2.8p2", 16);
putln ("d1 = ", d1.to_string ());
putln ("d2 = ", d2.to_string ());

putln ("d1 + d2 = ", d1.add (d2).to_string ());
putln ("d1 - d2 = ", d1.subtract (d2).to_string ());
putln ("d2 - d1 = ", d2.subtract (d1).to_string ());
putln ("d1 * d2 = ", d1.multiply (d2).to_string ());
putln ("d1 / d2 = ", d1.divide (d2).to_string ());
putln ("d1 == d2 = ", d1.eq (d2));
putln ("d1 != d2 = ", d1.ne (d2));
putln ("d1 < d2 = ", d1.lt (d2));
putln ("d1 <= d2 = ", d1.le (d2));
putln ("d1 > d2 = ", d1.gt (d2));
putln ("d1 >= d2 = ", d1.ge (d2));

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

try {
  var d3 = ieees.double ();
  put (d1.to_string (), " / ", d3.to_string (), " ...");
  d1.divide (d3);
} catch (ieee_zero_division_except) {
  putln ("  got zero_division");
}

{
  var d3 = ieees.double (), st, res;
  ieees.ignore_excepts = 1;
  put (d1.to_string (), " / ", d3.to_string (), " = ");
  res = d1.divide (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.dz);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ("3");
  put (d1.to_string (), " / ", d3.to_string (), " ...");
  d1.divide (d3);
} catch (ieee_imprecise_result_except) {
  putln ("  got imprecise result");
}

{
  var d3 = ieees.double ("3"), st, res;
  ieees.ignore_excepts = 1;
  put (d1.to_string (), " / ", d3.to_string (), " = ");
  res = d1.divide (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.imp);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ();
  d3.pmax ();
  put (d3.to_string (), " + ", d3.to_string (), " ...");
  d3.add (d3);
} catch (ieee_overflow_except) {
  putln ("  got overflow");
}

{
  var d3 = ieees.double (), st, res;
  ieees.ignore_excepts = 1;
  d3.pmax ();
  put (d3.to_string (), " + ", d3.to_string (), " = ");
  res = d3.add (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ofl);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ();
  d3.pmin ();
  put (d3.to_string (), " / 10 ...");
  d3.divide (ieees.double ("10"));
} catch (ieee_underflow_except) {
  putln ("  got underflow");
}

{
  var d3 = ieees.double (), st, res;
  d3.pmin ();
  ieees.ignore_excepts = 1;
  put (d3.to_string (), " / 10 = ");
  res = d3.divide (ieees.double ("10"));
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ufl);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ("SNaN");
  put (d3.to_string (), " + ", d3.to_string (), " ...");
  d3.add (d3);
} catch (ieee_invalid_operation_except) {
  putln ("  got invalid operation");
}

{
  var d3 = ieees.double ("SNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (d3.to_string (), " + ", d3.to_string (), " = ");
  res = d3.add (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.inv);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ("QNaN");
  put (d3.to_string (), " + ", d3.to_string (), " ...");
  d3.add (d3);
} catch (ieee_reserved_operand_except) {
  putln ("  got reserved operand");
}

{
  var d3 = ieees.double ("QNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (d3.to_string (), " + ", d3.to_string (), " = ");
  res = d3.add (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ro);
  ieees.ignore_excepts = 0;
}

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("trap mask = ", ieees.get_trap_mask ());

ieees.set_trap_mask (ieees.inv|ieees.ro|ieees.ofl
		     |ieees.ufl|ieees.imp|ieees.dz);
putln ("trap mask = ", ieees.get_trap_mask ());

var d3 = ieees.double ();
put (d1.to_string (), " / ", d3.to_string (), " = ");
putln (d1.divide (d3).to_string ());

d3 = ieees.double ("3");
put (d1.to_string (), " / ", d3.to_string (), " = ");
putln (d1.divide (d3).to_string ());

d3 = ieees.double ();
d3.pmax ();
put (d3.to_string (), " + ", d3.to_string (), " = ");
putln (d3.add (d3).to_string ());

d3 = ieees.double ();
d3.pmin ();
put (d3.to_string (), " / 10 = ");
putln (d3.divide (ieees.double ("10")).to_string ());

d3 = ieees.double ("SNaN");
put (d3.to_string (), " + ", d3.to_string (), " = ");
putln (d3.add (d3).to_string ());

d3 = ieees.double ("QNaN");
put (d3.to_string (), " + ", d3.to_string (), " = ");
putln (d3.add (d3).to_string ());

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("round = ", ieees.get_round ());

d3 = ieees.double ("1.2345678901234567");
d1 = ieees.double ("0.0000000000000004");
putln (d3.to_string (), " + ", d1.to_string (), " = ",
       d3.add (d1).to_string ());

ieees.set_round (ieees.rni);
putln ("round = ", ieees.get_round ());

d3 = ieees.double ("1.2345678901234567");
d1 = ieees.double ("0.0000000000000004");
putln (d3.to_string (), " + ", d1.to_string (), " = ",
       d3.add (d1).to_string ());

ieees.set_round (ieees.rpi);
putln ("round = ", ieees.get_round ());

d3 = ieees.double ("1.2345678901234567");
d1 = ieees.double ("0.0000000000000004");
putln (d3.to_string (), " + ", d1.to_string (), " = ",
       d3.add (d1).to_string ());

ieees.set_round (ieees.rz);
putln ("round = ", ieees.get_round ());

d3 = ieees.double ("1.2345678901234567");
d1 = ieees.double ("0.0000000000000004");
putln (d3.to_string (), " + ", d1.to_string (), " = ",
       d3.add (d1).to_string ());

try {
  ieees.set_round (6);
} catch (ieee_round_value_except) {
  putln ("  got invalid round value");
}

d1 = ieees.double ("5");
var md = d1.to_mpi (4);
putln ("md (from d1) = ", mpis.to_string (md));
d1.from_mpi (md);
putln ("d1 (from md) = ", d1.to_string ());

//////////////////////////////////////////////////////////////

ieees.reset ();
var q1 = ieees.quad(), q2 = ieees.quad();
putln ("*******IEEE quads:**********");

putln ("pzero q1 (2, 4, 8, 16)=", q1.to_binary_string (2), ", ",
       q1.to_binary_string (4), ", ", q1.to_binary_string (8), ", ",
       q1.to_binary_string (16));
putln ("pzero q1=", q1.to_string ());
putln ("pzero q2 (2, 4, 8, 16)=", q2.to_binary_string (2), ", ",
       q2.to_binary_string (4), ", ", q2.to_binary_string (8), ", ",
       q2.to_binary_string (16));
putln ("pzero q2=", q2.to_string ());

q1 = ieees.quad("0");
q2 = ieees.quad("0");

q1.nzero();
putln ("-zero q1=", q1.to_string (), " q1 is -zero = ", q1.is_nzero ());
q1.nan();
putln ("nan q1=", q1.to_string (), " q1 is nan = ", q1.is_nan ());
q1.trap_nan();
putln ("trap nan q1=", q1.to_string (),
       " q1 is trap nan = ", q1.is_trap_nan ());
q1.pinfinity();
putln ("+infinity q1=", q1.to_string (),
       " q1 is +infinity = ", q1.is_pinfinity ());
q1.ninfinity();
putln ("-infinity q1=", q1.to_string (),
       " q1 is -infinity = ", q1.is_ninfinity ());
q1.pmax();
putln ("+max q1 (10, 16)=", q1.to_string (), ", ", q1.to_binary_string (16),
       " q1 is norm = ", q1.is_normalized ());
q1.nmax();
putln ("-max q1 (10, 16)=", q1.to_string (), ", ", q1.to_binary_string (16),
       " q1 is norm = ", q1.is_normalized ());
q1.pmin();
putln ("+min q1 (10, 16)=", q1.to_string (), ", ", q1.to_binary_string (16),
       " q1 is denorm = ", q1.is_denormalized ());
q1.nmin();
putln ("-min q1 (10,16)=", q1.to_string (), ", ", q1.to_binary_string (16),
       " q1 is denorm = ", q1.is_denormalized ());

q1.from_float(5.0);
q2.from_float(10.0);
putln ("q1 (10,2,4,8,16)= ", q1.to_string (), ", ", q1.to_binary_string (2),
       ", ", q1.to_binary_string (4), ", ", q1.to_binary_string (8),
       ", ", q1.to_binary_string (16));
putln ("q2 = ", q2.to_string ());

q1.from_string("5.0");
q2.from_string("10.0");
putln ("q1 = ", q1.to_string ());
putln ("q2 = ", q2.to_string ());

q1.from_binary_string("5.0", 16);
q2.from_binary_string("2.8p2", 16);
putln ("q1 = ", q1.to_string ());
putln ("q2 = ", q2.to_string ());

putln ("q1 + q2 = ", q1.add (q2).to_string ());
putln ("q1 - q2 = ", q1.subtract (q2).to_string ());
putln ("q2 - q1 = ", q2.subtract (q1).to_string ());
putln ("q1 * q2 = ", q1.multiply (q2).to_string ());
putln ("q1 / q2 = ", q1.divide (q2).to_string ());
putln ("q1 == q2 = ", q1.eq (q2));
putln ("q1 != q2 = ", q1.ne (q2));
putln ("q1 < q2 = ", q1.lt (q2));
putln ("q1 <= q2 = ", q1.le (q2));
putln ("q1 > q2 = ", q1.gt (q2));
putln ("q1 >= q2 = ", q1.ge (q2));

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

try {
  var q3 = ieees.quad ();
  put (q1.to_string (), " / ", q3.to_string (), " ...");
  q1.divide (q3);
} catch (ieee_zero_division_except) {
  putln ("  got zero_division");
}

{
  var q3 = ieees.quad (), st, res;
  ieees.ignore_excepts = 1;
  put (q1.to_string (), " / ", q3.to_string (), " = ");
  res = q1.divide (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.dz);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ("3");
  put (q1.to_string (), " / ", q3.to_string (), " ...");
  q1.divide (q3);
} catch (ieee_imprecise_result_except) {
  putln ("  got imprecise result");
}

{
  var q3 = ieees.quad ("3"), st, res;
  ieees.ignore_excepts = 1;
  put (q1.to_string (), " / ", q3.to_string (), " = ");
  res = q1.divide (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.imp);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ();
  q3.pmax ();
  put (q3.to_string (), " + ", q3.to_string (), " ...");
  q3.add (q3);
} catch (ieee_overflow_except) {
  putln ("  got overflow");
}

{
  var q3 = ieees.quad (), st, res;
  ieees.ignore_excepts = 1;
  q3.pmax ();
  put (q3.to_string (), " + ", q3.to_string (), " = ");
  res = q3.add (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ofl);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ();
  q3.pmin ();
  put (q3.to_string (), " / 10 ...");
  q3.divide (ieees.quad ("10"));
} catch (ieee_underflow_except) {
  putln ("  got underflow");
}

{
  var q3 = ieees.quad (), st, res;
  q3.pmin ();
  ieees.ignore_excepts = 1;
  put (q3.to_string (), " / 10 = ");
  res = q3.divide (ieees.quad ("10"));
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ufl);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ("SNaN");
  put (q3.to_string (), " + ", q3.to_string (), " ...");
  q3.add (q3);
} catch (ieee_invalid_operation_except) {
  putln ("  got invalid operation");
}

{
  var q3 = ieees.quad ("SNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (q3.to_string (), " + ", q3.to_string (), " = ");
  res = q3.add (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.inv);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ("QNaN");
  put (q3.to_string (), " + ", q3.to_string (), " ...");
  q3.add (q3);
} catch (ieee_reserved_operand_except) {
  putln ("  got reserved operand");
}

{
  var q3 = ieees.quad ("QNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (q3.to_string (), " + ", q3.to_string (), " = ");
  res = q3.add (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ro);
  ieees.ignore_excepts = 0;
}

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("trap mask = ", ieees.get_trap_mask ());

ieees.set_trap_mask (ieees.inv|ieees.ro|ieees.ofl
		     |ieees.ufl|ieees.imp|ieees.dz);
putln ("trap mask = ", ieees.get_trap_mask ());

var q3 = ieees.quad ();
put (q1.to_string (), " / ", q3.to_string (), " = ");
putln (q1.divide (q3).to_string ());

q3 = ieees.quad ("3");
put (q1.to_string (), " / ", q3.to_string (), " = ");
putln (q1.divide (q3).to_string ());

q3 = ieees.quad ();
q3.pmax ();
put (q3.to_string (), " + ", q3.to_string (), " = ");
putln (q3.add (q3).to_string ());

q3 = ieees.quad ();
q3.pmin ();
put (q3.to_string (), " / 10 = ");
putln (q3.divide (ieees.quad ("10")).to_string ());

q3 = ieees.quad ("SNaN");
put (q3.to_string (), " + ", q3.to_string (), " = ");
putln (q3.add (q3).to_string ());

q3 = ieees.quad ("QNaN");
put (q3.to_string (), " + ", q3.to_string (), " = ");
putln (q3.add (q3).to_string ());

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("round = ", ieees.get_round ());

q3 = ieees.quad ("1.23456789012345678901234567890123456");
q1 = ieees.quad ("0.00000000000000000000000000000000015");
putln (q3.to_string (), " + ", q1.to_string (), " = ",
       q3.add (q1).to_string ());

ieees.set_round (ieees.rni);
putln ("round = ", ieees.get_round ());

q3 = ieees.quad ("1.23456789012345678901234567890123456");
q1 = ieees.quad ("0.00000000000000000000000000000000015");
putln (q3.to_string (), " + ", q1.to_string (), " = ",
       q3.add (q1).to_string ());

ieees.set_round (ieees.rpi);
putln ("round = ", ieees.get_round ());

q3 = ieees.quad ("1.23456789012345678901234567890123456");
q1 = ieees.quad ("0.00000000000000000000000000000000015");
putln (q3.to_string (), " + ", q1.to_string (), " = ",
       q3.add (q1).to_string ());

ieees.set_round (ieees.rz);
putln ("round = ", ieees.get_round ());

q3 = ieees.quad ("1.23456789012345678901234567890123456");
q1 = ieees.quad ("0.00000000000000000000000000000000015");
putln (q3.to_string (), " + ", q1.to_string (), " = ",
       q3.add (q1).to_string ());

try {
  ieees.set_round (6);
} catch (ieee_round_value_except) {
  putln ("  got invalid round value");
}

q1 = ieees.quad ("5");
var mq = q1.to_mpi (4);
putln ("mq (from q1) = ", mpis.to_string (mq));
q1.from_mpi (mq);
putln ("q1 (from mq) = ", q1.to_string ());

// Transformation single -> double -> quad

d1 = s1.to_double ();
putln ("single ", s1.to_string (), " -> double ", d1.to_string ());
q1 = s1.to_quad ();
putln ("single ", s1.to_string (), " -> quad ", q1.to_string ());

s1 = d1.to_single ();
putln ("double ", d1.to_string (), " -> single ", s1.to_string ());
q1 = d1.to_quad ();
putln ("double ", d1.to_string (), " -> quad ", q1.to_string ());

s1 = q1.to_single ();
putln ("quad ", q1.to_string (), " -> single ", s1.to_string ());
d1 = q1.to_double ();
putln ("quad ", q1.to_string (), " -> double ", d1.to_string ());
TEST453
        if uname | fgrep CYGWIN; then
            echo '      ' $DINO -L./d_ieee.dll -L./d_mpi.dll -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -Lieee.dll -Lmpi.dll -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT453' && $CMP $stdout $ftemp2; then
*******IEEE singles:**********
pzero s1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero s1=+0
pzero s2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero s2=+0
-zero s1=-0 s1 is -zero = 1
nan s1=QNaN s1 is nan = 1
trap nan s1=SNaN s1 is trap nan = 1
+infinity s1=+Inf s1 is +infinity = 1
-infinity s1=-Inf s1 is -infinity = 1
+max s1 (10, 16)=3.40282347e38, 1.fffffep127 s1 is norm = 1
-max s1 (10, 16)=-3.40282347e38, -1.fffffep127 s1 is norm = 1
+min s1 (10, 16)=1.40129846e-45, 1.p-149 s1 is denorm = 1
-min s1 (10,16)=-1.40129846e-45, -1.p-149 s1 is denorm = 1
s1 (10,2,4,8,16)= 5.00000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
s2 = 1.00000000e1
s1 = 5.00000000
s2 = 1.00000000e1
s1 = 5.00000000
s2 = 1.00000000e1
s1 + s2 = 1.50000000e1
s1 - s2 = -5.00000000
s2 - s1 = 5.00000000
s1 * s2 = 5.00000000e1
s1 / s2 = 5.00000000e-1
s1 == s2 = 0
s1 != s2 = 1
s1 < s2 = 1
s1 <= s2 = 1
s1 > s2 = 0
s1 >= s2 = 0
sticky status bits = 0
5.00000000 / +0 ...  got zero_division
5.00000000 / +0 = +Inf status bits = 32, 32
5.00000000 / 3.00000000 ...  got imprecise result
5.00000000 / 3.00000000 = 1.66666663 status bits = 16, 16
3.40282347e38 + 3.40282347e38 ...  got overflow
3.40282347e38 + 3.40282347e38 = +Inf status bits = 4, 4
1.40129846e-45 / 10 ...  got underflow
1.40129846e-45 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.00000000 / +0 = +Inf
5.00000000 / 3.00000000 = 1.66666663
3.40282347e38 + 3.40282347e38 = +Inf
1.40129846e-45 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.23456788 + 9.99999994e-9 = 1.23456788
round = 1
1.23456776 + 9.99999994e-9 = 1.23456776
round = 2
1.23456788 + 1.00000008e-8 = 1.23456800
round = 3
1.23456776 + 9.99999994e-9 = 1.23456776
  got invalid round value
ms (from s1) = 5
s1 (from ms) = 5.00000000
*******IEEE doubles:**********
pzero d1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero d1=+0
pzero d2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero d2=+0
-zero d1=-0 d1 is -zero = 1
nan d1=QNaN d1 is nan = 1
trap nan d1=SNaN d1 is trap nan = 1
+infinity d1=+Inf d1 is +infinity = 1
-infinity d1=-Inf d1 is -infinity = 1
+max d1 (10, 16)=1.7976931348623157e308, 1.fffffffffffffp1023 d1 is norm = 1
-max d1 (10, 16)=-1.7976931348623157e308, -1.fffffffffffffp1023 d1 is norm = 1
+min d1 (10, 16)=4.9406564584124654e-324, 1.p-1074 d1 is denorm = 1
-min d1 (10,16)=-4.9406564584124654e-324, -1.p-1074 d1 is denorm = 1
d1 (10,2,4,8,16)= 5.0000000000000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
d2 = 1.0000000000000000e1
d1 = 5.0000000000000000
d2 = 1.0000000000000000e1
d1 = 5.0000000000000000
d2 = 1.0000000000000000e1
d1 + d2 = 1.5000000000000000e1
d1 - d2 = -5.0000000000000000
d2 - d1 = 5.0000000000000000
d1 * d2 = 5.0000000000000000e1
d1 / d2 = 5.0000000000000000e-1
d1 == d2 = 0
d1 != d2 = 1
d1 < d2 = 1
d1 <= d2 = 1
d1 > d2 = 0
d1 >= d2 = 0
sticky status bits = 0
5.0000000000000000 / +0 ...  got zero_division
5.0000000000000000 / +0 = +Inf status bits = 32, 32
5.0000000000000000 / 3.0000000000000000 ...  got imprecise result
5.0000000000000000 / 3.0000000000000000 = 1.6666666666666667 status bits = 16, 16
1.7976931348623157e308 + 1.7976931348623157e308 ...  got overflow
1.7976931348623157e308 + 1.7976931348623157e308 = +Inf status bits = 4, 4
4.9406564584124654e-324 / 10 ...  got underflow
4.9406564584124654e-324 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.0000000000000000 / +0 = +Inf
5.0000000000000000 / 3.0000000000000000 = 1.6666666666666667
1.7976931348623157e308 + 1.7976931348623157e308 = +Inf
4.9406564584124654e-324 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234571
round = 1
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234569
round = 2
1.2345678901234569 + 4.0000000000000004e-16 = 1.2345678901234574
round = 3
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234569
  got invalid round value
md (from d1) = 5
d1 (from md) = 5.0000000000000000
*******IEEE quads:**********
pzero q1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero q1=+0
pzero q2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero q2=+0
-zero q1=-0 q1 is -zero = 1
nan q1=QNaN q1 is nan = 1
trap nan q1=SNaN q1 is trap nan = 1
+infinity q1=+Inf q1 is +infinity = 1
-infinity q1=-Inf q1 is -infinity = 1
+max q1 (10, 16)=1.18973149535723176508575932662800702e4932, 1.ffffffffffffffffffffffffffffp16383 q1 is norm = 1
-max q1 (10, 16)=-1.18973149535723176508575932662800702e4932, -1.ffffffffffffffffffffffffffffp16383 q1 is norm = 1
+min q1 (10, 16)=6.47517511943802511092443895822764655e-4966, 1.p-16494 q1 is denorm = 1
-min q1 (10,16)=-6.47517511943802511092443895822764655e-4966, -1.p-16494 q1 is denorm = 1
q1 (10,2,4,8,16)= 5.00000000000000000000000000000000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
q2 = 1.00000000000000000000000000000000000e1
q1 = 5.00000000000000000000000000000000000
q2 = 1.00000000000000000000000000000000000e1
q1 = 5.00000000000000000000000000000000000
q2 = 1.00000000000000000000000000000000000e1
q1 + q2 = 1.50000000000000000000000000000000000e1
q1 - q2 = -5.00000000000000000000000000000000000
q2 - q1 = 5.00000000000000000000000000000000000
q1 * q2 = 5.00000000000000000000000000000000000e1
q1 / q2 = 5.00000000000000000000000000000000000e-1
q1 == q2 = 0
q1 != q2 = 1
q1 < q2 = 1
q1 <= q2 = 1
q1 > q2 = 0
q1 >= q2 = 0
sticky status bits = 0
5.00000000000000000000000000000000000 / +0 ...  got zero_division
5.00000000000000000000000000000000000 / +0 = +Inf status bits = 32, 32
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 ...  got imprecise result
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 = 1.66666666666666666666666666666666673 status bits = 16, 16
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 ...  got overflow
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 = +Inf status bits = 4, 4
6.47517511943802511092443895822764655e-4966 / 10 ...  got underflow
6.47517511943802511092443895822764655e-4966 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.00000000000000000000000000000000000 / +0 = +Inf
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 = 1.66666666666666666666666666666666673
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 = +Inf
6.47517511943802511092443895822764655e-4966 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123475
round = 1
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123455
round = 2
1.23456789012345678901234567890123475 + 1.50000000000000000000000000000000015e-34 = 1.23456789012345678901234567890123494
round = 3
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123455
  got invalid round value
mq (from q1) = 5
q1 (from mq) = 5.00000000000000000000000000000000000
single 5.00000000 -> double 5.0000000000000000
single 5.00000000 -> quad 5.00000000000000000000000000000000000
double 5.0000000000000000 -> single 5.00000000
double 5.0000000000000000 -> quad 5.00000000000000000000000000000000000
quad 5.00000000000000000000000000000000000 -> single 5.00000000
quad 5.00000000000000000000000000000000000 -> double 5.0000000000000000
OUTPUT453
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
            echo '      ' $DINO -L./d_ieee.@EXTERN_LIB_SUFFIX@ -L./d_mpi.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -L./d_ieee.@EXTERN_LIB_SUFFIX@ -L./d_mpi.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT453' && $CMP $stdout $ftemp2; then
*******IEEE singles:**********
pzero s1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero s1=+0
pzero s2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero s2=+0
-zero s1=-0 s1 is -zero = 1
nan s1=QNaN s1 is nan = 1
trap nan s1=SNaN s1 is trap nan = 1
+infinity s1=+Inf s1 is +infinity = 1
-infinity s1=-Inf s1 is -infinity = 1
+max s1 (10, 16)=3.40282347e38, 1.fffffep127 s1 is norm = 1
-max s1 (10, 16)=-3.40282347e38, -1.fffffep127 s1 is norm = 1
+min s1 (10, 16)=1.40129846e-45, 1.p-149 s1 is denorm = 1
-min s1 (10,16)=-1.40129846e-45, -1.p-149 s1 is denorm = 1
s1 (10,2,4,8,16)= 5.00000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
s2 = 1.00000000e1
s1 = 5.00000000
s2 = 1.00000000e1
s1 = 5.00000000
s2 = 1.00000000e1
s1 + s2 = 1.50000000e1
s1 - s2 = -5.00000000
s2 - s1 = 5.00000000
s1 * s2 = 5.00000000e1
s1 / s2 = 5.00000000e-1
s1 == s2 = 0
s1 != s2 = 1
s1 < s2 = 1
s1 <= s2 = 1
s1 > s2 = 0
s1 >= s2 = 0
sticky status bits = 0
5.00000000 / +0 ...  got zero_division
5.00000000 / +0 = +Inf status bits = 32, 32
5.00000000 / 3.00000000 ...  got imprecise result
5.00000000 / 3.00000000 = 1.66666663 status bits = 16, 16
3.40282347e38 + 3.40282347e38 ...  got overflow
3.40282347e38 + 3.40282347e38 = +Inf status bits = 4, 4
1.40129846e-45 / 10 ...  got underflow
1.40129846e-45 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.00000000 / +0 = +Inf
5.00000000 / 3.00000000 = 1.66666663
3.40282347e38 + 3.40282347e38 = +Inf
1.40129846e-45 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.23456788 + 9.99999994e-9 = 1.23456788
round = 1
1.23456776 + 9.99999994e-9 = 1.23456776
round = 2
1.23456788 + 1.00000008e-8 = 1.23456800
round = 3
1.23456776 + 9.99999994e-9 = 1.23456776
  got invalid round value
ms (from s1) = 5
s1 (from ms) = 5.00000000
*******IEEE doubles:**********
pzero d1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero d1=+0
pzero d2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero d2=+0
-zero d1=-0 d1 is -zero = 1
nan d1=QNaN d1 is nan = 1
trap nan d1=SNaN d1 is trap nan = 1
+infinity d1=+Inf d1 is +infinity = 1
-infinity d1=-Inf d1 is -infinity = 1
+max d1 (10, 16)=1.7976931348623157e308, 1.fffffffffffffp1023 d1 is norm = 1
-max d1 (10, 16)=-1.7976931348623157e308, -1.fffffffffffffp1023 d1 is norm = 1
+min d1 (10, 16)=4.9406564584124654e-324, 1.p-1074 d1 is denorm = 1
-min d1 (10,16)=-4.9406564584124654e-324, -1.p-1074 d1 is denorm = 1
d1 (10,2,4,8,16)= 5.0000000000000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
d2 = 1.0000000000000000e1
d1 = 5.0000000000000000
d2 = 1.0000000000000000e1
d1 = 5.0000000000000000
d2 = 1.0000000000000000e1
d1 + d2 = 1.5000000000000000e1
d1 - d2 = -5.0000000000000000
d2 - d1 = 5.0000000000000000
d1 * d2 = 5.0000000000000000e1
d1 / d2 = 5.0000000000000000e-1
d1 == d2 = 0
d1 != d2 = 1
d1 < d2 = 1
d1 <= d2 = 1
d1 > d2 = 0
d1 >= d2 = 0
sticky status bits = 0
5.0000000000000000 / +0 ...  got zero_division
5.0000000000000000 / +0 = +Inf status bits = 32, 32
5.0000000000000000 / 3.0000000000000000 ...  got imprecise result
5.0000000000000000 / 3.0000000000000000 = 1.6666666666666667 status bits = 16, 16
1.7976931348623157e308 + 1.7976931348623157e308 ...  got overflow
1.7976931348623157e308 + 1.7976931348623157e308 = +Inf status bits = 4, 4
4.9406564584124654e-324 / 10 ...  got underflow
4.9406564584124654e-324 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.0000000000000000 / +0 = +Inf
5.0000000000000000 / 3.0000000000000000 = 1.6666666666666667
1.7976931348623157e308 + 1.7976931348623157e308 = +Inf
4.9406564584124654e-324 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234571
round = 1
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234569
round = 2
1.2345678901234569 + 4.0000000000000004e-16 = 1.2345678901234574
round = 3
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234569
  got invalid round value
md (from d1) = 5
d1 (from md) = 5.0000000000000000
*******IEEE quads:**********
pzero q1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero q1=+0
pzero q2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero q2=+0
-zero q1=-0 q1 is -zero = 1
nan q1=QNaN q1 is nan = 1
trap nan q1=SNaN q1 is trap nan = 1
+infinity q1=+Inf q1 is +infinity = 1
-infinity q1=-Inf q1 is -infinity = 1
+max q1 (10, 16)=1.18973149535723176508575932662800702e4932, 1.ffffffffffffffffffffffffffffp16383 q1 is norm = 1
-max q1 (10, 16)=-1.18973149535723176508575932662800702e4932, -1.ffffffffffffffffffffffffffffp16383 q1 is norm = 1
+min q1 (10, 16)=6.47517511943802511092443895822764655e-4966, 1.p-16494 q1 is denorm = 1
-min q1 (10,16)=-6.47517511943802511092443895822764655e-4966, -1.p-16494 q1 is denorm = 1
q1 (10,2,4,8,16)= 5.00000000000000000000000000000000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
q2 = 1.00000000000000000000000000000000000e1
q1 = 5.00000000000000000000000000000000000
q2 = 1.00000000000000000000000000000000000e1
q1 = 5.00000000000000000000000000000000000
q2 = 1.00000000000000000000000000000000000e1
q1 + q2 = 1.50000000000000000000000000000000000e1
q1 - q2 = -5.00000000000000000000000000000000000
q2 - q1 = 5.00000000000000000000000000000000000
q1 * q2 = 5.00000000000000000000000000000000000e1
q1 / q2 = 5.00000000000000000000000000000000000e-1
q1 == q2 = 0
q1 != q2 = 1
q1 < q2 = 1
q1 <= q2 = 1
q1 > q2 = 0
q1 >= q2 = 0
sticky status bits = 0
5.00000000000000000000000000000000000 / +0 ...  got zero_division
5.00000000000000000000000000000000000 / +0 = +Inf status bits = 32, 32
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 ...  got imprecise result
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 = 1.66666666666666666666666666666666673 status bits = 16, 16
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 ...  got overflow
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 = +Inf status bits = 4, 4
6.47517511943802511092443895822764655e-4966 / 10 ...  got underflow
6.47517511943802511092443895822764655e-4966 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.00000000000000000000000000000000000 / +0 = +Inf
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 = 1.66666666666666666666666666666666673
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 = +Inf
6.47517511943802511092443895822764655e-4966 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123475
round = 1
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123455
round = 2
1.23456789012345678901234567890123475 + 1.50000000000000000000000000000000015e-34 = 1.23456789012345678901234567890123494
round = 3
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123455
  got invalid round value
mq (from q1) = 5
q1 (from mq) = 5.00000000000000000000000000000000000
single 5.00000000 -> double 5.0000000000000000
single 5.00000000 -> quad 5.00000000000000000000000000000000000
double 5.0000000000000000 -> single 5.00000000
double 5.0000000000000000 -> quad 5.00000000000000000000000000000000000
quad 5.00000000000000000000000000000000000 -> single 5.00000000
quad 5.00000000000000000000000000000000000 -> double 5.0000000000000000
OUTPUT453
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
        fi
fi

# Test 454.
if test $result = ok -a $start_test_number -le 454; then
	echo test 454
        cat >$test_file <<'TEST454'
println (gmatch ("aa", "aaaaa"));
TEST454
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT454' && $CMP $stdout $ftemp2; then
[0, 2, 2, 4]
OUTPUT454
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 455.
if test $result = ok -a $start_test_number -le 455; then
	echo test 455
        cat >$test_file <<'TEST455'
println (gmatch ("aa", "aaaaa", 1));
TEST455
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT455' && $CMP $stdout $ftemp2; then
[0, 2, 1, 3, 2, 4, 3, 5]
OUTPUT455
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 456.
if test $result = ok -a $start_test_number -le 456; then
	echo test 456
        cat >$test_file <<'TEST456'
var i;
for (i = 0; i < 300000; i++)
  gmatch ("aa", "aaaaa", 1);
TEST456
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT456' && $CMP $stdout $ftemp2; then
OUTPUT456
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 457.
if test $result = ok -a $start_test_number -le 457; then
	echo test 457
        cat >$test_file <<'TEST457'
gmatch ("aa", "aaaaa", nil);
TEST457
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST457-1'; then
test.d:1:8: run time error - invalid parameter type of `gmatch'
TEST457-1
                result=ok
        else
                result=fail
        fi
fi

# Test 458.
if test $result = ok -a $start_test_number -le 458; then
	echo test 458
        cat >$test_file <<'TEST458'
gmatch ("aa");
TEST458
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST458-1'; then
test.d:1:8: run time error - unexpected number of parameters for `gmatch'
TEST458-1
                result=ok
        else
                result=fail
        fi
fi

# Test 459.
if test $result = ok -a $start_test_number -le 459; then
	echo test 459
        cat >$test_file <<'TEST459'
gmatch ("[aa", "aa");
TEST459
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST459-1'; then
test.d:1:8: run time error - unmatched bracket list operators in regexp
TEST459-1
                result=ok
        else
                result=fail
        fi
fi

# Test 460.
if test $result = ok -a $start_test_number -le 460; then
	echo test 460
        cat >$test_file <<'TEST460'
gmatch (nil, "aa");
TEST460
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST460-1'; then
test.d:1:8: run time error - invalid parameter type of `gmatch'
TEST460-1
                result=ok
        else
                result=fail
        fi
fi

# Test 461.
if test $result = ok -a $start_test_number -le 461; then
	echo test 461
        cat >$test_file <<'TEST461'
gmatch ("aa", nil);
TEST461
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST461-1'; then
test.d:1:8: run time error - invalid parameter type of `gmatch'
TEST461-1
                result=ok
        else
                result=fail
        fi
fi

# Test 462.
if test $result = ok -a $start_test_number -le 462; then
	echo test 462
        cat >$test_file <<'TEST462'
put (getf());
TEST462
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT462' && $CMP $stdout $ftemp2; then
abcd
OUTPUT462
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 463.
if test $result = ok -a $start_test_number -le 463; then
	echo test 463
        cat >$test_file <<'TEST463'
var c, f = open ("test.d", "r");
put (fgetf (f));
TEST463
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT463' && $CMP $stdout $ftemp2; then
var c, f = open ("test.d", "r");
put (fgetf (f));
OUTPUT463
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 464.
if test $result = ok -a $start_test_number -le 464; then
	echo test 464
        cat >$test_file <<'TEST464'
put (getf ());
put (getf ());
TEST464
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT464' && $CMP $stderr $ftemp2; then
test.d:2:11: run time error - EOF occured in `getf'
OUTPUT464
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 465.
if test $result = ok -a $start_test_number -le 465; then
	echo test 465
        cat >$test_file <<'TEST465'
var c, f=open ("test.d", "r");
for (;1;)
  put (fgetf (f));
TEST465
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT465' && $CMP $stderr $ftemp2; then
test.d:3:14: run time error - EOF occured in `fgetf'
OUTPUT465
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 466.
if test $result = ok -a $start_test_number -le 466; then
	echo test 466
        cat >$test_file <<'TEST466'
var c = getf (nil);
TEST466
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT466' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid parameter type of `getf'
OUTPUT466
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 467.
if test $result = ok -a $start_test_number -le 467; then
	echo test 467
        cat >$test_file <<'TEST467'
var c = fgetf ();
TEST467
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT467' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - unexpected number of parameters for `fgetf'
OUTPUT467
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 468.
if test $result = ok -a $start_test_number -le 468; then
	echo test 468
        cat >$test_file <<'TEST468'
var c = fgetf (nil);
TEST468
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT468' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid parameter type of `fgetf'
OUTPUT468
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 469.
if test $result = ok -a $start_test_number -le 469; then
	echo test 469
        cat >$test_file <<'TEST469'
var c = fgetf (stdin, nil);
TEST469
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT469' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid parameter type of `fgetf'
OUTPUT469
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 470.
if test $result = ok -a $start_test_number -le 470; then
	echo test 470
        cat >$test_file <<'TEST470'
println (char ('a'));
println (char ("97"));
TEST470
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT470' && $CMP $stdout $ftemp2; then
'a'
'a'
OUTPUT470
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 471.
if test $result = ok -a $start_test_number -le 471; then
	echo test 471
        cat >$test_file <<'TEST471'
println (int (10.0));
println (int ("10"));
TEST471
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT471' && $CMP $stdout $ftemp2; then
10
10
OUTPUT471
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 472.
if test $result = ok -a $start_test_number -le 472; then
	echo test 472
        cat >$test_file <<'TEST472'
println (float (10.5));
println (float ("10.5"));
println (float (10));
TEST472
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT472' && $CMP $stdout $ftemp2; then
10.5
10.5
10
OUTPUT472
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 473.
if test $result = ok -a $start_test_number -le 473; then
	echo test 473
        cat >$test_file <<'TEST473'
println (char (nil));
TEST473
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT473' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid type of operand of char (...)
OUTPUT473
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 474.
if test $result = ok -a $start_test_number -le 474; then
	echo test 474
        cat >$test_file <<'TEST474'
println (char (tab []));
TEST474
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT474' && $CMP $stderr $ftemp2; then
test.d:1:16: invalid operand type in char (...)
OUTPUT474
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 475.
if test $result = ok -a $start_test_number -le 475; then
	echo test 475
        cat >$test_file <<'TEST475'
println (char (300));
TEST475
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT475' && $CMP $stderr $ftemp2; then
test.d:1:10: system error - result too big (small): `int-to-char conversion'
OUTPUT475
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 476.
if test $result = ok -a $start_test_number -le 476; then
	echo test 476
        cat >$test_file <<'TEST476'
println (char ("3000000000000000000000000"));
TEST476
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT476' && $CMP $stderr $ftemp2; then
test.d:1:10: system error - result too big (small): `string-to-int conversion'
OUTPUT476
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 477.
if test $result = ok -a $start_test_number -le 477; then
	echo test 477
        cat >$test_file <<'TEST477'
println (int (nil));
TEST477
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT477' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid type of operand of int (...)
OUTPUT477
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 478.
if test $result = ok -a $start_test_number -le 478; then
	echo test 478
        cat >$test_file <<'TEST478'
println (int (tab []));
TEST478
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT478' && $CMP $stderr $ftemp2; then
test.d:1:15: invalid operand type in int (...)
OUTPUT478
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 479.
if test $result = ok -a $start_test_number -le 479; then
	echo test 479
        cat >$test_file <<'TEST479'
println (int ("3000000000000000000000000000"));
TEST479
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT479' && $CMP $stderr $ftemp2; then
test.d:1:10: system error - result too big (small): `string-to-int conversion'
OUTPUT479
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 480.
if test $result = ok -a $start_test_number -le 480; then
	echo test 480
        cat >$test_file <<'TEST480'
println (float (nil));
TEST480
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT480' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid type of operand of float (...)
OUTPUT480
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 481.
if test $result = ok -a $start_test_number -le 481; then
	echo test 481
        cat >$test_file <<'TEST481'
println (float (tab []));
TEST481
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT481' && $CMP $stderr $ftemp2; then
test.d:1:17: invalid operand type in float (...)
OUTPUT481
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 482.
if test $result = ok -a $start_test_number -le 482; then
	echo test 482
        cat >$test_file <<'TEST482'
println (float ("1e500"));
TEST482
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT482' && $CMP $stderr $ftemp2; then
test.d:1:10: system error - result too big (small): `string-to-float conversion'
OUTPUT482
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 483.
if test $result = ok -a $start_test_number -le 483; then
	echo test 483
        cat >$test_file <<'TEST483'
println (float ("1e-500"));
TEST483
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT483' && $CMP $stdout $ftemp2; then
0
OUTPUT483
                        result=ok
                else
                        result=fail
                fi
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT483-1' && $CMP $stderr $ftemp2; then
test.d:1:10: system error - result too big (small): `string-to-float conversion'
OUTPUT483-1
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 484.
if test $result = ok -a $start_test_number -le 484; then
	echo test 484
        cat >$test_file <<'TEST484'
putln (version);
TEST484
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                regex="^[0-9]\.[0-9]+$"
                echo '      ' egrep \'$regex\' $stdout
                if egrep "$regex" $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 485.
if test $result = ok -a $start_test_number -le 485; then
	echo test 485
        cat >$test_file <<'TEST485'
var objs_number = 0;
class object {
  priv var n = objs_number;
  objs_number++;
  putln ("creating ", n);
  priv fun destroy {objs_number--; putln ("destroying ", n);}
}

var i;
for (i = 0; i < 20; i++)
  object ();
gc ();
putln (objs_number);
TEST485
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT485' && $CMP $stdout $ftemp2; then
creating 0
creating 1
creating 2
creating 3
creating 4
creating 5
creating 6
creating 7
creating 8
creating 9
creating 10
creating 11
creating 12
creating 13
creating 14
creating 15
creating 16
creating 17
creating 18
creating 19
destroying 0
destroying 1
destroying 2
destroying 3
destroying 4
destroying 5
destroying 6
destroying 7
destroying 8
destroying 9
destroying 10
destroying 11
destroying 12
destroying 13
destroying 14
destroying 15
destroying 16
destroying 17
destroying 18
destroying 19
0
OUTPUT485
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 486.
if test $result = ok -a $start_test_number -le 486; then
	echo test 486
        cat >$test_file <<'TEST486'
put (sprint (nil));put (" ");
put (sprint (10));put (" ");
put (sprint (10.2e10));put (" ");
put (sprint ('c'));put (" ");
put (sprintln ("ssss"));
put (sprintln (["aaa", "bbb", "ccc"]));
put (sprintln (["v1", tab ["key":"val", tab ["key1":"val1"]]]));
fun f {}
put (sprintln (f));
class c {}
put (sprintln (c));
put (sprintln (c ()));
var stop;
stop = 0;
thread t {wait (stop);}
put (sprintln (t()));
wait (1) stop = 1;
TEST486
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT486' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+11 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", tab ["key":"val", tab ["key1":"val1"]:nil]]
fun f
class c
instance c()
thread 1 t()
OUTPUT486
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT486-1' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+011 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", tab ["key":"val", tab ["key1":"val1"]:nil]]
fun f
class c
instance c()
thread 1 t()
OUTPUT486-1
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT486-2' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+11 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", tab [tab ["key1":"val1"]:nil, "key":"val"]]
fun f
class c
instance c()
thread 1 t()
OUTPUT486-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT486-3' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+011 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", tab [tab ["key1":"val1"]:nil, "key":"val"]]
fun f
class c
instance c()
thread 1 t()
OUTPUT486-3
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 487.
if test $result = ok -a $start_test_number -le 487; then
	echo test 487
        cat >$test_file <<'TEST487'
put (sput (10));put (" ");
put (sput (10.2e20, " "));
put (sputln ('c', " ", "ssss"));
TEST487
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT487' && $CMP $stdout $ftemp2; then
10 1.02e+21 c ssss
OUTPUT487
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT487a' && $CMP $stdout $ftemp2; then
10 1.02e+021 c ssss
OUTPUT487a
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 488.
if test $result = ok -a $start_test_number -le 488; then
	echo test 488
        cat >$test_file <<'TEST488'
sputln (nil);
TEST488
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT488' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `sputln'
OUTPUT488
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 489.
if test $result = ok -a $start_test_number -le 489; then
	echo test 489
        cat >$test_file <<'TEST489'
sput ([10]);
TEST489
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT489' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `sput'
OUTPUT489
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 490.
if test $result = ok -a $start_test_number -le 490; then
	echo test 490: More error recovery with 2 
        cat >$test_file <<'TEST490'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_recovery (0);
p.set_grammar (g, 1);

var str = "a+a*(a*)+(*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

println (root);
exit (p.ambiguous_p);
TEST490
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT490' && $CMP $stdout $ftemp2; then
syntax error on token #7 (41) -- ignore 0 tokens starting with token #-1
nil
OUTPUT490
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 491.
if test $result = ok -a $start_test_number -le 491; then
	echo test 491: Parsing expression without lookahead
        cat >$test_file <<'TEST491'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
println (p.set_lookahead (0));
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
println (p.set_lookahead (1));
exit (p.ambiguous_p);
TEST491
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT491' && $CMP $stdout $ftemp2; then
1
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      $term(97, 5)
      mult(
        $term(97, 7)
        $term(97, 9)
      )
    )
  )
)
0
OUTPUT491
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 492.
if test $result = ok -a $start_test_number -le 492; then
	echo test 492: More parameter exception.
        cat >$test_file <<'TEST492'
var p = parser ();
p.set_lookahead ("0");
p.set_debug ("0");
p.set_lookahead (nil);
exit (0);
TEST492
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT492' && $CMP $stderr $ftemp2; then
test.d:4:17: run time error - invalid parameter type of `set_lookahead'
OUTPUT492
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 493.
if test $result = ok -a $start_test_number -le 493; then
	echo test 493: gethostinfo.
        cat >$test_file <<'TEST493'
include "socket";
var hi = sockets.gethostinfo (argv [0]);
println (hi.name, hi.aliases, hi.ipaddrs);
exit (0);
TEST493
        if uname | fgrep CYGWIN; then
            echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file 127.0.0.1 >$stdout"
            if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file 127.0.0.1 >$stdout; then
                echo '      ' egrep '^".+"\[.*\]\[".+"\]$' $stdout
                if egrep '^".+"\[.*\]\[".+"\]$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
            else
                result=fail
            fi
        else
            echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file 127.0.0.1 >$stdout"
            if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 127.0.0.1 >$stdout; then
                echo '      ' egrep '^".+"\[.*\]\[".+"\]$' $stdout
                if egrep '^".+"\[.*\]\[".+"\]$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
            else
                result=fail
            fi
	fi
fi

# Test 494.
if test $result = ok -a $start_test_number -le 494; then
	echo test 494: getservbyname.
        cat >$test_file <<'TEST494'
include "socket";

var s = sockets.getservbyname (argv[0], "tcp");
if (s != nil)
  println (s.name, s.aliases, s.port, s.proto);
exit (0);
TEST494
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '^".+"\[".+"\]37"tcp"$' $stdout
                if egrep '^".+"\[".+"\]37"tcp"$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '^".+"\[".+"\]37"tcp"$' $stdout
                if egrep '^".+"\[".+"\]37"tcp"$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 495.
if test $result = ok; then
	echo test 495: Skipping daytime udp.
elif test $result = ok -a $start_test_number -le 495; then
	echo test 495: daytime udp.
        cat >$test_file <<'TEST495'
include "socket";

var str, s = sockets.dgram_client ();
s.sendto ("get me date", "tock.usno.navy.mil", 13);
var d = s.recvfrom (300);
putln (d.str);
exit (0);
TEST495
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '^[A-Za-z]+ [A-Za-z]+ [0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9]' $stdout
                if egrep '^[A-Za-z]+ [A-Za-z]+ [0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9]' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '^[A-Za-z]+ [A-Za-z]+ [0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9]' $stdout
                if egrep '^[A-Za-z]+ [A-Za-z]+ [0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9]' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 496.
if test $result = ok -a $start_test_number -le 496; then
	echo test 496: daytime udp.
        cat >$test_file <<'TEST496'
include "socket";

var str, s = sockets.stream_client ("time.ien.it", 13);

str = "";
try {
  for (;;) {str @= s.read (20);}
} catch (socket_eof_except) {
}

putln (str);
exit (0);
TEST496
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '(^[A-Za-z]+ [A-Za-z]+[ ]+[0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9][0-9][0-9][0-9])|(^[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z0-9]+)' $stdout
                if egrep '(^[A-Za-z]+ [A-Za-z]+[ ]+[0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9][0-9][0-9][0-9])|(^[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z0-9]+)' $stdout; then
                        result=ok
                else
			cat $stdout
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '(^[A-Za-z]+ [A-Za-z]+[ ]+[0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9][0-9][0-9][0-9])|(^[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z0-9]+)' $stdout
                if egrep '(^[A-Za-z]+ [A-Za-z]+[ ]+[0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9][0-9][0-9][0-9])|(^[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z0-9]+)' $stdout; then
                        result=ok
                else
			cat $stdout
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 497.
if test $result = ok -a $start_test_number -le 497; then
	echo test 497: host is unknown
        cat >$test_file <<'TEST497'
include "socket";
var cl, send, rec, i;
cl = sockets.stream_client ("abracadabra", 10003);
exit (0);
TEST497
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file 2>$stderr"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file 2>$stderr >$stdout; then
                result=fail
        else
		sed 's,\\,/,g' $stderr|sed 's%^.*socket.d%@srcdir@/socket.d%' >$ftemp
                echo '      ' $CMP $ftemp $ftemp2
                if cat >$ftemp2 <<'OUTPUT497' && $CMP $ftemp $ftemp2; then
In file processed from test.d:1:18:
@srcdir@/socket.d:51:7: host is unknown
OUTPUT497
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT497-2' && $CMP $ftemp $ftemp2; then
In file processed from test.d:1:18:
@srcdir@/socket.d:47:45: connection timed out
OUTPUT497-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT497-3' && $CMP $ftemp $ftemp2; then
In file processed from test.d:1:18:
@srcdir@/socket.d:53:7: does not have an IP address
OUTPUT497-3
                        result=ok
                else
                        result=fail
                fi
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 2>$stderr"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 2>$stderr >$stdout; then
                result=fail
        else
		sed 's,\\,/,g' $stderr|sed 's%^.*socket.d%@srcdir@/socket.d%' >$ftemp
                echo '      ' $CMP $ftemp $ftemp2
                if cat >$ftemp2 <<'OUTPUT497-4' && $CMP $ftemp $ftemp2; then
In file processed from test.d:1:18:
@srcdir@/socket.d:51:7: host is unknown
OUTPUT497-4
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT497-5' && $CMP $ftemp $ftemp2; then
In file processed from test.d:1:18:
@srcdir@/socket.d:47:45: connection timed out
OUTPUT497-5
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT497-6' && $CMP $ftemp $ftemp2; then
In file processed from test.d:1:18:
@srcdir@/socket.d:53:7: does not have an IP address
OUTPUT497-6
                        result=ok
                else
                        result=fail
                fi
        fi
     fi
fi

# Test 498.
if test $result = ok -a $start_test_number -le 498; then
	echo test 498: Contexts and internal caches.
        cat >$test_file <<'TEST498'
class a (i, n) {
  fun ex {
    putln ("before = ", i);
    if (n != nil) n.ex ();
    putln ("after = ", i);
  }
}

var o = a (1, a (10, nil));

o.ex ();
TEST498
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT498' && $CMP $stdout $ftemp2; then
before = 1
before = 10
after = 10
after = 1
OUTPUT498
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 499.
if test $result = ok -a $start_test_number -le 499; then
	echo test 499: getservbyport.
        cat >$test_file <<'TEST499'
include "socket";

var s = sockets.getservbyport (argv [0] + 0, "tcp");
if (s != nil)
  println (s.name, s.aliases, s.port, s.proto);
exit (0);
TEST499
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file 37 >$stdout"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file 37 >$stdout; then
                echo '      ' test -z "\`cat $stdout\`" '|| egrep ^".+"\[".+"\]37"tcp"$' $stdout
                if test -z "`cat $stdout`" || egrep '^".+"\[".+"\]37"tcp"$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file 37 >$stdout"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 37 >$stdout; then
                echo '      ' test -z "\`cat $stdout\`" '|| egrep ^".+"\[".+"\]37"tcp"$' $stdout
                if test -z "`cat $stdout`" || egrep '^".+"\[".+"\]37"tcp"$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 500.
if test $result = ok -a $start_test_number -le 500; then
	echo test 500: getservbyname for unknown name.
        cat >$test_file <<'TEST500'
include "socket";

var s = sockets.getservbyname (argv[0], "tcp");
if (s != nil)
  println (s.name, s.aliases, s.port, s.proto);
exit (0);
TEST500
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file abracadabra >$stdout"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file abracadabra >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT500' && $CMP $stdout $ftemp2; then
OUTPUT500
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file abracadabra >$stdout"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file abracadabra >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT500a' && $CMP $stdout $ftemp2; then
OUTPUT500a
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 501.
if test $result = ok -a $start_test_number -le 501; then
	echo test 501: getservbyport for unknown port.
        cat >$test_file <<'TEST501'
include "socket";

var s = sockets.getservbyport (argv[0] + 0, "tcp");
if (s != nil)
  println (s.name, s.aliases, s.port, s.proto);
exit (0);
TEST501
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file 313131 >$stdout"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file 313131 >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT501' && $CMP $stdout $ftemp2; then
OUTPUT501
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file 313131 >$stdout"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 313131 >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT501a' && $CMP $stdout $ftemp2; then
OUTPUT501a
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 502.
if test $result = ok -a $start_test_number -le 502; then
	echo test 502: Final destroying by implicit program finish.
        cat >$test_file <<'TEST502'
class c {
  putln ("creating instance");
  fun destroy {putln ("destroying instance");}
}

var i = c ();
TEST502
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT502' && $CMP $stdout $ftemp2; then
creating instance
destroying instance
OUTPUT502
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 503.
if test $result = ok -a $start_test_number -le 503; then
	echo test 503: Final destroying by zero exit.
        cat >$test_file <<'TEST503'
class c {
  putln ("creating instance");
  fun destroy {putln ("destroying instance");}
}

var i = c ();
exit (0);
TEST503
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT503' && $CMP $stdout $ftemp2; then
creating instance
destroying instance
OUTPUT503
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 504.
if test $result = ok -a $start_test_number -le 504; then
	echo test 504: Final destroying by nonzero exit.
        cat >$test_file <<'TEST504'
class c {
  putln ("creating instance");
  fun destroy {putln ("destroying instance");}
}

var i = c ();
exit (1);
TEST504
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT504' && $CMP $stdout $ftemp2; then
creating instance
destroying instance
OUTPUT504
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 505.
if test $result = ok -a $start_test_number -le 505; then
	echo test 505: Final destroying by throw.
        cat >$test_file <<'TEST505'
class c {
  putln ("creating instance");
  fun destroy {putln ("destroying instance");}
}

var i = c ();
throw except ();
TEST505
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT505' && $CMP $stdout $ftemp2; then
creating instance
destroying instance
OUTPUT505
	           if cat >$ftemp2 <<'OUTPUT505a' && $CMP $stderr $ftemp2; then
test.d:7:1: run time error - exception except has not been processed
OUTPUT505a
                        result=ok
                   else
                        result=fail
                   fi
                else
                        result=fail
                fi
        fi
fi

# Test 506.
if test $result = ok -a $start_test_number -le 506; then
	echo test 506: Serhei\'s interpereter -- big program - 1500 lines.
	echo '      ' rm -rf $tempdir
	echo '      ' mkdir $tempdir
	if rm -rf $tempdir && mkdir $tempdir; then
	  echo '      ' Forming Grip interpriter files and test program in $tempdir
	  cat >$tempdir/anode_work.d <<'TEST506'
/***********************************************************
** These functions are used to translate a given object   **
** of class anode() to the equivalent object of class     **
** prog().                                                **
***********************************************************/
// For elaborate dumpings:
var dumpfl = 0;
fun bad_anode; fun parse_instruction_anode; fun check_block;
fun parse_expression_anode; fun flatten;
// Here is the function to parse a program anode. It is very trivial and
// is included for the client's convenience.
fun parse_program_anode (program_anode, local_dumpfl = 1) {
  // Initialize the dumpings.
  dumpfl = local_dumpfl;
  var object_program = prog (), intermediate_view;
  if (program_anode.name != "program") { // Wrong node.
    putln ("! Wrong grammar. Root anode name is : ", program_anode.name);
    bad_anode ();
  }
  if (dumpfl) putln ("& Entering translation phase.");
  intermediate_view =
  parse_instruction_anode (program_anode.transl[0]);
  // If we parsed a block, we return it as the object program so as to
  // have a bit of efficiency.
  if (intermediate_view. name == "block")
    object_program = intermediate_view.args[0];
  // Otherwise we copy the instruction.
  else object_program.exec = [intermediate_view];
  if (dumpfl)
    putln ("& Entering semantical checking phase.");
  object_program = check_block (object_program);
  if (dumpfl) {
    if (global_errfl) putln ("! Semantic check failed.");
    else putln ("& Semantic check sucessful.");
  }
  return object_program;
}
/* The function parse_instruction_anode() is used to parse an instruction. */
fun parse_instruction_anode (instruction_anode) {
  // We declare a variable to work on the result, which is an object of class
  // instr().
  if (dumpfl) {
    putln ("@ Initializing instruction parsing operation with node:");
    print_anode (instruction_anode);
  }
  var result = instr ();
  if (instruction_anode.name == "assign") { // Assignment statement.
    if (dumpfl) putln ("* Identified assignment statement.");
    result.name = "assign";
    result.args = [3 : nil];
    result.args [0] = instruction_anode.transl [0].transl [0].transl;
    result.args [2] = parse_expression_anode (instruction_anode.transl[1]);
    result.args [1] = (instruction_anode.transl [0].transl [0].transl.type0
                      == 'I' ?
                      instruction_anode.transl [0].transl :
                      bad_anode () );
    if (instruction_anode.transl [0].name == "array")
      result.args [1] = parse_expression_anode (instruction_anode.
                       transl [0].transl [1]);
    else if (instruction_anode.transl [0].name == "varac") {
      result.args [1] = expression ();
      result.args [1].opr = "num";
      result.args [1].opa1 = tok (0);
      // For compatibility with the semantic checker.
      result.args [1].opa1.type0 = "I";
      result.args [1].opa1.value = "0";
      result.args [1].opa2 = "integer";
    } else bad_anode ();
  } else if (instruction_anode.name == "vblock") {
    // Parse the block now.
    if (dumpfl) putln ("@ Initiating block parsing.");
    result.name = "block";
    result.args = [1 : nil];
    result.args [0] = prog ();
    // A block should be an object of class prog().
    // Process the declarations:
    if (dumpfl) putln ("@ Processing declarations...");
    var declarations = flatten (instruction_anode.transl[0], 2),
    current_identifier_declared_flag = new tab[];
    for (var current_declaration_processed = 0;
         current_declaration_processed < #declarations;
         current_declaration_processed++) {
      // "Flatten" the identifiers we want to declare.
      var identifiers_on_wait = flatten (
                                declarations [current_declaration_processed]
                              . transl[0], 1),
      // Analyze the specification.
      current_specification_analysis =
      component (declarations [current_declaration_processed]
                . transl [1]. transl [0],
                declarations [current_declaration_processed]
                . transl [1]. name);
      // We just assigned an object of class anode() where it is
      // not needed, so we must eradicate that.

      // Here we declare a shortcut variable used to declare arrays.
      var array_translation = current_specification_analysis.value;

      // Declare arrays here by deriving their size.
      if (current_specification_analysis.type0 != "constant")
        current_specification_analysis.arrfl +=
                      ( array_translation.name == "$nil" ? 0
                      : array_translation.name == "$term" ?
                        array_translation.transl.value
                      : bad_anode () ); // The grammar is corrupted.
      current_specification_analysis.value =
                   ( current_specification_analysis.type0 == "constant" ?
                     +array_translation.transl.value
                   : array_translation.name == "$nil" ? 0
                   : [current_specification_analysis.arrfl : 0]
                   // For arrays.
                   );
      // Now that we have the specification, we may introduce the identifiers
      // into the environment.
      if (dumpfl) putln ("@ Declaring identifiers...");
      for (var current_identifier_processing = 0;
           current_identifier_processing < #identifiers_on_wait;
           current_identifier_processing++) {
        if (identifiers_on_wait [current_identifier_processing]
           . transl [0].transl in current_identifier_declared_flag) {
          if (dumpfl) putln ("! Identifier declared twice.");
          put (program_file, ":",
               identifiers_on_wait [current_identifier_processing]
               . transl [0].transl.line_num, ":", identifiers_on_wait
               [current_identifier_processing]. transl [0].transl.char_num,
               ": ");
          grip_error ("Attempt to declare an identifier twice.");
        }
        result.args [0].vartable
        [identifiers_on_wait [current_identifier_processing]
        . transl [0].transl] = new current_specification_analysis;
        // Now we make a note of the fact that we have just declared the
        // identifier to solve the fact that the semantic checker that is
        // applied later to the block has no way of knowing that we attempted
        // to declare an identifier twice, so we check it right now.
        current_identifier_declared_flag
        [identifiers_on_wait
        [current_identifier_processing].transl [0].transl] = 1;
      }
    }
    // In case we stumble on a wrong node.
    /* The rest is pretty easy sailing. All we have to do now
    is let the instructions be parsed, and convert tokens in the table to
    strings. */
    var current_declaration, declarations_to_convert =
    keys (result.args [0].vartable);
    if (dumpfl) putln ("* Convert values : ",
                       sprint (declarations_to_convert));
    for (var current_declaration_num = 0;
         current_declaration_num < #declarations_to_convert;
         current_declaration_num++) {
      current_declaration = declarations_to_convert [current_declaration_num];
      if (dumpfl)
        putln ("* Conversion of ",
               sprint (current_declaration));
      if (type (current_declaration) == obj) {
        if (dumpfl)
          putln ("* Conversion worthy to ",
                 sprint (current_declaration.value));
        result.args [0].vartable [current_declaration.value] =
        result.args [0].vartable [current_declaration];
        result.args [0].vartable =
        del (result.args [0].vartable, current_declaration);
      } else if (dumpfl) putln ("* Conversion unworthy.");
    }
    if (dumpfl) {
      putln ("* Result variables :");
      println (result.args [0].vartable);
      putln ("@ Parsing the instructions...");
    }
    var instructions = flatten (instruction_anode.transl [1],
                                1);
    // We recursively call parse_instruction_anode() for each instruction.
    for (var current_instruction_number = 0;
         current_instruction_number < #instructions;
         current_instruction_number++) {
      result.args [0].exec @=
      [parse_instruction_anode (instructions [current_instruction_number].
                               transl [0])];
    }
    fun redeclare_block;
    // Now we must declare the configuration of variables here for the
    // other blocks.
    if (dumpfl) putln ("@ Redeclaring underlying blocks...");
    result.args [0] = redeclare_block (result.args [0]);
    fun redeclare_block (block) {
      fun do_redeclaration (block_to_redeclare) {
        // We have a block we need to define with synchronized variables.
        var current_identifier_processed_key;
        for (current_identifier_processed_key in block.vartable)
          if (!(current_identifier_processed_key
	        in block_to_redeclare.vartable)) {
            block_to_redeclare.vartable [current_identifier_processed_key] =
            block.vartable [current_identifier_processed_key];
          }
          redeclare_block (block_to_redeclare);
      }
      fun do_instruction (instr) {
        if (instr.name == "block") {
          do_redeclaration (instr.args [0]);
        } else if (instr.name == "for") {
          do_instruction (instr.args [0]);
          do_instruction (instr.args [2]);
          do_instruction (instr.args [3]);
        } else if (instr.name == "cond") {
          for (var current_alternative_processing = 1;
               current_alternative_processing < #instr.args;
               current_alternative_processing += 2)
            do_instruction (instr.args [current_alternative_processing]);
        }
      }
      try {
        for (var current_candidate_number = 0;
             current_candidate_number < #block.exec;
             current_candidate_number++)
          do_instruction (block.exec [current_candidate_number]);
      } catch ( error ) {
        if (dumpfl) putln ("! Synchronization of declarations failed.");
        bad_anode();
      }
      return block;
    }
    if (dumpfl) putln ("@ Block parsing over.");
    // Now we are done with our work on the block.
  } else if (instruction_anode.name == "condit") { // The GRIP conditional.
    /* In general, a GRIP conditional is written like this:
       'cond' '{'
        (<condition> <statement>)...
        ['else'      <statement>]
       '}'
       Not unlike the LISP version. */
       if (dumpfl) putln ("* Processing conditional.");
       // Do any initial poking around with the nodes:
       result = instr ();
       result.name = "cond";
       var option_list = flatten (instruction_anode.transl [0], 2);
       /* Now that we've done that, let's translate that conditional.
       Args[] for a cond statement look like this:
        [condition, statement,...]
       and the else part is represented by a expression evaluating to 1. */
       for (var current_option_number = 0;
            current_option_number < #option_list;
            current_option_number++) {
         var temp, current_parsed_option;
         if (option_list [current_option_number].name == "elsif")
           temp = parse_expression_anode (option_list [current_option_number].
                                          transl [0]);
         else if (option_list [current_option_number].name == "else") {
           temp = expression ();
           temp.opr = "num";
           temp.opa1 = tok (3);
           temp.opa1.type0 = 'I';
           temp.opa1.value = "1";
           temp.opa2 = "integer";
         } else bad_anode ();
         result.args @= [temp, parse_instruction_anode
                        (option_list [current_option_number].transl [1])];
       }
  } else if (instruction_anode.name == "foritr") {
  /* The GRIP for statement is exactly like the C one,
     except for the fact that a guard expression is REQUIRED.
     The internal representation is self-explanatory and represented
     by the tuple [initialization, guard, increment, body]. */
    // This is a quite trivial process:
    if (dumpfl) putln ("* For loop identified.");
    result.name = "for";
    result.args = [parse_instruction_anode (instruction_anode.transl [0]),
                   parse_expression_anode  (instruction_anode.transl [1]),
                   parse_instruction_anode (instruction_anode.transl [2]),
                   parse_instruction_anode (instruction_anode.transl [3])];
  /* The remaining commands are very trivial: The put statement, and the
     empty statement. */
  } else if (instruction_anode.name == "output") {
  /* The put statement outputs all its parameters with an additional newline
     character at the end. */
    // Trivial stuff first:
    if (dumpfl) putln ("* Analyzing output statement.");
    result.name = "put";
    var objects_on_wait_list = flatten (instruction_anode.transl [0],
                                        1);
    // Now, a loop to deal with every object we want to output.
    for (var current_object_processing = 0;
         current_object_processing < #objects_on_wait_list;
         current_object_processing++) {
      if (objects_on_wait_list [current_object_processing].name
          == "expressionel")
        result.args @= [parse_expression_anode
                       (objects_on_wait_list
                       [current_object_processing].transl [0])];
      else if (objects_on_wait_list [current_object_processing].name
               == "stringel") {
        var temp = expression ();
        temp.opr = "num";
        temp.opa1 = objects_on_wait_list [current_object_processing].transl[0]
                                         . transl;
        temp.opa2 = "string";
        result.args @= [temp];
      } else {
        if (dumpfl) putln ("! Wrong instruction node, name : ",               
                           instruction_anode.name);
        bad_anode ();
      }
    }
  } else if (instruction_anode.name == "$nil") {
    // The empty statement is represented by a nil-anode.
    if (dumpfl) putln ("* Conversion $nil -> empty statement.");
    result.name = "empty";
  /* If we get an unknown node, we finish with a fatal error message. */
  } else {
    if (dumpfl) putln ("! Unknown node name : ", instruction_anode.name);
    bad_anode ();
  }
  return result; // Now the result is returned.
}

fun parse_expression_anode (expression_anode) {
  /* This function parses an expression node into an object of
     class expression(). It can take both a factor and an expression. */
  if (dumpfl) {
    putln ("@ Initiating expression parsing with node :");
    print_anode (expression_anode);
  }
  // A variable on which to work and then return.
  var result = expression ();
  // For describing a factor.
  if (expression_anode.name == "factor") {
    if (dumpfl) putln ("* Identified a factor.");
    if (expression_anode.transl [0].name == "$term") { // Literal numbers.
      if (dumpfl) putln ("* Found literal number.");
      result.opr = "num";
      result.opa1 = expression_anode.transl [0].transl;
      result.opa2 = (expression_anode.transl [0].transl.value ==
                     int (expression_anode.transl [0].transl.value) ?
                     "integer" : "real");
    } else if (expression_anode.transl [0].name == "varac") {
      // Variable acessing.
      result.opr = "var";
      result.opa1 = expression_anode.transl [0].transl [0].transl;
      result.opa2 = expression ();
      result.opa2.opr = "num";
      result.opa2.opa1 = tok (3);
      result.opa2.opa1.type0 = 'N';
      result.opa2.opa1.value = "0";
      result.opa2.opa2 = "integer";
      if (dumpfl) putln ("* Parsed an variable reference.");
    } else if (expression_anode.transl [0].name == "array") {
      // Array referencing -- done by the same operator.
      result.opr = "var";
      result.opa1 = expression_anode.transl [0].transl [0].transl;
      result.opa2 = parse_expression_anode
      (expression_anode.transl [0].transl [1]);
      if (dumpfl) putln ("* Parsed an array reference.");
    } else if (expression_anode.transl [0].name == "expression" ||
               expression_anode.transl [0].name == "double" ||
               expression_anode.transl [0].name == "single") {
      // We have a parenthesized expression for which we just recursively
      // invoke parse_expression_anode().
      result = parse_expression_anode (expression_anode.transl [0]);
      if (dumpfl) putln ("* Processed parenthesized expression.");
    } else {
      if (dumpfl) putln ("! Bad node, name is ", expression_anode.name);
      bad_anode ();
    }
  } else if (expression_anode.name == "double") { // Binary operators.
    result.opr = (expression_anode.transl [1].transl.code == 21 ? // Plus.
                  "add" :
                  expression_anode.transl [1].transl.code == 22 ? // Minus.
                  "sub" :
                  expression_anode.transl [1].transl.code == 23 ? // Times.
                  "mul" :
                  expression_anode.transl [1].transl.code == 24 ?
                  // Division.
                  "div" :
                  expression_anode.transl [1].transl.code == 26 ?
                  // Logical or.
                  "or " :
                  expression_anode.transl [1].transl.code == 25 ?
                  // Logical and.
                  "and" :
                  expression_anode.transl [1].transl.code == 14 ?
                  "gtt" :
                  expression_anode.transl [1].transl.code == 13 ?
                  "ltt" :
                  expression_anode.transl [1].transl.code == 29 ?
                  "eqs" : bad_anode () );
    result.opa1 = parse_expression_anode (expression_anode.transl [0]);
    result.opa2 = parse_expression_anode (expression_anode.transl [2]);
    /* Now, for efficiency we replace ltt (A,B) by gtt (B,A). */
    if (result.opr == "ltt") {
        // Swap the operands.
        var temp = result.opa1;
        result.opa1 = result.opa2;
        result.opa2 = temp;
        // Rename the operator.
        result.opr = "gtt";
    }
  } else if (expression_anode.name == "single") {
    // To work on unary operators.
    if (expression_anode.transl [0].transl.code == 21) {
      // We have a unary plus operation that does not affect the operand.
      result = parse_expression_anode (expression_anode.transl [1]);
    } else {
      // Other possible operators include unary minus and negation (!).
      result.opr = ( expression_anode.transl [0].transl.code == 22 ?
                     // Unary minus.
                     "neg" :
                     expression_anode.transl [0].transl.code == 27 ?
                     // Logical negation.
                     "not" : bad_anode () );
      result.opa1 = parse_expression_anode (expression_anode.transl [1]);
    }
  } else if (expression_anode.name == "expression") {
    // This is a reference to a factor.
    result = parse_expression_anode (expression_anode.transl [0]);
  } else bad_anode ();
  return result;
}
       /**************************************************
       ** These are the functions to perform semantical **
       ** checking. The errors recognized are:          **
       ** 1. Attempt to declare identifier twice (found **
       ** at translation time).                         **
       ** 2. No such identifier declared.               **
       ** 3. Vector in a context expecting a scalar     **
       ** value.                                        **
       ** 4. Attempt to extract an element of a scalar  **
       ** value.                                        **
       ** 5. Attempt to assign to a constant.           **
       **************************************************/
// The function to check a block does nothing but introduce a name scope for
// its two internal functions and call check_instruction() for each statement.
fun check_block (block) {
  fun check_expression;
  /* check_block() has two internal functions that work on an instruction
     (check_instruction()) and expression (check_expression()). */
  fun check_instruction (instruction) {
    /* Most of the commands just cause invocations of other functions,
       but assignment finds four important semantic errors (see #2-5). */
    // Most important parts first this time.
    if (instruction.name == "assign") {
      if (dumpfl) putln ("* Checking an assignment statement.");
      /* First, check for error #2. */
      if (!(instruction.args [0].value in block.vartable)) {
        put (program_file, ":", instruction.args [0].line_num, ":",
        instruction.args [0].char_num, ": ");
        grip_error ("No such variable declared.");
      } else {
        /* If these would have appeared after the conditional, !keyvalue would
           be generated, which is undesirable. */
        /* Now, we may check for error #3. */
//        if (type (block.vartable [instruction.args [0].value].value)
//            == vec 
//            && instruction.args [1].opr == "num" &&
//            int (instruction.args [1].opa1.value) == 0) {
//          put (program_file, ":", instruction.args [0].line_num, ":",
//               instruction.args [0].char_num, ": ");
//          grip_error ("Structured value in scalar context.");
//        }
//        /* Lastly, error #4 must be checked. "elsif" is used for efficiency. */
//        else
        if (type (block.vartable [instruction.args [0].value].value) !=
                 vec &&
                 instruction.args [1].opr != "num" &&
                 int (instruction.args [1].opa1.value) != 0) {
          put (program_file, ":", instruction.args [0].line_num, ":",
               instruction.args [0].char_num, ": ");
          grip_error ("Attempt to reference element of scalar value.");
        } else if (block.vartable [instruction.args [0].value].type0 ==
                   "constant") {
          put (program_file, ":", instruction.args [0].line_num, ":",
               instruction.args [0].char_num, ": ");
          grip_error ("Attempt to assign to a constant.");
        }
      }
      // Here, we change the token to its value field.
      instruction.args [0] = instruction.args [0].value;
      // Now, we invoke check_expression to check two of the expressions:
      instruction.args [1] = check_expression (instruction.args [1]);
      instruction.args [2] = check_expression (instruction.args [2]);
      // Now we are done with our work.
    } else if (instruction.name == "put") {
      if (dumpfl) putln ("* Checking a put statement.");
    /* Here we just invoke check_expression() for every expression. */
      for (var current_object_num = 0;
           current_object_num < #instruction.args;
           current_object_num++) {
       instruction.args [current_object_num] =
        check_expression (instruction.args [current_object_num]);
      }
    } else if (instruction.name == "empty") {
      if (dumpfl) putln ("* Checking an empty statement.");
      // The empty statement is automatically correct.
    /* All the recursion is done by the statements that are structured. */
    } else if (instruction.name == "cond") {
      // Here we juct iterate through all the possible alternatives,
      // verifying whether each is correct.
      for (var current_alternative_num = 0;
           current_alternative_num < #instruction.args;
           current_alternative_num += 2) {
        instruction.args [current_alternative_num] =
        check_expression (instruction.args [current_alternative_num]);
        instruction.args [current_alternative_num + 1] =
        check_instruction (instruction.args [current_alternative_num + 1]);
      }
    } else if (instruction.name == "for") {
      // Here, it is even more basic.
      if (dumpfl) putln ("* Checking a for loop.");
      instruction.args [0] = check_instruction (instruction.args [0]);
      instruction.args [2] = check_instruction (instruction.args [2]);
      instruction.args [3] = check_instruction (instruction.args [3]);
      instruction.args [1] = check_expression  (instruction.args [1]);
    } else if (instruction.name == "block") {
      /* The block statement is resolved by a recursive invocation of
         check_block(). */
      instruction.args [0] = check_block (instruction.args [0]);
    } else fatal_error ("Internal error in translator.");
    if (dumpfl) {
      putln ("* Checked instruction, value :");
      print_instruction (instruction);
    }
    return instruction;
  }
  /* This function is used to check an expression and replace all tokens with
     corresponding values. */
  fun check_expression (expression) {
    /* Let us discuss the values that we need to check. Our errors
       shall be found all in one operator: var. Its internal representation
       is as follows:
       | opr   | opa1  | opa2    |
       +-------+-------+---------+
       | "var" | IDENT | ELEMENT |
       As you can see, it acts both as a reference to a scalar value
       and a vector. The other operators are trivial:
       num : don't do anything.
       neg, not : check opa1 only.
       Otherwise, we check both operands. */
    if (expression.opr == "num") { // Don't do anything except replace tokens:
      expression.opa1 = expression.opa1.value;
    } else if (expression.opr == "neg" ||
               expression.opr == "not") { // Check opa1:
      expression.opa1 = check_expression (expression.opa1);
    } else if (expression.opr == "var") { // Check for 
      /* The same errors are fixed here as the ones in the assignment
         statement. In fact, almost the same procedure is used here,
         except that we do only one recursive invokation at the end, and we
         work on a different domain of objects. For a more detailed explanation
         of the algorithm's quirks, see the procedure for assignment.*/
      if (!(expression.opa1.value in block.vartable)) {
        put (program_file, ":", expression.opa1.line_num, ":0: ");
        grip_error ("No such variable declared.");
      } else {
        /* Check for error #3. */
//        if (type (block.vartable [expression.opa1.value].value) == vec &&
//            expression.opa2.opr == "num" &&
//            int (expression.opa2.opa1.value) == 0) {
//          put (program_file, ":", expression.opa1.line_num, ":0: ");
//          grip_error ("Structured value in scalar context.");
//        }
//        else
          if (type (block.vartable [expression.opa1.value].value) !=
                 vec &&
                 expression.opa2.opr != "num" &&
                 int (expression.opa2.opa1.value) != 0) {
          put (program_file, ":", expression.opa1.value, ":0: ");
          grip_error ("Scalar value in structured context.");
        }
      }
      expression.opa1 = expression.opa1.value;
      expression.opa2 = check_expression (expression.opa2);
    } else { // A binary operator. Recursively invoke check_expression():
      expression.opa1 = check_expression (expression.opa1);
      expression.opa2 = check_expression (expression.opa2);
    }
    return expression;
  }
  if (dumpfl) putln ("@ Initiating block checking.");
  /* The main body of the function is quite trivial and consists of just a
     for-loop. Also, we must process the declarations. */
  for (var current_instruction_num = 0;
       current_instruction_num < #block.exec;
       current_instruction_num++)
    block.exec [current_instruction_num] =
    check_instruction (block.exec [current_instruction_num]);
  // Process the declarations.
  var current_declaration;
  return block;
}
/* What we have left now is a couple of common tasks I found to be
   easier to put in separate functions. */
// When an anode that is not supposed to turn up turns up, we finish
// with a diagnostic message.
fun bad_anode {
  fatal_error ("Grammar 'grip.g' corrupted or internal error.");
}
// For flattening recursive lists. This is so easily encoded in functional
// programming languages like ML! Wish I could use it here, but the SPI
// doesn't allow it.
fun flatten (list_anode_to_flatten, next_num) {
  if (dumpfl) {
    putln ("@ Executing flatten operation with:");
    println (list_anode_to_flatten.transl);
    print_anode (list_anode_to_flatten);
  }
  return // Last element or not?
         (list_anode_to_flatten.name != "$nil" ?
          [list_anode_to_flatten] @
          flatten (list_anode_to_flatten.transl [next_num], next_num) : []);
}
TEST506
	  cat >$tempdir/error.d <<'TEST506a'
/* If an error arises, this function shall perform the necessary dumping, and
   increment global_errfl. Other procedures check this variable occasionally,
   and if it isn't zero, call abend(). */
var global_errfl = 0;

fun grip_error (message, ...) {
  putln ("Error : ", message); // Print a general description of the problem.
  // Do any dumping necessary to roughly locate the problem.
  if (#args != 0)
    for (var i = 0; i < #args; i++)
      try {putln(args[i]);} catch ( partype)
          {println(args[i]);}
  global_errfl++; // Increment the global error counter.
}

// For fatal errors :
fun fatal_error (message, ...) {
  putln ("Fatal Error : ", message);
  if (#args != 0)
    for (var i = 0; i < #args; i++)
      try {putln (args[i]);}
      catch ( partype)
          {println (args[i]);}
  exit (3);
}

// To assist with abnormal endings.

fun abend (message) {
  putln (global_errfl, message, "error" @ (global_errfl == 1 ? "." : "s."));
  exit (2);
}

// To print out abstract nodes in a readable manner:

fun print_anode (node_to_print, tablevel = 0, tabchar = ' ') {
  for (var i = 0; i < tablevel; i++) put (tabchar);
  put (node_to_print.name, " ");
  if (node_to_print.name == "$nil") println ();
  else if (node_to_print.name == "$term")
    putln (node_to_print.transl.code, ":",
           node_to_print.transl.type0, ":",
           sprint (node_to_print.transl.value));
  else {
    putln ("(");
    for (i = 0; i < #node_to_print.transl; i++)
      print_anode (node_to_print.transl [i], tablevel + 2, tabchar);
    for (i = 0; i < tablevel; i++) put (tabchar);
    putln (")");
  }
}

// For printing objects of class expr().

fun print_expression (expr, tablevel = 0, tabchar = ' ') {
  for (var i = 0; i < tablevel; i++) put (tabchar);
  if (expr == nil) return;
  if (expr.opr == "num") putln (sprint (expr.opa1), " : ", sprint (expr.opa2));
  else if (expr.opr == "var") {
    put ("$", sprint (expr.opa1));
    if (!(expr.opa2.opr == "num" && expr.opa2.opa1 == "0")) {
      putln (" [");
      print_expression (expr.opa2, tablevel + 2, tabchar);
      for (i = 0; i < tablevel; i++) put (tabchar);
      putln ("]");
    } else putln ();
  } else {
    putln (expr.opr, " (");
    print_expression (expr.opa1, tablevel + 2, tabchar);
    print_expression (expr.opa2, tablevel + 2, tabchar);
    for (i = 0; i < tablevel; i++) put (tabchar);
    putln (")");
  }
}
// This function is used to print an instruction:
fun print_instruction (instruction, tablevel = 0, tabchar = ' ') {
  for (var i = 0; i < tablevel; i++) put (tabchar);
  if (instruction.name == "empty") putln ("-");
  else {
    put (instruction.name, " ");
    if (instruction.name == "block") {
      putln ("{");
      for (i in instruction.args [0].vartable) {
        for (var j = 0; j < tablevel + 2; j++) put (tabchar);
        putln ("$", sprint (i), " : ", instruction.args [0].vartable [i].type0,
               instruction.args [0].vartable [i].arrfl ?
               " [" @ instruction.args [0].vartable [i].arrfl @ "]" : "");
      }
      for (i = 0; i < #instruction.args [0].exec; i++)
        print_instruction (instruction.args [0].exec [i],
                           tablevel + 2, tabchar);
      for (i = 0; i < tablevel; i++) put (tabchar);
      putln ("}");
    } else if (instruction.name == "for") {
      putln ();
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      putln ("Initialization : ");
      print_instruction (instruction.args [0], tablevel + 2, tabchar);
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      putln ("---");
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      putln ("Condition : ");
      print_expression (instruction.args [1], tablevel + 2, tabchar);
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      putln ("Body : ");
      print_instruction (instruction.args [3], tablevel + 2, tabchar);
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      put ("Increment : ");
      print_instruction (instruction.args [2]);
    } else if (instruction.name == "cond") {
      putln ();
      for (i = 0; i < #instruction.args; i += 2) {
        print_expression  (instruction.args [i], tablevel + 2, tabchar);
        print_instruction (instruction.args [i + 1], tablevel + 2, tabchar);
        if (i < #instruction.args - 1) {
          for (var j = 0; j < tablevel; j++) put (tabchar);
          putln ("---");
        }
      }
    } else if (instruction.name == "assign") {
      put ("$", sprint (instruction.args [0]));
      if (!(instruction.args [1].opr == "num" &&
            instruction.args [1].opa1 == "0")) {
        putln (" [");
        print_expression (instruction.args [1], tablevel + 2, tabchar);
        for (i = 0; i < tablevel; i++) put (tabchar);
        putln ("]");
      } else putln ();
      print_expression (instruction.args [2], tablevel + 2, tabchar);
    } else if (instruction.name == "put") {
      putln ();
      for (i = 0; i < #instruction.args; i++)
        print_expression (instruction.args [i], tablevel + 2, tabchar);
      }
    }
}
TEST506a
	  cat >$tempdir/grip.d <<'TEST506b'
////////////////////////////////////////////////////////////////
// Grip 0.5s54 Designed and implemented by: Serhei Makarov.   //
// Special thanks to: Vladimir Makarov, for mentoring and     //
// moral support,                                             //
//                    Nadia Makarov, for moral support, and   //
//                    The person who invented ISPs, otherwise //
// I might not have gotten time to get such a head start in   //
// programming language design.                               //
////////////////////////////////////////////////////////////////

// GRIP 0.5 is a structured language roughly capable of performing
// algorhythmic calculations, e.g. a sieve for primes.
// WARNING : WE HAVE NOT IMPLEMENTED ANY INPUT DEVICES.

// Command line options :
//  -v
//  --verbose       Turns on dumpings at runtime.
//
//  -t
//  --parse-results Output the results of parsing.
//
//  -d
//  --full-parse    Output information about how
//                  the parse went.
//
//  -h
//  --help          Print possible command line
//                  options and quit.
//
//  -n
//  --version       Print version number and quit.
//
//  filename        Interpret 'filename'.
var verbose_flag = 0, debug_level = 0, file_name = "";

include "error"; // The error management package.
include "intrep"; // Interpretation package.
include "parser"; // Translation package.

var translator = grip_parser(), db_fl = 0;

// Db_fl is defined to find conflicting -td options and for -hn option usage.
// Find if we just want help.
if (#argv == 0) {
  putln ("No arguments found. Use 'grip --help' for help.");
  exit (0);
}
for (var argpos = 0; argpos < #argv; argpos++)
  if (argv[argpos] == "--help" ||
      argv[argpos] == "-h") {
    putln ("GRIP 0.5s54.");
    putln ("Usage: grip (option | filename)...");
    putln ("Options:");
    putln ("POSIX one character | GNU style long");
    putln (" -v                 | --verbose       : ",
           "Turn on dumpings at runtime.");
    putln (" -t                 | --parse-results : ",
           "Show the results of parsing.");
    putln (" -d                 | --full-parse    : ",
           "Show how the parse went.");
    putln (" -n                 | --version       : ",
           "Print version number and quit.");
    putln (" -h                 | --help          : ",
           "Show this screen.");
    putln ();
    putln ("Grip returns 0 on success, 2 on a non-fatal error, and");
    putln ("3 on a fatal error that prevents its functioning properly."); 
    exit (0);
  } else if (argv[argpos] == "-n" ||
             argv[argpos] == "--version") {
    putln ("GRIP 0.5s54 designed and implemented by Serhei V. Makarov.");
    putln ("Special thanks to:");
    putln ("                   Vladimir Makarov, for mentoring and");
    putln ("                   moral support, and");
    putln ("                   Nadia Makarov, for moral support.");
    exit (0);
  }
// Analyze argv[] to find out the filename needed.
for (argpos = 0; argpos < #argv; argpos++) {
  if (argv[argpos] == "-v" ||
      argv[argpos] == "--verbose") verbose_flag = 1;
  else if (argv[argpos] == "-t" ||
           argv[argpos] == "--parse-results") if (!db_fl) {
                debug_level = 2;
                db_fl++;
        } else grip_error ("Conflicting '-t' and '-d' options.");
  else if (argv[argpos] == "-d" ||
           argv[argpos] == "--full-parse") if (!db_fl) {
                debug_level = 5;
                db_fl++;
        } else grip_error ("Conflicting '-t' and '-d' options.");
  else if (argv[argpos] == "-" && file_name == "") file_name = "/dev/stdin";
  else if (file_name == "") file_name = argv[argpos];
  else grip_error ("Too many arguments or arguments invalid.");
}
if (file_name == "") grip_error ("No file name specified or file name invalid");
if (global_errfl) abend (" command line ");
// Translate and interpret.
var executable_program = 
translator.parse_file(file_name, debug_level, verbose_flag);
executable_program.execute (verbose_flag, verbose_flag, verbose_flag);
exit(0);
TEST506b
	  cat >$tempdir/grip.g <<'TEST506c'
TERM string = 1
      ident = 2
     number = 3
   programk = 4
        ddt = 5
   constant = 6
    integer = 7
       real = 8
       cond = 9
        for = 10
        put = 11
       else = 12
        lts = 13
        gts = 14
        lfp = 15
        rtp = 16
        lbr = 17
        rbr = 18
        lsb = 19
        rsb = 20
        pls = 21
        mns = 22
        str = 23
        fsl = 24
        amp = 25
        vrt = 26
        exc = 27
        smc = 28
        eqs = 29
        spc = 30
    invalid = 31;
program : programk ident statement # program (2)
statement : varac lts mns expression smc # assign (0 3)
          | lbr decl st_list rbr         # vblock (1 2)
          | cond lbr c_list              # condit (2)
          | for lfp statement expression smc statement rtp statement # foritr (2 3 5 7)
          | put p_list smc               # output (1)
          | smc                          # -
expression : expression dop factor # double (0 1 2)
           | uop factor            # single (0 1)
           | factor                # expression (0)
factor : varac              # factor (0)
       | number             # factor (0)
       | lfp expression rtp # factor (1)
dop : pls # 0
    | mns # 0
    | str # 0
    | fsl # 0
    | vrt # 0
    | amp # 0
    | eqs # 0
    | gts # 0
    | lts # 0
uop : pls # 0
    | mns # 0
    | exc # 0
decl : ident_list ddt specif smc decl # declare (0 2 4)
     |                                # -
ident_list : ident ident_list  # idl (0 1)
           |                   # -
specif : integer as      # integer (1)
       | real as         # real (1)
       | constant number # constant (1)
as : lsb number rsb # 1
   |                # -
st_list : statement st_list # st_list (0 1)
        |                   # -
c_list : expression statement c_list # elsif (0 1 2)
       | else statement rbr          # else (- 1 -)
       | rbr                         # -
p_list : expression p_list # expressionel (0 1)
       | string p_list     # stringel (0 1)
       |                   # -
varac : ident                    # varac (0)
      | ident lsb expression rsb # array (0 2)
TEST506c
	  cat >$tempdir/intrep.d <<'TEST506d'
// Here follows the internal representation of a GRIP program.
/* This is a variable cell class, designed for use with eval(). */
class component (value, type0) {
  var arrfl = 0;
}
/* This is a simple instruction definition, with a descriptor and arguments. */
class instr (){
  var name = "", args = [];
}
/* This is an expression class. Note that at most two operands are allowed. */
class expression (){
  var opr, opa1, opa2;
}

/******************************************************************************
** This is the definition for the actual internal representation of the      **
** program. Note that the high level structure is almost just an abstract    **
** form of the source code. There are only two variables: exec, which is     **
** a vector of instructions, and vartable, a table of component cells.       **
** This class also contains a virtual machine capable of executing the code. **
******************************************************************************/
class prog {
  var exec = []; // The executable code.
  var vartable = new tab [];
  // The environment, statically derived during translation.
  fun eval (expr, dumpfl = 0) { // The expression evaluator.
    var res; // The result is retained for debugging purposes.
    if (dumpfl) putln ("@ Initiating expression evaluator.");
    fun ovrlap (type1, type2) // A function to derive the type of the result. 
      { return type1 == "real" || type2 == "real" ? "real" : "integer"; }
    if (expr.opr == "num") res = component(expr.opa1,expr.opa2);
                           /* Expression is a single constant */
    else if (expr.opr == "var") {
      var index = eval (expr.opa2, dumpfl).value;

      res = vartable [expr.opa1];
      if (type (res.value) == vec) {
	//        println (index, "--", #res.value);
	if (index < 1 || index > #res.value) {
	  grip_error ("Runtime error : Array index out of bounds.");
	  exit (2);
	}
        res = component (res.value [index - 1], res.type0);
      }
    }
    // Variable reference.
    else if (expr.opr == "neg") // Unary minus.
      res = component (-eval (expr.opa1, dumpfl).value,
                        eval (expr.opa1, dumpfl).type0);
    else if (expr.opr == "add") // Addition.
      res = component (eval (expr.opa1, dumpfl).value +
                       eval (expr.opa2, dumpfl).value,
                       ovrlap (eval (expr.opa1, dumpfl).type0,
                               eval (expr.opa2, dumpfl).type0));
    else if (expr.opr == "sub") // Subtraction.
      res = component (eval (expr.opa1, dumpfl).value -
                       eval (expr.opa2, dumpfl).value,
                       ovrlap (eval (expr.opa1, dumpfl).type0,
                               eval (expr.opa2, dumpfl).type0));
    else if (expr.opr == "mul") // Multiplication.
      res = component (eval (expr.opa1, dumpfl).value *
                       eval (expr.opa2, dumpfl).value,
                       ovrlap (eval (expr.opa1, dumpfl).type0,
                               eval (expr.opa2, dumpfl).type0));
    else if (expr.opr == "div") {// Division.
      res = component (eval (expr.opa1, dumpfl).value /
                       eval (expr.opa2, dumpfl).value,
                       ovrlap (eval (expr.opa1, dumpfl).type0,
                               eval (expr.opa2, dumpfl).type0));
    }
    else if (expr.opr == "and") // Logical and.
      res = component (eval (expr.opa1, dumpfl).value &&
                       eval (expr.opa2, dumpfl).value,
                       "integer");
    else if (expr.opr == "or ") // Logical or.
      res = component (eval (expr.opa1, dumpfl).value ||
                       eval (expr.opa2, dumpfl).value,
                       "integer");
    else if (expr.opr == "not") // Logical negation
      res = component (!eval (expr.opa1, dumpfl).value, "integer");
    else if (expr.opr == "gtt") // Greater than.
      res = component (eval (expr.opa1, dumpfl).value >
                       eval (expr.opa2, dumpfl).value,
                       "integer");
    // The lack of a less than operation is for the fact that x<y <=> y>x.
    else if (expr.opr == "eqs") // Equals.
      res = component (eval (expr.opa1, dumpfl).value ==
                       eval (expr.opa2, dumpfl).value,
                       "integer");
    else {
      // If opr is not one of the specified operations, then there is an
      // error in the coding.
      putln ("Fatal Error : Internal error in expression generator :");
      print_expression (expr);
    }
    if (dumpfl) { // Dumping.
      putln ("* Expression Dumping:\n", sprint (res.value), " : ",
             sprint (res.type0));
      if (expr.opr != "num") print_expression (expr);
      putln ();
    }
    return res; // Now the result is made available to the client function.
  }
  /***********************************************************************
  ** This is the actual execution function. It invokes execinstr(), a   **
  ** function internal to execute(), which may recursively invoke       **
  ** itself, eval(), and execute() to evaluate expressions, or use      **
  ** structures.                                                        **
  ***********************************************************************/
  fun execute (dumpfl, strdumpfl, edumpfl) {
    if (dumpfl) putln ("& Entering execution phase.");
    // Dumping for blocks :
    if (dumpfl) {
      putln ("* Preliminary dumping of variables for this block:\n",
             vartable != tab [] ?
             sprint (vartable) : "", "\n"); 
    }
    fun execinstr;
    for (var instr = 0; instr < #exec; instr++) {
      // Sequentially perform statements.
      execinstr (exec [instr], strdumpfl, edumpfl); 
      /* Invoke execinstr() with the current instruction. */
    }
    if (global_errfl) abend (" runtime ");
    /*******************************************************
    ** Implementation of execinstr(). Like eval(), it     **
    ** chooses from a list of possible operations it can  **
    ** do, and executes the corresponding procedure       **
    ** needed to do the job.                              **
    *******************************************************/
    fun execinstr (currinstr, dumpfl, edumpfl = 0) {
      // Dumping for instructions :
      if (dumpfl) { putln ("@ Executing of instruction #",
                           instr + 1, ", value:");
                    print_instruction (currinstr);
      }
      if (currinstr.name == "cond") { /* Conditional branch. */
        for (var current_option_number = 0;
             current_option_number < #currinstr.args;
             current_option_number += 2) {
          /* This loop iterates through all of the
             alternatives, checking each one. */
          if (eval (currinstr.args [current_option_number], edumpfl).value) { 
            /* Check the current alternative. */
            execinstr (currinstr.args [current_option_number + 1], dumpfl); 
            // True: Execute this branch.
            break; // Exit the loop : No more altenatives need to be checked. 
          }
        }
      } else if (currinstr.name == "for") {
         // C-style 'for' loop implementation. Note that this statement can
         // loop at most 100,000 times.
         var g = 0; // This variable is used for enforcing the iteration limit.
         for (execinstr (currinstr.args [0], dumpfl); // Initialization.
              eval (currinstr.args [1], edumpfl). value; // Condition.
              execinstr (currinstr.args [2], dumpfl)) { // Increment.
           execinstr (currinstr.args [3], dumpfl); // Execute the body.
           g++; // Iteration count.
           if (g > 99999) { // Kill the for loop if alloted
                            // iterations are used up.
             if (dumpfl) putln ("! For loop ran out of iterations.");
             putln ("Warning: Iteration limit exceeded: For loop killed.");
             break; // Kill the loop.
           }
         }
       } else if (currinstr.name == "assign") {
         // Classical absolute assignment.
         var res = eval (currinstr.args [2], edumpfl),
             index = eval (currinstr.args [1], edumpfl).value,
             ourtype;
         // Ourtype is for real <- int compatibility.
         if (vartable  [currinstr.args [0]].type0 == "real") ourtype = "real";
         else ourtype = "integer";
         var target = vartable [currinstr.args [0]];
         if (type (target.value) != vec) {
           // Is this an array? If no :
          target.value = (ourtype == "real"
			  ? float (res. value) : int (res. value));
         } else { // If yes :
           if (#target.value < index || index < 1) {
             grip_error ("Runtime error : Array index out of bounds.");
             exit (2);
           }
           target.value [index - 1] = res.value;
         }
         vartable [currinstr.args [0]].type0 = ourtype;
       } else if (currinstr.name == "block") { // The compound statement.
         currinstr.args [0].execute (dumpfl, dumpfl, edumpfl);
       } else if (currinstr.name == "put") { // Output statement.
         var put_objs = []; // So as not to intermingle output with dumpings.
         for (var i = 0; i < #currinstr.args; i++)
           put_objs @= eval (currinstr.args [i], edumpfl).value;
         for (i = 0; i < #put_objs; i++)
           put (put_objs [i]);
           // Output the values of all expressions.
         putln (); // Don't forget a newline.
       } else if (currinstr.name == "empty") {
         // The nil statement - does nothing.
       } else { // Coding error.
         putln ("Fatal Error : Internal parsing error : ",
                "Illegal instruction generated as follows :");
         print_instruction (currinstr.name, currinstr.args);
         exit (3);
       }
     }
     // Dumping for blocks :
     if (dumpfl) {
       putln ("* Dumping of variables for this block:\n", #vartable != 0 ?
              sprint (vartable) : "", "\n"); 
     }
   } // End execute().
} // End class prog.
TEST506d
	  cat >$tempdir/parser.d <<'TEST506e'
/****************************************************************************
** This is the translator for the source code.                             **
****************************************************************************/
class tok (code) { // For encoding of identifiers, etc.
  use token former code;
  var value, type0, line_num, char_num;
}
class grip_parser {
  // The grip_parser class, using the Earley parser.
  var grammar, source_code; // Grammar is the Earley Parser code.
  include "scanner"; // Lexical analysis.
  include "translates"; // Syntactical and semantical analysis.
}
TEST506e
	  cat >$tempdir/scanner.d <<'TEST506f'
 /*****************************************************************
 ** The scanner() function does lexical analysis, i.e. finding   **
 ** numbers, and returns a vector of tokens ready for parsing.   **
 *****************************************************************/
fun scanner (code) {
  var tokens = [],
  /* Array that will later be translated to tokens and returned,
     which will be called the "token stream". */
  lexem = "", /* Lexem will accumulate characters in case we wanted to
  make a token with more than one character, i.e. an identifier.
  (Will be referred to as the "accumulation stream".) */
  /* Note on streams: We can't write to the token stream unless
                      accumulation stream is empty.
  */
  /* Next come two important tables to increase parsing efficiency. */
  character = final tab [':' : 5,
                         '<' : 13,
                         '>' : 14,
                         '(' : 15,
                         ')' : 16,
                         '{' : 17,
                         '}' : 18,
                         '[' : 19,
                         ']' : 20,
                         '+' : 21,
                         '-' : 22,
                         '*' : 23,
                         '/' : 24,
                         '&' : 25,
                         '|' : 26,
                         '!' : 27,
                         ';' : 28,
                         '=' : 29,
                         ' ' : 30], // For encoding special characters.
  keyword = final tab ["program" : 4,
                       "constant" : 6,
                       "integer" : 7,
                       "real" : 8,
                       "for" : 10,
                      "cond" : 9,
                      "else" : 12,
                      "put" : 11], // For encoding keywords.
  char0, /* Counter for the loop that follows. */
  lx = 0,
  lnn = 1; // For retaining the line number of a token.
  for (char0 = 0; char0 < #code;) { // Build up tokens[].
    if (char0 != 0 &&
        code[char0 - 1] == '\n') lnn++;
    if (code[char0] == '/') { // Value might be a comment.
      var nofl = 1; // Tells us whether we should keep the slash.
      char0++; // Look at the next character.
      if (code[char0] == '*') {
        nofl = 0; // Don't put the slash to tokens[].
        for (;; char0++) // It is a comment.
          if (code[char0] == '*') { // Comment might end.
            char0++; // Look at next character.
            if (code[char0] == '/') {
              char0++;
              break; // Comment is over.
            }
          }
      }
      // So that the slash is preserved if there was no comment.
      if (nofl) tokens = tokens @ '/';
    } else if (code[char0] <= '9' && code[char0] >= '0') {
      var realfl = 0; // For support of reals.
      lexem = "N";
      for (;; char0++) {
        for (; code[char0] <= '9' && code[char0] >= '0'; char0++)
          lexem = lexem @ code[char0];
        if (code[char0] == '.' && ! realfl) {
          realfl++; // To avoid meaningless constructs such as 2.3.56.
          continue; // For scanning reals.
        }
        break;
      }
      tokens = ins (tokens, lexem, #tokens);
      lexem = "";
    } else if (code [char0] <= 'z' &&
               code [char0] >= 'a' || code[char0] <= 'Z' &&
               code [char0] >= 'A') {
      lexem = "I";
      for (; code [char0] <= 'z' && code[char0] >= 'a'
             || code [char0] <= 'Z' && code [char0] >= 'A'
             || code [char0] <= '9' && code [char0] >= '0';
             char0++)
        lexem = lexem @ tolower (code [char0]);
      tokens = ins (tokens, lexem, #tokens);
      lexem = "";
    } else if (char0 < #code && (code [char0] == ' '  ||
                                 code [char0] == '\n' ||
                                 code [char0] == '\t' ||
                                 code [char0] == '\f' ||
                                 code [char0] == '\r' ||
                                 code [char0] == '\v')) {
      for (; char0 < #code && (code [char0] == ' '  ||
                               code [char0] == '\n' ||
                               code [char0] == '\t' ||
                               code [char0] == '\f' ||
                               code [char0] == '\r' ||
                               code [char0] == '\v');
           char0++)
        if (char0 != 0 && code [char0 - 1] == '\n') lnn++;
    } else if (code[char0] == '"'){
      char0++;
      lexem = "S";
      for (; char0 < #code && code[char0] != '"'; char0++)
        lexem = lexem @ code[char0];
      char0++;
      tokens = ins (tokens, lexem, #tokens);
      lexem = "";
    } else {
      tokens = ins (tokens, code[char0], #tokens);
      char0++;
    }
    // Translate what we got to a token.
    if (lx < #tokens &&
        type (tokens[lx]) != char) { // Are we dealing with a string?
      if (tokens[lx][0] == 'S') { // We have a string constant.
        var temp = tok (1); // Token with code 1.
        temp.type0 = tokens[lx][0]; // Add the type specifier.
        temp.value = del (tokens[lx], 0, 1); // Put the rest into value.
        tokens[lx] = temp; // Put the result into tokens.
      } else if (tokens[lx][0] == 'I') { // Identifier.
        var temp;
        if (del (tokens[lx], 0, 1) in keyword) {
          // Translate it into a keyword token if it's a keyword.
          temp = tok(keyword[tokens[lx]]);
          // Look it up in the keyword table.
          temp.type0 = 'K';
          // Give it type "K".
          temp.value = tokens[lx];
          // Give its reproduction for the syntax error manager.
        } else {
          temp = tok (2); // Token - code 2.
          temp.type0 = 'I';
          temp.value = tokens[lx];
          // Same procedure here as for string constants.
        }
        tokens[lx] = temp;
      } else if (tokens[lx][0] == 'N') { // Number.
        var temp = tok (3); // Token - code 3.
        temp.type0 = tokens[lx][0];
        temp.value = del (tokens[lx], 0, 1);
        tokens[lx] = temp;
      } else fatal_error ("Internal scanner error.", tokens, tokens[lx]);
      // Scanner malfunction.
    } else if (lx < #tokens) { // Single character.
      if (!(tokens[lx] in character)) { 
        // We have a bad character that we know the parser will spit out.
        put (file_name, ":", lnn, ":", char0 % lnn, ": ");
        grip_error ("Lexical error: Invalid character -- no encoding available.",
               sprint(tokens[lx]));
        /* Generate an invalid token that the parser recognizes, but does
           not use in any rule. */
        tokens [lx] = tok (31);
        lx++;
        continue;
      } else {
        var temp = tok(character [tokens[lx]]);
        temp.type0 = 'C';
        temp.value = tokens[lx];
        tokens[lx] = temp;
      }
    }
    if (lx < #tokens) {
      tokens[lx].line_num = lnn;
      tokens[lx].char_num = char0 % lnn;
      lx++;
    }
  }
  return tokens; // Make the result available to the client.
}
TEST506f
	  cat >$tempdir/translates.d <<'TEST506g'
 /*************************************************************************
 ** This is the actual translation function. It does any necessary       **
 ** operations that are done after the translation, so all the main      **
 ** block needs to do is analyze args and determine the parameters to    **
 ** this method.                                                         **
 *************************************************************************/
fun parse_file (program_file, debug_level, verbose_flag) {
  if (verbose_flag) putln ("& Entering parsing phase.");
  var token_vector; // To save typing.
  /* The following function is called by the parser to
     do any error messaging. */
  fun syntax_error (error_token_index,
                     error_token_value,
                     first_ignored_token_index,
                     first_ignored_token_value,
                     new_starting_token_index,
                     new_starting_token_value) {
    if (error_token_value == nil ||
        error_token_value.code != 31) {
      if (verbose_flag) putln ("! Syntax error.");
      if (error_token_value != nil)
        put (program_file, ":", error_token_value.line_num, ":0: ");
      grip_error (sput ("Syntax error at token value ",
                        error_token_value
                        == nil ? "EOF" :
                        error_token_value.code,
                   ":", error_token_value
                        == nil ? "EOF" :
                        error_token_value.type0,
                   ":", error_token_value
                        == nil ? "EOF" :
                        sprint (error_token_value.value)
                  )
            );
    }
  }
  // The next few lines install the grammar.
  try { // In case we can't find the file.
    var tape = open (env ["GRAMMARPATH"],"read");
    grammar = fgetf (tape);
    close (tape);
  } catch (eaccess,
           eagain,
           ebadf,
           ebusy,
           edom,
           efault,
           efbig,
           eio,
           eisdir,
           emfile,
           emlink,
           enametoolong,
           enfile,
           enodev,
           enoent,
           enomem,
           eperm,
           epipe,
           espipe,
           exdev)
  {fatal_error ("Could not find grammar file 'grip.g'.");}
  var program, // Source code.
  abstract_tree; // Intermediate code.
  try { // To cause exception !pmemory to die with a graceful error message.
    pub var machine = parser();
    machine.set_grammar (grammar, 1);
    machine.set_debug (debug_level); // Turns on verbose mode if applicable.
    machine.set_one_parse (1); // In case the grammar is ambiguous.
    machine.set_recovery (1); // Turn off error recovery.
    machine.set_recovery_match (0); // Shift 5 tokens when error is found.
    try { // To cover 'no such file' 
      program = open (program_file, "read"); // Get the source code.
    } catch (eaccess,
             eagain,
             ebadf,
             ebusy,
             edom,
             efault,
             efbig,
             eio,
             eisdir,
             emfile,
             emlink,
             enametoolong,
             enfile,
             enodev,
             enoent,
             enomem,
             eperm,
             epipe,
             espipe,
             exdev
             ) { // No such file in reach.
      putln ("Error: No valid file named ",
             sprint (program_file), " found.");
      global_errfl++;
      abend (" I/O ");
    }
    source_code = fgetf (program) @ " ";
    // So we don't get out-of range array bounds during scanning.
    close(program);
    if (verbose_flag) putln ("@ Initiating scanner.");
    token_vector = scanner (source_code);
    if (verbose_flag && global_errfl)
      putln ("! Scanner failed, working in error recovery mode.");
    // Use scanner() to process source_code.
    if (verbose_flag) putln ("@ Initiating Earley's Parser.");
    abstract_tree =
    machine.parse (token_vector, syntax_error);
    // Parse token_vector into abstract_tree.
  } catch ( pmemory) {
    // There wasn't enough memory to parse the program.
    if (verbose_flag)
      putln ("! Insufficient memory to set up parser, parsing failed.");
    grip_error ("Insufficient memory for parser.");
  }
  if (global_errfl) { // If syntax errors were found, stop the program.
    if (verbose_flag) putln ("! Syntax error: Terminating now.");
    abend (" syntax ");
  } else if (verbose_flag) {
    putln ("& Parsing phase sucessful.");
  /* Here ends the grammar checking. abstract_tree contains the
     intermediate representation of the program. The task now is
     to translate it into an object of class prog, and check it
     for semantical correctness. */
  }
  include "anode_work"; // Used to derive an object of class prog().
  if (verbose_flag) print_anode (abstract_tree);
  return parse_program_anode (abstract_tree, verbose_flag);
}
TEST506g
	  cat >$tempdir/sieve.g <<'TEST506h'
/* The program heading. The identifier can conflict with identifiers in
   the statement. */
program primeSieve 
/* This is all one block statement. A GRIP program in fact consists of
    only one statement. */
{
        /* Constant declarations. */
        sievesize : constant 100;
        /* Global variables. */
        i count : integer;
        /* An array. */
        flags : integer [100];
        /* Initialize count and flags. */
        count <- 0;
        /* If it isn't the C-style for loop :-) */
        for (i <- 0; i < sievesize; i <- i + 1; /* This semicolon has to be here. */)
                flags[i + 1] <- 1;
        /* Now get to work! */
        for (i <- 0; i < sievesize; i <- i + 1;)
                /* This is a multi-branch form of if-then-else. */
                cond { /* This is NOT a block statement. Negative. */
                        flags[i + 1] { /* This is another block-statement. */
                                /* Two local variables. */
                                k prime : integer;
                                prime <- 2 * i + 3;
                                k <- prime + i;
                                for (; k < sievesize; k <- k + prime;)
                                        flags[k + 1] <- 0;
                                count <- count + 1;
                        }
                        /* Here would have been "else blablablablabla...", but primeSieve has no
                            need for "else blablablablabla..." */
                }
        /* I/O, unfortunately without the I. Maybe later ;-( */
        put "The number of primes less than " sievesize " is " count;
}
/* This has all of the constructs available to a GRIP programmer. Not much, eh? :-| */
TEST506h
	  echo '      ' GRAMMARPATH=$tempdir/grip.g $DINO $tempdir/grip.d $tempdir/sieve.g
          if GRAMMARPATH=$tempdir/grip.g $DINO $tempdir/grip.d $tempdir/sieve.g 2>$stderr >$stdout; then
              echo '      ' $CMP $stdout $ftemp2
              if cat >$ftemp2 <<'OUTPUT506-2' && $CMP $stdout $ftemp2; then
The number of primes less than 100 is 45
OUTPUT506-2
                  result=ok
              else
                  result=fail
              fi
          else
              result=fail
          fi
        else
          result=fail
        fi
        if test $result = ok; then
          echo '      ' Serhei\'s interpreter test is ok  -- rm -rf $tempdir
          rm -rf $tempdir
        else
          echo '      ' Serhei\'s interpreter test failed -- look at directory $tempdir
        fi
fi

# Test 507.
if test $result = ok -a $start_test_number -le 507; then
	echo test 507: Check bug of deleting elements from table.
        cat >$test_file <<'TEST507'
var ts = ["MII", "MI;I", "MMI", "M;MI", "MFI", "MMF", "BBB", "MBB",
	  "MIB", "MMB", "MFB", "MIb", "MMb", "MFb"];
var seq = tab [], ignore = tab [], useq;

fun add_transl (seq, s, t) {
  var i;

  if (s in seq) {
    for (i = 0; i < #seq [s]; i++)
      if (seq [s] [i] == t)
	return;
    seq [s] = seq [s] @ [t];
  } else
    seq [s] = [t];
}

fun add_seq (str) {
  var start, i, j, s;
  start = 0;
  for (i = 0; i < #str; i++)
    if (str [i] == ';') {
      s = subv (str, start, i + 1 - start);
      start = i + 1;
      for (j = start; j < #str; j++)
        if (str [j] == 't')
          break;
      if (!(s in ignore))
	add_transl (seq, s, subv (str, start, j - start));
    }
  if (#str - start >= 3) {
    s = subv (str, start, -1);
    if (!(s in ignore))
      add_transl (seq, s, "");
  }
}

fun build_start_seqs {
  var i, j;

  for (i = 0; i < #ts; i++) {
    add_seq ("t" @ ts [i] @ ";");
    for (j = 0; j < #ts; j++) {
      add_seq ("t" @ ts [i] @ "t" @ ts [j] @ ";");
      add_seq ("t" @ ts [i] @ "t" @ ts [j]);
    }
  }
}

fun subscr_divide (s) {
  var v = [nil, nil], k, m = 0, i = 0, f = 0, b = 0, nopb = 0;
  
  for (k = 0; k < #s; k++)
    if (s [k] == 'I') {
      if (i == 2)
        break;
      i++;
    } else if (s [k] == 'M') {
      if (m == 2)
        break;
      m++;
    } else if (s [k] == 'F') {
      if (f == 2)
        break;
      f++;
    } else if (s [k] == 'B' || s [k] == 'b') {
      if (nopb && (k != 0 && s [k - 1] == 't' || s [k] == 'b') || b == 3)
        break; // conflict on B0
      if (s [k] == 'b')
	nopb = 1;
      b++;
    }
  if (k < #s && s [k - 1] == 't')
    k--;
  v [0] = subv (s, 0, k);
  if (k < #s)
    v [1] = subv (s, k, -1);
  return v;
}

fun build_all_seqs (seq) {
  var i, j, v, cont, p, s;

  for (;;) {
    cont = 0;
    v = vec (seq);
    for (i = 0; i < #v; i += 2) {
      s = v [i];
      p = subscr_divide (s);
      if (p [1] != nil) {
	ignore [s] = nil;
	del (seq, s);
	add_transl (seq, p[0], p [1][0] != 't' ? p[1] : "");
	if (p [1][0] != 't') {
	  add_transl (seq, p[1], "");
	  for (j = 0; j < #ts; j++) {
	    add_seq (p [1] @ "t" @ ts [j] @ ";");
	    add_seq (p [1] @ "t" @ ts [j]);
	  }
	}
	cont = 1;
      }
    }
    if (!cont)
      break;
  }
}

build_start_seqs ();
build_all_seqs (seq);
TEST507
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        else
                result=fail
        fi
fi

# Test 508.
if test $result = ok -a $start_test_number -le 508; then
	echo test 508: Check bug of deleting elements from table.
        cat >$test_file <<'TEST508'
class c (i) {
  class sc (ai) {}
}
var i = c (10);
putln (i.sc (20) == i.sc (20));
putln (i.sc (20) == i.sc (30));
putln (i.sc (20) == c(10).sc (20));
putln (i.sc (20) == c(30).sc (20));
TEST508
        echo '      ' $DINO $test_file ">$stdout" "2>$stderr"
        if $DINO $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT508' && $CMP $stdout $ftemp2; then
1
0
0
0
OUTPUT508
                  result=ok
                else
                  result=fail
                fi
        else
                result=fail
        fi
fi


# Test 509.
if test $result = ok -a $start_test_number -le 509; then
	echo test 509: Checking that return is in function/class/ext.
        cat >$test_file <<'TEST509'
return 10;
TEST509
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST509-1'; then
test.d:1:1: statement return is not in function or class
TEST509-1
                result=ok
        else
                result=fail
        fi
fi

# Test 510.
if test $result = ok -a $start_test_number -le 510; then
	echo test 510: Checking that return is in function/class/ext.
        cat >$test_file <<'TEST510'
var k = "aaa", t = tab [];
t [k] = 10;
k [1] = 'b';
TEST510
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST510-1'; then
test.d:3:3: run time error - attempt to modify immutable vector
TEST510-1
                result=ok
        else
                result=fail
        fi
fi

# Test 511.
if test $result = ok -a $start_test_number -le 511; then
	echo test 511: format output
        cat >$test_file <<'TEST511'
// default conversion
putf ("%d\n", 10);
putf ("%o\n", 10);
putf ("%x\n", 10);
putf ("%X\n", 10);
putf ("%e\n", 10.5);
putf ("%E\n", 10.5);
putf ("%f\n", 10.5);
putf ("%g\n", 10.5);
putf ("%G\n", 10.5);
putf ("%c\n", 'z');
putf ("%s\n", "Abracadabra");
// width
putf ("%15d\n", 10);
putf ("%15o\n", 10);
putf ("%15x\n", 10);
putf ("%15X\n", 10);
putf ("%15e\n", 10.5);
putf ("%15E\n", 10.5);
putf ("%15f\n", 10.5);
putf ("%15g\n", 10.5);
putf ("%15G\n", 10.5);
putf ("%15c\n", 'z');
putf ("%15s\n", "Abracadabra");
// flag -
putf ("%-15d\n", 10);
putf ("%-15o\n", 10);
putf ("%-15x\n", 10);
putf ("%-15X\n", 10);
putf ("%-15e\n", 10.5);
putf ("%-15E\n", 10.5);
putf ("%-15f\n", 10.5);
putf ("%-15g\n", 10.5);
putf ("%-15G\n", 10.5);
putf ("%-15c\n", 'z');
putf ("%-15s\n", "Abracadabra");
// flag #
putf ("%#o\n", 10);
putf ("%#x\n", 10);
putf ("%#X\n", 10);
putf ("%#e\n", 10.5);
putf ("%#E\n", 10.5);
putf ("%#f\n", 10.5);
putf ("%#g\n", 10.5);
putf ("%#G\n", 10.5);
// flag 0
putf ("%015d\n", 10);
putf ("%015o\n", 10);
putf ("%015x\n", 10);
putf ("%015X\n", 10);
putf ("%015e\n", 10.5);
putf ("%015E\n", 10.5);
putf ("%015f\n", 10.5);
putf ("%015g\n", 10.5);
putf ("%015G\n", 10.5);
// flag <blank>
putf ("% 15d\n", 10);
putf ("% 15e\n", 10.5);
putf ("% 15E\n", 10.5);
putf ("% 15f\n", 10.5);
putf ("% 15g\n", 10.5);
putf ("% 15G\n", 10.5);
// flag +
putf ("%+15d\n", 10);
putf ("%+15e\n", 10.5);
putf ("%+15E\n", 10.5);
putf ("%+15f\n", 10.5);
putf ("%+15g\n", 10.5);
putf ("%+15G\n", 10.5);
// flag + and <blank> -> ignore blank
putf ("%+ 15d\n", 10);
putf ("%+ 15e\n", 10.5);
putf ("%+ 15E\n", 10.5);
putf ("%+ 15f\n", 10.5);
putf ("%+ 15g\n", 10.5);
putf ("%+ 15G\n", 10.5);
// flag - and 0 -> ignore 0
putf ("%-015d\n", 10);
putf ("%-015o\n", 10);
putf ("%-015x\n", 10);
putf ("%-015X\n", 10);
putf ("%-015e\n", 10.5);
putf ("%-015E\n", 10.5);
putf ("%-015f\n", 10.5);
putf ("%-015g\n", 10.5);
putf ("%-015G\n", 10.5);
// parameter defined width
putf ("%*d\n", 15, 10);
putf ("%*o\n", 15, 10);
putf ("%*x\n", 15, 10);
putf ("%*X\n", 15, 10);
putf ("%*e\n", 15, 10.5);
putf ("%*E\n", 15, 10.5);
putf ("%*f\n", 15, 10.5);
putf ("%*g\n", 15, 10.5);
putf ("%*G\n", 15, 10.5);
putf ("%*c\n", 15, 'z');
// negative width -> absolute value and flag -
putf ("%*s\n", 15, "Abracadabra");
putf ("%*d\n", -15, 10);
putf ("%*o\n", -15, 10);
putf ("%*x\n", -15, 10);
putf ("%*X\n", -15, 10);
putf ("%*e\n", -15, 10.5);
putf ("%*E\n", -15, 10.5);
putf ("%*f\n", -15, 10.5);
putf ("%*g\n", -15, 10.5);
putf ("%*G\n", -15, 10.5);
putf ("%*c\n", -15, 'z');
putf ("%*s\n", -15, "Abracadabra");
// zero width
putf ("%*d\n", 0, 10);
putf ("%*o\n", 0, 10);
putf ("%*x\n", 0, 10);
putf ("%*X\n", 0, 10);
putf ("%*e\n", 0, 10.5);
putf ("%*E\n", 0, 10.5);
putf ("%*f\n", 0, 10.5);
putf ("%*g\n", 0, 10.5);
putf ("%*G\n", 0, 10.5);
putf ("%*c\n", 0, 'z');
putf ("%*s\n", 0, "Abracadabra");
// zero precision value
putf ("%.0d\n", 10);
putf ("%.0o\n", 10);
putf ("%.0x\n", 10);
putf ("%.0X\n", 10);
putf ("%.0e\n", 10.5);
putf ("%.0E\n", 10.5);
putf ("%.0f\n", 10.5);
putf ("%.0g\n", 10.5);
putf ("%.0G\n", 10.5);
putf ("%.0s\n", "Abracadabra");
// absent precision value -> zero value
putf ("%.d\n", 10);
putf ("%.o\n", 10);
putf ("%.x\n", 10);
putf ("%.X\n", 10);
putf ("%.e\n", 10.5);
putf ("%.E\n", 10.5);
putf ("%.f\n", 10.5);
putf ("%.g\n", 10.5);
putf ("%.G\n", 10.5);
putf ("%.s\n", "Abracadabra");
// precision with numeric conversion and flag 0 -> ignore flag 0
putf ("%05.0d\n", 10);
putf ("%05.0o\n", 10);
putf ("%05.0x\n", 10);
putf ("%05.0X\n", 10);
putf ("%05.d\n", 10);
putf ("%05.o\n", 10);
putf ("%05.x\n", 10);
putf ("%05.X\n", 10);
// precision value 10
putf ("%.10d\n", 10);
putf ("%.10o\n", 10);
putf ("%.10x\n", 10);
putf ("%.10X\n", 10);
putf ("%.10e\n", 10.5);
putf ("%.10E\n", 10.5);
putf ("%.10f\n", 10.5);
putf ("%.10g\n", 10.5);
putf ("%.10G\n", 10.5);
putf ("%.10s\n", "Abracadabra");
// precision value as parameter
putf ("%.*d\n", 10, 10);
putf ("%.*o\n", 10, 10);
putf ("%.*x\n", 10, 10);
putf ("%.*X\n", 10, 10);
putf ("%.*e\n", 10, 10.5);
putf ("%.*E\n", 10, 10.5);
putf ("%.*f\n", 10, 10.5);
putf ("%.*g\n", 10, 10.5);
putf ("%.*G\n", 10, 10.5);
putf ("%.*s\n", 10, "Abracadabra");
// negative precision value -> value zero
putf ("%.*d\n", -10, 10);
putf ("%.*o\n", -10, 10);
putf ("%.*x\n", -10, 10);
putf ("%.*X\n", -10, 10);
putf ("%.*e\n", -10, 10.5);
putf ("%.*E\n", -10, 10.5);
putf ("%.*f\n", -10, 10.5);
putf ("%.*g\n", -10, 10.5);
putf ("%.*G\n", -10, 10.5);
putf ("%.*s\n", -10, "Abracadabra");
// zero precision value for outputing zero
putf ("%.0d\n", 0);
putf ("%.0o\n", 0);
putf ("%.0x\n", 0);
putf ("%.0X\n", 0);
// %
putf ("%%\n");

// The same for fputf
// default conversion
fputf (stdout, "%d\n", 10);
fputf (stdout, "%o\n", 10);
fputf (stdout, "%x\n", 10);
fputf (stdout, "%X\n", 10);
fputf (stdout, "%e\n", 10.5);
fputf (stdout, "%E\n", 10.5);
fputf (stdout, "%f\n", 10.5);
fputf (stdout, "%g\n", 10.5);
fputf (stdout, "%G\n", 10.5);
fputf (stdout, "%c\n", 'z');
fputf (stdout, "%s\n", "Abracadabra");
// width
fputf (stdout, "%15d\n", 10);
fputf (stdout, "%15o\n", 10);
fputf (stdout, "%15x\n", 10);
fputf (stdout, "%15X\n", 10);
fputf (stdout, "%15e\n", 10.5);
fputf (stdout, "%15E\n", 10.5);
fputf (stdout, "%15f\n", 10.5);
fputf (stdout, "%15g\n", 10.5);
fputf (stdout, "%15G\n", 10.5);
fputf (stdout, "%15c\n", 'z');
fputf (stdout, "%15s\n", "Abracadabra");
// flag -
fputf (stdout, "%-15d\n", 10);
fputf (stdout, "%-15o\n", 10);
fputf (stdout, "%-15x\n", 10);
fputf (stdout, "%-15X\n", 10);
fputf (stdout, "%-15e\n", 10.5);
fputf (stdout, "%-15E\n", 10.5);
fputf (stdout, "%-15f\n", 10.5);
fputf (stdout, "%-15g\n", 10.5);
fputf (stdout, "%-15G\n", 10.5);
fputf (stdout, "%-15c\n", 'z');
fputf (stdout, "%-15s\n", "Abracadabra");
// flag #
fputf (stdout, "%#o\n", 10);
fputf (stdout, "%#x\n", 10);
fputf (stdout, "%#X\n", 10);
fputf (stdout, "%#e\n", 10.5);
fputf (stdout, "%#E\n", 10.5);
fputf (stdout, "%#f\n", 10.5);
fputf (stdout, "%#g\n", 10.5);
fputf (stdout, "%#G\n", 10.5);
// flag 0
fputf (stdout, "%015d\n", 10);
fputf (stdout, "%015o\n", 10);
fputf (stdout, "%015x\n", 10);
fputf (stdout, "%015X\n", 10);
fputf (stdout, "%015e\n", 10.5);
fputf (stdout, "%015E\n", 10.5);
fputf (stdout, "%015f\n", 10.5);
fputf (stdout, "%015g\n", 10.5);
fputf (stdout, "%015G\n", 10.5);
// flag <blank>
fputf (stdout, "% 15d\n", 10);
fputf (stdout, "% 15e\n", 10.5);
fputf (stdout, "% 15E\n", 10.5);
fputf (stdout, "% 15f\n", 10.5);
fputf (stdout, "% 15g\n", 10.5);
fputf (stdout, "% 15G\n", 10.5);
// flag +
fputf (stdout, "%+15d\n", 10);
fputf (stdout, "%+15e\n", 10.5);
fputf (stdout, "%+15E\n", 10.5);
fputf (stdout, "%+15f\n", 10.5);
fputf (stdout, "%+15g\n", 10.5);
fputf (stdout, "%+15G\n", 10.5);
// flag + and <blank> -> ignore blank
fputf (stdout, "%+ 15d\n", 10);
fputf (stdout, "%+ 15e\n", 10.5);
fputf (stdout, "%+ 15E\n", 10.5);
fputf (stdout, "%+ 15f\n", 10.5);
fputf (stdout, "%+ 15g\n", 10.5);
fputf (stdout, "%+ 15G\n", 10.5);
// flag - and 0 -> ignore 0
fputf (stdout, "%-015d\n", 10);
fputf (stdout, "%-015o\n", 10);
fputf (stdout, "%-015x\n", 10);
fputf (stdout, "%-015X\n", 10);
fputf (stdout, "%-015e\n", 10.5);
fputf (stdout, "%-015E\n", 10.5);
fputf (stdout, "%-015f\n", 10.5);
fputf (stdout, "%-015g\n", 10.5);
fputf (stdout, "%-015G\n", 10.5);
// parameter defined width
fputf (stdout, "%*d\n", 15, 10);
fputf (stdout, "%*o\n", 15, 10);
fputf (stdout, "%*x\n", 15, 10);
fputf (stdout, "%*X\n", 15, 10);
fputf (stdout, "%*e\n", 15, 10.5);
fputf (stdout, "%*E\n", 15, 10.5);
fputf (stdout, "%*f\n", 15, 10.5);
fputf (stdout, "%*g\n", 15, 10.5);
fputf (stdout, "%*G\n", 15, 10.5);
fputf (stdout, "%*c\n", 15, 'z');
// negative width -> absolute value and flag -
fputf (stdout, "%*s\n", 15, "Abracadabra");
fputf (stdout, "%*d\n", -15, 10);
fputf (stdout, "%*o\n", -15, 10);
fputf (stdout, "%*x\n", -15, 10);
fputf (stdout, "%*X\n", -15, 10);
fputf (stdout, "%*e\n", -15, 10.5);
fputf (stdout, "%*E\n", -15, 10.5);
fputf (stdout, "%*f\n", -15, 10.5);
fputf (stdout, "%*g\n", -15, 10.5);
fputf (stdout, "%*G\n", -15, 10.5);
fputf (stdout, "%*c\n", -15, 'z');
fputf (stdout, "%*s\n", -15, "Abracadabra");
// zero width
fputf (stdout, "%*d\n", 0, 10);
fputf (stdout, "%*o\n", 0, 10);
fputf (stdout, "%*x\n", 0, 10);
fputf (stdout, "%*X\n", 0, 10);
fputf (stdout, "%*e\n", 0, 10.5);
fputf (stdout, "%*E\n", 0, 10.5);
fputf (stdout, "%*f\n", 0, 10.5);
fputf (stdout, "%*g\n", 0, 10.5);
fputf (stdout, "%*G\n", 0, 10.5);
fputf (stdout, "%*c\n", 0, 'z');
fputf (stdout, "%*s\n", 0, "Abracadabra");
// zero precision value
fputf (stdout, "%.0d\n", 10);
fputf (stdout, "%.0o\n", 10);
fputf (stdout, "%.0x\n", 10);
fputf (stdout, "%.0X\n", 10);
fputf (stdout, "%.0e\n", 10.5);
fputf (stdout, "%.0E\n", 10.5);
fputf (stdout, "%.0f\n", 10.5);
fputf (stdout, "%.0g\n", 10.5);
fputf (stdout, "%.0G\n", 10.5);
fputf (stdout, "%.0s\n", "Abracadabra");
// absent precision value -> zero value
fputf (stdout, "%.d\n", 10);
fputf (stdout, "%.o\n", 10);
fputf (stdout, "%.x\n", 10);
fputf (stdout, "%.X\n", 10);
fputf (stdout, "%.e\n", 10.5);
fputf (stdout, "%.E\n", 10.5);
fputf (stdout, "%.f\n", 10.5);
fputf (stdout, "%.g\n", 10.5);
fputf (stdout, "%.G\n", 10.5);
fputf (stdout, "%.s\n", "Abracadabra");
// precision with numeric conversion and flag 0 -> ignore flag 0
fputf (stdout, "%05.0d\n", 10);
fputf (stdout, "%05.0o\n", 10);
fputf (stdout, "%05.0x\n", 10);
fputf (stdout, "%05.0X\n", 10);
fputf (stdout, "%05.d\n", 10);
fputf (stdout, "%05.o\n", 10);
fputf (stdout, "%05.x\n", 10);
fputf (stdout, "%05.X\n", 10);
// precision value 10
fputf (stdout, "%.10d\n", 10);
fputf (stdout, "%.10o\n", 10);
fputf (stdout, "%.10x\n", 10);
fputf (stdout, "%.10X\n", 10);
fputf (stdout, "%.10e\n", 10.5);
fputf (stdout, "%.10E\n", 10.5);
fputf (stdout, "%.10f\n", 10.5);
fputf (stdout, "%.10g\n", 10.5);
fputf (stdout, "%.10G\n", 10.5);
fputf (stdout, "%.10s\n", "Abracadabra");
// precision value as parameter
fputf (stdout, "%.*d\n", 10, 10);
fputf (stdout, "%.*o\n", 10, 10);
fputf (stdout, "%.*x\n", 10, 10);
fputf (stdout, "%.*X\n", 10, 10);
fputf (stdout, "%.*e\n", 10, 10.5);
fputf (stdout, "%.*E\n", 10, 10.5);
fputf (stdout, "%.*f\n", 10, 10.5);
fputf (stdout, "%.*g\n", 10, 10.5);
fputf (stdout, "%.*G\n", 10, 10.5);
fputf (stdout, "%.*s\n", 10, "Abracadabra");
// negative precision value -> value zero
fputf (stdout, "%.*d\n", -10, 10);
fputf (stdout, "%.*o\n", -10, 10);
fputf (stdout, "%.*x\n", -10, 10);
fputf (stdout, "%.*X\n", -10, 10);
fputf (stdout, "%.*e\n", -10, 10.5);
fputf (stdout, "%.*E\n", -10, 10.5);
fputf (stdout, "%.*f\n", -10, 10.5);
fputf (stdout, "%.*g\n", -10, 10.5);
fputf (stdout, "%.*G\n", -10, 10.5);
fputf (stdout, "%.*s\n", -10, "Abracadabra");
// zero precision value for outputing zero
fputf (stdout, "%.0d\n", 0);
fputf (stdout, "%.0o\n", 0);
fputf (stdout, "%.0x\n", 0);
fputf (stdout, "%.0X\n", 0);
// %
fputf (stdout, "%%\n");

// The same for sputf
// default conversion
put (sputf ("%d\n", 10));
put (sputf ("%o\n", 10));
put (sputf ("%x\n", 10));
put (sputf ("%X\n", 10));
put (sputf ("%e\n", 10.5));
put (sputf ("%E\n", 10.5));
put (sputf ("%f\n", 10.5));
put (sputf ("%g\n", 10.5));
put (sputf ("%G\n", 10.5));
put (sputf ("%c\n", 'z'));
put (sputf ("%s\n", "Abracadabra"));
// width
put (sputf ("%15d\n", 10));
put (sputf ("%15o\n", 10));
put (sputf ("%15x\n", 10));
put (sputf ("%15X\n", 10));
put (sputf ("%15e\n", 10.5));
put (sputf ("%15E\n", 10.5));
put (sputf ("%15f\n", 10.5));
put (sputf ("%15g\n", 10.5));
put (sputf ("%15G\n", 10.5));
put (sputf ("%15c\n", 'z'));
put (sputf ("%15s\n", "Abracadabra"));
// flag -
put (sputf ("%-15d\n", 10));
put (sputf ("%-15o\n", 10));
put (sputf ("%-15x\n", 10));
put (sputf ("%-15X\n", 10));
put (sputf ("%-15e\n", 10.5));
put (sputf ("%-15E\n", 10.5));
put (sputf ("%-15f\n", 10.5));
put (sputf ("%-15g\n", 10.5));
put (sputf ("%-15G\n", 10.5));
put (sputf ("%-15c\n", 'z'));
put (sputf ("%-15s\n", "Abracadabra"));
// flag #
put (sputf ("%#o\n", 10));
put (sputf ("%#x\n", 10));
put (sputf ("%#X\n", 10));
put (sputf ("%#e\n", 10.5));
put (sputf ("%#E\n", 10.5));
put (sputf ("%#f\n", 10.5));
put (sputf ("%#g\n", 10.5));
put (sputf ("%#G\n", 10.5));
// flag 0
put (sputf ("%015d\n", 10));
put (sputf ("%015o\n", 10));
put (sputf ("%015x\n", 10));
put (sputf ("%015X\n", 10));
put (sputf ("%015e\n", 10.5));
put (sputf ("%015E\n", 10.5));
put (sputf ("%015f\n", 10.5));
put (sputf ("%015g\n", 10.5));
put (sputf ("%015G\n", 10.5));
// flag <blank>
put (sputf ("% 15d\n", 10));
put (sputf ("% 15e\n", 10.5));
put (sputf ("% 15E\n", 10.5));
put (sputf ("% 15f\n", 10.5));
put (sputf ("% 15g\n", 10.5));
put (sputf ("% 15G\n", 10.5));
// flag +
put (sputf ("%+15d\n", 10));
put (sputf ("%+15e\n", 10.5));
put (sputf ("%+15E\n", 10.5));
put (sputf ("%+15f\n", 10.5));
put (sputf ("%+15g\n", 10.5));
put (sputf ("%+15G\n", 10.5));
// flag + and <blank> -> ignore blank
put (sputf ("%+ 15d\n", 10));
put (sputf ("%+ 15e\n", 10.5));
put (sputf ("%+ 15E\n", 10.5));
put (sputf ("%+ 15f\n", 10.5));
put (sputf ("%+ 15g\n", 10.5));
put (sputf ("%+ 15G\n", 10.5));
// flag - and 0 -> ignore 0
put (sputf ("%-015d\n", 10));
put (sputf ("%-015o\n", 10));
put (sputf ("%-015x\n", 10));
put (sputf ("%-015X\n", 10));
put (sputf ("%-015e\n", 10.5));
put (sputf ("%-015E\n", 10.5));
put (sputf ("%-015f\n", 10.5));
put (sputf ("%-015g\n", 10.5));
put (sputf ("%-015G\n", 10.5));
// parameter defined width
put (sputf ("%*d\n", 15, 10));
put (sputf ("%*o\n", 15, 10));
put (sputf ("%*x\n", 15, 10));
put (sputf ("%*X\n", 15, 10));
put (sputf ("%*e\n", 15, 10.5));
put (sputf ("%*E\n", 15, 10.5));
put (sputf ("%*f\n", 15, 10.5));
put (sputf ("%*g\n", 15, 10.5));
put (sputf ("%*G\n", 15, 10.5));
put (sputf ("%*c\n", 15, 'z'));
// negative width -> absolute value and flag -
put (sputf ("%*s\n", 15, "Abracadabra"));
put (sputf ("%*d\n", -15, 10));
put (sputf ("%*o\n", -15, 10));
put (sputf ("%*x\n", -15, 10));
put (sputf ("%*X\n", -15, 10));
put (sputf ("%*e\n", -15, 10.5));
put (sputf ("%*E\n", -15, 10.5));
put (sputf ("%*f\n", -15, 10.5));
put (sputf ("%*g\n", -15, 10.5));
put (sputf ("%*G\n", -15, 10.5));
put (sputf ("%*c\n", -15, 'z'));
put (sputf ("%*s\n", -15, "Abracadabra"));
// zero width
put (sputf ("%*d\n", 0, 10));
put (sputf ("%*o\n", 0, 10));
put (sputf ("%*x\n", 0, 10));
put (sputf ("%*X\n", 0, 10));
put (sputf ("%*e\n", 0, 10.5));
put (sputf ("%*E\n", 0, 10.5));
put (sputf ("%*f\n", 0, 10.5));
put (sputf ("%*g\n", 0, 10.5));
put (sputf ("%*G\n", 0, 10.5));
put (sputf ("%*c\n", 0, 'z'));
put (sputf ("%*s\n", 0, "Abracadabra"));
// zero precision value
put (sputf ("%.0d\n", 10));
put (sputf ("%.0o\n", 10));
put (sputf ("%.0x\n", 10));
put (sputf ("%.0X\n", 10));
put (sputf ("%.0e\n", 10.5));
put (sputf ("%.0E\n", 10.5));
put (sputf ("%.0f\n", 10.5));
put (sputf ("%.0g\n", 10.5));
put (sputf ("%.0G\n", 10.5));
put (sputf ("%.0s\n", "Abracadabra"));
// absent precision value -> zero value
put (sputf ("%.d\n", 10));
put (sputf ("%.o\n", 10));
put (sputf ("%.x\n", 10));
put (sputf ("%.X\n", 10));
put (sputf ("%.e\n", 10.5));
put (sputf ("%.E\n", 10.5));
put (sputf ("%.f\n", 10.5));
put (sputf ("%.g\n", 10.5));
put (sputf ("%.G\n", 10.5));
put (sputf ("%.s\n", "Abracadabra"));
// precision with numeric conversion and flag 0 -> ignore flag 0
put (sputf ("%05.0d\n", 10));
put (sputf ("%05.0o\n", 10));
put (sputf ("%05.0x\n", 10));
put (sputf ("%05.0X\n", 10));
put (sputf ("%05.d\n", 10));
put (sputf ("%05.o\n", 10));
put (sputf ("%05.x\n", 10));
put (sputf ("%05.X\n", 10));
// precision value 10
put (sputf ("%.10d\n", 10));
put (sputf ("%.10o\n", 10));
put (sputf ("%.10x\n", 10));
put (sputf ("%.10X\n", 10));
put (sputf ("%.10e\n", 10.5));
put (sputf ("%.10E\n", 10.5));
put (sputf ("%.10f\n", 10.5));
put (sputf ("%.10g\n", 10.5));
put (sputf ("%.10G\n", 10.5));
put (sputf ("%.10s\n", "Abracadabra"));
// precision value as parameter
put (sputf ("%.*d\n", 10, 10));
put (sputf ("%.*o\n", 10, 10));
put (sputf ("%.*x\n", 10, 10));
put (sputf ("%.*X\n", 10, 10));
put (sputf ("%.*e\n", 10, 10.5));
put (sputf ("%.*E\n", 10, 10.5));
put (sputf ("%.*f\n", 10, 10.5));
put (sputf ("%.*g\n", 10, 10.5));
put (sputf ("%.*G\n", 10, 10.5));
put (sputf ("%.*s\n", 10, "Abracadabra"));
// negative precision value -> value zero
put (sputf ("%.*d\n", -10, 10));
put (sputf ("%.*o\n", -10, 10));
put (sputf ("%.*x\n", -10, 10));
put (sputf ("%.*X\n", -10, 10));
put (sputf ("%.*e\n", -10, 10.5));
put (sputf ("%.*E\n", -10, 10.5));
put (sputf ("%.*f\n", -10, 10.5));
put (sputf ("%.*g\n", -10, 10.5));
put (sputf ("%.*G\n", -10, 10.5));
put (sputf ("%.*s\n", -10, "Abracadabra"));
// zero precision value for outputing zero
put (sputf ("%.0d\n", 0));
put (sputf ("%.0o\n", 0));
put (sputf ("%.0x\n", 0));
put (sputf ("%.0X\n", 0));
// %
put (sputf ("%%\n"));
// big precision
putf ("%.21474836s", "stop\n");
TEST511
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT511' && $CMP $stdout $ftemp2; then
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
stop
OUTPUT511
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT511-1' && $CMP $stdout $ftemp2; then
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
stop
OUTPUT511-1
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 512.
if test $result = ok -a $start_test_number -le 512; then
	echo test 512: adjustment for %d
        cat >$test_file <<'TEST512'
sputf ("%#d", 10);
TEST512
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST512-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST512-1
                result=ok
        else
                result=fail
        fi
fi

# Test 513.
if test $result = ok -a $start_test_number -le 513; then
	echo test 513: adjustment for %c
        cat >$test_file <<'TEST513'
sputf ("%#c", 10);
TEST513
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST513-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST513-1
                result=ok
        else
                result=fail
        fi
fi

# Test 514.
if test $result = ok -a $start_test_number -le 514; then
	echo test 514: blank flag for %o
        cat >$test_file <<'TEST514'
sputf ("% o", 10);
TEST514
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST514-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST514-1
                result=ok
        else
                result=fail
        fi
fi

# Test 515.
if test $result = ok -a $start_test_number -le 515; then
	echo test 515: adjustment for %s
        cat >$test_file <<'TEST515'
sputf ("%#s", "Abracadabra");
TEST515
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST515-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST515-1
                result=ok
        else
                result=fail
        fi
fi

# Test 516.
if test $result = ok -a $start_test_number -le 516; then
	echo test 516: zero flag for %c
        cat >$test_file <<'TEST516'
sputf ("%015c", 'z');
TEST516
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST516-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST516-1
                result=ok
        else
                result=fail
        fi
fi

# Test 517.
if test $result = ok -a $start_test_number -le 517; then
	echo test 517: zero flag for %s
        cat >$test_file <<'TEST517'
sputf ("%015s", "Abracadabra");
TEST517
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST517-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST517-1
                result=ok
        else
                result=fail
        fi
fi

# Test 518.
if test $result = ok -a $start_test_number -le 518; then
	echo test 518: blank flag for %o
        cat >$test_file <<'TEST518'
sputf ("% 15o", 10);
TEST518
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST518-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST518-1
                result=ok
        else
                result=fail
        fi
fi

# Test 519.
if test $result = ok -a $start_test_number -le 519; then
	echo test 519: blank flag for %x
        cat >$test_file <<'TEST519'
sputf ("% 15x", 10);
TEST519
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST519-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST519-1
                result=ok
        else
                result=fail
        fi
fi

# Test 520.
if test $result = ok -a $start_test_number -le 520; then
	echo test 520: blank flag for %X
        cat >$test_file <<'TEST520'
sputf ("% 15X", 10);
TEST520
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST520-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST520-1
                result=ok
        else
                result=fail
        fi
fi

# Test 521.
if test $result = ok -a $start_test_number -le 521; then
	echo test 521: blank flag for %c
        cat >$test_file <<'TEST521'
sputf ("% 15c", 10);
TEST521
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST521-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST521-1
                result=ok
        else
                result=fail
        fi
fi

# Test 522.
if test $result = ok -a $start_test_number -le 522; then
	echo test 522: blank flag for %s
        cat >$test_file <<'TEST522'
sputf ("% 15s", "Abracadabra");
TEST522
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST522-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST522-1
                result=ok
        else
                result=fail
        fi
fi

# Test 523.
if test $result = ok -a $start_test_number -le 523; then
	echo test 523: flag + for %o
        cat >$test_file <<'TEST523'
sputf ("%+15o", 10);
TEST523
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST523-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST523-1
                result=ok
        else
                result=fail
        fi
fi

# Test 524.
if test $result = ok -a $start_test_number -le 524; then
	echo test 524: flag + for %x
        cat >$test_file <<'TEST524'
sputf ("%+15x", 10);
TEST524
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST524-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST524-1
                result=ok
        else
                result=fail
        fi
fi

# Test 525.
if test $result = ok -a $start_test_number -le 525; then
	echo test 525: flag + for %X
        cat >$test_file <<'TEST525'
sputf ("%+15X", 10);
TEST525
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST525-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST525-1
                result=ok
        else
                result=fail
        fi
fi

# Test 526.
if test $result = ok -a $start_test_number -le 526; then
	echo test 526: flag + for %c
        cat >$test_file <<'TEST526'
sputf ("%+15c", 10);
TEST526
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST526-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST526-1
                result=ok
        else
                result=fail
        fi
fi

# Test 527.
if test $result = ok -a $start_test_number -le 527; then
	echo test 527: flag + for %s
        cat >$test_file <<'TEST527'
sputf ("%+15s", 10);
TEST527
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST527-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST527-1
                result=ok
        else
                result=fail
        fi
fi

# Test 528.
if test $result = ok -a $start_test_number -le 528; then
	echo test 528: Few arguments for format
        cat >$test_file <<'TEST528'
sputf ("%d");
TEST528
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST528-1'; then
test.d:1:7: run time error - unexpected number of parameters for `sputf'
TEST528-1
                result=ok
        else
                result=fail
        fi
fi

# Test 529.
if test $result = ok -a $start_test_number -le 529; then
	echo test 529: Few arguments for format
        cat >$test_file <<'TEST529'
sputf ("%*d", 10);
TEST529
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST529-1'; then
test.d:1:7: run time error - unexpected number of parameters for `sputf'
TEST529-1
                result=ok
        else
                result=fail
        fi
fi

# Test 530.
if test $result = ok -a $start_test_number -le 530; then
	echo test 530: Too many parameters
        cat >$test_file <<'TEST530'
sputf ("%*d", 10, 10, 10);
TEST530
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST530-1'; then
test.d:1:7: run time error - unexpected number of parameters for `sputf'
TEST530-1
                result=ok
        else
                result=fail
        fi
fi

# Test 531.
if test $result = ok -a $start_test_number -le 531; then
	echo test 531: Too many parameters
        cat >$test_file <<'TEST531'
sputf ("%d", 10, 10);
TEST531
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST531-1'; then
test.d:1:7: run time error - unexpected number of parameters for `sputf'
TEST531-1
                result=ok
        else
                result=fail
        fi
fi

# Test 532.
if test $result = ok -a $start_test_number -le 532; then
	echo test 532: Parameter does not correspond to conversion
        cat >$test_file <<'TEST532'
sputf ("%d", "");
TEST532
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST532-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST532-1
                result=ok
        else
                result=fail
        fi
fi

# Test 533.
if test $result = ok -a $start_test_number -le 533; then
	echo test 533: Parameter does not correspond to conversion
        cat >$test_file <<'TEST533'
sputf ("%d", 'c');
TEST533
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST533-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST533-1
                result=ok
        else
                result=fail
        fi
fi

# Test 534.
if test $result = ok -a $start_test_number -le 534; then
	echo test 534: Parameter does not correspond to conversion
        cat >$test_file <<'TEST534'
sputf ("%d", 10.0);
TEST534
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST534-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST534-1
                result=ok
        else
                result=fail
        fi
fi

# Test 535.
if test $result = ok -a $start_test_number -le 535; then
	echo test 535: Parameter does not correspond to conversion
        cat >$test_file <<'TEST535'
sputf ("%c", 10);
TEST535
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST535-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST535-1
                result=ok
        else
                result=fail
        fi
fi

# Test 536.
if test $result = ok -a $start_test_number -le 536; then
	echo test 536: Parameter does not correspond to conversion
        cat >$test_file <<'TEST536'
sputf ("%c", "");
TEST536
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST536-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST536-1
                result=ok
        else
                result=fail
        fi
fi

# Test 537.
if test $result = ok -a $start_test_number -le 537; then
	echo test 537: Parameter does not correspond to conversion
        cat >$test_file <<'TEST537'
sputf ("%c", 10.0);
TEST537
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST537-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST537-1
                result=ok
        else
                result=fail
        fi
fi

# Test 538.
if test $result = ok -a $start_test_number -le 538; then
	echo test 538: Parameter does not correspond to conversion
        cat >$test_file <<'TEST538'
sputf ("%g", "");
TEST538
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST538-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST538-1
                result=ok
        else
                result=fail
        fi
fi

# Test 539.
if test $result = ok -a $start_test_number -le 539; then
	echo test 539: Parameter does not correspond to conversion
        cat >$test_file <<'TEST539'
sputf ("%g", 'c');
TEST539
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST539-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST539-1
                result=ok
        else
                result=fail
        fi
fi

# Test 540.
if test $result = ok -a $start_test_number -le 540; then
	echo test 540: Parameter does not correspond to conversion
        cat >$test_file <<'TEST540'
sputf ("%g", 10);
TEST540
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST540-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST540-1
                result=ok
        else
                result=fail
        fi
fi

# Test 541.
if test $result = ok -a $start_test_number -le 541; then
	echo test 541: Absent format
        cat >$test_file <<'TEST541'
sputf ();
TEST541
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST541-1'; then
test.d:1:7: run time error - unexpected number of parameters for `sputf'
TEST541-1
                result=ok
        else
                result=fail
        fi
fi

# Test 542.
if test $result = ok -a $start_test_number -le 542; then
	echo test 542: Absent format
        cat >$test_file <<'TEST542'
fputf (stdout);
TEST542
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST542-1'; then
test.d:1:7: run time error - unexpected number of parameters for `fputf'
TEST542-1
                result=ok
        else
                result=fail
        fi
fi

# Test 543.
if test $result = ok -a $start_test_number -le 543; then
	echo test 543: Invalid parameter
        cat >$test_file <<'TEST543'
sputf ([]);
TEST543
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST543-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST543-1
                result=ok
        else
                result=fail
        fi
fi

# Test 544.
if test $result = ok -a $start_test_number -le 544; then
	echo test 544: Invalid %%
        cat >$test_file <<'TEST544'
sputf ("%#%");
TEST544
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST544-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST544-1
                result=ok
        else
                result=fail
        fi
fi

# Test 545.
if test $result = ok -a $start_test_number -le 545; then
	echo test 545: Invalid %%
        cat >$test_file <<'TEST545'
sputf ("%0%");
TEST545
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST545-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST545-1
                result=ok
        else
                result=fail
        fi
fi

# Test 546.
if test $result = ok -a $start_test_number -le 546; then
	echo test 546: Invalid %%
        cat >$test_file <<'TEST546'
sputf ("%-%");
TEST546
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST546-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST546-1
                result=ok
        else
                result=fail
        fi
fi

# Test 547.
if test $result = ok -a $start_test_number -le 547; then
	echo test 547: Invalid %%
        cat >$test_file <<'TEST547'
sputf ("% %");
TEST547
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST547-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST547-1
                result=ok
        else
                result=fail
        fi
fi

# Test 548.
if test $result = ok -a $start_test_number -le 548; then
	echo test 548: Invalid %%
        cat >$test_file <<'TEST548'
sputf ("%+%");
TEST548
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST548-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST548-1
                result=ok
        else
                result=fail
        fi
fi

# Test 549.
if test $result = ok -a $start_test_number -le 549; then
	echo test 549: Unknown conversion
        cat >$test_file <<'TEST549'
sputf ("%w", 10);
TEST549
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST549-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST549-1
                result=ok
        else
                result=fail
        fi
fi

# Test 550.
if test $result = ok -a $start_test_number -le 550; then
	echo test 550: Too big width
        cat >$test_file <<'TEST550'
sputf ("%214748364s", "");
TEST550
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST550-1'; then
test.d:1:7: no memory
TEST550-1
                result=ok
        else
                result=fail
        fi
fi

# Test 551.
if test $result = ok -a $start_test_number -le 551; then
	echo test 551: Too big width
        cat >$test_file <<'TEST551'
sputf ("%2147483648s", "");
TEST551
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST551-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST551-1
                result=ok
        else
                result=fail
        fi
fi

# Test 552.
if test $result = ok -a $start_test_number -le 552; then
	echo test 552: Too big precision
        cat >$test_file <<'TEST552'
sputf ("%.2147483648s", "");
TEST552
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST552-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST552-1
                result=ok
        else
                result=fail
        fi
fi

# Test 553.
if test $result = ok -a $start_test_number -le 553; then
	echo test 553: Precision with %c
        cat >$test_file <<'TEST553'
sputf ("%.0c", 'z');
TEST553
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST553-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST553-1
                result=ok
        else
                result=fail
        fi
fi

# Test 553.
if test $result = ok -a $start_test_number -le 553; then
	echo test 553: Ackermann from Language Shootout
        cat >$test_file <<'TEST553'
fun Ack (m, n) {
  if (m == 0) return n + 1;
  if (n == 0) return Ack (m - 1, 1);
  return Ack (m - 1, Ack (m, n - 1));
}

var N = int (#argv < 1 ? 1 : argv [0]);
putln ("Ack(3,", N ,"): ", Ack (3, N));

TEST553
        echo '      ' $DINO $test_file 9 "2>$stderr"
        if $DINO $test_file 9 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT553' && $CMP $stdout $ftemp2; then
Ack(3,9): 4093
OUTPUT553
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 554.
if test $result = ok -a $start_test_number -le 554; then
	echo test 554: Binary Trees from Language Shootout
        cat >$test_file <<'TEST554'
class node (item, left, right) {}

fun BottomUpTree (item, depth) {
  if (depth <= 0) return item;
  var i = item + item;

  depth--;
  return node (item, BottomUpTree (i - 1, depth), BottomUpTree (i, depth));
}

fun ItemCheck (tree) {
  return (type (tree) != obj
	  ? tree : tree.item + ItemCheck (tree.left) - ItemCheck (tree.right));
}

var N = int (#argv < 1 ? 0 : argv [0]);
var mindepth = 4, maxdepth = max (N, mindepth + 2);
var stretchdepth = maxdepth + 1, stretchtree = BottomUpTree (0, stretchdepth);

putf ("stretch tree of depth %d\t  check: %d\n", stretchdepth,
      ItemCheck (stretchtree));

var i, depth, longlivedtree = BottomUpTree (0, maxdepth);

for (depth = mindepth; depth <= maxdepth; depth += 2) {
  var iterations = 1 << (maxdepth - depth + mindepth), check = 0;

  for (i = 0; i < iterations; i++)
    check += (ItemCheck (BottomUpTree (1, depth))
	      + ItemCheck (BottomUpTree (-1, depth)));
  putf ("%d\t  trees of depth %d\t  check: %d\n", iterations*2, depth, check);
}

putf ("long lived tree of depth %d\t  check: %d\n",
      maxdepth, ItemCheck (longlivedtree));
TEST554
        echo '      ' $DINO $test_file 12 "2>$stderr"
        if $DINO $test_file 12 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT554' && $CMP $stdout $ftemp2; then
stretch tree of depth 13	  check: -1
8192	  trees of depth 4	  check: -8192
2048	  trees of depth 6	  check: -2048
512	  trees of depth 8	  check: -512
128	  trees of depth 10	  check: -128
32	  trees of depth 12	  check: -32
long lived tree of depth 12	  check: -1
OUTPUT554
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 555.
if test $result = ok -a $start_test_number -le 555; then
	echo test 555: Chameneos from Language Shootout
        cat >$test_file <<'TEST555'
val blue = 0, red = 1, yellow = 2, faded = 3;
var colors = [blue, red, yellow, blue], N = int (#argv < 1 ? 10 : argv [0]);
var first = nil, second = nil;

// Create a very social creature.
class creature (my_color, creatures_met = 0) {
  thread be {
    for (;my_color != faded;) {
      var other;

      wait (second == nil); // Wait until meeting place clears.
      if (first != nil) { // Hey, I found a new friend!
	other = first; wait (1) {first = nil; second = my_color;}
      } else if (N > 0) { // Sniff, nobody here (yet).
	N--; first = my_color;
	wait (second != nil);
	other = second; wait (1) second = nil;
      } else other = faded; // meeting place is closed

      // change color
      if (other == faded) my_color = other;
      else {
	creatures_met++;
	if (my_color == other) ;
	else if (my_color == blue) my_color = (other == red ? yellow : red);
	else if (my_color == red) my_color = (other == blue ? yellow : blue);
	else if (my_color == yellow) my_color = (other == blue ? red : blue);
      }
    }
  }
}

var i, meetings = 0, creatures = [#colors : nil];

for (i = 0; i < #colors; i++) {
  creatures [i] = creature (colors [i]); creatures [i].be ();
}

for (i = 0; i < #colors; i++) {
  wait (creatures [i].my_color == faded);
  meetings += creatures [i].creatures_met;
}
putln (meetings);
TEST555
        echo '      ' $DINO $test_file 1000000 "2>$stderr"
        if $DINO $test_file 1000000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT555' && $CMP $stdout $ftemp2; then
2000000
OUTPUT555
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 556.
if test $result = ok -a $start_test_number -le 556; then
	echo test 556: Cheap Concurrency from Language Shootout
        cat >$test_file <<'TEST556'
var N = int (#argv < 1 ? 10 : argv [0]);
var cont_p = 1, i, t, first = nil, last = nil, count = 0;

class thread_node (next = nil, n = -1) {
  thread start {
    for (; cont_p;) {
      wait (n >= 0 || ! cont_p);
      if (next != nil) {next.n = n + 1; n = -1;}
    }
  }
}


for (i = 0; i < 500; i++) {
  t = thread_node (); t.start ();
  if (last == nil) {last = t; first = last;}
  else {last.next = t; last = last.next;}
}

for (i = 0; i < N; i++) {
  first.n = count; wait (last.n >= 0); count = last.n + 1; last.n = -1;
}
wait (1) cont_p = 0; putln (count);
TEST556
        echo '      ' $DINO $test_file 3000 "2>$stderr"
        if $DINO $test_file 3000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT556' && $CMP $stdout $ftemp2; then
1500000
OUTPUT556
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 557.
if test $result = ok -a $start_test_number -le 557; then
	echo test 557: Cheap Concurrency from Language Shootout
        cat >$test_file <<'TEST557'
var N = int (#argv < 1 ? 10 : argv [0]);
var cont_p = 1, i, t, first = nil, last = nil, count = 0;

class thread_node (next = nil, n = -1) {
  thread start {
    for (; cont_p;) {
      wait (n >= 0 || ! cont_p);
      if (next != nil) {next.n = n + 1; n = -1;}
    }
  }
}


for (i = 0; i < 500; i++) {
  t = thread_node (); t.start ();
  if (last == nil) {last = t; first = last;}
  else {last.next = t; last = last.next;}
}

for (i = 0; i < N; i++) {
  first.n = count; wait (last.n >= 0); count = last.n + 1; last.n = -1;
}
wait (1)cont_p = 0; putln (count);
TEST557
        echo '      ' $DINO $test_file 3000 "2>$stderr"
        if $DINO $test_file 3000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT557' && $CMP $stdout $ftemp2; then
1500000
OUTPUT557
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 558.
if test $result = ok -a $start_test_number -le 558; then
	echo test 558: Fasta from Language Shootout
        cat >$test_file <<'TEST558'
var IM = 139968, IA = 3877, IC = 29573, Last = 42;

fun random (max) {
  Last = (Last * IA + IC) % IM;
  return (max * Last) / IM;
}

class freq (c, p) {}

// Weighted selection from alphabet

fun makeCumulative (a) {
  var i, cp = 0, len = #a;

   for (i = 0; i < len; i++) {
     cp += a [i].p; a [i].p = cp;
   }
}

fun selectRandom (a) {
  var i, len = #a, r = random (1.0);

  for (i = 0; i < len; i++)
    if (r < a[i].p) return a [i].c;
  return a [len - 1].c;
}

// Generate and write FASTA format

fun makeRandomFasta (id, desc, a, n) {
  var i, m, length = 60;

  putln (">", id, " ", desc);
  for (;n > 0; n -= length) {
    m = (n < length ? n : length);
    for (i = 0; i < m; i++)
      put (selectRandom (a));
    putln ();
  }
}

fun makeRepeatFasta (id, desc, s, n) {
  var i, m, todo = n, length = 60, k = 0, kn = #s;

  putln (">", id, " ", desc);
  for (; todo > 0;) {
    m = (todo < length ? todo : length);
    for (i = 0; i < m; i++) {
      if (k >= kn)
	k = 0;
      put (s [k]);
      k++;
    }
    putln ();
    todo -= length;
  }
}


// Main -- define alphabets, make 3 fragments

var alu =   "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG"
          @ "GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA"
          @ "CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT"
          @ "ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA"
          @ "GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG"
	  @ "AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC"
          @ "AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

var iub = [ freq ('a', 0.27), freq ('c', 0.12), freq ('g', 0.12),
	    freq ('t', 0.27), freq ('B', 0.02), freq ('D', 0.02),
	    freq ('H', 0.02), freq ('K', 0.02), freq ('M', 0.02),
	    freq ('N', 0.02), freq ('R', 0.02), freq ('S', 0.02),
	    freq ('V', 0.02), freq ('W', 0.02), freq ('Y', 0.02) ];
makeCumulative (iub);

var homosapiens = [ freq ('a', 0.3029549426680), freq ('c', 0.1979883004921),
		    freq ('g', 0.1975473066391), freq ('t', 0.3015094502008) ];
makeCumulative (homosapiens);

var N = int (#argv < 1 ? 1000 : argv [0]);
makeRepeatFasta ("ONE", "Homo sapiens alu", alu, N * 2);
makeRandomFasta ("TWO", "IUB ambiguity codes", iub, N * 3);
makeRandomFasta ("THREE", "Homo sapiens frequency", homosapiens, N * 5);
TEST558
        echo '      ' $DINO $test_file 1000 "2>$stderr"
        if $DINO $test_file 1000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT558' && $CMP $stdout $ftemp2; then
>ONE Homo sapiens alu
GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGA
TCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACT
AAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAG
GCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCG
CCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGT
GGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCA
GGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAA
TTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAG
AATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCA
GCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGT
AATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACC
AGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTG
GTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACC
CGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAG
AGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTT
TGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACA
TGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCT
GTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGG
TTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGT
CTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGG
CGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCG
TCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTA
CTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCG
AGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCG
GGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACC
TGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAA
TACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGA
GGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACT
GCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTC
ACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGT
TCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGC
CGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCG
CTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTG
GGCGACAGAGCGAGACTCCG
>TWO IUB ambiguity codes
cttBtatcatatgctaKggNcataaaSatgtaaaDcDRtBggDtctttataattcBgtcg
tactDtDagcctatttSVHtHttKtgtHMaSattgWaHKHttttagacatWatgtRgaaa
NtactMcSMtYtcMgRtacttctWBacgaaatatagScDtttgaagacacatagtVgYgt
cattHWtMMWcStgttaggKtSgaYaaccWStcgBttgcgaMttBYatcWtgacaYcaga
gtaBDtRacttttcWatMttDBcatWtatcttactaBgaYtcttgttttttttYaaScYa
HgtgttNtSatcMtcVaaaStccRcctDaataataStcYtRDSaMtDttgttSagtRRca
tttHatSttMtWgtcgtatSSagactYaaattcaMtWatttaSgYttaRgKaRtccactt
tattRggaMcDaWaWagttttgacatgttctacaaaRaatataataaMttcgDacgaSSt
acaStYRctVaNMtMgtaggcKatcttttattaaaaagVWaHKYagtttttatttaacct
tacgtVtcVaattVMBcttaMtttaStgacttagattWWacVtgWYagWVRctDattBYt
gtttaagaagattattgacVatMaacattVctgtBSgaVtgWWggaKHaatKWcBScSWa
accRVacacaaactaccScattRatatKVtactatatttHttaagtttSKtRtacaaagt
RDttcaaaaWgcacatWaDgtDKacgaacaattacaRNWaatHtttStgttattaaMtgt
tgDcgtMgcatBtgcttcgcgaDWgagctgcgaggggVtaaScNatttacttaatgacag
cccccacatYScaMgtaggtYaNgttctgaMaacNaMRaacaaacaKctacatagYWctg
ttWaaataaaataRattagHacacaagcgKatacBttRttaagtatttccgatctHSaat
actcNttMaagtattMtgRtgaMgcataatHcMtaBSaRattagttgatHtMttaaKagg
YtaaBataSaVatactWtataVWgKgttaaaacagtgcgRatatacatVtHRtVYataSa
KtWaStVcNKHKttactatccctcatgWHatWaRcttactaggatctataDtDHBttata
aaaHgtacVtagaYttYaKcctattcttcttaataNDaaggaaaDYgcggctaaWSctBa
aNtgctggMBaKctaMVKagBaactaWaDaMaccYVtNtaHtVWtKgRtcaaNtYaNacg
gtttNattgVtttctgtBaWgtaattcaagtcaVWtactNggattctttaYtaaagccgc
tcttagHVggaYtgtNcDaVagctctctKgacgtatagYcctRYHDtgBattDaaDgccK
tcHaaStttMcctagtattgcRgWBaVatHaaaataYtgtttagMDMRtaataaggatMt
ttctWgtNtgtgaaaaMaatatRtttMtDgHHtgtcattttcWattRSHcVagaagtacg
ggtaKVattKYagactNaatgtttgKMMgYNtcccgSKttctaStatatNVataYHgtNa
BKRgNacaactgatttcctttaNcgatttctctataScaHtataRagtcRVttacDSDtt
aRtSatacHgtSKacYagttMHtWataggatgactNtatSaNctataVtttRNKtgRacc
tttYtatgttactttttcctttaaacatacaHactMacacggtWataMtBVacRaSaatc
cgtaBVttccagccBcttaRKtgtgcctttttRtgtcagcRttKtaaacKtaaatctcac
aattgcaNtSBaaccgggttattaaBcKatDagttactcttcattVtttHaaggctKKga
tacatcBggScagtVcacattttgaHaDSgHatRMaHWggtatatRgccDttcgtatcga
aacaHtaagttaRatgaVacttagattVKtaaYttaaatcaNatccRttRRaMScNaaaD
gttVHWgtcHaaHgacVaWtgttScactaagSgttatcttagggDtaccagWattWtRtg
ttHWHacgattBtgVcaYatcggttgagKcWtKKcaVtgaYgWctgYggVctgtHgaNcV
taBtWaaYatcDRaaRtSctgaHaYRttagatMatgcatttNattaDttaattgttctaa
ccctcccctagaWBtttHtBccttagaVaatMcBHagaVcWcagBVttcBtaYMccagat
gaaaaHctctaacgttagNWRtcggattNatcRaNHttcagtKttttgWatWttcSaNgg
gaWtactKKMaacatKatacNattgctWtatctaVgagctatgtRaHtYcWcttagccaa
tYttWttaWSSttaHcaaaaagVacVgtaVaRMgattaVcDactttcHHggHRtgNcctt
tYatcatKgctcctctatVcaaaaKaaaagtatatctgMtWtaaaacaStttMtcgactt
taSatcgDataaactaaacaagtaaVctaggaSccaatMVtaaSKNVattttgHccatca
cBVctgcaVatVttRtactgtVcaattHgtaaattaaattttYtatattaaRSgYtgBag
aHSBDgtagcacRHtYcBgtcacttacactaYcgctWtattgSHtSatcataaatataHt
cgtYaaMNgBaatttaRgaMaatatttBtttaaaHHKaatctgatWatYaacttMctctt
ttVctagctDaaagtaVaKaKRtaacBgtatccaaccactHHaagaagaaggaNaaatBW
attccgStaMSaMatBttgcatgRSacgttVVtaaDMtcSgVatWcaSatcttttVatag
ttactttacgatcaccNtaDVgSRcgVcgtgaacgaNtaNatatagtHtMgtHcMtagaa
attBgtataRaaaacaYKgtRccYtatgaagtaataKgtaaMttgaaRVatgcagaKStc
tHNaaatctBBtcttaYaBWHgtVtgacagcaRcataWctcaBcYacYgatDgtDHccta
>THREE Homo sapiens frequency
aacacttcaccaggtatcgtgaaggctcaagattacccagagaacctttgcaatataaga
atatgtatgcagcattaccctaagtaattatattctttttctgactcaaagtgacaagcc
ctagtgtatattaaatcggtatatttgggaaattcctcaaactatcctaatcaggtagcc
atgaaagtgatcaaaaaagttcgtacttataccatacatgaattctggccaagtaaaaaa
tagattgcgcaaaattcgtaccttaagtctctcgccaagatattaggatcctattactca
tatcgtgtttttctttattgccgccatccccggagtatctcacccatccttctcttaaag
gcctaatattacctatgcaaataaacatatattgttgaaaattgagaacctgatcgtgat
tcttatgtgtaccatatgtatagtaatcacgcgactatatagtgctttagtatcgcccgt
gggtgagtgaatattctgggctagcgtgagatagtttcttgtcctaatatttttcagatc
gaatagcttctatttttgtgtttattgacatatgtcgaaactccttactcagtgaaagtc
atgaccagatccacgaacaatcttcggaatcagtctcgttttacggcggaatcttgagtc
taacttatatcccgtcgcttactttctaacaccccttatgtatttttaaaattacgttta
ttcgaacgtacttggcggaagcgttattttttgaagtaagttacattgggcagactcttg
acattttcgatacgactttctttcatccatcacaggactcgttcgtattgatatcagaag
ctcgtgatgattagttgtcttctttaccaatactttgaggcctattctgcgaaatttttg
ttgccctgcgaacttcacataccaaggaacacctcgcaacatgccttcatatccatcgtt
cattgtaattcttacacaatgaatcctaagtaattacatccctgcgtaaaagatggtagg
ggcactgaggatatattaccaagcatttagttatgagtaatcagcaatgtttcttgtatt
aagttctctaaaatagttacatcgtaatgttatctcgggttccgcgaataaacgagatag
attcattatatatggccctaagcaaaaacctcctcgtattctgttggtaattagaatcac
acaatacgggttgagatattaattatttgtagtacgaagagatataaaaagatgaacaat
tactcaagtcaagatgtatacgggatttataataaaaatcgggtagagatctgctttgca
attcagacgtgccactaaatcgtaatatgtcgcgttacatcagaaagggtaactattatt
aattaataaagggcttaatcactacatattagatcttatccgatagtcttatctattcgt
tgtatttttaagcggttctaattcagtcattatatcagtgctccgagttctttattattg
ttttaaggatgacaaaatgcctcttgttataacgctgggagaagcagactaagagtcgga
gcagttggtagaatgaggctgcaaaagacggtctcgacgaatggacagactttactaaac
caatgaaagacagaagtagagcaaagtctgaagtggtatcagcttaattatgacaaccct
taatacttccctttcgccgaatactggcgtggaaaggttttaaaagtcgaagtagttaga
ggcatctctcgctcataaataggtagactactcgcaatccaatgtgactatgtaatactg
ggaacatcagtccgcgatgcagcgtgtttatcaaccgtccccactcgcctggggagacat
gagaccacccccgtggggattattagtccgcagtaatcgactcttgacaatccttttcga
ttatgtcatagcaatttacgacagttcagcgaagtgactactcggcgaaatggtattact
aaagcattcgaacccacatgaatgtgattcttggcaatttctaatccactaaagcttttc
cgttgaatctggttgtagatatttatataagttcactaattaagatcacggtagtatatt
gatagtgatgtctttgcaagaggttggccgaggaatttacggattctctattgatacaat
ttgtctggcttataactcttaaggctgaaccaggcgtttttagacgacttgatcagctgt
tagaatggtttggactccctctttcatgtcagtaacatttcagccgttattgttacgata
tgcttgaacaatattgatctaccacacacccatagtatattttataggtcatgctgttac
ctacgagcatggtattccacttcccattcaatgagtattcaacatcactagcctcagaga
tgatgacccacctctaataacgtcacgttgcggccatgtgaaacctgaacttgagtagac
gatatcaagcgctttaaattgcatataacatttgagggtaaagctaagcggatgctttat
ataatcaatactcaataataagatttgattgcattttagagttatgacacgacatagttc
actaacgagttactattcccagatctagactgaagtactgatcgagacgatccttacgtc
gatgatcgttagttatcgacttaggtcgggtctctagcggtattggtacttaaccggaca
ctatactaataacccatgatcaaagcataacagaatacagacgataatttcgccaacata
tatgtacagaccccaagcatgagaagctcattgaaagctatcattgaagtcccgctcaca
atgtgtcttttccagacggtttaactggttcccgggagtcctggagtttcgacttacata
aatggaaacaatgtattttgctaatttatctatagcgtcatttggaccaatacagaatat
tatgttgcctagtaatccactataacccgcaagtgctgatagaaaatttttagacgattt
ataaatgccccaagtatccctcccgtgaatcctccgttatactaattagtattcgttcat
acgtataccgcgcatatatgaacatttggcgataaggcgcgtgaattgttacgtgacaga
gatagcagtttcttgtgatatggttaacagacgtacatgaagggaaactttatatctata
gtgatgcttccgtagaaataccgccactggtctgccaatgatgaagtatgtagctttagg
tttgtactatgaggctttcgtttgtttgcagagtataacagttgcgagtgaaaaaccgac
gaatttatactaatacgctttcactattggctacaaaatagggaagagtttcaatcatga
gagggagtatatggatgctttgtagctaaaggtagaacgtatgtatatgctgccgttcat
tcttgaaagatacataagcgataagttacgacaattataagcaacatccctaccttcgta
acgatttcactgttactgcgcttgaaatacactatggggctattggcggagagaagcaga
tcgcgccgagcatatacgagacctataatgttgatgatagagaaggcgtctgaattgata
catcgaagtacactttctttcgtagtatctctcgtcctctttctatctccggacacaaga
attaagttatatatatagagtcttaccaatcatgttgaatcctgattctcagagttcttt
ggcgggccttgtgatgactgagaaacaatgcaatattgctccaaatttcctaagcaaatt
ctcggttatgttatgttatcagcaaagcgttacgttatgttatttaaatctggaatgacg
gagcgaagttcttatgtcggtgtgggaataattcttttgaagacagcactccttaaataa
tatcgctccgtgtttgtatttatcgaatgggtctgtaaccttgcacaagcaaatcggtgg
tgtatatatcggataacaattaatacgatgttcatagtgacagtatactgatcgagtcct
ctaaagtcaattacctcacttaacaatctcattgatgttgtgtcattcccggtatcgccc
gtagtatgtgctctgattgaccgagtgtgaaccaaggaacatctactaatgcctttgtta
ggtaagatctctctgaattccttcgtgccaacttaaaacattatcaaaatttcttctact
tggattaactacttttacgagcatggcaaattcccctgtggaagacggttcattattatc
ggaaaccttatagaaattgcgtgttgactgaaattagatttttattgtaagagttgcatc
tttgcgattcctctggtctagcttccaatgaacagtcctcccttctattcgacatcgggt
ccttcgtacatgtctttgcgatgtaataattaggttcggagtgtggccttaatgggtgca
actaggaatacaacgcaaatttgctgacatgatagcaaatcggtatgccggcaccaaaac
gtgctccttgcttagcttgtgaatgagactcagtagttaaataaatccatatctgcaatc
gattccacaggtattgtccactatctttgaactactctaagagatacaagcttagctgag
accgaggtgtatatgactacgctgatatctgtaaggtaccaatgcaggcaaagtatgcga
gaagctaataccggctgtttccagctttataagattaaaatttggctgtcctggcggcct
cagaattgttctatcgtaatcagttggttcattaattagctaagtacgaggtacaactta
tctgtcccagaacagctccacaagtttttttacagccgaaacccctgtgtgaatcttaat
atccaagcgcgttatctgattagagtttacaactcagtattttatcagtacgttttgttt
ccaacattacccggtatgacaaaatgacgccacgtgtcgaataatggtctgaccaatgta
ggaagtgaaaagataaatat
OUTPUT558
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 559.
if test $result = ok -a $start_test_number -le 559; then
	echo test 559: Fannkuch from Language Shootout
        cat >$test_file <<'TEST559'
fun fannkuch (n) {
   var perm, maxperm, perm1 = [n : 0], count = [n : 0];
   var i, k, t, flipscount, maxflipscount = 0, m = n - 1, r = n, check = 0;

   for (i = 0; i < n; i++) perm1 [i] = i;
   for (;;) {
      if (check < 30) {
         for (i = 0; i < n; i++) put (perm1 [i] + 1);
         putln (); check++;
      }

      for (; r != 1; r--) count [r - 1] = r;
      if (perm1 [0] != 0 && perm1 [m] != m) {
	perm = new perm1;
	for (flipscount = 0;; flipscount++) {
	  k = perm [0];
	  if (k == 0) break;
	  for (i = (k + 1) / 2 - 1; i >= 0 ; i--) {
            t = perm [i]; perm [i] = perm [k - i]; perm[k - i] = t;
          }
	}

	if (flipscount > maxflipscount) {
	  maxflipscount = flipscount; maxperm = new perm1;
	}
      }

      for (;;r++) {
         if (r == n) return maxflipscount;
         t = perm1 [0];
         for (i = 0; i < r; i++) perm1 [i] = perm1 [i + 1];
         perm1 [r] = t;
	 count [r]--;
         if (count [r] > 0) break;
      }
   }
}

var n = int (#argv < 1 ? 1 : argv [0]);
putln ("Pfannkuchen(", n, ") = ", fannkuch(n));
TEST559
        echo '      ' $DINO $test_file 9 "2>$stderr"
        if $DINO $test_file 9 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT559' && $CMP $stdout $ftemp2; then
123456789
213456789
231456789
321456789
312456789
132456789
234156789
324156789
342156789
432156789
423156789
243156789
341256789
431256789
413256789
143256789
134256789
314256789
412356789
142356789
124356789
214356789
241356789
421356789
234516789
324516789
342516789
432516789
423516789
243516789
Pfannkuchen(9) = 30
OUTPUT559
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 560.
if test $result = ok -a $start_test_number -le 560; then
	echo test 560: Harmonic from Language Shootout
        cat >$test_file <<'TEST560'
var d, partialSum = 0.0, n = int (#argv < 1 ? 10000000 : argv [0]);

for (d = 1; d <= n; d++) partialSum += 1.0 / d;
putf ("%0.9f\n", partialSum);
TEST560
        echo '      ' $DINO $test_file 10000000 "2>$stderr"
        if $DINO $test_file 10000000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT560' && $CMP $stdout $ftemp2; then
16.695311366
OUTPUT560
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 561.
if test $result = ok -a $start_test_number -le 561; then
	echo test 561: K-nucleotide from Language Shootout
        cat >$test_file <<'TEST561'
fun kfrequency (seq, freq, k, frame) {
  var i, c, stop = #seq - k + 1;

  for (i = frame; i < stop; i += k) {
    c = subv (seq, i, k);
    if (c in freq) freq [c]++;
    else freq [c] = 1;
  }
}

fun count (seq, frag) {
  var frame, k = #frag, freq = tab [];

  for (frame = 0; frame < k; frame++) kfrequency (seq, freq, k, frame);
  putln (frag in freq ? freq [frag] : 0, "\t", frag);
}

fun frequency (seq, k) {
  var i, c, sum, frame, freq = tab [], sfreq = [];
  fun freq_cmp (el1, el2) {
    return freq [el2] - freq [el1];
  }

  for (frame = 0; frame < k; frame++) kfrequency (seq, freq, k, frame);
  for (c in freq) ins (sfreq, c, -1);
  sfreq = sort (sfreq, freq_cmp);
  sum = #seq - k + 1;
  for (i = 0; i < #sfreq; i++) {
    c = sfreq [i];
    putf ("%s %0.3f\n", c, (freq [c] * 100.) / sum);
  }
  putln ();
}

fun readseq {
  var c, line, lines = [];

  try {
    for (;;) {
      line = getln ();
      if (line [0] == '>' && subv (line, 1, 5) == "THREE") break;
    }
    for (;;) {
      line = getln ();
      c = line [0];
      if (c == '>')
	break;
      else if (c != ';')
	insv (lines, toupper (line), -1);
    }
  } catch (eof) {}
  return lines;
}

var seq = readseq ();
frequency (seq, 1);
frequency (seq, 2);
count (seq, "GGT");
count (seq, "GGTA");
count (seq, "GGTATT");
count (seq, "GGTATTTTAATT");
count (seq, "GGTATTTTAATTTATAGT");
TEST561
        echo '      ' $DINO $test_file 1000 "2>$stderr"
        if $DINO $test_file 1000 <<'INPUT561' 2>$stderr >$stdout; then
>ONE Homo sapiens alu
GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGA
TCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACT
AAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAG
GCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCG
CCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGT
GGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCA
GGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAA
TTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAG
AATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCA
GCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGT
AATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACC
AGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTG
GTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACC
CGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAG
AGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTT
TGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACA
TGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCT
GTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGG
TTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGT
CTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGG
CGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCG
TCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTA
CTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCG
AGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCG
GGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACC
TGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAA
TACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGA
GGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACT
GCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTC
ACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGT
TCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGC
CGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCG
CTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTG
GGCGACAGAGCGAGACTCCG
>TWO IUB ambiguity codes
cttBtatcatatgctaKggNcataaaSatgtaaaDcDRtBggDtctttataattcBgtcg
tactDtDagcctatttSVHtHttKtgtHMaSattgWaHKHttttagacatWatgtRgaaa
NtactMcSMtYtcMgRtacttctWBacgaaatatagScDtttgaagacacatagtVgYgt
cattHWtMMWcStgttaggKtSgaYaaccWStcgBttgcgaMttBYatcWtgacaYcaga
gtaBDtRacttttcWatMttDBcatWtatcttactaBgaYtcttgttttttttYaaScYa
HgtgttNtSatcMtcVaaaStccRcctDaataataStcYtRDSaMtDttgttSagtRRca
tttHatSttMtWgtcgtatSSagactYaaattcaMtWatttaSgYttaRgKaRtccactt
tattRggaMcDaWaWagttttgacatgttctacaaaRaatataataaMttcgDacgaSSt
acaStYRctVaNMtMgtaggcKatcttttattaaaaagVWaHKYagtttttatttaacct
tacgtVtcVaattVMBcttaMtttaStgacttagattWWacVtgWYagWVRctDattBYt
gtttaagaagattattgacVatMaacattVctgtBSgaVtgWWggaKHaatKWcBScSWa
accRVacacaaactaccScattRatatKVtactatatttHttaagtttSKtRtacaaagt
RDttcaaaaWgcacatWaDgtDKacgaacaattacaRNWaatHtttStgttattaaMtgt
tgDcgtMgcatBtgcttcgcgaDWgagctgcgaggggVtaaScNatttacttaatgacag
cccccacatYScaMgtaggtYaNgttctgaMaacNaMRaacaaacaKctacatagYWctg
ttWaaataaaataRattagHacacaagcgKatacBttRttaagtatttccgatctHSaat
actcNttMaagtattMtgRtgaMgcataatHcMtaBSaRattagttgatHtMttaaKagg
YtaaBataSaVatactWtataVWgKgttaaaacagtgcgRatatacatVtHRtVYataSa
KtWaStVcNKHKttactatccctcatgWHatWaRcttactaggatctataDtDHBttata
aaaHgtacVtagaYttYaKcctattcttcttaataNDaaggaaaDYgcggctaaWSctBa
aNtgctggMBaKctaMVKagBaactaWaDaMaccYVtNtaHtVWtKgRtcaaNtYaNacg
gtttNattgVtttctgtBaWgtaattcaagtcaVWtactNggattctttaYtaaagccgc
tcttagHVggaYtgtNcDaVagctctctKgacgtatagYcctRYHDtgBattDaaDgccK
tcHaaStttMcctagtattgcRgWBaVatHaaaataYtgtttagMDMRtaataaggatMt
ttctWgtNtgtgaaaaMaatatRtttMtDgHHtgtcattttcWattRSHcVagaagtacg
ggtaKVattKYagactNaatgtttgKMMgYNtcccgSKttctaStatatNVataYHgtNa
BKRgNacaactgatttcctttaNcgatttctctataScaHtataRagtcRVttacDSDtt
aRtSatacHgtSKacYagttMHtWataggatgactNtatSaNctataVtttRNKtgRacc
tttYtatgttactttttcctttaaacatacaHactMacacggtWataMtBVacRaSaatc
cgtaBVttccagccBcttaRKtgtgcctttttRtgtcagcRttKtaaacKtaaatctcac
aattgcaNtSBaaccgggttattaaBcKatDagttactcttcattVtttHaaggctKKga
tacatcBggScagtVcacattttgaHaDSgHatRMaHWggtatatRgccDttcgtatcga
aacaHtaagttaRatgaVacttagattVKtaaYttaaatcaNatccRttRRaMScNaaaD
gttVHWgtcHaaHgacVaWtgttScactaagSgttatcttagggDtaccagWattWtRtg
ttHWHacgattBtgVcaYatcggttgagKcWtKKcaVtgaYgWctgYggVctgtHgaNcV
taBtWaaYatcDRaaRtSctgaHaYRttagatMatgcatttNattaDttaattgttctaa
ccctcccctagaWBtttHtBccttagaVaatMcBHagaVcWcagBVttcBtaYMccagat
gaaaaHctctaacgttagNWRtcggattNatcRaNHttcagtKttttgWatWttcSaNgg
gaWtactKKMaacatKatacNattgctWtatctaVgagctatgtRaHtYcWcttagccaa
tYttWttaWSSttaHcaaaaagVacVgtaVaRMgattaVcDactttcHHggHRtgNcctt
tYatcatKgctcctctatVcaaaaKaaaagtatatctgMtWtaaaacaStttMtcgactt
taSatcgDataaactaaacaagtaaVctaggaSccaatMVtaaSKNVattttgHccatca
cBVctgcaVatVttRtactgtVcaattHgtaaattaaattttYtatattaaRSgYtgBag
aHSBDgtagcacRHtYcBgtcacttacactaYcgctWtattgSHtSatcataaatataHt
cgtYaaMNgBaatttaRgaMaatatttBtttaaaHHKaatctgatWatYaacttMctctt
ttVctagctDaaagtaVaKaKRtaacBgtatccaaccactHHaagaagaaggaNaaatBW
attccgStaMSaMatBttgcatgRSacgttVVtaaDMtcSgVatWcaSatcttttVatag
ttactttacgatcaccNtaDVgSRcgVcgtgaacgaNtaNatatagtHtMgtHcMtagaa
attBgtataRaaaacaYKgtRccYtatgaagtaataKgtaaMttgaaRVatgcagaKStc
tHNaaatctBBtcttaYaBWHgtVtgacagcaRcataWctcaBcYacYgatDgtDHccta
>THREE Homo sapiens frequency
aacacttcaccaggtatcgtgaaggctcaagattacccagagaacctttgcaatataaga
atatgtatgcagcattaccctaagtaattatattctttttctgactcaaagtgacaagcc
ctagtgtatattaaatcggtatatttgggaaattcctcaaactatcctaatcaggtagcc
atgaaagtgatcaaaaaagttcgtacttataccatacatgaattctggccaagtaaaaaa
tagattgcgcaaaattcgtaccttaagtctctcgccaagatattaggatcctattactca
tatcgtgtttttctttattgccgccatccccggagtatctcacccatccttctcttaaag
gcctaatattacctatgcaaataaacatatattgttgaaaattgagaacctgatcgtgat
tcttatgtgtaccatatgtatagtaatcacgcgactatatagtgctttagtatcgcccgt
gggtgagtgaatattctgggctagcgtgagatagtttcttgtcctaatatttttcagatc
gaatagcttctatttttgtgtttattgacatatgtcgaaactccttactcagtgaaagtc
atgaccagatccacgaacaatcttcggaatcagtctcgttttacggcggaatcttgagtc
taacttatatcccgtcgcttactttctaacaccccttatgtatttttaaaattacgttta
ttcgaacgtacttggcggaagcgttattttttgaagtaagttacattgggcagactcttg
acattttcgatacgactttctttcatccatcacaggactcgttcgtattgatatcagaag
ctcgtgatgattagttgtcttctttaccaatactttgaggcctattctgcgaaatttttg
ttgccctgcgaacttcacataccaaggaacacctcgcaacatgccttcatatccatcgtt
cattgtaattcttacacaatgaatcctaagtaattacatccctgcgtaaaagatggtagg
ggcactgaggatatattaccaagcatttagttatgagtaatcagcaatgtttcttgtatt
aagttctctaaaatagttacatcgtaatgttatctcgggttccgcgaataaacgagatag
attcattatatatggccctaagcaaaaacctcctcgtattctgttggtaattagaatcac
acaatacgggttgagatattaattatttgtagtacgaagagatataaaaagatgaacaat
tactcaagtcaagatgtatacgggatttataataaaaatcgggtagagatctgctttgca
attcagacgtgccactaaatcgtaatatgtcgcgttacatcagaaagggtaactattatt
aattaataaagggcttaatcactacatattagatcttatccgatagtcttatctattcgt
tgtatttttaagcggttctaattcagtcattatatcagtgctccgagttctttattattg
ttttaaggatgacaaaatgcctcttgttataacgctgggagaagcagactaagagtcgga
gcagttggtagaatgaggctgcaaaagacggtctcgacgaatggacagactttactaaac
caatgaaagacagaagtagagcaaagtctgaagtggtatcagcttaattatgacaaccct
taatacttccctttcgccgaatactggcgtggaaaggttttaaaagtcgaagtagttaga
ggcatctctcgctcataaataggtagactactcgcaatccaatgtgactatgtaatactg
ggaacatcagtccgcgatgcagcgtgtttatcaaccgtccccactcgcctggggagacat
gagaccacccccgtggggattattagtccgcagtaatcgactcttgacaatccttttcga
ttatgtcatagcaatttacgacagttcagcgaagtgactactcggcgaaatggtattact
aaagcattcgaacccacatgaatgtgattcttggcaatttctaatccactaaagcttttc
cgttgaatctggttgtagatatttatataagttcactaattaagatcacggtagtatatt
gatagtgatgtctttgcaagaggttggccgaggaatttacggattctctattgatacaat
ttgtctggcttataactcttaaggctgaaccaggcgtttttagacgacttgatcagctgt
tagaatggtttggactccctctttcatgtcagtaacatttcagccgttattgttacgata
tgcttgaacaatattgatctaccacacacccatagtatattttataggtcatgctgttac
ctacgagcatggtattccacttcccattcaatgagtattcaacatcactagcctcagaga
tgatgacccacctctaataacgtcacgttgcggccatgtgaaacctgaacttgagtagac
gatatcaagcgctttaaattgcatataacatttgagggtaaagctaagcggatgctttat
ataatcaatactcaataataagatttgattgcattttagagttatgacacgacatagttc
actaacgagttactattcccagatctagactgaagtactgatcgagacgatccttacgtc
gatgatcgttagttatcgacttaggtcgggtctctagcggtattggtacttaaccggaca
ctatactaataacccatgatcaaagcataacagaatacagacgataatttcgccaacata
tatgtacagaccccaagcatgagaagctcattgaaagctatcattgaagtcccgctcaca
atgtgtcttttccagacggtttaactggttcccgggagtcctggagtttcgacttacata
aatggaaacaatgtattttgctaatttatctatagcgtcatttggaccaatacagaatat
tatgttgcctagtaatccactataacccgcaagtgctgatagaaaatttttagacgattt
ataaatgccccaagtatccctcccgtgaatcctccgttatactaattagtattcgttcat
acgtataccgcgcatatatgaacatttggcgataaggcgcgtgaattgttacgtgacaga
gatagcagtttcttgtgatatggttaacagacgtacatgaagggaaactttatatctata
gtgatgcttccgtagaaataccgccactggtctgccaatgatgaagtatgtagctttagg
tttgtactatgaggctttcgtttgtttgcagagtataacagttgcgagtgaaaaaccgac
gaatttatactaatacgctttcactattggctacaaaatagggaagagtttcaatcatga
gagggagtatatggatgctttgtagctaaaggtagaacgtatgtatatgctgccgttcat
tcttgaaagatacataagcgataagttacgacaattataagcaacatccctaccttcgta
acgatttcactgttactgcgcttgaaatacactatggggctattggcggagagaagcaga
tcgcgccgagcatatacgagacctataatgttgatgatagagaaggcgtctgaattgata
catcgaagtacactttctttcgtagtatctctcgtcctctttctatctccggacacaaga
attaagttatatatatagagtcttaccaatcatgttgaatcctgattctcagagttcttt
ggcgggccttgtgatgactgagaaacaatgcaatattgctccaaatttcctaagcaaatt
ctcggttatgttatgttatcagcaaagcgttacgttatgttatttaaatctggaatgacg
gagcgaagttcttatgtcggtgtgggaataattcttttgaagacagcactccttaaataa
tatcgctccgtgtttgtatttatcgaatgggtctgtaaccttgcacaagcaaatcggtgg
tgtatatatcggataacaattaatacgatgttcatagtgacagtatactgatcgagtcct
ctaaagtcaattacctcacttaacaatctcattgatgttgtgtcattcccggtatcgccc
gtagtatgtgctctgattgaccgagtgtgaaccaaggaacatctactaatgcctttgtta
ggtaagatctctctgaattccttcgtgccaacttaaaacattatcaaaatttcttctact
tggattaactacttttacgagcatggcaaattcccctgtggaagacggttcattattatc
ggaaaccttatagaaattgcgtgttgactgaaattagatttttattgtaagagttgcatc
tttgcgattcctctggtctagcttccaatgaacagtcctcccttctattcgacatcgggt
ccttcgtacatgtctttgcgatgtaataattaggttcggagtgtggccttaatgggtgca
actaggaatacaacgcaaatttgctgacatgatagcaaatcggtatgccggcaccaaaac
gtgctccttgcttagcttgtgaatgagactcagtagttaaataaatccatatctgcaatc
gattccacaggtattgtccactatctttgaactactctaagagatacaagcttagctgag
accgaggtgtatatgactacgctgatatctgtaaggtaccaatgcaggcaaagtatgcga
gaagctaataccggctgtttccagctttataagattaaaatttggctgtcctggcggcct
cagaattgttctatcgtaatcagttggttcattaattagctaagtacgaggtacaactta
tctgtcccagaacagctccacaagtttttttacagccgaaacccctgtgtgaatcttaat
atccaagcgcgttatctgattagagtttacaactcagtattttatcagtacgttttgttt
ccaacattacccggtatgacaaaatgacgccacgtgtcgaataatggtctgaccaatgta
ggaagtgaaaagataaatat
INPUT561
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT561' && $CMP $stdout $ftemp2; then
T 31.520
A 29.600
C 19.480
G 19.400

AT 9.922
TT 9.602
TA 9.402
AA 8.402
GA 6.321
TC 6.301
TG 6.201
GT 6.041
CT 5.961
AG 5.841
CA 5.461
AC 5.441
CC 4.041
CG 4.021
GC 3.701
GG 3.341

54	GGT
24	GGTA
4	GGTATT
0	GGTATTTTAATT
0	GGTATTTTAATTTATAGT
OUTPUT561
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 562.
if test $result = ok -a $start_test_number -le 562; then
	echo test 562: Fasta from Language Shootout
        cat >$test_file <<'TEST562'
var PI = 3.141592653589793;
var SOLAR_MASS = 4 * PI * PI;
var DAYS_PER_YEAR = 365.24;

class body (x, y, z, vx, vy, vz, mass) {}

var Jupiter = body (4.84143144246472090e+00,
		    -1.16032004402742839e+00,
	            -1.03622044471123109e-01,
		    1.66007664274403694e-03 * DAYS_PER_YEAR,
		    7.69901118419740425e-03 * DAYS_PER_YEAR,
		    -6.90460016972063023e-05 * DAYS_PER_YEAR,
		    9.54791938424326609e-04 * SOLAR_MASS);

var Saturn = body (8.34336671824457987e+00,
		   4.12479856412430479e+00,
		   -4.03523417114321381e-01,
		   -2.76742510726862411e-03 * DAYS_PER_YEAR,
		   4.99852801234917238e-03 * DAYS_PER_YEAR,
		   2.30417297573763929e-05 * DAYS_PER_YEAR,
		   2.85885980666130812e-04 * SOLAR_MASS);

var Uranus = body (1.28943695621391310e+01,
		   -1.51111514016986312e+01,
		   -2.23307578892655734e-01,
		   2.96460137564761618e-03 * DAYS_PER_YEAR,
		   2.37847173959480950e-03 * DAYS_PER_YEAR,
		   -2.96589568540237556e-05 * DAYS_PER_YEAR,
		   4.36624404335156298e-05 * SOLAR_MASS);

var Neptune = body (1.53796971148509165e+01,
		    -2.59193146099879641e+01,
		    1.79258772950371181e-01,
		    2.68067772490389322e-03 * DAYS_PER_YEAR,
		    1.62824170038242295e-03 * DAYS_PER_YEAR,
		    -9.51592254519715870e-05 * DAYS_PER_YEAR,
		    5.15138902046611451e-05 * SOLAR_MASS);

var Sun = body (0., 0., 0., 0., 0., 0., SOLAR_MASS);

fun advance (bodies, dt) {
  var i, j;

  for (i = 0; i < #bodies; i++) {
    var bi = bodies [i];
    var bix = bi.x, biy = bi.y, biz = bi.z, bimass = bi.mass;
    var bivx = bi.vx, bivy = bi.vy, bivz = bi.vz;

    for (j = i + 1; j < #bodies; j++) {
      var bj = bodies [j];
      var dx = bix - bj.x, dy = biy - bj.y, dz = biz - bj.z;
      var distance = sqrt (dx * dx + dy * dy + dz * dz);
      var mag = dt / (distance * distance * distance);
      var bim = bimass * mag, bjm = bj.mass * mag;
      
      bivx -= dx * bjm; bivy -= dy * bjm; bivz -= dz * bjm;
      bj.vx += dx * bim; bj.vy += dy * bim; bj.vz += dz * bim;
    }
    bi.vx = bivx; bi.vy = bivy; bi.vz = bivz;
  }
  for (i = 0; i < #bodies; i++) {
    var bi = bodies[i];

    bi.x += dt * bi.vx; bi.y += dt * bi.vy; bi.z += dt * bi.vz;
  }
}

fun energy (bodies) {
  var i, j, e = 0.;

  for (i = 0; i < #bodies; i++) {
    var bi = bodies [i];
    var vx = bi.vx, vy = bi.vy, vz = bi.vz, bim = bi.mass;

    e = e + (0.5 * bim * (vx * vx + vy * vy + vz * vz));
    for (j = i + 1; j < #bodies; j++) {
      var bj = bodies [j];
      var dx = bi.x - bj.x, dy = bi.y - bj.y, dz = bi.z - bj.z;
      var distance = sqrt (dx * dx + dy * dy + dz * dz);

      e = e - ((bim * bj.mass) / distance);
    }
  }
  return e;
}

fun offsetMomentum (b) {
  var i, px = 0., py = 0., pz = 0.;

  for (i = 0; i < #b; i++) {
    var bi = b [i];
    var bim = bi.mass;

    px = px + (bi.vx * bim);
    py = py + (bi.vy * bim);
    pz = pz + (bi.vz * bim);
  }
  b [0].vx = -px / SOLAR_MASS;
  b [0].vy = -py / SOLAR_MASS;
  b [0].vz = -pz / SOLAR_MASS;
}

var i, N = int (#argv < 1 ? 1000 : argv [0]);
var bodies = [Sun, Jupiter, Saturn, Uranus, Neptune];

offsetMomentum (bodies);
putf ("%0.9f\n", energy (bodies));
for (i = 0; i < N; i++) {advance (bodies, 0.01);}
putf ("%0.9f\n", energy (bodies));
TEST562
        echo '      ' $DINO $test_file 100000 "2>$stderr"
        if $DINO $test_file 100000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT562' && $CMP $stdout $ftemp2; then
-0.169075164
-0.169079859
OUTPUT562
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 563.
if test $result = ok -a $start_test_number -le 563; then
	echo test 563: Nsieve from Language Shootout
        cat >$test_file <<'TEST563'
fun nsieve (m) {
  var i, k, flags = [m + 1 : 1], count = 0;
  
  for (i = 2; i <= m; i++)
    if (flags [i]) {
      for (k = i + i; k <= m; k += i)
	flags [k] = 0;
      count++;
    }
  return count;
}

var i, m, n = max (2, int (#argv < 1 ? 1 : argv [0]));

for (i = 0; i <= 2; i++) {
  m = (1 << (n - i)) * 10000; putf ("Primes up to %8d %8d\n", m, nsieve (m));
}
TEST563
        echo '      ' $DINO $test_file 8 "2>$stderr"
        if $DINO $test_file 8 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT563' && $CMP $stdout $ftemp2; then
Primes up to  2560000   187134
Primes up to  1280000    98610
Primes up to   640000    52074
OUTPUT563
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 564.
if test $result = ok -a $start_test_number -le 564; then
	echo test 564: Nsieve Bits from Language Shootout
        cat >$test_file <<'TEST564'
var power = 5, precision = 1 << power, mask = precision - 1;

fun nsieve (m) {
  var i, k, cm = (m + precision) / precision, flags = [cm : ~0], count = 0;
  
  for (i = 2; i <= m; i++)
    if (flags [i >> power] & (1 << (i & mask))) {
      for (k = i + i; k <= m; k += i)
	flags [k >> power] &= ~(1 << (k & mask));
      count++;
    }
  return count;
}


var i, m, N = max (2, int (#argv < 1 ? 1 : argv [0]));

for (i = 0; i <= 2; i++) {
  m = (1 << (N - i)) * 10000;
  putf ("Primes up to %8d %8d\n", m, nsieve (m));
}
TEST564
        echo '      ' $DINO $test_file 8 "2>$stderr"
        if $DINO $test_file 8 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT564' && $CMP $stdout $ftemp2; then
Primes up to  2560000   187134
Primes up to  1280000    98610
Primes up to   640000    52074
OUTPUT564
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 565.
if test $result = ok -a $start_test_number -le 565; then
	echo test 565: Pidigits from Language Shootout
        cat >$test_file <<'TEST565'
var k = 0, z = [1L, 0L, 0L, 1L];

fun extract_digit; fun compose; fun next_lft;

fun next_digit {
  var y;

  for (;;) {
    y = extract_digit (3);
    if (y == extract_digit (4)) {
      z = compose ([10L, long (-10 * y), 0L, 1L], z);
      return y;
    }
    z = compose (z, next_lft ());
  }
}

fun next_lft {
  k++;
  return [long (k), long (4 * k + 2), 0L, long (2 * k + 1)];
}

fun extract_digit (x) {
  var xx = long (x);

  return int ((z [0] * xx + z [1]) / (z [2] * xx + z [3]));
}

fun compose (z, w) {
  return [z [0] * w [0] + z [1] * w [2], z [0] * w [1] + z [1] * w [3],
	  z [2] * w [0] + z [3] * w [2], z [2] * w [1] + z [3] * w [3]];
}

// main loop

var i, j, n = int (argv [0]);

for(i = 1; i <= n; i++) {
  put (next_digit());
  if (i % 10 == 0) putln ("\t:", i);
}

if (n % 10 != 0) {
  for (j = n % 10; j <= 10; j++) put (" ");
  putln ("\t:", n);
}
TEST565
        echo '      ' $DINO $test_file 1000 "2>$stderr"
        if $DINO $test_file 1000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT565' && $CMP $stdout $ftemp2; then
3141592653	:10
5897932384	:20
6264338327	:30
9502884197	:40
1693993751	:50
0582097494	:60
4592307816	:70
4062862089	:80
9862803482	:90
5342117067	:100
9821480865	:110
1328230664	:120
7093844609	:130
5505822317	:140
2535940812	:150
8481117450	:160
2841027019	:170
3852110555	:180
9644622948	:190
9549303819	:200
6442881097	:210
5665933446	:220
1284756482	:230
3378678316	:240
5271201909	:250
1456485669	:260
2346034861	:270
0454326648	:280
2133936072	:290
6024914127	:300
3724587006	:310
6063155881	:320
7488152092	:330
0962829254	:340
0917153643	:350
6789259036	:360
0011330530	:370
5488204665	:380
2138414695	:390
1941511609	:400
4330572703	:410
6575959195	:420
3092186117	:430
3819326117	:440
9310511854	:450
8074462379	:460
9627495673	:470
5188575272	:480
4891227938	:490
1830119491	:500
2983367336	:510
2440656643	:520
0860213949	:530
4639522473	:540
7190702179	:550
8609437027	:560
7053921717	:570
6293176752	:580
3846748184	:590
6766940513	:600
2000568127	:610
1452635608	:620
2778577134	:630
2757789609	:640
1736371787	:650
2146844090	:660
1224953430	:670
1465495853	:680
7105079227	:690
9689258923	:700
5420199561	:710
1212902196	:720
0864034418	:730
1598136297	:740
7477130996	:750
0518707211	:760
3499999983	:770
7297804995	:780
1059731732	:790
8160963185	:800
9502445945	:810
5346908302	:820
6425223082	:830
5334468503	:840
5261931188	:850
1710100031	:860
3783875288	:870
6587533208	:880
3814206171	:890
7766914730	:900
3598253490	:910
4287554687	:920
3115956286	:930
3882353787	:940
5937519577	:950
8185778053	:960
2171226806	:970
6130019278	:980
7661119590	:990
9216420198	:1000
OUTPUT565
                        result=ok
                else
                        result=fail
                fi
       elif fgrep 'run time error - can not find external function' $stderr >/dev/null;then
		echo GMP package is absent -- skip
                result=ok
        else
                result=fail
        fi
fi

# Test 567.
if test $result = ok -a $start_test_number -le 566; then
	echo test 566: Random from Language Shootout
        cat >$test_file <<'TEST567'
var c, i, v, seq = getf (), ilen = #seq;

seq = gsub (">[^\n]+\n|\n", seq, "");

var clen = #seq;
var variants = ["agggtaaa|tttaccct", "[cgt]gggtaaa|tttaccc[acg]",
		"a[act]ggtaaa|tttacc[agt]t", "ag[act]gtaaa|tttac[agt]ct",
		"agg[act]taaa|ttta[agt]cct", "aggg[acg]aaa|ttt[cgt]ccct",
		"agggt[cgt]aa|tt[acg]accct", "agggta[cgt]a|t[acg]taccct",
		"agggtaa[cgt]|[acg]ttaccct"];

for (i = 0; i < #variants; i++) {
  v = gmatch (variants [i], seq);
  putln (variants [i], " ", v == nil ? 0 : #v / 2);
}

var subst = tab [
  "B" : "(c|g|t)", "D" : "(a|g|t)", "H" : "(a|c|t)", "K" : "(g|t)",
  "M" : "(a|c)", "N" : "(a|c|g|t)", "R" : "(a|g)", "S" : "(c|g)",
  "V" : "(a|c|g)", "W" : "(a|t)", "Y" : "(c|t)"
];

for (c in subst)
  seq = gsub (c, seq, subst [c]);

putln ("\n", ilen, "\n", clen, "\n", #seq);
TEST567
        echo '      ' $DINO $test_file 1000 "2>$stderr"
        if $DINO $test_file 1000 <<'INPUT567' 2>$stderr >$stdout; then
>ONE Homo sapiens alu
GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGA
TCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACT
AAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAG
GCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCG
CCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGT
GGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCA
GGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAA
TTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAG
AATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCA
GCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGT
AATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACC
AGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTG
GTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACC
CGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAG
AGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTT
TGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACA
TGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCT
GTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGG
TTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGT
CTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGG
CGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCG
TCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTA
CTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCG
AGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCG
GGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACC
TGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAA
TACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGA
GGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACT
GCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTC
ACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGT
TCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGC
CGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCG
CTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTG
GGCGACAGAGCGAGACTCCG
>TWO IUB ambiguity codes
cttBtatcatatgctaKggNcataaaSatgtaaaDcDRtBggDtctttataattcBgtcg
tactDtDagcctatttSVHtHttKtgtHMaSattgWaHKHttttagacatWatgtRgaaa
NtactMcSMtYtcMgRtacttctWBacgaaatatagScDtttgaagacacatagtVgYgt
cattHWtMMWcStgttaggKtSgaYaaccWStcgBttgcgaMttBYatcWtgacaYcaga
gtaBDtRacttttcWatMttDBcatWtatcttactaBgaYtcttgttttttttYaaScYa
HgtgttNtSatcMtcVaaaStccRcctDaataataStcYtRDSaMtDttgttSagtRRca
tttHatSttMtWgtcgtatSSagactYaaattcaMtWatttaSgYttaRgKaRtccactt
tattRggaMcDaWaWagttttgacatgttctacaaaRaatataataaMttcgDacgaSSt
acaStYRctVaNMtMgtaggcKatcttttattaaaaagVWaHKYagtttttatttaacct
tacgtVtcVaattVMBcttaMtttaStgacttagattWWacVtgWYagWVRctDattBYt
gtttaagaagattattgacVatMaacattVctgtBSgaVtgWWggaKHaatKWcBScSWa
accRVacacaaactaccScattRatatKVtactatatttHttaagtttSKtRtacaaagt
RDttcaaaaWgcacatWaDgtDKacgaacaattacaRNWaatHtttStgttattaaMtgt
tgDcgtMgcatBtgcttcgcgaDWgagctgcgaggggVtaaScNatttacttaatgacag
cccccacatYScaMgtaggtYaNgttctgaMaacNaMRaacaaacaKctacatagYWctg
ttWaaataaaataRattagHacacaagcgKatacBttRttaagtatttccgatctHSaat
actcNttMaagtattMtgRtgaMgcataatHcMtaBSaRattagttgatHtMttaaKagg
YtaaBataSaVatactWtataVWgKgttaaaacagtgcgRatatacatVtHRtVYataSa
KtWaStVcNKHKttactatccctcatgWHatWaRcttactaggatctataDtDHBttata
aaaHgtacVtagaYttYaKcctattcttcttaataNDaaggaaaDYgcggctaaWSctBa
aNtgctggMBaKctaMVKagBaactaWaDaMaccYVtNtaHtVWtKgRtcaaNtYaNacg
gtttNattgVtttctgtBaWgtaattcaagtcaVWtactNggattctttaYtaaagccgc
tcttagHVggaYtgtNcDaVagctctctKgacgtatagYcctRYHDtgBattDaaDgccK
tcHaaStttMcctagtattgcRgWBaVatHaaaataYtgtttagMDMRtaataaggatMt
ttctWgtNtgtgaaaaMaatatRtttMtDgHHtgtcattttcWattRSHcVagaagtacg
ggtaKVattKYagactNaatgtttgKMMgYNtcccgSKttctaStatatNVataYHgtNa
BKRgNacaactgatttcctttaNcgatttctctataScaHtataRagtcRVttacDSDtt
aRtSatacHgtSKacYagttMHtWataggatgactNtatSaNctataVtttRNKtgRacc
tttYtatgttactttttcctttaaacatacaHactMacacggtWataMtBVacRaSaatc
cgtaBVttccagccBcttaRKtgtgcctttttRtgtcagcRttKtaaacKtaaatctcac
aattgcaNtSBaaccgggttattaaBcKatDagttactcttcattVtttHaaggctKKga
tacatcBggScagtVcacattttgaHaDSgHatRMaHWggtatatRgccDttcgtatcga
aacaHtaagttaRatgaVacttagattVKtaaYttaaatcaNatccRttRRaMScNaaaD
gttVHWgtcHaaHgacVaWtgttScactaagSgttatcttagggDtaccagWattWtRtg
ttHWHacgattBtgVcaYatcggttgagKcWtKKcaVtgaYgWctgYggVctgtHgaNcV
taBtWaaYatcDRaaRtSctgaHaYRttagatMatgcatttNattaDttaattgttctaa
ccctcccctagaWBtttHtBccttagaVaatMcBHagaVcWcagBVttcBtaYMccagat
gaaaaHctctaacgttagNWRtcggattNatcRaNHttcagtKttttgWatWttcSaNgg
gaWtactKKMaacatKatacNattgctWtatctaVgagctatgtRaHtYcWcttagccaa
tYttWttaWSSttaHcaaaaagVacVgtaVaRMgattaVcDactttcHHggHRtgNcctt
tYatcatKgctcctctatVcaaaaKaaaagtatatctgMtWtaaaacaStttMtcgactt
taSatcgDataaactaaacaagtaaVctaggaSccaatMVtaaSKNVattttgHccatca
cBVctgcaVatVttRtactgtVcaattHgtaaattaaattttYtatattaaRSgYtgBag
aHSBDgtagcacRHtYcBgtcacttacactaYcgctWtattgSHtSatcataaatataHt
cgtYaaMNgBaatttaRgaMaatatttBtttaaaHHKaatctgatWatYaacttMctctt
ttVctagctDaaagtaVaKaKRtaacBgtatccaaccactHHaagaagaaggaNaaatBW
attccgStaMSaMatBttgcatgRSacgttVVtaaDMtcSgVatWcaSatcttttVatag
ttactttacgatcaccNtaDVgSRcgVcgtgaacgaNtaNatatagtHtMgtHcMtagaa
attBgtataRaaaacaYKgtRccYtatgaagtaataKgtaaMttgaaRVatgcagaKStc
tHNaaatctBBtcttaYaBWHgtVtgacagcaRcataWctcaBcYacYgatDgtDHccta
>THREE Homo sapiens frequency
aacacttcaccaggtatcgtgaaggctcaagattacccagagaacctttgcaatataaga
atatgtatgcagcattaccctaagtaattatattctttttctgactcaaagtgacaagcc
ctagtgtatattaaatcggtatatttgggaaattcctcaaactatcctaatcaggtagcc
atgaaagtgatcaaaaaagttcgtacttataccatacatgaattctggccaagtaaaaaa
tagattgcgcaaaattcgtaccttaagtctctcgccaagatattaggatcctattactca
tatcgtgtttttctttattgccgccatccccggagtatctcacccatccttctcttaaag
gcctaatattacctatgcaaataaacatatattgttgaaaattgagaacctgatcgtgat
tcttatgtgtaccatatgtatagtaatcacgcgactatatagtgctttagtatcgcccgt
gggtgagtgaatattctgggctagcgtgagatagtttcttgtcctaatatttttcagatc
gaatagcttctatttttgtgtttattgacatatgtcgaaactccttactcagtgaaagtc
atgaccagatccacgaacaatcttcggaatcagtctcgttttacggcggaatcttgagtc
taacttatatcccgtcgcttactttctaacaccccttatgtatttttaaaattacgttta
ttcgaacgtacttggcggaagcgttattttttgaagtaagttacattgggcagactcttg
acattttcgatacgactttctttcatccatcacaggactcgttcgtattgatatcagaag
ctcgtgatgattagttgtcttctttaccaatactttgaggcctattctgcgaaatttttg
ttgccctgcgaacttcacataccaaggaacacctcgcaacatgccttcatatccatcgtt
cattgtaattcttacacaatgaatcctaagtaattacatccctgcgtaaaagatggtagg
ggcactgaggatatattaccaagcatttagttatgagtaatcagcaatgtttcttgtatt
aagttctctaaaatagttacatcgtaatgttatctcgggttccgcgaataaacgagatag
attcattatatatggccctaagcaaaaacctcctcgtattctgttggtaattagaatcac
acaatacgggttgagatattaattatttgtagtacgaagagatataaaaagatgaacaat
tactcaagtcaagatgtatacgggatttataataaaaatcgggtagagatctgctttgca
attcagacgtgccactaaatcgtaatatgtcgcgttacatcagaaagggtaactattatt
aattaataaagggcttaatcactacatattagatcttatccgatagtcttatctattcgt
tgtatttttaagcggttctaattcagtcattatatcagtgctccgagttctttattattg
ttttaaggatgacaaaatgcctcttgttataacgctgggagaagcagactaagagtcgga
gcagttggtagaatgaggctgcaaaagacggtctcgacgaatggacagactttactaaac
caatgaaagacagaagtagagcaaagtctgaagtggtatcagcttaattatgacaaccct
taatacttccctttcgccgaatactggcgtggaaaggttttaaaagtcgaagtagttaga
ggcatctctcgctcataaataggtagactactcgcaatccaatgtgactatgtaatactg
ggaacatcagtccgcgatgcagcgtgtttatcaaccgtccccactcgcctggggagacat
gagaccacccccgtggggattattagtccgcagtaatcgactcttgacaatccttttcga
ttatgtcatagcaatttacgacagttcagcgaagtgactactcggcgaaatggtattact
aaagcattcgaacccacatgaatgtgattcttggcaatttctaatccactaaagcttttc
cgttgaatctggttgtagatatttatataagttcactaattaagatcacggtagtatatt
gatagtgatgtctttgcaagaggttggccgaggaatttacggattctctattgatacaat
ttgtctggcttataactcttaaggctgaaccaggcgtttttagacgacttgatcagctgt
tagaatggtttggactccctctttcatgtcagtaacatttcagccgttattgttacgata
tgcttgaacaatattgatctaccacacacccatagtatattttataggtcatgctgttac
ctacgagcatggtattccacttcccattcaatgagtattcaacatcactagcctcagaga
tgatgacccacctctaataacgtcacgttgcggccatgtgaaacctgaacttgagtagac
gatatcaagcgctttaaattgcatataacatttgagggtaaagctaagcggatgctttat
ataatcaatactcaataataagatttgattgcattttagagttatgacacgacatagttc
actaacgagttactattcccagatctagactgaagtactgatcgagacgatccttacgtc
gatgatcgttagttatcgacttaggtcgggtctctagcggtattggtacttaaccggaca
ctatactaataacccatgatcaaagcataacagaatacagacgataatttcgccaacata
tatgtacagaccccaagcatgagaagctcattgaaagctatcattgaagtcccgctcaca
atgtgtcttttccagacggtttaactggttcccgggagtcctggagtttcgacttacata
aatggaaacaatgtattttgctaatttatctatagcgtcatttggaccaatacagaatat
tatgttgcctagtaatccactataacccgcaagtgctgatagaaaatttttagacgattt
ataaatgccccaagtatccctcccgtgaatcctccgttatactaattagtattcgttcat
acgtataccgcgcatatatgaacatttggcgataaggcgcgtgaattgttacgtgacaga
gatagcagtttcttgtgatatggttaacagacgtacatgaagggaaactttatatctata
gtgatgcttccgtagaaataccgccactggtctgccaatgatgaagtatgtagctttagg
tttgtactatgaggctttcgtttgtttgcagagtataacagttgcgagtgaaaaaccgac
gaatttatactaatacgctttcactattggctacaaaatagggaagagtttcaatcatga
gagggagtatatggatgctttgtagctaaaggtagaacgtatgtatatgctgccgttcat
tcttgaaagatacataagcgataagttacgacaattataagcaacatccctaccttcgta
acgatttcactgttactgcgcttgaaatacactatggggctattggcggagagaagcaga
tcgcgccgagcatatacgagacctataatgttgatgatagagaaggcgtctgaattgata
catcgaagtacactttctttcgtagtatctctcgtcctctttctatctccggacacaaga
attaagttatatatatagagtcttaccaatcatgttgaatcctgattctcagagttcttt
ggcgggccttgtgatgactgagaaacaatgcaatattgctccaaatttcctaagcaaatt
ctcggttatgttatgttatcagcaaagcgttacgttatgttatttaaatctggaatgacg
gagcgaagttcttatgtcggtgtgggaataattcttttgaagacagcactccttaaataa
tatcgctccgtgtttgtatttatcgaatgggtctgtaaccttgcacaagcaaatcggtgg
tgtatatatcggataacaattaatacgatgttcatagtgacagtatactgatcgagtcct
ctaaagtcaattacctcacttaacaatctcattgatgttgtgtcattcccggtatcgccc
gtagtatgtgctctgattgaccgagtgtgaaccaaggaacatctactaatgcctttgtta
ggtaagatctctctgaattccttcgtgccaacttaaaacattatcaaaatttcttctact
tggattaactacttttacgagcatggcaaattcccctgtggaagacggttcattattatc
ggaaaccttatagaaattgcgtgttgactgaaattagatttttattgtaagagttgcatc
tttgcgattcctctggtctagcttccaatgaacagtcctcccttctattcgacatcgggt
ccttcgtacatgtctttgcgatgtaataattaggttcggagtgtggccttaatgggtgca
actaggaatacaacgcaaatttgctgacatgatagcaaatcggtatgccggcaccaaaac
gtgctccttgcttagcttgtgaatgagactcagtagttaaataaatccatatctgcaatc
gattccacaggtattgtccactatctttgaactactctaagagatacaagcttagctgag
accgaggtgtatatgactacgctgatatctgtaaggtaccaatgcaggcaaagtatgcga
gaagctaataccggctgtttccagctttataagattaaaatttggctgtcctggcggcct
cagaattgttctatcgtaatcagttggttcattaattagctaagtacgaggtacaactta
tctgtcccagaacagctccacaagtttttttacagccgaaacccctgtgtgaatcttaat
atccaagcgcgttatctgattagagtttacaactcagtattttatcagtacgttttgttt
ccaacattacccggtatgacaaaatgacgccacgtgtcgaataatggtctgaccaatgta
ggaagtgaaaagataaatat
INPUT567
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT567' && $CMP $stdout $ftemp2; then
agggtaaa|tttaccct 1
[cgt]gggtaaa|tttaccc[acg] 0
a[act]ggtaaa|tttacc[agt]t 0
ag[act]gtaaa|tttac[agt]ct 0
agg[act]taaa|ttta[agt]cct 1
aggg[acg]aaa|ttt[cgt]ccct 0
agggt[cgt]aa|tt[acg]accct 0
agggta[cgt]a|t[acg]taccct 0
agggtaa[cgt]|[acg]ttaccct 2

10245
10000
13348
OUTPUT567
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 568.
if test $result = ok -a $start_test_number -le 568; then
	echo test 568: Reverse Complement from Language Shootout
        cat >$test_file <<'TEST568'
var tr =   "ACBDGHKMNSRUTWVYacbdghkmnsrutwvy";
var subst = "TGVHCDMKNSYAAWBRTGVHCDMKNSYAAWBR";
var line, seq = [];

fun output_seq (seq) {
  var i;

  for (i = 0; i < #seq; i += 60) putln (subv (seq, i, 60));
}

try {
  for (;;) {
    line = getln ();
    if (line [0] != '>') insv (seq, line, -1);
    else {
      output_seq (translit (rev (seq), tr, subst));
      del (seq, 0, -1); putln (line);
    }
  }
} catch (eof) {}

output_seq (translit (rev (seq), tr, subst));
TEST568
        echo '      ' $DINO $test_file 1000 "2>$stderr"
        if $DINO $test_file 1000 <<'INPUT568' 2>$stderr >$stdout; then
>ONE Homo sapiens alu
GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGA
TCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACT
AAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAG
GCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCG
CCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGT
GGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCA
GGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAA
TTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAG
AATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCA
GCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGT
AATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACC
AGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTG
GTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACC
CGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAG
AGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTT
TGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACA
TGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCT
GTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGG
TTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGT
CTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGG
CGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCG
TCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTA
CTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCG
AGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCG
GGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACC
TGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAA
TACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGA
GGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACT
GCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTC
ACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGT
TCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGC
CGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCG
CTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTG
GGCGACAGAGCGAGACTCCG
>TWO IUB ambiguity codes
cttBtatcatatgctaKggNcataaaSatgtaaaDcDRtBggDtctttataattcBgtcg
tactDtDagcctatttSVHtHttKtgtHMaSattgWaHKHttttagacatWatgtRgaaa
NtactMcSMtYtcMgRtacttctWBacgaaatatagScDtttgaagacacatagtVgYgt
cattHWtMMWcStgttaggKtSgaYaaccWStcgBttgcgaMttBYatcWtgacaYcaga
gtaBDtRacttttcWatMttDBcatWtatcttactaBgaYtcttgttttttttYaaScYa
HgtgttNtSatcMtcVaaaStccRcctDaataataStcYtRDSaMtDttgttSagtRRca
tttHatSttMtWgtcgtatSSagactYaaattcaMtWatttaSgYttaRgKaRtccactt
tattRggaMcDaWaWagttttgacatgttctacaaaRaatataataaMttcgDacgaSSt
acaStYRctVaNMtMgtaggcKatcttttattaaaaagVWaHKYagtttttatttaacct
tacgtVtcVaattVMBcttaMtttaStgacttagattWWacVtgWYagWVRctDattBYt
gtttaagaagattattgacVatMaacattVctgtBSgaVtgWWggaKHaatKWcBScSWa
accRVacacaaactaccScattRatatKVtactatatttHttaagtttSKtRtacaaagt
RDttcaaaaWgcacatWaDgtDKacgaacaattacaRNWaatHtttStgttattaaMtgt
tgDcgtMgcatBtgcttcgcgaDWgagctgcgaggggVtaaScNatttacttaatgacag
cccccacatYScaMgtaggtYaNgttctgaMaacNaMRaacaaacaKctacatagYWctg
ttWaaataaaataRattagHacacaagcgKatacBttRttaagtatttccgatctHSaat
actcNttMaagtattMtgRtgaMgcataatHcMtaBSaRattagttgatHtMttaaKagg
YtaaBataSaVatactWtataVWgKgttaaaacagtgcgRatatacatVtHRtVYataSa
KtWaStVcNKHKttactatccctcatgWHatWaRcttactaggatctataDtDHBttata
aaaHgtacVtagaYttYaKcctattcttcttaataNDaaggaaaDYgcggctaaWSctBa
aNtgctggMBaKctaMVKagBaactaWaDaMaccYVtNtaHtVWtKgRtcaaNtYaNacg
gtttNattgVtttctgtBaWgtaattcaagtcaVWtactNggattctttaYtaaagccgc
tcttagHVggaYtgtNcDaVagctctctKgacgtatagYcctRYHDtgBattDaaDgccK
tcHaaStttMcctagtattgcRgWBaVatHaaaataYtgtttagMDMRtaataaggatMt
ttctWgtNtgtgaaaaMaatatRtttMtDgHHtgtcattttcWattRSHcVagaagtacg
ggtaKVattKYagactNaatgtttgKMMgYNtcccgSKttctaStatatNVataYHgtNa
BKRgNacaactgatttcctttaNcgatttctctataScaHtataRagtcRVttacDSDtt
aRtSatacHgtSKacYagttMHtWataggatgactNtatSaNctataVtttRNKtgRacc
tttYtatgttactttttcctttaaacatacaHactMacacggtWataMtBVacRaSaatc
cgtaBVttccagccBcttaRKtgtgcctttttRtgtcagcRttKtaaacKtaaatctcac
aattgcaNtSBaaccgggttattaaBcKatDagttactcttcattVtttHaaggctKKga
tacatcBggScagtVcacattttgaHaDSgHatRMaHWggtatatRgccDttcgtatcga
aacaHtaagttaRatgaVacttagattVKtaaYttaaatcaNatccRttRRaMScNaaaD
gttVHWgtcHaaHgacVaWtgttScactaagSgttatcttagggDtaccagWattWtRtg
ttHWHacgattBtgVcaYatcggttgagKcWtKKcaVtgaYgWctgYggVctgtHgaNcV
taBtWaaYatcDRaaRtSctgaHaYRttagatMatgcatttNattaDttaattgttctaa
ccctcccctagaWBtttHtBccttagaVaatMcBHagaVcWcagBVttcBtaYMccagat
gaaaaHctctaacgttagNWRtcggattNatcRaNHttcagtKttttgWatWttcSaNgg
gaWtactKKMaacatKatacNattgctWtatctaVgagctatgtRaHtYcWcttagccaa
tYttWttaWSSttaHcaaaaagVacVgtaVaRMgattaVcDactttcHHggHRtgNcctt
tYatcatKgctcctctatVcaaaaKaaaagtatatctgMtWtaaaacaStttMtcgactt
taSatcgDataaactaaacaagtaaVctaggaSccaatMVtaaSKNVattttgHccatca
cBVctgcaVatVttRtactgtVcaattHgtaaattaaattttYtatattaaRSgYtgBag
aHSBDgtagcacRHtYcBgtcacttacactaYcgctWtattgSHtSatcataaatataHt
cgtYaaMNgBaatttaRgaMaatatttBtttaaaHHKaatctgatWatYaacttMctctt
ttVctagctDaaagtaVaKaKRtaacBgtatccaaccactHHaagaagaaggaNaaatBW
attccgStaMSaMatBttgcatgRSacgttVVtaaDMtcSgVatWcaSatcttttVatag
ttactttacgatcaccNtaDVgSRcgVcgtgaacgaNtaNatatagtHtMgtHcMtagaa
attBgtataRaaaacaYKgtRccYtatgaagtaataKgtaaMttgaaRVatgcagaKStc
tHNaaatctBBtcttaYaBWHgtVtgacagcaRcataWctcaBcYacYgatDgtDHccta
>THREE Homo sapiens frequency
aacacttcaccaggtatcgtgaaggctcaagattacccagagaacctttgcaatataaga
atatgtatgcagcattaccctaagtaattatattctttttctgactcaaagtgacaagcc
ctagtgtatattaaatcggtatatttgggaaattcctcaaactatcctaatcaggtagcc
atgaaagtgatcaaaaaagttcgtacttataccatacatgaattctggccaagtaaaaaa
tagattgcgcaaaattcgtaccttaagtctctcgccaagatattaggatcctattactca
tatcgtgtttttctttattgccgccatccccggagtatctcacccatccttctcttaaag
gcctaatattacctatgcaaataaacatatattgttgaaaattgagaacctgatcgtgat
tcttatgtgtaccatatgtatagtaatcacgcgactatatagtgctttagtatcgcccgt
gggtgagtgaatattctgggctagcgtgagatagtttcttgtcctaatatttttcagatc
gaatagcttctatttttgtgtttattgacatatgtcgaaactccttactcagtgaaagtc
atgaccagatccacgaacaatcttcggaatcagtctcgttttacggcggaatcttgagtc
taacttatatcccgtcgcttactttctaacaccccttatgtatttttaaaattacgttta
ttcgaacgtacttggcggaagcgttattttttgaagtaagttacattgggcagactcttg
acattttcgatacgactttctttcatccatcacaggactcgttcgtattgatatcagaag
ctcgtgatgattagttgtcttctttaccaatactttgaggcctattctgcgaaatttttg
ttgccctgcgaacttcacataccaaggaacacctcgcaacatgccttcatatccatcgtt
cattgtaattcttacacaatgaatcctaagtaattacatccctgcgtaaaagatggtagg
ggcactgaggatatattaccaagcatttagttatgagtaatcagcaatgtttcttgtatt
aagttctctaaaatagttacatcgtaatgttatctcgggttccgcgaataaacgagatag
attcattatatatggccctaagcaaaaacctcctcgtattctgttggtaattagaatcac
acaatacgggttgagatattaattatttgtagtacgaagagatataaaaagatgaacaat
tactcaagtcaagatgtatacgggatttataataaaaatcgggtagagatctgctttgca
attcagacgtgccactaaatcgtaatatgtcgcgttacatcagaaagggtaactattatt
aattaataaagggcttaatcactacatattagatcttatccgatagtcttatctattcgt
tgtatttttaagcggttctaattcagtcattatatcagtgctccgagttctttattattg
ttttaaggatgacaaaatgcctcttgttataacgctgggagaagcagactaagagtcgga
gcagttggtagaatgaggctgcaaaagacggtctcgacgaatggacagactttactaaac
caatgaaagacagaagtagagcaaagtctgaagtggtatcagcttaattatgacaaccct
taatacttccctttcgccgaatactggcgtggaaaggttttaaaagtcgaagtagttaga
ggcatctctcgctcataaataggtagactactcgcaatccaatgtgactatgtaatactg
ggaacatcagtccgcgatgcagcgtgtttatcaaccgtccccactcgcctggggagacat
gagaccacccccgtggggattattagtccgcagtaatcgactcttgacaatccttttcga
ttatgtcatagcaatttacgacagttcagcgaagtgactactcggcgaaatggtattact
aaagcattcgaacccacatgaatgtgattcttggcaatttctaatccactaaagcttttc
cgttgaatctggttgtagatatttatataagttcactaattaagatcacggtagtatatt
gatagtgatgtctttgcaagaggttggccgaggaatttacggattctctattgatacaat
ttgtctggcttataactcttaaggctgaaccaggcgtttttagacgacttgatcagctgt
tagaatggtttggactccctctttcatgtcagtaacatttcagccgttattgttacgata
tgcttgaacaatattgatctaccacacacccatagtatattttataggtcatgctgttac
ctacgagcatggtattccacttcccattcaatgagtattcaacatcactagcctcagaga
tgatgacccacctctaataacgtcacgttgcggccatgtgaaacctgaacttgagtagac
gatatcaagcgctttaaattgcatataacatttgagggtaaagctaagcggatgctttat
ataatcaatactcaataataagatttgattgcattttagagttatgacacgacatagttc
actaacgagttactattcccagatctagactgaagtactgatcgagacgatccttacgtc
gatgatcgttagttatcgacttaggtcgggtctctagcggtattggtacttaaccggaca
ctatactaataacccatgatcaaagcataacagaatacagacgataatttcgccaacata
tatgtacagaccccaagcatgagaagctcattgaaagctatcattgaagtcccgctcaca
atgtgtcttttccagacggtttaactggttcccgggagtcctggagtttcgacttacata
aatggaaacaatgtattttgctaatttatctatagcgtcatttggaccaatacagaatat
tatgttgcctagtaatccactataacccgcaagtgctgatagaaaatttttagacgattt
ataaatgccccaagtatccctcccgtgaatcctccgttatactaattagtattcgttcat
acgtataccgcgcatatatgaacatttggcgataaggcgcgtgaattgttacgtgacaga
gatagcagtttcttgtgatatggttaacagacgtacatgaagggaaactttatatctata
gtgatgcttccgtagaaataccgccactggtctgccaatgatgaagtatgtagctttagg
tttgtactatgaggctttcgtttgtttgcagagtataacagttgcgagtgaaaaaccgac
gaatttatactaatacgctttcactattggctacaaaatagggaagagtttcaatcatga
gagggagtatatggatgctttgtagctaaaggtagaacgtatgtatatgctgccgttcat
tcttgaaagatacataagcgataagttacgacaattataagcaacatccctaccttcgta
acgatttcactgttactgcgcttgaaatacactatggggctattggcggagagaagcaga
tcgcgccgagcatatacgagacctataatgttgatgatagagaaggcgtctgaattgata
catcgaagtacactttctttcgtagtatctctcgtcctctttctatctccggacacaaga
attaagttatatatatagagtcttaccaatcatgttgaatcctgattctcagagttcttt
ggcgggccttgtgatgactgagaaacaatgcaatattgctccaaatttcctaagcaaatt
ctcggttatgttatgttatcagcaaagcgttacgttatgttatttaaatctggaatgacg
gagcgaagttcttatgtcggtgtgggaataattcttttgaagacagcactccttaaataa
tatcgctccgtgtttgtatttatcgaatgggtctgtaaccttgcacaagcaaatcggtgg
tgtatatatcggataacaattaatacgatgttcatagtgacagtatactgatcgagtcct
ctaaagtcaattacctcacttaacaatctcattgatgttgtgtcattcccggtatcgccc
gtagtatgtgctctgattgaccgagtgtgaaccaaggaacatctactaatgcctttgtta
ggtaagatctctctgaattccttcgtgccaacttaaaacattatcaaaatttcttctact
tggattaactacttttacgagcatggcaaattcccctgtggaagacggttcattattatc
ggaaaccttatagaaattgcgtgttgactgaaattagatttttattgtaagagttgcatc
tttgcgattcctctggtctagcttccaatgaacagtcctcccttctattcgacatcgggt
ccttcgtacatgtctttgcgatgtaataattaggttcggagtgtggccttaatgggtgca
actaggaatacaacgcaaatttgctgacatgatagcaaatcggtatgccggcaccaaaac
gtgctccttgcttagcttgtgaatgagactcagtagttaaataaatccatatctgcaatc
gattccacaggtattgtccactatctttgaactactctaagagatacaagcttagctgag
accgaggtgtatatgactacgctgatatctgtaaggtaccaatgcaggcaaagtatgcga
gaagctaataccggctgtttccagctttataagattaaaatttggctgtcctggcggcct
cagaattgttctatcgtaatcagttggttcattaattagctaagtacgaggtacaactta
tctgtcccagaacagctccacaagtttttttacagccgaaacccctgtgtgaatcttaat
atccaagcgcgttatctgattagagtttacaactcagtattttatcagtacgttttgttt
ccaacattacccggtatgacaaaatgacgccacgtgtcgaataatggtctgaccaatgta
ggaagtgaaaagataaatat
INPUT568
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT568' && $CMP $stdout $ftemp2; then
>ONE Homo sapiens alu
CGGAGTCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAAC
CTCCGCCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACA
GGCGCGCGCCACCACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCAT
GTTGGCCAGGCTGGTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAA
AGTGCTGGGATTACAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTC
TGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCGCCTCCCGG
GTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGCGCGCCACC
ACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGGCCAGGCTG
GTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTA
CAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTCTGTCGCCCAGGCT
GGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCGCCTCCCGGGTTCAAGCGATTC
TCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGCGCGCCACCACGCCCGGCTAAT
TTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGGCCAGGCTGGTCTCGAACTCCT
GACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTACAGGCGTGAGCCA
CCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGC
GCGATCTCGGCTCACTGCAACCTCCGCCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCC
TCCCGAGTAGCTGGGATTACAGGCGCGCGCCACCACGCCCGGCTAATTTTTGTATTTTTA
GTAGAGACGGGGTTTCACCATGTTGGCCAGGCTGGTCTCGAACTCCTGACCTCAGGTGAT
CCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTACAGGCGTGAGCCACCGCGCCCGGCCT
TTTTGAGACGGAGTCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTC
ACTGCAACCTCCGCCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTG
GGATTACAGGCGCGCGCCACCACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGT
TTCACCATGTTGGCCAGGCTGGTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGG
CCTCCCAAAGTGCTGGGATTACAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAG
TCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCG
CCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGC
GCGCCACCACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGG
CCAGGCTGGTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGC
TGGGATTACAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTCTGTCG
CCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCGCCTCCCGGGTTCA
AGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGCGCGCCACCACGCC
CGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGGCCAGGCTGGTCTC
GAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTACAGGC
GTGAGCCACCGCGCCCGGCC
>TWO IUB ambiguity codes
TAGGDHACHATCRGTRGVTGAGWTATGYTGCTGTCABACDWVTRTAAGAVVAGATTTNDA
GASMTCTGCATBYTTCAAKTTACMTATTACTTCATARGGYACMRTGTTTTYTATACVAAT
TTCTAKGDACKADACTATATNTANTCGTTCACGBCGYSCBHTANGGTGATCGTAAAGTAA
CTATBAAAAGATSTGWATBCSGAKHTTABBAACGTSYCATGCAAVATKTSKTASCGGAAT
WVATTTNTCCTTCTTCTTDDAGTGGTTGGATACVGTTAYMTMTBTACTTTHAGCTAGBAA
AAGAGKAAGTTRATWATCAGATTMDDTTTAAAVAAATATTKTCYTAAATTVCNKTTRACG
ADTATATTTATGATSADSCAATAWAGCGRTAGTGTAAGTGACVGRADYGTGCTACHVSDT
CTVCARCSYTTAATATARAAAATTTAATTTACDAATTGBACAGTAYAABATBTGCAGBVG
TGATGGDCAAAATBNMSTTABKATTGGSTCCTAGBTTACTTGTTTAGTTTATHCGATSTA
AAGTCGAKAAASTGTTTTAWAKCAGATATACTTTTMTTTTGBATAGAGGAGCMATGATRA
AAGGNCAYDCCDDGAAAGTHGBTAATCKYTBTACBGTBCTTTTTGDTAASSWTAAWAARA
TTGGCTAAGWGRADTYACATAGCTCBTAGATAWAGCAATNGTATMATGTTKMMAGTAWTC
CCNTSGAAWATWCAAAAMACTGAADNTYGATNAATCCGAYWNCTAACGTTAGAGDTTTTC
ATCTGGKRTAVGAABVCTGWGBTCTDVGKATTBTCTAAGGVADAAAVWTCTAGGGGAGGG
TTAGAACAATTAAHTAATNAAATGCATKATCTAAYRTDTCAGSAYTTYHGATRTTWAVTA
BGNTCDACAGBCCRCAGWCRTCABTGMMAWGMCTCAACCGATRTGBCAVAATCGTDWDAA
CAYAWAATWCTGGTAHCCCTAAGATAACSCTTAGTGSAACAWTBGTCDTTDGACWDBAAC
HTTTNGSKTYYAAYGGATNTGATTTAARTTAMBAATCTAAGTBTCATYTAACTTADTGTT
TCGATACGAAHGGCYATATACCWDTKYATDCSHTDTCAAAATGTGBACTGSCCVGATGTA
TCMMAGCCTTDAAABAATGAAGAGTAACTHATMGVTTAATAACCCGGTTVSANTGCAATT
GTGAGATTTAMGTTTAMAAYGCTGACAYAAAAAGGCACAMYTAAGVGGCTGGAABVTACG
GATTSTYGTBVAKTATWACCGTGTKAGTDTGTATGTTTAAAGGAAAAAGTAACATARAAA
GGTYCAMNYAAABTATAGNTSATANAGTCATCCTATWADKAACTRGTMSACDGTATSAYT
AAHSHGTAABYGACTYTATADTGSTATAGAGAAATCGNTAAAGGAAATCAGTTGTNCYMV
TNACDRTATBNATATASTAGAAMSCGGGANRCKKMCAAACATTNAGTCTRMAATBMTACC
CGTACTTCTBGDSYAATWGAAAATGACADDCHAKAAAYATATTKTTTTCACANACWAGAA
AKATCCTTATTAYKHKCTAAACARTATTTTDATBTVWCYGCAATACTAGGKAAASTTDGA
MGGCHTTHAATVCAHDRYAGGRCTATACGTCMAGAGAGCTBTHGNACARTCCBDCTAAGA
GCGGCTTTARTAAAGAATCCNAGTAWBTGACTTGAATTACWTVACAGAAABCAATNAAAC
CGTNTRANTTGAYCMAWBADTANABRGGTKTHTWTAGTTVCTMBKTAGMTVKCCAGCANT
TVAGSWTTAGCCGCRHTTTCCTTHNTATTAAGAAGAATAGGMTRAARTCTABGTACDTTT
TATAAVDHAHTATAGATCCTAGTAAGYTWATDWCATGAGGGATAGTAAMDMNGBASTWAM
TSTATRBAYDABATGTATATYCGCACTGTTTTAACMCWBTATAWAGTATBTSTATVTTAR
CCTMTTAAKADATCAACTAATYTSVTAKGDATTATGCKTCAYCAKAATACTTKAANGAGT
ATTSDAGATCGGAAATACTTAAYAAVGTATMCGCTTGTGTDCTAATYTATTTTATTTWAA
CAGWRCTATGTAGMTGTTTGTTYKTNGTTKTCAGAACNTRACCTACKTGSRATGTGGGGG
CTGTCATTAAGTAAATNGSTTABCCCCTCGCAGCTCWHTCGCGAAGCAVATGCKACGHCA
ACAKTTAATAACASAAADATTWNYTGTAATTGTTCGTMHACHTWATGTGCWTTTTGAAHY
ACTTTGTAYAMSAAACTTAADAAATATAGTABMATATYAATGSGGTAGTTTGTGTBYGGT
TWSGSVGWMATTDMTCCWWCABTCSVACAGBAATGTTKATBGTCAATAATCTTCTTAAAC
ARVAATHAGYBWCTRWCABGTWWAATCTAAGTCASTAAAKTAAGVKBAATTBGABACGTA
AGGTTAAATAAAAACTRMDTWBCTTTTTAATAAAAGATMGCCTACKAKNTBAGYRASTGT
ASSTCGTHCGAAKTTATTATATTYTTTGTAGAACATGTCAAAACTWTWTHGKTCCYAATA
AAGTGGAYTMCYTAARCSTAAATWAKTGAATTTRAGTCTSSATACGACWAKAASATDAAA
TGYYACTSAACAAHAKTSHYARGASTATTATTHAGGYGGASTTTBGAKGATSANAACACD
TRGSTTRAAAAAAAACAAGARTCVTAGTAAGATAWATGVHAAKATWGAAAAGTYAHVTAC
TCTGRTGTCAWGATRVAAKTCGCAAVCGASWGGTTRTCSAMCCTAACASGWKKAWDAATG
ACRCBACTATGTGTCTTCAAAHGSCTATATTTCGTVWAGAAGTAYCKGARAKSGKAGTAN
TTTCYACATWATGTCTAAAADMDTWCAATSTKDACAMAADADBSAAATAGGCTHAHAGTA
CGACVGAATTATAAAGAHCCVAYHGHTTTACATSTTTATGNCCMTAGCATATGATAVAAG
>THREE Homo sapiens frequency
ATATTTATCTTTTCACTTCCTACATTGGTCAGACCATTATTCGACACGTGGCGTCATTTT
GTCATACCGGGTAATGTTGGAAACAAAACGTACTGATAAAATACTGAGTTGTAAACTCTA
ATCAGATAACGCGCTTGGATATTAAGATTCACACAGGGGTTTCGGCTGTAAAAAAACTTG
TGGAGCTGTTCTGGGACAGATAAGTTGTACCTCGTACTTAGCTAATTAATGAACCAACTG
ATTACGATAGAACAATTCTGAGGCCGCCAGGACAGCCAAATTTTAATCTTATAAAGCTGG
AAACAGCCGGTATTAGCTTCTCGCATACTTTGCCTGCATTGGTACCTTACAGATATCAGC
GTAGTCATATACACCTCGGTCTCAGCTAAGCTTGTATCTCTTAGAGTAGTTCAAAGATAG
TGGACAATACCTGTGGAATCGATTGCAGATATGGATTTATTTAACTACTGAGTCTCATTC
ACAAGCTAAGCAAGGAGCACGTTTTGGTGCCGGCATACCGATTTGCTATCATGTCAGCAA
ATTTGCGTTGTATTCCTAGTTGCACCCATTAAGGCCACACTCCGAACCTAATTATTACAT
CGCAAAGACATGTACGAAGGACCCGATGTCGAATAGAAGGGAGGACTGTTCATTGGAAGC
TAGACCAGAGGAATCGCAAAGATGCAACTCTTACAATAAAAATCTAATTTCAGTCAACAC
GCAATTTCTATAAGGTTTCCGATAATAATGAACCGTCTTCCACAGGGGAATTTGCCATGC
TCGTAAAAGTAGTTAATCCAAGTAGAAGAAATTTTGATAATGTTTTAAGTTGGCACGAAG
GAATTCAGAGAGATCTTACCTAACAAAGGCATTAGTAGATGTTCCTTGGTTCACACTCGG
TCAATCAGAGCACATACTACGGGCGATACCGGGAATGACACAACATCAATGAGATTGTTA
AGTGAGGTAATTGACTTTAGAGGACTCGATCAGTATACTGTCACTATGAACATCGTATTA
ATTGTTATCCGATATATACACCACCGATTTGCTTGTGCAAGGTTACAGACCCATTCGATA
AATACAAACACGGAGCGATATTATTTAAGGAGTGCTGTCTTCAAAAGAATTATTCCCACA
CCGACATAAGAACTTCGCTCCGTCATTCCAGATTTAAATAACATAACGTAACGCTTTGCT
GATAACATAACATAACCGAGAATTTGCTTAGGAAATTTGGAGCAATATTGCATTGTTTCT
CAGTCATCACAAGGCCCGCCAAAGAACTCTGAGAATCAGGATTCAACATGATTGGTAAGA
CTCTATATATATAACTTAATTCTTGTGTCCGGAGATAGAAAGAGGACGAGAGATACTACG
AAAGAAAGTGTACTTCGATGTATCAATTCAGACGCCTTCTCTATCATCAACATTATAGGT
CTCGTATATGCTCGGCGCGATCTGCTTCTCTCCGCCAATAGCCCCATAGTGTATTTCAAG
CGCAGTAACAGTGAAATCGTTACGAAGGTAGGGATGTTGCTTATAATTGTCGTAACTTAT
CGCTTATGTATCTTTCAAGAATGAACGGCAGCATATACATACGTTCTACCTTTAGCTACA
AAGCATCCATATACTCCCTCTCATGATTGAAACTCTTCCCTATTTTGTAGCCAATAGTGA
AAGCGTATTAGTATAAATTCGTCGGTTTTTCACTCGCAACTGTTATACTCTGCAAACAAA
CGAAAGCCTCATAGTACAAACCTAAAGCTACATACTTCATCATTGGCAGACCAGTGGCGG
TATTTCTACGGAAGCATCACTATAGATATAAAGTTTCCCTTCATGTACGTCTGTTAACCA
TATCACAAGAAACTGCTATCTCTGTCACGTAACAATTCACGCGCCTTATCGCCAAATGTT
CATATATGCGCGGTATACGTATGAACGAATACTAATTAGTATAACGGAGGATTCACGGGA
GGGATACTTGGGGCATTTATAAATCGTCTAAAAATTTTCTATCAGCACTTGCGGGTTATA
GTGGATTACTAGGCAACATAATATTCTGTATTGGTCCAAATGACGCTATAGATAAATTAG
CAAAATACATTGTTTCCATTTATGTAAGTCGAAACTCCAGGACTCCCGGGAACCAGTTAA
ACCGTCTGGAAAAGACACATTGTGAGCGGGACTTCAATGATAGCTTTCAATGAGCTTCTC
ATGCTTGGGGTCTGTACATATATGTTGGCGAAATTATCGTCTGTATTCTGTTATGCTTTG
ATCATGGGTTATTAGTATAGTGTCCGGTTAAGTACCAATACCGCTAGAGACCCGACCTAA
GTCGATAACTAACGATCATCGACGTAAGGATCGTCTCGATCAGTACTTCAGTCTAGATCT
GGGAATAGTAACTCGTTAGTGAACTATGTCGTGTCATAACTCTAAAATGCAATCAAATCT
TATTATTGAGTATTGATTATATAAAGCATCCGCTTAGCTTTACCCTCAAATGTTATATGC
AATTTAAAGCGCTTGATATCGTCTACTCAAGTTCAGGTTTCACATGGCCGCAACGTGACG
TTATTAGAGGTGGGTCATCATCTCTGAGGCTAGTGATGTTGAATACTCATTGAATGGGAA
GTGGAATACCATGCTCGTAGGTAACAGCATGACCTATAAAATATACTATGGGTGTGTGGT
AGATCAATATTGTTCAAGCATATCGTAACAATAACGGCTGAAATGTTACTGACATGAAAG
AGGGAGTCCAAACCATTCTAACAGCTGATCAAGTCGTCTAAAAACGCCTGGTTCAGCCTT
AAGAGTTATAAGCCAGACAAATTGTATCAATAGAGAATCCGTAAATTCCTCGGCCAACCT
CTTGCAAAGACATCACTATCAATATACTACCGTGATCTTAATTAGTGAACTTATATAAAT
ATCTACAACCAGATTCAACGGAAAAGCTTTAGTGGATTAGAAATTGCCAAGAATCACATT
CATGTGGGTTCGAATGCTTTAGTAATACCATTTCGCCGAGTAGTCACTTCGCTGAACTGT
CGTAAATTGCTATGACATAATCGAAAAGGATTGTCAAGAGTCGATTACTGCGGACTAATA
ATCCCCACGGGGGTGGTCTCATGTCTCCCCAGGCGAGTGGGGACGGTTGATAAACACGCT
GCATCGCGGACTGATGTTCCCAGTATTACATAGTCACATTGGATTGCGAGTAGTCTACCT
ATTTATGAGCGAGAGATGCCTCTAACTACTTCGACTTTTAAAACCTTTCCACGCCAGTAT
TCGGCGAAAGGGAAGTATTAAGGGTTGTCATAATTAAGCTGATACCACTTCAGACTTTGC
TCTACTTCTGTCTTTCATTGGTTTAGTAAAGTCTGTCCATTCGTCGAGACCGTCTTTTGC
AGCCTCATTCTACCAACTGCTCCGACTCTTAGTCTGCTTCTCCCAGCGTTATAACAAGAG
GCATTTTGTCATCCTTAAAACAATAATAAAGAACTCGGAGCACTGATATAATGACTGAAT
TAGAACCGCTTAAAAATACAACGAATAGATAAGACTATCGGATAAGATCTAATATGTAGT
GATTAAGCCCTTTATTAATTAATAATAGTTACCCTTTCTGATGTAACGCGACATATTACG
ATTTAGTGGCACGTCTGAATTGCAAAGCAGATCTCTACCCGATTTTTATTATAAATCCCG
TATACATCTTGACTTGAGTAATTGTTCATCTTTTTATATCTCTTCGTACTACAAATAATT
AATATCTCAACCCGTATTGTGTGATTCTAATTACCAACAGAATACGAGGAGGTTTTTGCT
TAGGGCCATATATAATGAATCTATCTCGTTTATTCGCGGAACCCGAGATAACATTACGAT
GTAACTATTTTAGAGAACTTAATACAAGAAACATTGCTGATTACTCATAACTAAATGCTT
GGTAATATATCCTCAGTGCCCCTACCATCTTTTACGCAGGGATGTAATTACTTAGGATTC
ATTGTGTAAGAATTACAATGAACGATGGATATGAAGGCATGTTGCGAGGTGTTCCTTGGT
ATGTGAAGTTCGCAGGGCAACAAAAATTTCGCAGAATAGGCCTCAAAGTATTGGTAAAGA
AGACAACTAATCATCACGAGCTTCTGATATCAATACGAACGAGTCCTGTGATGGATGAAA
GAAAGTCGTATCGAAAATGTCAAGAGTCTGCCCAATGTAACTTACTTCAAAAAATAACGC
TTCCGCCAAGTACGTTCGAATAAACGTAATTTTAAAAATACATAAGGGGTGTTAGAAAGT
AAGCGACGGGATATAAGTTAGACTCAAGATTCCGCCGTAAAACGAGACTGATTCCGAAGA
TTGTTCGTGGATCTGGTCATGACTTTCACTGAGTAAGGAGTTTCGACATATGTCAATAAA
CACAAAAATAGAAGCTATTCGATCTGAAAAATATTAGGACAAGAAACTATCTCACGCTAG
CCCAGAATATTCACTCACCCACGGGCGATACTAAAGCACTATATAGTCGCGTGATTACTA
TACATATGGTACACATAAGAATCACGATCAGGTTCTCAATTTTCAACAATATATGTTTAT
TTGCATAGGTAATATTAGGCCTTTAAGAGAAGGATGGGTGAGATACTCCGGGGATGGCGG
CAATAAAGAAAAACACGATATGAGTAATAGGATCCTAATATCTTGGCGAGAGACTTAAGG
TACGAATTTTGCGCAATCTATTTTTTACTTGGCCAGAATTCATGTATGGTATAAGTACGA
ACTTTTTTGATCACTTTCATGGCTACCTGATTAGGATAGTTTGAGGAATTTCCCAAATAT
ACCGATTTAATATACACTAGGGCTTGTCACTTTGAGTCAGAAAAAGAATATAATTACTTA
GGGTAATGCTGCATACATATTCTTATATTGCAAAGGTTCTCTGGGTAATCTTGAGCCTTC
ACGATACCTGGTGAAGTGTT
OUTPUT568
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 569.
if test $result = ok -a $start_test_number -le 569; then
	echo test 569: Spectral Norm from Language Shootout
        cat >$test_file <<'TEST569'
fun A (i, j) { return 1.0 / ((i + j) * (i + j + 1) / 2 + i + 1); }

fun Av (n, v) {
   var i, j, Av = [n : 0.0];

   for (i = 0; i < n; i++)
      for (j = 0; j < n; j++) Av [i] += A (i, j) * v [j];
   return Av;
}

fun Atv (n, v) {
   var i, j, Atv = [n : 0.0];

   for (i = 0; i < n; i++)
     for (j = 0; j < n; j++) Atv [i] += A (j, i) * v [j];
   return Atv;
}

fun AtAv (n, v) {return Atv (n, Av (n, v));}

var n = int (#argv < 1 ? 100 : argv [0]);
var i, u = [n : 1.0], v = [n : 0.0], vBv = 0.0, vv = 0.0;

for (i = 0; i < 10; i++) { v = AtAv (n, u); u = AtAv (n, v); }
for (i = 0; i < n; i++) { vBv += u [i] * v [i]; vv += v [i] * v [i]; }

putf ("%0.9f\n", sqrt (vBv / vv));
TEST569
        echo '      ' $DINO $test_file 200 "2>$stderr"
        if $DINO $test_file 200 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT569' && $CMP $stdout $ftemp2; then
1.274223601
OUTPUT569
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 570.
if test $result = ok -a $start_test_number -le 570; then
	echo test 570: Sum file Language Shootout
        cat >$test_file <<'TEST570'
var sum = 0;
try {
  for (;;) sum += int (getln ());
} catch (eof) {}

putln (sum);
TEST570
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file  <<'INPUT570' 2>$stderr >$stdout; then
276
498
-981
770
-401
702
966
950
-853
-53
-293
604
288
892
-697
204
96
408
880
-7
-817
422
-261
-485
-77
826
184
864
-751
626
812
-369
-353
-371
488
-83
-659
24
524
-21
840
-757
-17
-973
-843
260
858
-389
-521
-99
482
-561
-213
630
766
932
112
-419
-877
762
266
-837
170
834
746
764
922
-89
576
-63
90
684
316
506
-959
708
70
252
-747
342
-593
-895
-937
-707
350
588
-201
-683
-113
-511
-867
322
202
472
150
-9
-643
28
336
86
-925
836
-473
-451
-971
-805
-619
84
-67
806
270
366
334
-555
-557
-331
-409
-553
-145
-71
528
490
492
828
628
-961
536
-859
-271
974
-671
-749
414
-257
778
56
598
-437
-899
-785
-987
32
-999
132
-821
-209
402
-543
194
-967
294
-943
-285
-483
-97
660
-481
-829
-309
-597
-855
80
-355
192
-823
436
916
282
-629
612
-329
-535
780
-47
706
110
756
-857
-933
-345
-523
718
-31
902
678
540
698
456
-399
126
412
-563
-321
-487
-641
-195
-199
-955
772
INPUT570
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT570' && $CMP $stdout $ftemp2; then
-4818
OUTPUT570
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 571.
if test $result = ok -a $start_test_number -le 571; then
	echo test 571: Takfp Language Shootout
        cat >$test_file <<'TEST571'
fun Tak (x, y, z) {
  if (y >= x) return z;
  return Tak (Tak (x - 1.0, y, z), Tak (y - 1.0, z, x), Tak (z -1.0, x, y));
}

var n = int (#argv < 1 ? 1 : argv [0]);
putf ("%.1f\n", Tak (n * 3.0, n * 2.0, n * 1.0));
TEST571
        echo '      ' $DINO $test_file 9 "2>$stderr"
        if $DINO $test_file 9 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT571' && $CMP $stdout $ftemp2; then
18.0
OUTPUT571
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 572.
if test $result = ok -a $start_test_number -le 572; then
	echo test 572: Swap statement implementation.
        cat >$test_file <<'TEST572'
var t, a = 1, b = 2;

putln (a, " ", b);
t = a; a = b; b = t;
putln (a, " ", b);

var ar = [1, 2, 3];
println (ar);
t = ar[0]; ar[0] = ar[2]; ar[2] = t;
println (ar);

class s (i) {}
var c1 = s (0), c2 = s (3);
putln (c1.i, ' ', c2.i);
t = c1.i; c1.i = c2.i; c2.i = t;
putln (c1.i, ' ', c2.i);

var tbl = tab ["s" : 1, "t" : 2];
putln (tbl["s"], ' ', tbl["t"]);
t = tbl["s"]; tbl["s"] = tbl["t"]; tbl["t"] = t;
putln (tbl["s"], ' ', tbl["t"]);
TEST572
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT572' && $CMP $stdout $ftemp2; then
1 2
2 1
[1, 2, 3]
[3, 2, 1]
0 3
3 0
1 2
2 1
OUTPUT572
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 573.
if test $result = ok -a $start_test_number -le 573; then
	echo test 573: Health from Language Shootout.
        cat >$test_file <<'TEST573'
class queue {
  class node (item, next) {}
  var first = nil, last = nil;

  fun Add (o) {
    var a = node (o, nil);

    if (first == nil) first = a; else last.next = a;
    last = a;
  }
  
  fun Remove (o) {
    var c, p = nil;

    for (c = first; c != nil && c.item !== o; c = c.next) p = c;
    if (c == nil) return;
    if (p == nil) first = first.next; else p.next = c.next;
    if (last === c) last = p;
  }

  fun Clear { first = nil; last = nil; }
}

class Patient (remainingTime = 0, hospitalTime = 0, hospitalVisits = 0) {}

val LEVELS = 5, DISTRICTS = 4;

class Hospital; class Totals;

class HealthcareRegion (level, s) {
  var districts = [DISTRICTS : nil];
  var localHospital = Hospital (level == LEVELS, level, s);

  fun TransferPatients {
    var i, n;
    
    for (i = #districts - 1; i >= 0; i--)
      if (districts [i] != nil)
	for (n = districts [i].TransferPatients().first; n != nil; n = n.next)
	  localHospital.NewArrival(n.item);

    localHospital.TriageExaminationTreatment ();
    return localHospital.transfers;
  }

  fun AccumulateTotals {
    var i, t = Totals ();

    for (i = #districts - 1; i >= 0; i--)
      if (districts [i] != nil)
	t.PlusTotal (districts [i].AccumulateTotals ());
    
    localHospital.AccumulateTotals (t);
    return t;
  }

  fun TreatmentQueue { return localHospital.treatment; }
}

fun CreateRegion (level, seed1, seed2) {
  var i, r = nil;
  
  if(level > 0) {
    r = HealthcareRegion (level, seed1 * seed2);
    for(i = #r.districts - 1; i >= 0; i--)
      r.districts [i] = CreateRegion (level - 1, seed1 * 4 + i + 1, seed2);
  }
  return r;
}

class Hospital (hasNoRegionalHospital, level, seed) {
  var availableStaff = 1 << (level - 1);
  var triage = queue (), examination = queue ();
  var treatment = queue (), transfers = queue ();
  var discharged = Totals ();

  fun DischargePatients; fun TreatOrTransferPatients; fun TriagePatients;
  fun genRandom; fun NewArrival;

  fun TriageExaminationTreatment {
    DischargePatients ();
    TreatOrTransferPatients ();
    TriagePatients ();
    
    if (genRandom (1.0) > 0.7) NewArrival (Patient ());
  }
  
  fun AccumulateTotals (t) {
    var n;
    
    for (n = triage.first; n != nil; n = n.next) t.PlusPatient (n.item);
    for (n = examination.first; n != nil; n = n.next) t.PlusPatient (n.item);
    for (n = treatment.first; n != nil; n = n.next) t.PlusPatient (n.item);
    t.PlusTotal (discharged);
  }
  
  fun NewArrival (p) {
    p.hospitalVisits++;
    if (availableStaff == 0) triage.Add (p);
    else {
      availableStaff--;
      p.remainingTime = 3;
      p.hospitalTime += 3;
      examination.Add (p);
    }
  }
  
  fun DischargePatients {
    var n, p;
    
    for (n = treatment.first; n != nil; n = n.next) {
      p = n.item; p.remainingTime--;
      if (p.remainingTime == 0) {
	availableStaff++;
	treatment.Remove (p);
	discharged.PlusPatient (p);
      }
    }
  }

  fun TreatOrTransferPatients {
    var p, n;

    transfers.Clear ();
    for (n = examination.first; n != nil; n = n.next) {
      p = n.item; p.remainingTime--;
      if (p.remainingTime == 0) { // no transfer
	if (genRandom (1.0) > 0.1 || hasNoRegionalHospital) {
	  treatment.Add(p);
	  p.remainingTime = 10;
	  p.hospitalTime += 10;
	} else { // transfer
	  availableStaff++;
	  transfers.Add (p);
	}
	examination.Remove(p);
      }
    }
  }

  fun TriagePatients {
    var p, n;

    for (n = triage.first; n != nil; n = n.next) {
      p = n.item;
      if (availableStaff == 0) p.hospitalTime++;
      else {
	availableStaff--;
	p.remainingTime = 3;
	p.hospitalTime += 3;
	examination.Add (p);
	triage.Remove (p);
      }
    }
  }

  val IM = 139968, IA = 3877, IC = 29573;

  fun genRandom (max) {
    seed = (seed * IA + IC) % IM;
    return max * seed / IM ;
  }
}

class Totals {
  var patients = 0, hospitalTime = 0, hospitalVisits = 0;

  fun PlusTotal (t) {
    patients += t.patients;
    hospitalTime += t.hospitalTime;
    hospitalVisits += t.hospitalVisits;
  }

   fun PlusPatient (p) {
     patients++;
     hospitalTime += p.hospitalTime;
     hospitalVisits += p.hospitalVisits;
   }
}

var N = int (#argv < 1 ? 100 : argv [0]);
var i, healthcareSystem = CreateRegion (LEVELS, 0, 42), t, n;

for (i = 0; i < N; i++)
  healthcareSystem.TransferPatients ();

t = healthcareSystem.AccumulateTotals ();

putln ("Patients: ", t.patients);
putln ("Time:     ", t.hospitalTime);
putln ("Visits:   ", t.hospitalVisits);

putln ("\nTreatment Queue - Remaining Treatment Time");
for (n = healthcareSystem.TreatmentQueue ().first; n != nil; n = n.next)
  putln (n.item.remainingTime, "\tanonymous patient");
TEST573
        echo '      ' $DINO $test_file 100 "2>$stderr"
        if $DINO $test_file 100 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT573' && $CMP $stdout $ftemp2; then
Patients: 10151
Time:     363815
Visits:   10526

Treatment Queue - Remaining Treatment Time
1	anonymous patient
3	anonymous patient
9	anonymous patient
10	anonymous patient
OUTPUT573
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 574.
if test $result = ok -a $start_test_number -le 574; then
	echo test 574: Sync-statement
        cat >$test_file <<'TEST574'
var f = 1;
thread t {
  wait (1) {
    var i;

    f = 0;
    for (i = 0; i < 1000000; i++)
      if (i % 100000 == 0) putln (i);
  }
}

t ();
wait (! f);
putln ("it should be the last message");
TEST574
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT574' && $CMP $stdout $ftemp2; then
0
100000
200000
300000
400000
500000
600000
700000
800000
900000
it should be the last message
OUTPUT574
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 575.
if test $result = ok -a $start_test_number -le 575; then
	echo test 575: Wait in sync-statement
        cat >$test_file <<'TEST575'
var flag = 0;

thread f {
  wait (1) {
    wait (flag);
    flag = 0;
  }
}

f ();
flag = 1;
wait (! flag);
putln ("it can not be printed");
TEST575
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT575' && $CMP $stderr $ftemp2; then
test.d:5:5: wait in sync-statement
OUTPUT575
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 576.
if test $result = ok -a $start_test_number -le 576; then
	echo test 576: Catching wait in sync-statement
        cat >$test_file <<'TEST576'
var flag = 0;

thread f {
  try {
    wait (1) wait (flag);
  } catch (syncwait) {
    putln ("got the exception");
    flag = 0;
  }
}

f ();
flag = 1;
wait (! flag);
putln ("continue");
TEST576
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT576' && $CMP $stdout $ftemp2; then
got the exception
continue
OUTPUT576
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 577.
if test $result = ok -a $start_test_number -le 577; then
	echo test 577: Thread call in sync-statement
        cat >$test_file <<'TEST577'
var flag = 0;

thread f {
}

wait (1) f ();
putln ("it can not be printed");
TEST577
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT577' && $CMP $stderr $ftemp2; then
test.d:6:12: thread call in sync-statement
OUTPUT577
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 578.
if test $result = ok -a $start_test_number -le 578; then
	echo test 578: Catching thread call in sync-statement
        cat >$test_file <<'TEST578'
var flag = 0;

thread f {
}

try {
  wait (1) f ();
} catch (syncthreadcall) {
  putln ("got the exception");
}

putln ("continue");
TEST578
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT578' && $CMP $stdout $ftemp2; then
got the exception
continue
OUTPUT578
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 579.
if test $result = ok -a $start_test_number -le 579; then
	echo test 579: Longs
        cat >$test_file <<'TEST579'
var gmp1 = 5L;
var gmp2 = 10L;
var gmp3 = 0L;

putln (int (gmp1));
putln (float (gmp2));
gmp1 = long ("10000000000000000000000000000000000000000000000L");
gmp2 = long ("5000000000000000000000000000000000000000000000L");
putln (gmp1 + gmp2);
putln (gmp1 - gmp2);
putln (-gmp1);
putln (-gmp1 < 0 ? gmp1 : -gmp1);
putln (gmp1 * gmp2);
putln (gmp1 / gmp2);
putln (gmp1 % gmp2);
putln (gmp2 % gmp1);
putln (gmp1 < gmp2);
putln (gmp2 <= gmp1);
putf ("%o\n", gmp1);
putf ("%o\n", gmp2);
TEST579
        if uname | fgrep CYGWIN; then
            echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT579' && $CMP $stdout $ftemp2; then
5
10
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
-10000000000000000000000000000000000000000000000
10000000000000000000000000000000000000000000000
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
5000000000000000000000000000000000000000000000
0
1
700324573052063614067325026200675322000000000000000
340152275425031706033552413100336551000000000000000
OUTPUT579
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
            echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT579' && $CMP $stdout $ftemp2; then
5
10
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
-10000000000000000000000000000000000000000000000
10000000000000000000000000000000000000000000000
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
5000000000000000000000000000000000000000000000
0
1
700324573052063614067325026200675322000000000000000
340152275425031706033552413100336551000000000000000
OUTPUT579
                        result=ok
                else
                        result=fail
                fi
	    elif fgrep 'run time error - can not find external function' $stderr >/dev/null;then
		echo GMP package is absent -- skip
                result=ok
	    else
                result=fail
	    fi
        fi
fi

# Test 580.
if test $result = ok -a $start_test_number -le 580; then
	echo test 580: exit tracing
        cat >$test_file <<'TEST580'
fun a {
  exit (0);
}
fun b {
  a ();
}
fun c (i) {
  if (i == 0) b (); else c (i - 1);
}
class d {
  c (5);
}
d ();
TEST580
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT580' && $CMP $stderr $ftemp2; then
test.d:11:5:calling a
test.d:13:3:calling d
OUTPUT580
                        result=ok
                else
                        result=fail
                fi
	else
                result=fail
        fi
fi

# Test 581.
if test $result = ok -a $start_test_number -le 581; then
	echo test 581: exception tracing
        cat >$test_file <<'TEST581'
fun a {
  throw except ();
}
fun b {
  a ();
}
fun c (i) {
  if (i == 0) b (); else c (i - 1);
}
class d {
  c (5);
}
d ();
TEST581
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT581' && $CMP $stderr $ftemp2; then
test.d:2:3: run time error - exception except has not been processed
test.d:11:5:calling a
test.d:13:3:calling d
OUTPUT581
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 582.
if test $result = ok -a $start_test_number -le 582; then
	echo test 582: catched exception tracing
        cat >$test_file <<'TEST582'
fun a {
  var i = 0;
  i[10]=0;
}
fun b {
  a ();
}
fun c (i) {
  if (i == 0) b (); else c (i - 1);
}
class d {
  c (5);
}
var i;
for (i = 0; i < 10; i++) 
  try {
    d ();
  } catch (error) {
    putln ("got it: ", e.msg);
  }
TEST582
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT582' && $CMP $stdout $ftemp2; then
got it: run time error - index operation for non vector or table
got it: run time error - index operation for non vector or table
got it: run time error - index operation for non vector or table
got it: run time error - index operation for non vector or table
got it: run time error - index operation for non vector or table
got it: run time error - index operation for non vector or table
got it: run time error - index operation for non vector or table
got it: run time error - index operation for non vector or table
got it: run time error - index operation for non vector or table
got it: run time error - index operation for non vector or table
OUTPUT582
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 583.
if test $result = ok -a $start_test_number -le 583; then
	echo test 583: normal exit tracing
        cat >$test_file <<'TEST583'
var i;
for (i =0; i < 10; i++);
TEST583
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT583' && $CMP $stdout $ftemp2; then
OUTPUT583
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 584.
if test $result = ok -a $start_test_number -le 584; then
	echo test 584: Read/write dump
        cat >$test_file <<'TEST584'
var SieveSize, i, prime, k, count, flags;
SieveSize = 8190;

flags = [SieveSize + 1 : 0];
count = 0;
for (i = 0; i <= SieveSize; i++)
  flags[i] = 1;
for (i = 0; i <= SieveSize; i++;)
  if (flags[i])
    {
      prime = i + i + 3;
      k = i + prime;
      for (;1;;)
        {
          if (k > SieveSize)
            break;
          flags[k] = 0;
          k += prime;
        }
      count++;
    }

println (count);
TEST584
        echo '      ' $DINO '-d' $test_file ">$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
            echo '      ' $DINO -i "$stdout" ">$ftemp 2>&1"
            if $DINO -i "$stdout" > "$ftemp" 2>&1; then
                 echo '      ' $CMP $ftemp2 $ftemp
                 if cat >$ftemp2 <<'OUTPUT584' && $CMP $ftemp $ftemp2; then
1899
OUTPUT584
                      result=ok
                  else
                      result=fail
                  fi
            fi
        else
                result=fail
        fi
fi

# Test 585.
if test $result = ok -a $start_test_number -le 585; then
	echo test 585: Read/write optimized code
        cat >$test_file <<'TEST585'
var SieveSize, i, prime, k, count, flags;
SieveSize = 8190;

flags = [SieveSize + 1 : 0];
count = 0;
for (i = 0; i <= SieveSize; i++)
  flags[i] = 1;
for (i = 0; i <= SieveSize; i++;)
  if (flags[i])
    {
      prime = i + i + 3;
      k = i + prime;
      for (;1;;)
        {
          if (k > SieveSize)
            break;
          flags[k] = 0;
          k += prime;
        }
      count++;
    }

println (count);
TEST585
        echo '      ' $DINO '-d -O' $test_file ">$stdout"
        if $DINO -d -O $test_file 2>$stderr >$stdout; then
            echo '      ' $DINO -i "$stdout" ">$ftemp >2&1"
            if $DINO -i "$stdout" > "$ftemp" 2>&1; then
                 echo '      ' $CMP $ftemp2 $ftemp
                 if cat >$ftemp2 <<'OUTPUT585' && $CMP $ftemp $ftemp2; then
1899
OUTPUT585
                      result=ok
                  else
                      result=fail
                  fi
            fi
        else
                result=fail
        fi
fi

# Test 586.
if test $result = ok -a $start_test_number -le 586; then
	echo test 586: Different vector binary operations: 1
        cat >$test_file <<'TEST586'
var i, two = 2, three = 3, m = -32;
for (i = 0; i < 2; i++) {
  var v1 = [10:two], v2 = [10:three], v3 = [10:m], v4 = [5:tab [two], 5:tab [three]], t=tab[two];
  println ("+", v1[:] + v2[:]);
  println ("-", v1[:] - v2[:]);
  println ("*", v1[:] * v2[:]);
  println ("<<", v1[:] << v2[:]);
  println (">>", v3[:] >> v2[:]);
  println (">>>", v1[:] >>> v2[:]);
  println ("&", v1[:] & v2[:]);
  println ("^", v1[:] ^ v2[:]);
  println ("|", v1[:] | v2[:]);
  println ("@", v1[:] @ v2[:]);
  println ("in", v1[:] in v4[:]);
  println ("==", v1[:] == v2[:]);
  println ("!=", v1[:] != v2[:]);
  println ("===", v1[:] === v2[:]);
  println ("!==", v1[:] !== v2[:]);
  println ("<=", v1[:] <= v2[:]);
  println ("<", v1[:] < v2[:]);
  println (">=", v1[:] >= v2[:]);
  println (">", v1[:] > v2[:]);
  putln ("--------------------------------");
 
  println ("+", v1[:] + three);
  println ("-", v1[:] - three);
  println ("*", v1[:] * three);
  println ("<<", v1[:] << three);
  println (">>", v3[:] >> three);
  println (">>>", v1[:] >>> three);
  println ("&", v1[:] & three);
  println ("^", v1[:] ^ three);
  println ("|", v1[:] | three);
  println ("@", v1[:] @ three);
  println ("in", v1[:] in t);
  println ("==", v1[:] == three);
  println ("!=", v1[:] != three);
  println ("===", v1[:] === three);
  println ("!==", v1[:] !== three);
  println ("<=", v1[:] <= three);
  println ("<", v1[:] < three);
  println (">=", v1[:] >= three);
  println (">", v1[:] > three);
  putln ("--------------------------------");
  
  println ("+", two + v2[:]);
  println ("-", two - v2[:]);
  println ("*", two * v2[:]);
  println ("<<", two << v2[:]);
  println (">>", m >> v2[:]);
  println (">>>", two >>> v2[:]);
  println ("&", two & v2[:]);
  println ("^", two ^ v2[:]);
  println ("|", two | v2[:]);
  println ("@", two @ v2[:]);
  println ("in", two in v4[:]);
  println ("==", two == v2[:]);
  println ("!=", two != v2[:]);
  println ("===", two === v2[:]);
  println ("!==", two !== v2[:]);
  println ("<=", two <= v2[:]);
  println ("<", two < v2[:]);
  println (">=", two >= v2[:]);
  println (">", two > v2[:]);
  putln ("--------------------------------\n");
  two = 2.0; three = 3.0; m = -32.0;
}
TEST586
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT586' && $CMP $stdout $ftemp2; then
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

OUTPUT586
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 587.
if test $result = ok -a $start_test_number -le 587; then
	echo test 587: Different vector binary operations: 2
        cat >$test_file <<'TEST587'
var i, two = 2, three = 3, m = -32;
for (i = 0; i < 2; i++) {
  var v1 = [10:two, nil], v2 = [10:three], v3 = [10:m, nil];
  var v4 = [5:tab [two], 5:tab [three]], t=tab [two];

  println ("+", v1[0:10] + v2[:]);
  println ("-", v1[0:10] - v2[:]);
  println ("*", v1[0:10] * v2[:]);
  println ("<<", v1[0:10] << v2[:]);
  println (">>", v3[0:10] >> v2[:]);
  println (">>>", v1[0:10] >>> v2[:]);
  println ("&", v1[0:10] & v2[:]);
  println ("^", v1[0:10] ^ v2[:]);
  println ("|", v1[0:10] | v2[:]);
  println ("@", v1[0:10] @ v2[:]);
  println ("in", v1[0:10] in v4[:]);
  println ("==", v1[0:10] == v2[:]);
  println ("!=", v1[0:10] != v2[:]);
  println ("===", v1[0:10] === v2[:]);
  println ("!==", v1[0:10] !== v2[:]);
  println ("<", v1[0:10] < v2[:]);
  println (">", v1[0:10] > v2[:]);
  println ("<=", v1[0:10] <= v2[:]);
  println (">=", v1[0:10] >= v2[:]);
  putln ("--------------------------------");
  
  println ("+", v1[0:10] + 3);
  println ("-", v1[0:10] - 3);
  println ("*", v1[0:10] * 3);
  println ("<<", v1[0:10] << 3);
  println (">>", v3[0:10] >> 3);
  println (">>>", v1[0:10] >>> 3);
  println ("&", v1[0:10] & 3);
  println ("^", v1[0:10] ^ 3);
  println ("|", v1[0:10] | 3);
  println ("@", v1[0:10] @ 3);
  println ("in", v1[0:10] in t);
  println ("==", v1[0:10] == 3);
  println ("!=", v1[0:10] != 3);
  println ("===", v1[0:10] === 3);
  println ("!==", v1[0:10] !== 3);
  println ("<", v1[0:10] < 3);
  println (">", v1[0:10] > 3);
  println ("<=", v1[0:10] <= 3);
  println (">=", v1[0:10] >= 3);
  putln ("--------------------------------\n");
  two = 2.0; three = 3.0; m = -32.0;
}
TEST587
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT587' && $CMP $stdout $ftemp2; then
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

OUTPUT587
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 588.
if test $result = ok -a $start_test_number -le 588; then
	echo test 588: Different vector binary operations: 3
        cat >$test_file <<'TEST588'
var i, two = 2, three = 3, m = -32;
for (i = 0; i < 2; i++) {
  var v1 = [10:two, nil], v2 = [10:three], v3 = [10:m, nil];
  var v4 = [5:tab [two], 5:tab [three]], t=tab [two];

  println ("+", v1[0:10] + v2[:]);
  println ("-", v1[0:10] - v2[:]);
  println ("*", v1[0:10] * v2[:]);
  println ("<<", v1[0:10] << v2[:]);
  println (">>", v3[0:10] >> v2[:]);
  println (">>>", v1[0:10] >>> v2[:]);
  println ("&", v1[0:10] & v2[:]);
  println ("^", v1[0:10] ^ v2[:]);
  println ("|", v1[0:10] | v2[:]);
  println ("@", v1[0:10] @ v2[:]);
  println ("in", v1[0:10] in v4[:]);
  println ("==", v1[0:10] == v2[:]);
  println ("!=", v1[0:10] != v2[:]);
  println ("===", v1[0:10] === v2[:]);
  println ("!==", v1[0:10] !== v2[:]);
  println ("<", v1[0:10] < v2[:]);
  println (">", v1[0:10] > v2[:]);
  println ("<=", v1[0:10] <= v2[:]);
  println (">=", v1[0:10] >= v2[:]);
  putln ("--------------------------------");
  
  println ("+", v1[0:10] + three);
  println ("-", v1[0:10] - three);
  println ("*", v1[0:10] * three);
  println ("<<", v1[0:10] << three);
  println (">>", v3[0:10] >> three);
  println (">>>", v1[0:10] >>> three);
  println ("&", v1[0:10] & three);
  println ("^", v1[0:10] ^ three);
  println ("|", v1[0:10] | three);
  println ("@", v1[0:10] @ three);
  println ("in", v1[0:10] in t);
  println ("==", v1[0:10] == three);
  println ("!=", v1[0:10] != three);
  println ("===", v1[0:10] === three);
  println ("!==", v1[0:10] !== three);
  println ("<", v1[0:10] < three);
  println (">", v1[0:10] > three);
  println ("<=", v1[0:10] <= three);
  println (">=", v1[0:10] >= three);
  putln ("--------------------------------\n");
  two = 2.0; three = 3.0; m = -32.0;
}
TEST588
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT588' && $CMP $stdout $ftemp2; then
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

OUTPUT588
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 589.
if test $result = ok -a $start_test_number -le 589; then
	echo test 589: Different vector binary operations: 4
        cat >$test_file <<'TEST589'
var i, two = 2, three = 3, m = -32;
for (i = 0; i < 2; i++) {
  var v1 = [10:two, nil], v2 = [10:three, 0.5], v3 = [10:m, nil];
  var v4 = [5:tab [two], 5:tab [three]], t=tab [two];

  println ("+", v1[0:10] + v2[:10]);
  println ("-", v1[0:10] - v2[:10]);
  println ("*", v1[0:10] * v2[:10]);
  println ("<<", v1[0:10] << v2[:10]);
  println (">>", v3[0:10] >> v2[:10]);
  println (">>>", v1[0:10] >>> v2[:10]);
  println ("&", v1[0:10] & v2[:10]);
  println ("^", v1[0:10] ^ v2[:10]);
  println ("|", v1[0:10] | v2[:10]);
  println ("@", v1[0:10] @ v2[:10]);
  println ("in", v1[0:10] in v4[:10]);
  println ("==", v1[0:10] == v2[:10]);
  println ("!=", v1[0:10] != v2[:10]);
  println ("===", v1[0:10] === v2[:10]);
  println ("!==", v1[0:10] !== v2[:10]);
  println ("<", v1[0:10] < v2[:10]);
  println (">", v1[0:10] > v2[:10]);
  println ("<=", v1[0:10] <= v2[:10]);
  println (">=", v1[0:10] >= v2[:10]);
  putln ("--------------------------------");

  println ("+", two + v2[:10]);
  println ("-", two - v2[:10]);
  println ("*", two * v2[:10]);
  println ("<<", two << v2[:10]);
  println (">>", m >> v2[:10]);
  println (">>>", two >>> v2[:10]);
  println ("&", two & v2[:10]);
  println ("^", two ^ v2[:10]);
  println ("|", two | v2[:10]);
  println ("@", two @ v2[:10]);
  println ("in", three in v4[0:10]);
  println ("==", two == v2[:10]);
  println ("!=", two != v2[:10]);
  println ("===", two === v2[:10]);
  println ("!==", two !== v2[:10]);
  println ("<", two < v2[:10]);
  println (">", two > v2[:10]);
  println ("<=", two <= v2[:10]);
  println (">=", two >= v2[:10]);
  putln ("--------------------------------\n");
  two = 2.0; three = 3.0; m = -32.0;
}
TEST589
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT589' && $CMP $stdout $ftemp2; then
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[0, 0, 0, 0, 0, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[0, 0, 0, 0, 0, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

OUTPUT589
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 590.
if test $result = ok -a $start_test_number -le 590; then
	echo test 590: Different vector binary operations: 5
        cat >$test_file <<'TEST590'
var i, two = 2, four = 4;
for (i = 0; i < 2; i++) {
  var v1 = [10:two], v2 = [10:four];
  println ("/", v1[:] / v2[:]);
  println ("%", v1[:] % v2[:]);
  println ("/", v2[:] / v1[:]);
  println ("%", v2[:] % v1[:]);
  putln ("--------------------------------");
 
  println ("/", v1[:] / four);
  println ("%", v1[:] % four);
  println ("/", v2[:] / two);
  println ("%", v2[:] % two);
  putln ("--------------------------------");
  
  println ("/", two / v2[:]);
  println ("%", two % v2[:]);
  println ("/", four / v2[:]);
  println ("%", four % v2[:]);
  putln ("--------------------------------");

  v1 = [10:two, nil]; v2 = [10:four];
  println ("/", v1[0:10] / v2[:]);
  println ("%", v1[0:10] % v2[:]);
  println ("/", v2[:] / v1[0:10]);
  println ("%", v2[:] % v1[0:10]);
  putln ("--------------------------------");
  
  println ("/", v1[0:10] / 4);
  println ("%", v1[0:10] % 4);
  println ("/", 4 / v1[0:10]);
  println ("%", 4 % v1[0:10]);
  putln ("--------------------------------");

  v1 = [10:two, nil]; v2 = [10:four, 0.5];
  println ("/", v1[0:10] / v2[:10]);
  println ("%", v1[0:10] % v2[:10]);
  println ("/", four / v2[:10]);
  println ("%", four % v2[:10]);
  putln ("--------------------------------\n");

  two = 2.0; four = 4.0;
}
TEST590
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT590' && $CMP $stdout $ftemp2; then
"/"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

"/"[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

OUTPUT590
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 591.
if test $result = ok -a $start_test_number -le 591; then
	echo test 591: Different vector fold operations
        cat >$test_file <<'TEST591'
var i, v1 = [10:2];
for (i = 0; i < 4; i++) {
  println (".+", .+v1[0:10]);
  println (".*", .*v1[0:10]);
  println (".&", .&v1[0:10]);
  println (".^", .^v1[0:10]);
  println (".|", .|v1[0:10]);
  putln ("--------------------------------");

  if (i == 0)
    v1 = [10:2, nil];
  else if (i == 1)
    v1 = [10:2.5, nil];
  else
    v1 = [5:2.0, 5:2, nil];
}

v1 = [];
println (".+", .+v1[:]);
println (".*", .*v1[:]);
println (".&", .&v1[:]);
println (".^", .^v1[:]);
println (".|", .|v1[:]);
TEST591
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT591' && $CMP $stdout $ftemp2; then
".+"20
".*"1024
".&"2
".^"0
".|"2
--------------------------------
".+"20
".*"1024
".&"2
".^"0
".|"2
--------------------------------
".+"25
".*"9536.74
".&"2
".^"0
".|"2
--------------------------------
".+"20
".*"1024
".&"2
".^"0
".|"2
--------------------------------
".+"0
".*"1
".&"-1
".^"0
".|"0
OUTPUT591
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 592.
if test $result = ok -a $start_test_number -le 592; then
	echo test 592: Different vector unary operations
        cat >$test_file <<'TEST592'
var i, two = 2;
for (i = 0; i < 2; i++) {
  var v1 = [10:two];
  println ("+", +v1[:]);
  println ("-", -v1[:]);
  println ("!", !v1[:]);
  println ("~", ~v1[:]);
  println ("#", #v1[:]);
  putln ("--------------------------------");
  two = 2.5;
}
TEST592
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT592' && $CMP $stdout $ftemp2; then
"+"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"-"[-2, -2, -2, -2, -2, -2, -2, -2, -2, -2]
"!"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"~"[-3, -3, -3, -3, -3, -3, -3, -3, -3, -3]
"#"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
--------------------------------
"+"[2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5]
"-"[-2.5, -2.5, -2.5, -2.5, -2.5, -2.5, -2.5, -2.5, -2.5, -2.5]
"!"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"~"[-3, -3, -3, -3, -3, -3, -3, -3, -3, -3]
"#"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
--------------------------------
OUTPUT592
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 593.
if test $result = ok -a $start_test_number -le 593; then
	echo test 593: Different vector unary operations 2
        cat >$test_file <<'TEST593'
var i, v = [4:[5:1]];
for (i = 1; i < #v; i++) put (v[i-1] === v[i]);
putln ();
v[:] = new v[:];
println (v);
for (i = 1; i < #v; i++) put (v[i-1] === v[i]);
putln ();
println (v);
TEST593
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT593' && $CMP $stdout $ftemp2; then
111
[[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]
000
[[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]
OUTPUT593
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 594.
if test $result = ok -a $start_test_number -le 594; then
	echo test 594: Different vector unary operations 3
        cat >$test_file <<'TEST594'
var i, two = 2;
for (i = 0; i < 2; i++) {
  var v1 = [10:two];
  println ("type()", type (v1[:]));
  println ("char()", char (v1[:]));
  println ("int()", int (v1[:]));
  println ("float()", float (v1[:]));
  putln ("--------------------------------");
  two = 2.5;
}
TEST594
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT594' && $CMP $stdout $ftemp2; then
"type()"[int, int, int, int, int, int, int, int, int, int]
"char()""\2\2\2\2\2\2\2\2\2\2"
"int()"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"float()"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
--------------------------------
"type()"[float, float, float, float, float, float, float, float, float, float]
"char()""\2\2\2\2\2\2\2\2\2\2"
"int()"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"float()"[2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5]
--------------------------------
OUTPUT594
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 595.
if test $result = ok -a $start_test_number -le 595; then
	echo test 595: Eltype of vector of fun and class
        cat >$test_file <<'TEST595'
fun f {}
class c {}
val v = [f, c];
println (eltype (v));

val v = [c, c];
println (eltype (v));
TEST595
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT595' && $CMP $stdout $ftemp2; then
nil
class
OUTPUT595
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 596
if test $result = ok -a $start_test_number -le 596; then
	echo test 596: Different vector unary operations 5
        cat >$test_file <<'TEST596'
var i, v = [4:[5:1]];
v[:] = final v[:];
println (v);
v[0][0] = 2;
println (v);
TEST596
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT596' && $CMP $stderr $ftemp2; then
test.d:4:5: run time error - attempt to modify immutable vector
OUTPUT596
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT596-2' && $CMP $stdout $ftemp2; then
[[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]
OUTPUT596-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 597.
if test $result = ok -a $start_test_number -le 597; then
	echo test 597: A bug with extended life block
        cat >$test_file <<'TEST597'
var o = nil;
thread t {class tc {}; o = tc ();}
fun f {class fc {};return fc();}
fun main {
  var one, two;
  one = context (f()); t (); wait (o != nil); two = context (o);
  println (one, two);
}
main ();
TEST597
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT597' && $CMP $ftemp $ftemp2; then
stack f()stack t()
OUTPUT597
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 598.
if test $result = ok -a $start_test_number -le 598; then
	echo test 598: Different vector unary operations 6
        cat >$test_file <<'TEST598'
var i, two = 2, v1 = [5:"ab"];
for (i = 0; i < 2; i++) {
  println ("vec()", vec (v1[:]));
  println ("tab()", tab (v1[:]));
  putln ("--------------------------------");
  v1 = [tab [1:2], tab [3:4], tab [5:6]];
}
TEST598
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT598' && $CMP $stdout $ftemp2; then
"vec()"["ab", "ab", "ab", "ab", "ab"]
"tab()"[tab [0:'a', 1:'b'], tab [0:'a', 1:'b'], tab [0:'a', 1:'b'], tab [0:'a', 1:'b'], tab [0:'a', 1:'b']]
--------------------------------
"vec()"[[1, 2], [3, 4], [5, 6]]
"tab()"[tab [1:2], tab [3:4], tab [5:6]]
--------------------------------
OUTPUT598
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 599.
if test $result = ok -a $start_test_number -le 599; then
	echo test 599: Different format vector operations
        cat >$test_file <<'TEST599'
var v1=[1.2, 2.3, 3.4, 4.5], v2=["%.3e", "%.5e", "%g", "%+g"];
println (vec (v1[:], "%g"));
println (vec (4.5, v2[:]));
println (vec (v1[:], v2[:]));
TEST599
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT599' && $CMP $stdout $ftemp2; then
["1.2", "2.3", "3.4", "4.5"]
["4.500e+00", "4.50000e+00", "4.5", "+4.5"]
["1.200e+00", "2.30000e+00", "3.4", "+4.5"]
OUTPUT599
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 600.
if test $result = ok -a $start_test_number -le 600; then
	echo test 600: Different slice assignments
        cat >$test_file <<'TEST600'
var m = new [5:[7:1]];
m[::2][::3]=5;
println (m);
TEST600
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT600' && $CMP $stdout $ftemp2; then
[[5, 1, 1, 5, 1, 1, 5], [5, 1, 1, 5, 1, 1, 5], [5, 1, 1, 5, 1, 1, 5], [5, 1, 1, 5, 1, 1, 5], [5, 1, 1, 5, 1, 1, 5]]
OUTPUT600
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 601.
if test $result = ok -a $start_test_number -le 601; then
	echo test 601: Different slice assignments 2
        cat >$test_file <<'TEST601'
var i,v=[20:0], r=[30:0];
for (i = 0; i < #r; i++)r[i]=i;
v[5:15:2] = r[1:6];
println (v);
v=[20:0.5];
v[5:15:2] = r[1:6];
println (v);
TEST601
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT601' && $CMP $stdout $ftemp2; then
[0, 0, 0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0]
[0.5, 0.5, 0.5, 0.5, 0.5, 1, 0.5, 2, 0.5, 3, 0.5, 4, 0.5, 5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
OUTPUT601
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 602.
if test $result = ok -a $start_test_number -le 602; then
	echo test 602: Different slice assignments 3
        cat >$test_file <<'TEST602'
var i, r=[30:0];
for (i = 0; i < #r; i++)r[i]=i;
r[:] = r[::-1];
println (r);
TEST602
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT602' && $CMP $stdout $ftemp2; then
[29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
OUTPUT602
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 603.
if test $result = ok -a $start_test_number -le 603; then
	echo test 603: Different slice assignments 4
        cat >$test_file <<'TEST603'
var r = 5, perm1=[10:0], i, t;
for (i = 0; i < 10; i++) perm1[i] = i;

println (r, perm1);
t = perm1[0]; perm1[0:r-1] = perm1[1:r]; perm1[r-1] = t;
println (perm1);
TEST603
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT603' && $CMP $stdout $ftemp2; then
5[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[1, 2, 3, 4, 0, 5, 6, 7, 8, 9]
OUTPUT603
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 604
if test $result = ok -a $start_test_number -le 604; then
	echo test 604: Wrong slice assignment
        cat >$test_file <<'TEST604'
var i, r=[30:0];
for (i = 0; i < #r; i++)r[i]=i;
r[1:5] = r[2:5];
println (r);
TEST604
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT604' && $CMP $stderr $ftemp2; then
test.d:3:2: run time error - different lengths of slices 4 vs 3 (dimension = 1)
OUTPUT604
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT604-2' && $CMP $stdout $ftemp2; then
OUTPUT604-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 605.
if test $result = ok -a $start_test_number -le 605; then
	echo test 605: Anonymous func/class/thread
        cat >$test_file <<'TEST605'
putln (fun (a,b) {return a < b ? a : b;} (3, 5));
fun (a,b) {putln (a > b ? a : b);} (3, 5);
var o = class (c) {};
putln (o (42).c);
thread {put ("Wait... "); wait (o==nil); putln ("Continue");} ();
o = nil;
TEST605
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT605' && $CMP $stdout $ftemp2; then
3
5
42
Wait... Continue
OUTPUT605
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 606.
if test $result = ok -a $start_test_number -le 606; then
	echo test 606: Fold function
        cat >$test_file <<'TEST606'
var v = [1,2,3,4];
println (fold (fun (a, b) {return a + b;}, v[:], 0));
println (fold (fun (a, b) {return a * b;}, v[:], 1));
var f = fold;
println (f (fun (a, b) {return a * b;}, v[:], 1));
TEST606
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT606' && $CMP $stdout $ftemp2; then
10
24
24
OUTPUT606
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 607
if test $result = ok -a $start_test_number -le 607; then
	echo test 607: Wrong fold argument
        cat >$test_file <<'TEST607'
var v = [1,2,3,4];
println (fold (fun (a, b) {return a + b;}, nil, 0));
TEST607
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT607' && $CMP $stderr $ftemp2; then
test.d:2:15: run time error - invalid parameter type of `fold'
OUTPUT607
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT607-2' && $CMP $stdout $ftemp2; then
OUTPUT607-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 608.
if test $result = ok -a $start_test_number -le 608; then
	echo test 608: Filter function
        cat >$test_file <<'TEST608'
var i, v = [0, 1, -2, 3, -4];
println (filter (fun (a) {return a > 0;}, v));
v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
println (filter (fun (a) {return a > 0;}, v, 2));
for (i = 0; i < 1000; i++) {
  v = [[0, 1.1, -2, 3, -4], [5, -6.1, 7, -8, 9]];
  v = filter (fun (a) {if (i % 100) gc ();return a > 0;}, v, 2);
}
println (v);
TEST608
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT608' && $CMP $stdout $ftemp2; then
[1, 3]
[[1, 3], [5, 7, 9]]
[[1.1, 3], [5, 7, 9]]
OUTPUT608
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 609
if test $result = ok -a $start_test_number -le 609; then
	echo test 609: Wrong filter argument
        cat >$test_file <<'TEST609'
var v = [0, 1, -2, 3, -4];
println (filter (fun (a) {return a > 0;}, nil));
TEST609
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT609' && $CMP $stderr $ftemp2; then
test.d:2:17: run time error - invalid parameter type of `filter'
OUTPUT609
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT609-2' && $CMP $stdout $ftemp2; then
OUTPUT609-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 610
if test $result = ok -a $start_test_number -le 610; then
	echo test 610: Another wrong filter argument
        cat >$test_file <<'TEST610'
var v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
println (filter (fun (a) {return a > 0;}, v));
TEST610
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT610' && $CMP $stderr $ftemp2; then
test.d:2:36: run time error - invalid types of operands of operator ">"
OUTPUT610
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT610-2' && $CMP $stdout $ftemp2; then
OUTPUT610-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 611
if test $result = ok -a $start_test_number -le 611; then
	echo test 611: Wrong filter function result
        cat >$test_file <<'TEST611'
var v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
println (filter (fun (a) {return nil;}, v, 2));
TEST611
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT611' && $CMP $stderr $ftemp2; then
test.d:2:17: run time error - invalid function result used by function `filter'
OUTPUT611
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT611-2' && $CMP $stdout $ftemp2; then
OUTPUT611-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 612.
if test $result = ok -a $start_test_number -le 612; then
	echo test 612: Map function
        cat >$test_file <<'TEST612'
var i, v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
println (map (fun (a) {return a < 0 ? nil : a;}, v, 2));
for (i = 0; i < 1000; i++) {
  v = [[0, 1.1, -2, 3, -4], [5, -6.1, 7, -8, 9]];
  v = map (fun (a) {if (i % 100) gc ();return a < 0 ? 0 : a;}, v, 2);
}
println (v);
TEST612
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT612' && $CMP $stdout $ftemp2; then
[[0, 1, nil, 3, nil], [5, nil, 7, nil, 9]]
[[0, 1.1, 0, 3, 0], [5, 0, 7, 0, 9]]
OUTPUT612
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 613
if test $result = ok -a $start_test_number -le 613; then
	echo test 613: Wrong map argument
        cat >$test_file <<'TEST613'
var v = [0, 1, -2, 3, -4];
println (map (fun (a) {return a > 0;}, nil));
TEST613
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT613' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - invalid parameter type of `map'
OUTPUT613
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT613-2' && $CMP $stdout $ftemp2; then
OUTPUT613-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 614
if test $result = ok -a $start_test_number -le 614; then
	echo test 614: Another wrong map argument
        cat >$test_file <<'TEST614'
var v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
println (map (fun (a) {return a > 0;}, v));
TEST614
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT614' && $CMP $stderr $ftemp2; then
test.d:2:33: run time error - invalid types of operands of operator ">"
OUTPUT614
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT614-2' && $CMP $stdout $ftemp2; then
OUTPUT614-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 615.
if test $result = ok -a $start_test_number -le 615; then
	echo test 615: addi generation
        cat >$test_file <<'TEST615'
for (var i = 0; i < 1000; i--);
TEST615
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep addi $stdout
                if fgrep addi $stdout > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 616.
if test $result = ok -a $start_test_number -le 616; then
	echo test 616: addi generation
        cat >$test_file <<'TEST616'
var i = 0;
i++;
i+=2;
i=i+3;
i=4+i;
TEST616
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`' fgrep addi $stdout '|wc -l`' = 4
                if expr `fgrep " addi" $stdout|wc -l` = 4 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 617.
if test $result = ok -a $start_test_number -le 617; then
	echo test 617: btcmp generation
        cat >$test_file <<'TEST617'
var i = 0, k = 0;
for (;i!=k;);
for (;i==k;);
for (;i<=k;);
for (;i<k;);
for (;i>=k;);
for (;i>k;);
TEST617
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep btne $stdout '&&' fgrep bteq $stdout '&&' fgrep btle $stdout '&&' fgrep btlt $stdout '&&' fgrep btge $stdout '&&' fgrep btgt $stdout
                if (fgrep btne $stdout && fgrep bteq $stdout && fgrep btle $stdout && fgrep btlt $stdout && fgrep btge $stdout && fgrep btgt $stdout) > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 618.
if test $result = ok -a $start_test_number -le 618; then
	echo test 618: addi with neg. constant generation
        cat >$test_file <<'TEST618'
var i = 0;
i--;
i-=2;
i=i-3;
i=4-i;
TEST618
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`fgrep addi' $stdout '|wc -l`' = 3
                if expr `fgrep " addi" $stdout|wc -l` = 3 > /dev/null ; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 619.
if test $result = ok -a $start_test_number -le 619; then
	echo test 619: no addi generation for slices
        cat >$test_file <<'TEST619'
var i = [10:0];
i[:]++;
i[:]=i[:]+1;
TEST619
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep -v addi $stdout
                if fgrep -v addi $stdout > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 620.
if test $result = ok -a $start_test_number -le 620; then
	echo test 620: btcmpinc generation
        cat >$test_file <<'TEST620'
var i = 0, k = 10, n= 1;
for (;i!=k;i++)n++;
for (;i==k;i++)n++;
for (;i<=k;i++)n++;
for (;i<k;i++)n++;
for (;i>=k;i++)n++;
for (;i>k;i++)n++;
TEST620
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep btneinc $stdout '&&' fgrep bteqinc $stdout '&&' fgrep btleinc $stdout '&&' fgrep btltinc $stdout '&&' fgrep btgeinc $stdout '&&' fgrep btgtinc $stdout
                if (fgrep btneinc $stdout && fgrep bteqinc $stdout && fgrep btleinc $stdout && fgrep btltinc $stdout && fgrep btgeinc $stdout && fgrep btgtinc $stdout) > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 621.
if test $result = ok -a $start_test_number -le 621; then
	echo test 621: bfcmp generation
        cat >$test_file <<'TEST621'
var i=1, b=5, n=0;
if (i < b) n++;else n--;
TEST621
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep btge $stdout
                if fgrep btge $stdout > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 622.
if test $result = ok -a $start_test_number -le 622; then
	echo test 622: Call tail optimization
        cat >$test_file <<'TEST622'
fun even;
fun odd (n) {
  if (n == 0) return 0;
  return even (n - 1);
}

fun even (n) {
  if (n == 0) return 1;
  return odd (n - 1);
}

putln ("odd  (10000000) = ", odd (10000000));
putln ("even (10000000) = ", even (10000000));
TEST622
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT622' && $CMP $stdout $ftemp2; then
odd  (10000000) = 0
even (10000000) = 1
OUTPUT622
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 623.
if test $result = ok -a $start_test_number -le 623; then
	echo test 623: Immediate call generation
        cat >$test_file <<'TEST623'
fun f {
  fun h {
  }
  fun g {
     h ();
  }
  g ();
}
fun e {
  f();
}
TEST623
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep  $stdout itcall '&&' fgrep citcall $stdout '&&' fgrep titcall $stdout
                if (fgrep itcall $stdout && fgrep citcall $stdout && fgrep titcall $stdout) > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 624.
if test $result = ok -a $start_test_number -le 624; then
	echo test 624: Branch and compare with immediate generation
        cat >$test_file <<'TEST624'
var i = 0;
if (i < 1) i++;
if (i > 1) i++;
if (i <= 1) i++;
if (i >= 1) i++;
if (i == 1) i++;
if (i != 1) i++;
if (2 < i) i++;
if (2 > i) i++;
if (2 <= i) i++;
if (2 >= i) i++;
if (2 == i) i++;
if (2 != i) i++;
TEST624
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`' egrep "'btgei|btlei|btgti|btlti|btnei|bteqi'" $stdout '| wc -l`' = 12
                if expr `egrep 'btgei|btlei|btgti|btlti|btnei|bteqi' $stdout | wc -l` = 12 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 625.
if test $result = ok -a $start_test_number -le 625; then
	echo test 625: Compare with immediate generation
        cat >$test_file <<'TEST625'
var i = 0;
i = i < 1;
i = i > 1;
i = i <= 1;
i = i >= 1;
i = i == 1;
i = i != 1;
i = 2 < i;
i = 2 > i;
i = 2 <= i;
i = 2 >= i;
i = 2 == i;
i = 2 != i;
TEST625
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`' egrep "'gei|lei|gti|lti|nei|eqi'" $stdout '| wc -l`' = 12
                if expr `egrep 'gei|lei|gti|lti|nei|eqi' $stdout | wc -l` = 12 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 626
if test $result = ok -a $start_test_number -le 626; then
	echo test 626: Too few actuals
        cat >$test_file <<'TEST626'
fun f (a, b) {
}

f(1);
TEST626
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT626' && $CMP $stderr $ftemp2; then
test.d:4:2: run time error - too few actual parameters for `f'
OUTPUT626
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT626-2' && $CMP $stdout $ftemp2; then
OUTPUT626-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 627
if test $result = ok -a $start_test_number -le 627; then
	echo test 627: Too many actuals
        cat >$test_file <<'TEST627'
fun f {
}

f(1);
TEST627
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT627' && $CMP $stderr $ftemp2; then
test.d:4:2: run time error - too many actual parameters for `f'
OUTPUT627
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT627-2' && $CMP $stdout $ftemp2; then
OUTPUT627-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 628
if test $result = ok -a $start_test_number -le 628; then
	echo test 628: Too few actuals when ... is present
        cat >$test_file <<'TEST628'
fun f (a, ...) {
}

f ();
TEST628
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT628' && $CMP $stderr $ftemp2; then
test.d:4:3: run time error - too few actual parameters for `f'
OUTPUT628
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT628-2' && $CMP $stdout $ftemp2; then
OUTPUT628-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 629
if test $result = ok -a $start_test_number -le 629; then
	echo test 629: Undefined comparison values
        cat >$test_file <<'TEST629'
var i;
println (i == 10);
TEST629
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT629' && $CMP $stderr $ftemp2; then
test.d:2:12: run time error - invalid types of operands of operator "==" or "!="
OUTPUT629
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT629-2' && $CMP $stdout $ftemp2; then
OUTPUT629-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 630
if test $result = ok -a $start_test_number -le 630; then
	echo test 630: Undefined identity values
        cat >$test_file <<'TEST630'
var i;
println (i !== 10);
TEST630
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT630' && $CMP $stderr $ftemp2; then
test.d:2:12: run time error - invalid types of operands of operator "===" or "!=="
OUTPUT630
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT630-2' && $CMP $stdout $ftemp2; then
OUTPUT630-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 631
if test $result = ok -a $start_test_number -le 631; then
	echo test 631: Undefined local values
        cat >$test_file <<'TEST631'
var i, j = i;
TEST631
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT631' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - undefined `i' value access
OUTPUT631
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT631-2' && $CMP $stdout $ftemp2; then
OUTPUT631-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 632
if test $result = ok -a $start_test_number -le 632; then
	echo test 632: Undefined object values
        cat >$test_file <<'TEST632'
class c { var i;}
println (c().i);
TEST632
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT632' && $CMP $stderr $ftemp2; then
test.d:2:13: run time error - undefined `i' value access
OUTPUT632
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT632-2' && $CMP $stdout $ftemp2; then
OUTPUT632-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 633
if test $result = ok -a $start_test_number -le 633; then
	echo test 633: Undefined global values
        cat >$test_file <<'TEST633'
var v=[1:0], a;
v[0]=a;
TEST633
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT633' && $CMP $stderr $ftemp2; then
test.d:2:5: run time error - undefined value assign
OUTPUT633
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT633-2' && $CMP $stdout $ftemp2; then
OUTPUT633-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 634
if test $result = ok -a $start_test_number -le 634; then
	echo test 634: This not in func/block
        cat >$test_file <<'TEST634'
var i = this;
TEST634
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT634' && $CMP $stderr $ftemp2; then
test.d:1:9: this is not in function or class
OUTPUT634
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT634-2' && $CMP $stdout $ftemp2; then
OUTPUT634-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 635.
if test $result = ok -a $start_test_number -le 635; then
	echo test 635: This in func/class
        cat >$test_file <<'TEST635'
var i; fun f {i = this;}
class c {i = this;}
thread t {i = this;}
TEST635
        echo '      ' $DINO $test_file "2>$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT635' && $CMP $stdout $ftemp2; then
OUTPUT635
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 636.
if test $result = ok -a $start_test_number -le 636; then
	echo test 636: Correct this value in func/class
        cat >$test_file <<'TEST636'
var i; fun f {i = this;} f (); putln (inside (i, f));
class c {i = this;} c (); putln (inside (i, c));
var s = 0; fun t {i = this; s = 1;} t (); wait (s == 1); putln (inside (i, t));
class c1 {} class c2 {use c1; i=this;} c2 (); putln (isa (i, c1));
TEST636
        echo '      ' $DINO $test_file "2>$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT636' && $CMP $stdout $ftemp2; then
1
1
1
1
OUTPUT636
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 637.
if test $result = ok -a $start_test_number -le 637; then
	echo test 637: Condition generation of if or for statements
        cat >$test_file <<'TEST637'
val i = 1, j = 2, k = 3;
if (i < j && j < k) putln();
if (i < j || j < k) putln();
if (! (i < j)) putln ();

for (;i < j && j < k;) putln();
for (;i < j || j < k;) putln();
for (;! (i < j);) putln ();

if (1) putln ();
if (!1) putln ();
TEST637
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep -v lconv $stdout '&&' fgrep -v brfs $stdout '&&' fgrep -v brts $stdout
                if (fgrep -v lconv $stdout && fgrep -v brfs $stdout && fgrep -v brts $stdout) > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 638.
if test $result = ok -a $start_test_number -le 638; then
	echo test 638: Condition generation result
        cat >$test_file <<'TEST638'
var i = 1, j = 2, k = 3;
i = i < j && j < k;
i = i < j || j < k;
i = ! (i < j);
TEST638
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep lconv $stdout '&&' fgrep brfs $stdout '&&' fgrep brts $stdout '&&' fgrep not $stdout
                if (fgrep lconv $stdout && fgrep brfs $stdout && fgrep brts $stdout && fgrep not $stdout) > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 639.
if test $result = ok -a $start_test_number -le 639; then
	echo test 639: Transpose function: expected results
        cat >$test_file <<'TEST639'
var m=[[1]];
println (transpose(m));
m=[[1,2],[3,4]];
println (transpose(m));
m=[[1,2,3],[4,5,6]];
println (transpose(m));
m=[[1,2]];
println (transpose(m));
m=[[1],[2]];
println (transpose(m));
m=[[1],['a']];
println (transpose(m));
TEST639
        echo '      ' $DINO $test_file "2>$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT639' && $CMP $stdout $ftemp2; then
[[1]]
[[1, 3], [2, 4]]
[[1, 4], [2, 5], [3, 6]]
[[1], [2]]
[[1, 2]]
[[1, 'a']]
OUTPUT639
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 640
if test $result = ok -a $start_test_number -le 640; then
	echo test 640: Transpose function: not vector
        cat >$test_file <<'TEST640'
var m=1;
println (transpose(m));
TEST640
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT640' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - invalid parameter type of `transpose'
OUTPUT640
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT640-2' && $CMP $stdout $ftemp2; then
OUTPUT640-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 641
if test $result = ok -a $start_test_number -le 641; then
	echo test 641: Transpose function: empty vector
        cat >$test_file <<'TEST641'
val m=[];
println (transpose(m));
TEST641
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT641' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - wrong matrix form for matrix operation `transpose'
OUTPUT641
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT641-2' && $CMP $stdout $ftemp2; then
OUTPUT641-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 642
if test $result = ok -a $start_test_number -le 642; then
	echo test 642: Transpose function: different row lengths
        cat >$test_file <<'TEST642'
val m=[[1],[2,3]];
println (transpose(m));
TEST642
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT642' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - wrong matrix form for matrix operation `transpose'
OUTPUT642
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT642-2' && $CMP $stdout $ftemp2; then
OUTPUT642-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 643
if test $result = ok -a $start_test_number -le 643; then
	echo test 643: Transpose function: empty row
        cat >$test_file <<'TEST643'
val m=[[]];
println (transpose(m));
TEST643
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT643' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - wrong matrix form for matrix operation `transpose'
OUTPUT643
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT643-2' && $CMP $stdout $ftemp2; then
OUTPUT643-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 644.
if test $result = ok -a $start_test_number -le 644; then
	echo test 644: REPL correct program
        cat >$test_file <<'TEST644'
fun fact (x)
{
  if (x <= 1)
    return 1;
  return x * fact (x-1);
}

var i, x, n = 3;

for (i = 0; i < n; i++)
  x = fact (12);

putln (x);
TEST644
        echo '      ' $DINO "<" $test_file "2>&1 | egrep -v 'version|Copyright|if-stmt' >$stdout"
        if $DINO < $test_file 2>&1 | egrep -v 'version|Copyright|if-stmt' >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT644' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino>     |     |     |     |     | dino> dino> dino> dino>     | dino> dino> 479001600
dino> 
OUTPUT644
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 645.
if test $result = ok -a $start_test_number -le 645; then
	echo test 645: REPL syntax error
        cat >$test_file <<'TEST645'
val ;
putln ("Right");
val ;
putln ("Right again");
TEST645
        echo '      ' $DINO "<" $test_file "2>&1 | egrep -v 'version|Copyright|if-stmt' >$stdout"
        if $DINO < $test_file 2>&1 | egrep -v 'version|Copyright|if-stmt' >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT645' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino>       val ;
          ^
      syntax error
dino> Right
dino>       val ;
          ^
      syntax error
dino> Right again
dino> 
OUTPUT645
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 646.
if test $result = ok -a $start_test_number -le 646; then
	echo test 646: REPL context error
        cat >$test_file <<'TEST646'
final fun f;
fun f{}
putln ("Right");
final fun f;
fun f{}
putln ("Right again");
throw 1;
putln ("One more: right");
TEST646
        echo '      ' $DINO "<" $test_file "2>&1 | egrep -v 'version|Copyright|if-stmt' >$stdout"
        if $DINO < $test_file 2>&1 | egrep -v 'version|Copyright|if-stmt' >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT646' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino> dino>       fun f{}
          ^
      forward and matched decls of `f' have different access/final attributes
      final fun f;
                ^
      (previous declaration of identifier `f')
dino> Right
dino> dino>       fun f{}
          ^
      forward and matched decls of `f' have different access/final attributes
      final fun f;
                ^
      (previous declaration of identifier `f')
dino> Right again
dino>       throw 1;
      ^
      invalid type of throw-expr
dino> One more: right
dino> 
OUTPUT646
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 647.
if test $result = ok -a $start_test_number -le 647; then
	echo test 647: REPL eval error
        cat >$test_file <<'TEST647'
val i = 5/0;
putln ("Right");
val i = 5/0;
putln ("Right again");
val i = 5/0;
putln ("One more: right");
TEST647
        echo '      ' $DINO "<" $test_file "2>&1 | egrep -v 'version|Copyright|if-stmt' >$stdout"
        if $DINO < $test_file 2>&1 | egrep -v 'version|Copyright|if-stmt' >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT647' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino>       val i = 5/0;
               ^
      floating point exception
dino> Right
dino>       val i = 5/0;
               ^
      floating point exception
dino> Right again
dino>       val i = 5/0;
               ^
      floating point exception
dino> One more: right
dino> 
OUTPUT647
                        result=ok
# when system does not catch zero division
                elif cat >$ftemp2 <<'OUTPUT647a' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino> dino> Right
dino> dino> Right again
dino> dino> One more: right
dino> 
OUTPUT647a
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 648.
if test $result = ok -a $start_test_number -le 648; then
	echo test 648: REPL printing
        cat >$test_file <<'TEST648'
fun fact (x) {
  if (x <= 1) {
    x;
    return 1;
  }
  return x * fact (x-1);
}

var i, x, n = 2;
for (i = 0; i < n; i++)
  fact (8);
TEST648
        echo '      ' $DINO "<" $test_file "2>&1 | egrep -v 'version|Copyright|if-stmt' >$stdout"
        if $DINO < $test_file 2>&1 | egrep -v 'version|Copyright|if-stmt' >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT648' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino>     |     |     |     |     |     | dino> dino> dino>     | 40320
40320
dino> 
OUTPUT648
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 649.
if test $result = ok -a $start_test_number -le 649; then
	echo test 649: REPL printing long vectors and tables
        cat >$test_file <<'TEST649'
[49:1, 50: 2.0];
[100:1];
tab [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50];
TEST649
        echo '      ' $DINO "<" $test_file "2>&1 | egrep -v 'version|Copyright|if-stmt' >$stdout"
        if $DINO < $test_file 2>&1 | egrep -v 'version|Copyright|if-stmt' >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT649' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino> [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, ...]
dino> [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]
dino> tab [0:nil, 1:nil, 2:nil, 3:nil, 4:nil, 5:nil, 6:nil, 7:nil, 8:nil, 9:nil, 10:nil, 11:nil, 12:nil, 13:nil, 14:nil, 15:nil, 16:nil, 17:nil, 18:nil, 19:nil, 20:nil, 21:nil, 22:nil, 23:nil, 24:nil, 25:nil, 26:nil, 27:nil, 28:nil, 29:nil, 30:nil, 31:nil, 32:nil, 33:nil, 34:nil, 35:nil, 36:nil, 37:nil, 38:nil, 39:nil, 40:nil, 41:nil, 42:nil, 43:nil, 44:nil, 45:nil, 46:nil, 47:nil, 48:nil, 49:nil, ...]
dino> 
OUTPUT649
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 650.
if test $result = ok -a $start_test_number -le 650; then
	echo test 650: Integer format printing
        cat >$test_file <<'TEST650'
fun err {putln ("badformat");}
put ("#0- +d: "); try {putf ("->%#0- +d<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +d: "); try {putf ("->%#0- +d<-\n",0);} catch (invfmt) {err ();}
put ("#0- +d: "); try {putf ("->%#0- +d<-\n",4);} catch (invfmt) {err ();}
put ("0- +d: "); try {putf ("->%0- +d<-\n",-4);} catch (invfmt) {err ();}
put ("0- +d: "); try {putf ("->%0- +d<-\n",0);} catch (invfmt) {err ();}
put ("0- +d: "); try {putf ("->%0- +d<-\n",4);} catch (invfmt) {err ();}
put ("#- +d: "); try {putf ("->%#- +d<-\n",-4);} catch (invfmt) {err ();}
put ("#- +d: "); try {putf ("->%#- +d<-\n",0);} catch (invfmt) {err ();}
put ("#- +d: "); try {putf ("->%#- +d<-\n",4);} catch (invfmt) {err ();}
put ("- +d: "); try {putf ("->%- +d<-\n",-4);} catch (invfmt) {err ();}
put ("- +d: "); try {putf ("->%- +d<-\n",0);} catch (invfmt) {err ();}
put ("- +d: "); try {putf ("->%- +d<-\n",4);} catch (invfmt) {err ();}
put ("#0 +d: "); try {putf ("->%#0 +d<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +d: "); try {putf ("->%#0 +d<-\n",0);} catch (invfmt) {err ();}
put ("#0 +d: "); try {putf ("->%#0 +d<-\n",4);} catch (invfmt) {err ();}
put ("0 +d: "); try {putf ("->%0 +d<-\n",-4);} catch (invfmt) {err ();}
put ("0 +d: "); try {putf ("->%0 +d<-\n",0);} catch (invfmt) {err ();}
put ("0 +d: "); try {putf ("->%0 +d<-\n",4);} catch (invfmt) {err ();}
put ("# +d: "); try {putf ("->%# +d<-\n",-4);} catch (invfmt) {err ();}
put ("# +d: "); try {putf ("->%# +d<-\n",0);} catch (invfmt) {err ();}
put ("# +d: "); try {putf ("->%# +d<-\n",4);} catch (invfmt) {err ();}
put (" +d: "); try {putf ("->% +d<-\n",-4);} catch (invfmt) {err ();}
put (" +d: "); try {putf ("->% +d<-\n",0);} catch (invfmt) {err ();}
put (" +d: "); try {putf ("->% +d<-\n",4);} catch (invfmt) {err ();}
put ("#0-+d: "); try {putf ("->%#0-+d<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+d: "); try {putf ("->%#0-+d<-\n",0);} catch (invfmt) {err ();}
put ("#0-+d: "); try {putf ("->%#0-+d<-\n",4);} catch (invfmt) {err ();}
put ("0-+d: "); try {putf ("->%0-+d<-\n",-4);} catch (invfmt) {err ();}
put ("0-+d: "); try {putf ("->%0-+d<-\n",0);} catch (invfmt) {err ();}
put ("0-+d: "); try {putf ("->%0-+d<-\n",4);} catch (invfmt) {err ();}
put ("#-+d: "); try {putf ("->%#-+d<-\n",-4);} catch (invfmt) {err ();}
put ("#-+d: "); try {putf ("->%#-+d<-\n",0);} catch (invfmt) {err ();}
put ("#-+d: "); try {putf ("->%#-+d<-\n",4);} catch (invfmt) {err ();}
put ("-+d: "); try {putf ("->%-+d<-\n",-4);} catch (invfmt) {err ();}
put ("-+d: "); try {putf ("->%-+d<-\n",0);} catch (invfmt) {err ();}
put ("-+d: "); try {putf ("->%-+d<-\n",4);} catch (invfmt) {err ();}
put ("#0+d: "); try {putf ("->%#0+d<-\n",-4);} catch (invfmt) {err ();}
put ("#0+d: "); try {putf ("->%#0+d<-\n",0);} catch (invfmt) {err ();}
put ("#0+d: "); try {putf ("->%#0+d<-\n",4);} catch (invfmt) {err ();}
put ("0+d: "); try {putf ("->%0+d<-\n",-4);} catch (invfmt) {err ();}
put ("0+d: "); try {putf ("->%0+d<-\n",0);} catch (invfmt) {err ();}
put ("0+d: "); try {putf ("->%0+d<-\n",4);} catch (invfmt) {err ();}
put ("#+d: "); try {putf ("->%#+d<-\n",-4);} catch (invfmt) {err ();}
put ("#+d: "); try {putf ("->%#+d<-\n",0);} catch (invfmt) {err ();}
put ("#+d: "); try {putf ("->%#+d<-\n",4);} catch (invfmt) {err ();}
put ("+d: "); try {putf ("->%+d<-\n",-4);} catch (invfmt) {err ();}
put ("+d: "); try {putf ("->%+d<-\n",0);} catch (invfmt) {err ();}
put ("+d: "); try {putf ("->%+d<-\n",4);} catch (invfmt) {err ();}
put ("#0- d: "); try {putf ("->%#0- d<-\n",-4);} catch (invfmt) {err ();}
put ("#0- d: "); try {putf ("->%#0- d<-\n",0);} catch (invfmt) {err ();}
put ("#0- d: "); try {putf ("->%#0- d<-\n",4);} catch (invfmt) {err ();}
put ("0- d: "); try {putf ("->%0- d<-\n",-4);} catch (invfmt) {err ();}
put ("0- d: "); try {putf ("->%0- d<-\n",0);} catch (invfmt) {err ();}
put ("0- d: "); try {putf ("->%0- d<-\n",4);} catch (invfmt) {err ();}
put ("#- d: "); try {putf ("->%#- d<-\n",-4);} catch (invfmt) {err ();}
put ("#- d: "); try {putf ("->%#- d<-\n",0);} catch (invfmt) {err ();}
put ("#- d: "); try {putf ("->%#- d<-\n",4);} catch (invfmt) {err ();}
put ("- d: "); try {putf ("->%- d<-\n",-4);} catch (invfmt) {err ();}
put ("- d: "); try {putf ("->%- d<-\n",0);} catch (invfmt) {err ();}
put ("- d: "); try {putf ("->%- d<-\n",4);} catch (invfmt) {err ();}
put ("#0 d: "); try {putf ("->%#0 d<-\n",-4);} catch (invfmt) {err ();}
put ("#0 d: "); try {putf ("->%#0 d<-\n",0);} catch (invfmt) {err ();}
put ("#0 d: "); try {putf ("->%#0 d<-\n",4);} catch (invfmt) {err ();}
put ("0 d: "); try {putf ("->%0 d<-\n",-4);} catch (invfmt) {err ();}
put ("0 d: "); try {putf ("->%0 d<-\n",0);} catch (invfmt) {err ();}
put ("0 d: "); try {putf ("->%0 d<-\n",4);} catch (invfmt) {err ();}
put ("# d: "); try {putf ("->%# d<-\n",-4);} catch (invfmt) {err ();}
put ("# d: "); try {putf ("->%# d<-\n",0);} catch (invfmt) {err ();}
put ("# d: "); try {putf ("->%# d<-\n",4);} catch (invfmt) {err ();}
put (" d: "); try {putf ("->% d<-\n",-4);} catch (invfmt) {err ();}
put (" d: "); try {putf ("->% d<-\n",0);} catch (invfmt) {err ();}
put (" d: "); try {putf ("->% d<-\n",4);} catch (invfmt) {err ();}
put ("#0-d: "); try {putf ("->%#0-d<-\n",-4);} catch (invfmt) {err ();}
put ("#0-d: "); try {putf ("->%#0-d<-\n",0);} catch (invfmt) {err ();}
put ("#0-d: "); try {putf ("->%#0-d<-\n",4);} catch (invfmt) {err ();}
put ("0-d: "); try {putf ("->%0-d<-\n",-4);} catch (invfmt) {err ();}
put ("0-d: "); try {putf ("->%0-d<-\n",0);} catch (invfmt) {err ();}
put ("0-d: "); try {putf ("->%0-d<-\n",4);} catch (invfmt) {err ();}
put ("#-d: "); try {putf ("->%#-d<-\n",-4);} catch (invfmt) {err ();}
put ("#-d: "); try {putf ("->%#-d<-\n",0);} catch (invfmt) {err ();}
put ("#-d: "); try {putf ("->%#-d<-\n",4);} catch (invfmt) {err ();}
put ("-d: "); try {putf ("->%-d<-\n",-4);} catch (invfmt) {err ();}
put ("-d: "); try {putf ("->%-d<-\n",0);} catch (invfmt) {err ();}
put ("-d: "); try {putf ("->%-d<-\n",4);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",-4);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",0);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",4);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",-4);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",0);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",4);} catch (invfmt) {err ();}
put ("#d: "); try {putf ("->%#d<-\n",-4);} catch (invfmt) {err ();}
put ("#d: "); try {putf ("->%#d<-\n",0);} catch (invfmt) {err ();}
put ("#d: "); try {putf ("->%#d<-\n",4);} catch (invfmt) {err ();}
put ("d: "); try {putf ("->%d<-\n",-4);} catch (invfmt) {err ();}
put ("d: "); try {putf ("->%d<-\n",0);} catch (invfmt) {err ();}
put ("d: "); try {putf ("->%d<-\n",4);} catch (invfmt) {err ();}
put ("#0- +o: "); try {putf ("->%#0- +o<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +o: "); try {putf ("->%#0- +o<-\n",0);} catch (invfmt) {err ();}
put ("#0- +o: "); try {putf ("->%#0- +o<-\n",4);} catch (invfmt) {err ();}
put ("0- +o: "); try {putf ("->%0- +o<-\n",-4);} catch (invfmt) {err ();}
put ("0- +o: "); try {putf ("->%0- +o<-\n",0);} catch (invfmt) {err ();}
put ("0- +o: "); try {putf ("->%0- +o<-\n",4);} catch (invfmt) {err ();}
put ("#- +o: "); try {putf ("->%#- +o<-\n",-4);} catch (invfmt) {err ();}
put ("#- +o: "); try {putf ("->%#- +o<-\n",0);} catch (invfmt) {err ();}
put ("#- +o: "); try {putf ("->%#- +o<-\n",4);} catch (invfmt) {err ();}
put ("- +o: "); try {putf ("->%- +o<-\n",-4);} catch (invfmt) {err ();}
put ("- +o: "); try {putf ("->%- +o<-\n",0);} catch (invfmt) {err ();}
put ("- +o: "); try {putf ("->%- +o<-\n",4);} catch (invfmt) {err ();}
put ("#0 +o: "); try {putf ("->%#0 +o<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +o: "); try {putf ("->%#0 +o<-\n",0);} catch (invfmt) {err ();}
put ("#0 +o: "); try {putf ("->%#0 +o<-\n",4);} catch (invfmt) {err ();}
put ("0 +o: "); try {putf ("->%0 +o<-\n",-4);} catch (invfmt) {err ();}
put ("0 +o: "); try {putf ("->%0 +o<-\n",0);} catch (invfmt) {err ();}
put ("0 +o: "); try {putf ("->%0 +o<-\n",4);} catch (invfmt) {err ();}
put ("# +o: "); try {putf ("->%# +o<-\n",-4);} catch (invfmt) {err ();}
put ("# +o: "); try {putf ("->%# +o<-\n",0);} catch (invfmt) {err ();}
put ("# +o: "); try {putf ("->%# +o<-\n",4);} catch (invfmt) {err ();}
put (" +o: "); try {putf ("->% +o<-\n",-4);} catch (invfmt) {err ();}
put (" +o: "); try {putf ("->% +o<-\n",0);} catch (invfmt) {err ();}
put (" +o: "); try {putf ("->% +o<-\n",4);} catch (invfmt) {err ();}
put ("#0-+o: "); try {putf ("->%#0-+o<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+o: "); try {putf ("->%#0-+o<-\n",0);} catch (invfmt) {err ();}
put ("#0-+o: "); try {putf ("->%#0-+o<-\n",4);} catch (invfmt) {err ();}
put ("0-+o: "); try {putf ("->%0-+o<-\n",-4);} catch (invfmt) {err ();}
put ("0-+o: "); try {putf ("->%0-+o<-\n",0);} catch (invfmt) {err ();}
put ("0-+o: "); try {putf ("->%0-+o<-\n",4);} catch (invfmt) {err ();}
put ("#-+o: "); try {putf ("->%#-+o<-\n",-4);} catch (invfmt) {err ();}
put ("#-+o: "); try {putf ("->%#-+o<-\n",0);} catch (invfmt) {err ();}
put ("#-+o: "); try {putf ("->%#-+o<-\n",4);} catch (invfmt) {err ();}
put ("-+o: "); try {putf ("->%-+o<-\n",-4);} catch (invfmt) {err ();}
put ("-+o: "); try {putf ("->%-+o<-\n",0);} catch (invfmt) {err ();}
put ("-+o: "); try {putf ("->%-+o<-\n",4);} catch (invfmt) {err ();}
put ("#0+o: "); try {putf ("->%#0+o<-\n",-4);} catch (invfmt) {err ();}
put ("#0+o: "); try {putf ("->%#0+o<-\n",0);} catch (invfmt) {err ();}
put ("#0+o: "); try {putf ("->%#0+o<-\n",4);} catch (invfmt) {err ();}
put ("0+o: "); try {putf ("->%0+o<-\n",-4);} catch (invfmt) {err ();}
put ("0+o: "); try {putf ("->%0+o<-\n",0);} catch (invfmt) {err ();}
put ("0+o: "); try {putf ("->%0+o<-\n",4);} catch (invfmt) {err ();}
put ("#+o: "); try {putf ("->%#+o<-\n",-4);} catch (invfmt) {err ();}
put ("#+o: "); try {putf ("->%#+o<-\n",0);} catch (invfmt) {err ();}
put ("#+o: "); try {putf ("->%#+o<-\n",4);} catch (invfmt) {err ();}
put ("+o: "); try {putf ("->%+o<-\n",-4);} catch (invfmt) {err ();}
put ("+o: "); try {putf ("->%+o<-\n",0);} catch (invfmt) {err ();}
put ("+o: "); try {putf ("->%+o<-\n",4);} catch (invfmt) {err ();}
put ("#0- o: "); try {putf ("->%#0- o<-\n",-4);} catch (invfmt) {err ();}
put ("#0- o: "); try {putf ("->%#0- o<-\n",0);} catch (invfmt) {err ();}
put ("#0- o: "); try {putf ("->%#0- o<-\n",4);} catch (invfmt) {err ();}
put ("0- o: "); try {putf ("->%0- o<-\n",-4);} catch (invfmt) {err ();}
put ("0- o: "); try {putf ("->%0- o<-\n",0);} catch (invfmt) {err ();}
put ("0- o: "); try {putf ("->%0- o<-\n",4);} catch (invfmt) {err ();}
put ("#- o: "); try {putf ("->%#- o<-\n",-4);} catch (invfmt) {err ();}
put ("#- o: "); try {putf ("->%#- o<-\n",0);} catch (invfmt) {err ();}
put ("#- o: "); try {putf ("->%#- o<-\n",4);} catch (invfmt) {err ();}
put ("- o: "); try {putf ("->%- o<-\n",-4);} catch (invfmt) {err ();}
put ("- o: "); try {putf ("->%- o<-\n",0);} catch (invfmt) {err ();}
put ("- o: "); try {putf ("->%- o<-\n",4);} catch (invfmt) {err ();}
put ("#0 o: "); try {putf ("->%#0 o<-\n",-4);} catch (invfmt) {err ();}
put ("#0 o: "); try {putf ("->%#0 o<-\n",0);} catch (invfmt) {err ();}
put ("#0 o: "); try {putf ("->%#0 o<-\n",4);} catch (invfmt) {err ();}
put ("0 o: "); try {putf ("->%0 o<-\n",-4);} catch (invfmt) {err ();}
put ("0 o: "); try {putf ("->%0 o<-\n",0);} catch (invfmt) {err ();}
put ("0 o: "); try {putf ("->%0 o<-\n",4);} catch (invfmt) {err ();}
put ("# o: "); try {putf ("->%# o<-\n",-4);} catch (invfmt) {err ();}
put ("# o: "); try {putf ("->%# o<-\n",0);} catch (invfmt) {err ();}
put ("# o: "); try {putf ("->%# o<-\n",4);} catch (invfmt) {err ();}
put (" o: "); try {putf ("->% o<-\n",-4);} catch (invfmt) {err ();}
put (" o: "); try {putf ("->% o<-\n",0);} catch (invfmt) {err ();}
put (" o: "); try {putf ("->% o<-\n",4);} catch (invfmt) {err ();}
put ("#0-o: "); try {putf ("->%#0-o<-\n",-4);} catch (invfmt) {err ();}
put ("#0-o: "); try {putf ("->%#0-o<-\n",0);} catch (invfmt) {err ();}
put ("#0-o: "); try {putf ("->%#0-o<-\n",4);} catch (invfmt) {err ();}
put ("0-o: "); try {putf ("->%0-o<-\n",-4);} catch (invfmt) {err ();}
put ("0-o: "); try {putf ("->%0-o<-\n",0);} catch (invfmt) {err ();}
put ("0-o: "); try {putf ("->%0-o<-\n",4);} catch (invfmt) {err ();}
put ("#-o: "); try {putf ("->%#-o<-\n",-4);} catch (invfmt) {err ();}
put ("#-o: "); try {putf ("->%#-o<-\n",0);} catch (invfmt) {err ();}
put ("#-o: "); try {putf ("->%#-o<-\n",4);} catch (invfmt) {err ();}
put ("-o: "); try {putf ("->%-o<-\n",-4);} catch (invfmt) {err ();}
put ("-o: "); try {putf ("->%-o<-\n",0);} catch (invfmt) {err ();}
put ("-o: "); try {putf ("->%-o<-\n",4);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",-4);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",0);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",4);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",-4);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",0);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",4);} catch (invfmt) {err ();}
put ("#o: "); try {putf ("->%#o<-\n",-4);} catch (invfmt) {err ();}
put ("#o: "); try {putf ("->%#o<-\n",0);} catch (invfmt) {err ();}
put ("#o: "); try {putf ("->%#o<-\n",4);} catch (invfmt) {err ();}
put ("o: "); try {putf ("->%o<-\n",-4);} catch (invfmt) {err ();}
put ("o: "); try {putf ("->%o<-\n",0);} catch (invfmt) {err ();}
put ("o: "); try {putf ("->%o<-\n",4);} catch (invfmt) {err ();}
put ("#0- +x: "); try {putf ("->%#0- +x<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +x: "); try {putf ("->%#0- +x<-\n",0);} catch (invfmt) {err ();}
put ("#0- +x: "); try {putf ("->%#0- +x<-\n",4);} catch (invfmt) {err ();}
put ("0- +x: "); try {putf ("->%0- +x<-\n",-4);} catch (invfmt) {err ();}
put ("0- +x: "); try {putf ("->%0- +x<-\n",0);} catch (invfmt) {err ();}
put ("0- +x: "); try {putf ("->%0- +x<-\n",4);} catch (invfmt) {err ();}
put ("#- +x: "); try {putf ("->%#- +x<-\n",-4);} catch (invfmt) {err ();}
put ("#- +x: "); try {putf ("->%#- +x<-\n",0);} catch (invfmt) {err ();}
put ("#- +x: "); try {putf ("->%#- +x<-\n",4);} catch (invfmt) {err ();}
put ("- +x: "); try {putf ("->%- +x<-\n",-4);} catch (invfmt) {err ();}
put ("- +x: "); try {putf ("->%- +x<-\n",0);} catch (invfmt) {err ();}
put ("- +x: "); try {putf ("->%- +x<-\n",4);} catch (invfmt) {err ();}
put ("#0 +x: "); try {putf ("->%#0 +x<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +x: "); try {putf ("->%#0 +x<-\n",0);} catch (invfmt) {err ();}
put ("#0 +x: "); try {putf ("->%#0 +x<-\n",4);} catch (invfmt) {err ();}
put ("0 +x: "); try {putf ("->%0 +x<-\n",-4);} catch (invfmt) {err ();}
put ("0 +x: "); try {putf ("->%0 +x<-\n",0);} catch (invfmt) {err ();}
put ("0 +x: "); try {putf ("->%0 +x<-\n",4);} catch (invfmt) {err ();}
put ("# +x: "); try {putf ("->%# +x<-\n",-4);} catch (invfmt) {err ();}
put ("# +x: "); try {putf ("->%# +x<-\n",0);} catch (invfmt) {err ();}
put ("# +x: "); try {putf ("->%# +x<-\n",4);} catch (invfmt) {err ();}
put (" +x: "); try {putf ("->% +x<-\n",-4);} catch (invfmt) {err ();}
put (" +x: "); try {putf ("->% +x<-\n",0);} catch (invfmt) {err ();}
put (" +x: "); try {putf ("->% +x<-\n",4);} catch (invfmt) {err ();}
put ("#0-+x: "); try {putf ("->%#0-+x<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+x: "); try {putf ("->%#0-+x<-\n",0);} catch (invfmt) {err ();}
put ("#0-+x: "); try {putf ("->%#0-+x<-\n",4);} catch (invfmt) {err ();}
put ("0-+x: "); try {putf ("->%0-+x<-\n",-4);} catch (invfmt) {err ();}
put ("0-+x: "); try {putf ("->%0-+x<-\n",0);} catch (invfmt) {err ();}
put ("0-+x: "); try {putf ("->%0-+x<-\n",4);} catch (invfmt) {err ();}
put ("#-+x: "); try {putf ("->%#-+x<-\n",-4);} catch (invfmt) {err ();}
put ("#-+x: "); try {putf ("->%#-+x<-\n",0);} catch (invfmt) {err ();}
put ("#-+x: "); try {putf ("->%#-+x<-\n",4);} catch (invfmt) {err ();}
put ("-+x: "); try {putf ("->%-+x<-\n",-4);} catch (invfmt) {err ();}
put ("-+x: "); try {putf ("->%-+x<-\n",0);} catch (invfmt) {err ();}
put ("-+x: "); try {putf ("->%-+x<-\n",4);} catch (invfmt) {err ();}
put ("#0+x: "); try {putf ("->%#0+x<-\n",-4);} catch (invfmt) {err ();}
put ("#0+x: "); try {putf ("->%#0+x<-\n",0);} catch (invfmt) {err ();}
put ("#0+x: "); try {putf ("->%#0+x<-\n",4);} catch (invfmt) {err ();}
put ("0+x: "); try {putf ("->%0+x<-\n",-4);} catch (invfmt) {err ();}
put ("0+x: "); try {putf ("->%0+x<-\n",0);} catch (invfmt) {err ();}
put ("0+x: "); try {putf ("->%0+x<-\n",4);} catch (invfmt) {err ();}
put ("#+x: "); try {putf ("->%#+x<-\n",-4);} catch (invfmt) {err ();}
put ("#+x: "); try {putf ("->%#+x<-\n",0);} catch (invfmt) {err ();}
put ("#+x: "); try {putf ("->%#+x<-\n",4);} catch (invfmt) {err ();}
put ("+x: "); try {putf ("->%+x<-\n",-4);} catch (invfmt) {err ();}
put ("+x: "); try {putf ("->%+x<-\n",0);} catch (invfmt) {err ();}
put ("+x: "); try {putf ("->%+x<-\n",4);} catch (invfmt) {err ();}
put ("#0- x: "); try {putf ("->%#0- x<-\n",-4);} catch (invfmt) {err ();}
put ("#0- x: "); try {putf ("->%#0- x<-\n",0);} catch (invfmt) {err ();}
put ("#0- x: "); try {putf ("->%#0- x<-\n",4);} catch (invfmt) {err ();}
put ("0- x: "); try {putf ("->%0- x<-\n",-4);} catch (invfmt) {err ();}
put ("0- x: "); try {putf ("->%0- x<-\n",0);} catch (invfmt) {err ();}
put ("0- x: "); try {putf ("->%0- x<-\n",4);} catch (invfmt) {err ();}
put ("#- x: "); try {putf ("->%#- x<-\n",-4);} catch (invfmt) {err ();}
put ("#- x: "); try {putf ("->%#- x<-\n",0);} catch (invfmt) {err ();}
put ("#- x: "); try {putf ("->%#- x<-\n",4);} catch (invfmt) {err ();}
put ("- x: "); try {putf ("->%- x<-\n",-4);} catch (invfmt) {err ();}
put ("- x: "); try {putf ("->%- x<-\n",0);} catch (invfmt) {err ();}
put ("- x: "); try {putf ("->%- x<-\n",4);} catch (invfmt) {err ();}
put ("#0 x: "); try {putf ("->%#0 x<-\n",-4);} catch (invfmt) {err ();}
put ("#0 x: "); try {putf ("->%#0 x<-\n",0);} catch (invfmt) {err ();}
put ("#0 x: "); try {putf ("->%#0 x<-\n",4);} catch (invfmt) {err ();}
put ("0 x: "); try {putf ("->%0 x<-\n",-4);} catch (invfmt) {err ();}
put ("0 x: "); try {putf ("->%0 x<-\n",0);} catch (invfmt) {err ();}
put ("0 x: "); try {putf ("->%0 x<-\n",4);} catch (invfmt) {err ();}
put ("# x: "); try {putf ("->%# x<-\n",-4);} catch (invfmt) {err ();}
put ("# x: "); try {putf ("->%# x<-\n",0);} catch (invfmt) {err ();}
put ("# x: "); try {putf ("->%# x<-\n",4);} catch (invfmt) {err ();}
put (" x: "); try {putf ("->% x<-\n",-4);} catch (invfmt) {err ();}
put (" x: "); try {putf ("->% x<-\n",0);} catch (invfmt) {err ();}
put (" x: "); try {putf ("->% x<-\n",4);} catch (invfmt) {err ();}
put ("#0-x: "); try {putf ("->%#0-x<-\n",-4);} catch (invfmt) {err ();}
put ("#0-x: "); try {putf ("->%#0-x<-\n",0);} catch (invfmt) {err ();}
put ("#0-x: "); try {putf ("->%#0-x<-\n",4);} catch (invfmt) {err ();}
put ("0-x: "); try {putf ("->%0-x<-\n",-4);} catch (invfmt) {err ();}
put ("0-x: "); try {putf ("->%0-x<-\n",0);} catch (invfmt) {err ();}
put ("0-x: "); try {putf ("->%0-x<-\n",4);} catch (invfmt) {err ();}
put ("#-x: "); try {putf ("->%#-x<-\n",-4);} catch (invfmt) {err ();}
put ("#-x: "); try {putf ("->%#-x<-\n",0);} catch (invfmt) {err ();}
put ("#-x: "); try {putf ("->%#-x<-\n",4);} catch (invfmt) {err ();}
put ("-x: "); try {putf ("->%-x<-\n",-4);} catch (invfmt) {err ();}
put ("-x: "); try {putf ("->%-x<-\n",0);} catch (invfmt) {err ();}
put ("-x: "); try {putf ("->%-x<-\n",4);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",-4);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",0);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",4);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",-4);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",0);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",4);} catch (invfmt) {err ();}
put ("#x: "); try {putf ("->%#x<-\n",-4);} catch (invfmt) {err ();}
put ("#x: "); try {putf ("->%#x<-\n",0);} catch (invfmt) {err ();}
put ("#x: "); try {putf ("->%#x<-\n",4);} catch (invfmt) {err ();}
put ("x: "); try {putf ("->%x<-\n",-4);} catch (invfmt) {err ();}
put ("x: "); try {putf ("->%x<-\n",0);} catch (invfmt) {err ();}
put ("x: "); try {putf ("->%x<-\n",4);} catch (invfmt) {err ();}
put ("#0- +X: "); try {putf ("->%#0- +X<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +X: "); try {putf ("->%#0- +X<-\n",0);} catch (invfmt) {err ();}
put ("#0- +X: "); try {putf ("->%#0- +X<-\n",4);} catch (invfmt) {err ();}
put ("0- +X: "); try {putf ("->%0- +X<-\n",-4);} catch (invfmt) {err ();}
put ("0- +X: "); try {putf ("->%0- +X<-\n",0);} catch (invfmt) {err ();}
put ("0- +X: "); try {putf ("->%0- +X<-\n",4);} catch (invfmt) {err ();}
put ("#- +X: "); try {putf ("->%#- +X<-\n",-4);} catch (invfmt) {err ();}
put ("#- +X: "); try {putf ("->%#- +X<-\n",0);} catch (invfmt) {err ();}
put ("#- +X: "); try {putf ("->%#- +X<-\n",4);} catch (invfmt) {err ();}
put ("- +X: "); try {putf ("->%- +X<-\n",-4);} catch (invfmt) {err ();}
put ("- +X: "); try {putf ("->%- +X<-\n",0);} catch (invfmt) {err ();}
put ("- +X: "); try {putf ("->%- +X<-\n",4);} catch (invfmt) {err ();}
put ("#0 +X: "); try {putf ("->%#0 +X<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +X: "); try {putf ("->%#0 +X<-\n",0);} catch (invfmt) {err ();}
put ("#0 +X: "); try {putf ("->%#0 +X<-\n",4);} catch (invfmt) {err ();}
put ("0 +X: "); try {putf ("->%0 +X<-\n",-4);} catch (invfmt) {err ();}
put ("0 +X: "); try {putf ("->%0 +X<-\n",0);} catch (invfmt) {err ();}
put ("0 +X: "); try {putf ("->%0 +X<-\n",4);} catch (invfmt) {err ();}
put ("# +X: "); try {putf ("->%# +X<-\n",-4);} catch (invfmt) {err ();}
put ("# +X: "); try {putf ("->%# +X<-\n",0);} catch (invfmt) {err ();}
put ("# +X: "); try {putf ("->%# +X<-\n",4);} catch (invfmt) {err ();}
put (" +X: "); try {putf ("->% +X<-\n",-4);} catch (invfmt) {err ();}
put (" +X: "); try {putf ("->% +X<-\n",0);} catch (invfmt) {err ();}
put (" +X: "); try {putf ("->% +X<-\n",4);} catch (invfmt) {err ();}
put ("#0-+X: "); try {putf ("->%#0-+X<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+X: "); try {putf ("->%#0-+X<-\n",0);} catch (invfmt) {err ();}
put ("#0-+X: "); try {putf ("->%#0-+X<-\n",4);} catch (invfmt) {err ();}
put ("0-+X: "); try {putf ("->%0-+X<-\n",-4);} catch (invfmt) {err ();}
put ("0-+X: "); try {putf ("->%0-+X<-\n",0);} catch (invfmt) {err ();}
put ("0-+X: "); try {putf ("->%0-+X<-\n",4);} catch (invfmt) {err ();}
put ("#-+X: "); try {putf ("->%#-+X<-\n",-4);} catch (invfmt) {err ();}
put ("#-+X: "); try {putf ("->%#-+X<-\n",0);} catch (invfmt) {err ();}
put ("#-+X: "); try {putf ("->%#-+X<-\n",4);} catch (invfmt) {err ();}
put ("-+X: "); try {putf ("->%-+X<-\n",-4);} catch (invfmt) {err ();}
put ("-+X: "); try {putf ("->%-+X<-\n",0);} catch (invfmt) {err ();}
put ("-+X: "); try {putf ("->%-+X<-\n",4);} catch (invfmt) {err ();}
put ("#0+X: "); try {putf ("->%#0+X<-\n",-4);} catch (invfmt) {err ();}
put ("#0+X: "); try {putf ("->%#0+X<-\n",0);} catch (invfmt) {err ();}
put ("#0+X: "); try {putf ("->%#0+X<-\n",4);} catch (invfmt) {err ();}
put ("0+X: "); try {putf ("->%0+X<-\n",-4);} catch (invfmt) {err ();}
put ("0+X: "); try {putf ("->%0+X<-\n",0);} catch (invfmt) {err ();}
put ("0+X: "); try {putf ("->%0+X<-\n",4);} catch (invfmt) {err ();}
put ("#+X: "); try {putf ("->%#+X<-\n",-4);} catch (invfmt) {err ();}
put ("#+X: "); try {putf ("->%#+X<-\n",0);} catch (invfmt) {err ();}
put ("#+X: "); try {putf ("->%#+X<-\n",4);} catch (invfmt) {err ();}
put ("+X: "); try {putf ("->%+X<-\n",-4);} catch (invfmt) {err ();}
put ("+X: "); try {putf ("->%+X<-\n",0);} catch (invfmt) {err ();}
put ("+X: "); try {putf ("->%+X<-\n",4);} catch (invfmt) {err ();}
put ("#0- X: "); try {putf ("->%#0- X<-\n",-4);} catch (invfmt) {err ();}
put ("#0- X: "); try {putf ("->%#0- X<-\n",0);} catch (invfmt) {err ();}
put ("#0- X: "); try {putf ("->%#0- X<-\n",4);} catch (invfmt) {err ();}
put ("0- X: "); try {putf ("->%0- X<-\n",-4);} catch (invfmt) {err ();}
put ("0- X: "); try {putf ("->%0- X<-\n",0);} catch (invfmt) {err ();}
put ("0- X: "); try {putf ("->%0- X<-\n",4);} catch (invfmt) {err ();}
put ("#- X: "); try {putf ("->%#- X<-\n",-4);} catch (invfmt) {err ();}
put ("#- X: "); try {putf ("->%#- X<-\n",0);} catch (invfmt) {err ();}
put ("#- X: "); try {putf ("->%#- X<-\n",4);} catch (invfmt) {err ();}
put ("- X: "); try {putf ("->%- X<-\n",-4);} catch (invfmt) {err ();}
put ("- X: "); try {putf ("->%- X<-\n",0);} catch (invfmt) {err ();}
put ("- X: "); try {putf ("->%- X<-\n",4);} catch (invfmt) {err ();}
put ("#0 X: "); try {putf ("->%#0 X<-\n",-4);} catch (invfmt) {err ();}
put ("#0 X: "); try {putf ("->%#0 X<-\n",0);} catch (invfmt) {err ();}
put ("#0 X: "); try {putf ("->%#0 X<-\n",4);} catch (invfmt) {err ();}
put ("0 X: "); try {putf ("->%0 X<-\n",-4);} catch (invfmt) {err ();}
put ("0 X: "); try {putf ("->%0 X<-\n",0);} catch (invfmt) {err ();}
put ("0 X: "); try {putf ("->%0 X<-\n",4);} catch (invfmt) {err ();}
put ("# X: "); try {putf ("->%# X<-\n",-4);} catch (invfmt) {err ();}
put ("# X: "); try {putf ("->%# X<-\n",0);} catch (invfmt) {err ();}
put ("# X: "); try {putf ("->%# X<-\n",4);} catch (invfmt) {err ();}
put (" X: "); try {putf ("->% X<-\n",-4);} catch (invfmt) {err ();}
put (" X: "); try {putf ("->% X<-\n",0);} catch (invfmt) {err ();}
put (" X: "); try {putf ("->% X<-\n",4);} catch (invfmt) {err ();}
put ("#0-X: "); try {putf ("->%#0-X<-\n",-4);} catch (invfmt) {err ();}
put ("#0-X: "); try {putf ("->%#0-X<-\n",0);} catch (invfmt) {err ();}
put ("#0-X: "); try {putf ("->%#0-X<-\n",4);} catch (invfmt) {err ();}
put ("0-X: "); try {putf ("->%0-X<-\n",-4);} catch (invfmt) {err ();}
put ("0-X: "); try {putf ("->%0-X<-\n",0);} catch (invfmt) {err ();}
put ("0-X: "); try {putf ("->%0-X<-\n",4);} catch (invfmt) {err ();}
put ("#-X: "); try {putf ("->%#-X<-\n",-4);} catch (invfmt) {err ();}
put ("#-X: "); try {putf ("->%#-X<-\n",0);} catch (invfmt) {err ();}
put ("#-X: "); try {putf ("->%#-X<-\n",4);} catch (invfmt) {err ();}
put ("-X: "); try {putf ("->%-X<-\n",-4);} catch (invfmt) {err ();}
put ("-X: "); try {putf ("->%-X<-\n",0);} catch (invfmt) {err ();}
put ("-X: "); try {putf ("->%-X<-\n",4);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",-4);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",0);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",4);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",-4);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",0);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",4);} catch (invfmt) {err ();}
put ("#X: "); try {putf ("->%#X<-\n",-4);} catch (invfmt) {err ();}
put ("#X: "); try {putf ("->%#X<-\n",0);} catch (invfmt) {err ();}
put ("#X: "); try {putf ("->%#X<-\n",4);} catch (invfmt) {err ();}
put ("X: "); try {putf ("->%X<-\n",-4);} catch (invfmt) {err ();}
put ("X: "); try {putf ("->%X<-\n",0);} catch (invfmt) {err ();}
put ("X: "); try {putf ("->%X<-\n",4);} catch (invfmt) {err ();}
put ("#0- +0d: "); try {putf ("->%#0- +0d<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +0d: "); try {putf ("->%#0- +0d<-\n",0);} catch (invfmt) {err ();}
put ("#0- +0d: "); try {putf ("->%#0- +0d<-\n",4);} catch (invfmt) {err ();}
put ("0- +0d: "); try {putf ("->%0- +0d<-\n",-4);} catch (invfmt) {err ();}
put ("0- +0d: "); try {putf ("->%0- +0d<-\n",0);} catch (invfmt) {err ();}
put ("0- +0d: "); try {putf ("->%0- +0d<-\n",4);} catch (invfmt) {err ();}
put ("#- +0d: "); try {putf ("->%#- +0d<-\n",-4);} catch (invfmt) {err ();}
put ("#- +0d: "); try {putf ("->%#- +0d<-\n",0);} catch (invfmt) {err ();}
put ("#- +0d: "); try {putf ("->%#- +0d<-\n",4);} catch (invfmt) {err ();}
put ("- +0d: "); try {putf ("->%- +0d<-\n",-4);} catch (invfmt) {err ();}
put ("- +0d: "); try {putf ("->%- +0d<-\n",0);} catch (invfmt) {err ();}
put ("- +0d: "); try {putf ("->%- +0d<-\n",4);} catch (invfmt) {err ();}
put ("#0 +0d: "); try {putf ("->%#0 +0d<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +0d: "); try {putf ("->%#0 +0d<-\n",0);} catch (invfmt) {err ();}
put ("#0 +0d: "); try {putf ("->%#0 +0d<-\n",4);} catch (invfmt) {err ();}
put ("0 +0d: "); try {putf ("->%0 +0d<-\n",-4);} catch (invfmt) {err ();}
put ("0 +0d: "); try {putf ("->%0 +0d<-\n",0);} catch (invfmt) {err ();}
put ("0 +0d: "); try {putf ("->%0 +0d<-\n",4);} catch (invfmt) {err ();}
put ("# +0d: "); try {putf ("->%# +0d<-\n",-4);} catch (invfmt) {err ();}
put ("# +0d: "); try {putf ("->%# +0d<-\n",0);} catch (invfmt) {err ();}
put ("# +0d: "); try {putf ("->%# +0d<-\n",4);} catch (invfmt) {err ();}
put (" +0d: "); try {putf ("->% +0d<-\n",-4);} catch (invfmt) {err ();}
put (" +0d: "); try {putf ("->% +0d<-\n",0);} catch (invfmt) {err ();}
put (" +0d: "); try {putf ("->% +0d<-\n",4);} catch (invfmt) {err ();}
put ("#0-+0d: "); try {putf ("->%#0-+0d<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+0d: "); try {putf ("->%#0-+0d<-\n",0);} catch (invfmt) {err ();}
put ("#0-+0d: "); try {putf ("->%#0-+0d<-\n",4);} catch (invfmt) {err ();}
put ("0-+0d: "); try {putf ("->%0-+0d<-\n",-4);} catch (invfmt) {err ();}
put ("0-+0d: "); try {putf ("->%0-+0d<-\n",0);} catch (invfmt) {err ();}
put ("0-+0d: "); try {putf ("->%0-+0d<-\n",4);} catch (invfmt) {err ();}
put ("#-+0d: "); try {putf ("->%#-+0d<-\n",-4);} catch (invfmt) {err ();}
put ("#-+0d: "); try {putf ("->%#-+0d<-\n",0);} catch (invfmt) {err ();}
put ("#-+0d: "); try {putf ("->%#-+0d<-\n",4);} catch (invfmt) {err ();}
put ("-+0d: "); try {putf ("->%-+0d<-\n",-4);} catch (invfmt) {err ();}
put ("-+0d: "); try {putf ("->%-+0d<-\n",0);} catch (invfmt) {err ();}
put ("-+0d: "); try {putf ("->%-+0d<-\n",4);} catch (invfmt) {err ();}
put ("#0+0d: "); try {putf ("->%#0+0d<-\n",-4);} catch (invfmt) {err ();}
put ("#0+0d: "); try {putf ("->%#0+0d<-\n",0);} catch (invfmt) {err ();}
put ("#0+0d: "); try {putf ("->%#0+0d<-\n",4);} catch (invfmt) {err ();}
put ("0+0d: "); try {putf ("->%0+0d<-\n",-4);} catch (invfmt) {err ();}
put ("0+0d: "); try {putf ("->%0+0d<-\n",0);} catch (invfmt) {err ();}
put ("0+0d: "); try {putf ("->%0+0d<-\n",4);} catch (invfmt) {err ();}
put ("#+0d: "); try {putf ("->%#+0d<-\n",-4);} catch (invfmt) {err ();}
put ("#+0d: "); try {putf ("->%#+0d<-\n",0);} catch (invfmt) {err ();}
put ("#+0d: "); try {putf ("->%#+0d<-\n",4);} catch (invfmt) {err ();}
put ("+0d: "); try {putf ("->%+0d<-\n",-4);} catch (invfmt) {err ();}
put ("+0d: "); try {putf ("->%+0d<-\n",0);} catch (invfmt) {err ();}
put ("+0d: "); try {putf ("->%+0d<-\n",4);} catch (invfmt) {err ();}
put ("#0- 0d: "); try {putf ("->%#0- 0d<-\n",-4);} catch (invfmt) {err ();}
put ("#0- 0d: "); try {putf ("->%#0- 0d<-\n",0);} catch (invfmt) {err ();}
put ("#0- 0d: "); try {putf ("->%#0- 0d<-\n",4);} catch (invfmt) {err ();}
put ("0- 0d: "); try {putf ("->%0- 0d<-\n",-4);} catch (invfmt) {err ();}
put ("0- 0d: "); try {putf ("->%0- 0d<-\n",0);} catch (invfmt) {err ();}
put ("0- 0d: "); try {putf ("->%0- 0d<-\n",4);} catch (invfmt) {err ();}
put ("#- 0d: "); try {putf ("->%#- 0d<-\n",-4);} catch (invfmt) {err ();}
put ("#- 0d: "); try {putf ("->%#- 0d<-\n",0);} catch (invfmt) {err ();}
put ("#- 0d: "); try {putf ("->%#- 0d<-\n",4);} catch (invfmt) {err ();}
put ("- 0d: "); try {putf ("->%- 0d<-\n",-4);} catch (invfmt) {err ();}
put ("- 0d: "); try {putf ("->%- 0d<-\n",0);} catch (invfmt) {err ();}
put ("- 0d: "); try {putf ("->%- 0d<-\n",4);} catch (invfmt) {err ();}
put ("#0 0d: "); try {putf ("->%#0 0d<-\n",-4);} catch (invfmt) {err ();}
put ("#0 0d: "); try {putf ("->%#0 0d<-\n",0);} catch (invfmt) {err ();}
put ("#0 0d: "); try {putf ("->%#0 0d<-\n",4);} catch (invfmt) {err ();}
put ("0 0d: "); try {putf ("->%0 0d<-\n",-4);} catch (invfmt) {err ();}
put ("0 0d: "); try {putf ("->%0 0d<-\n",0);} catch (invfmt) {err ();}
put ("0 0d: "); try {putf ("->%0 0d<-\n",4);} catch (invfmt) {err ();}
put ("# 0d: "); try {putf ("->%# 0d<-\n",-4);} catch (invfmt) {err ();}
put ("# 0d: "); try {putf ("->%# 0d<-\n",0);} catch (invfmt) {err ();}
put ("# 0d: "); try {putf ("->%# 0d<-\n",4);} catch (invfmt) {err ();}
put (" 0d: "); try {putf ("->% 0d<-\n",-4);} catch (invfmt) {err ();}
put (" 0d: "); try {putf ("->% 0d<-\n",0);} catch (invfmt) {err ();}
put (" 0d: "); try {putf ("->% 0d<-\n",4);} catch (invfmt) {err ();}
put ("#0-0d: "); try {putf ("->%#0-0d<-\n",-4);} catch (invfmt) {err ();}
put ("#0-0d: "); try {putf ("->%#0-0d<-\n",0);} catch (invfmt) {err ();}
put ("#0-0d: "); try {putf ("->%#0-0d<-\n",4);} catch (invfmt) {err ();}
put ("0-0d: "); try {putf ("->%0-0d<-\n",-4);} catch (invfmt) {err ();}
put ("0-0d: "); try {putf ("->%0-0d<-\n",0);} catch (invfmt) {err ();}
put ("0-0d: "); try {putf ("->%0-0d<-\n",4);} catch (invfmt) {err ();}
put ("#-0d: "); try {putf ("->%#-0d<-\n",-4);} catch (invfmt) {err ();}
put ("#-0d: "); try {putf ("->%#-0d<-\n",0);} catch (invfmt) {err ();}
put ("#-0d: "); try {putf ("->%#-0d<-\n",4);} catch (invfmt) {err ();}
put ("-0d: "); try {putf ("->%-0d<-\n",-4);} catch (invfmt) {err ();}
put ("-0d: "); try {putf ("->%-0d<-\n",0);} catch (invfmt) {err ();}
put ("-0d: "); try {putf ("->%-0d<-\n",4);} catch (invfmt) {err ();}
put ("#00d: "); try {putf ("->%#00d<-\n",-4);} catch (invfmt) {err ();}
put ("#00d: "); try {putf ("->%#00d<-\n",0);} catch (invfmt) {err ();}
put ("#00d: "); try {putf ("->%#00d<-\n",4);} catch (invfmt) {err ();}
put ("00d: "); try {putf ("->%00d<-\n",-4);} catch (invfmt) {err ();}
put ("00d: "); try {putf ("->%00d<-\n",0);} catch (invfmt) {err ();}
put ("00d: "); try {putf ("->%00d<-\n",4);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",-4);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",0);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",4);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",-4);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",0);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",4);} catch (invfmt) {err ();}
put ("#0- +0o: "); try {putf ("->%#0- +0o<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +0o: "); try {putf ("->%#0- +0o<-\n",0);} catch (invfmt) {err ();}
put ("#0- +0o: "); try {putf ("->%#0- +0o<-\n",4);} catch (invfmt) {err ();}
put ("0- +0o: "); try {putf ("->%0- +0o<-\n",-4);} catch (invfmt) {err ();}
put ("0- +0o: "); try {putf ("->%0- +0o<-\n",0);} catch (invfmt) {err ();}
put ("0- +0o: "); try {putf ("->%0- +0o<-\n",4);} catch (invfmt) {err ();}
put ("#- +0o: "); try {putf ("->%#- +0o<-\n",-4);} catch (invfmt) {err ();}
put ("#- +0o: "); try {putf ("->%#- +0o<-\n",0);} catch (invfmt) {err ();}
put ("#- +0o: "); try {putf ("->%#- +0o<-\n",4);} catch (invfmt) {err ();}
put ("- +0o: "); try {putf ("->%- +0o<-\n",-4);} catch (invfmt) {err ();}
put ("- +0o: "); try {putf ("->%- +0o<-\n",0);} catch (invfmt) {err ();}
put ("- +0o: "); try {putf ("->%- +0o<-\n",4);} catch (invfmt) {err ();}
put ("#0 +0o: "); try {putf ("->%#0 +0o<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +0o: "); try {putf ("->%#0 +0o<-\n",0);} catch (invfmt) {err ();}
put ("#0 +0o: "); try {putf ("->%#0 +0o<-\n",4);} catch (invfmt) {err ();}
put ("0 +0o: "); try {putf ("->%0 +0o<-\n",-4);} catch (invfmt) {err ();}
put ("0 +0o: "); try {putf ("->%0 +0o<-\n",0);} catch (invfmt) {err ();}
put ("0 +0o: "); try {putf ("->%0 +0o<-\n",4);} catch (invfmt) {err ();}
put ("# +0o: "); try {putf ("->%# +0o<-\n",-4);} catch (invfmt) {err ();}
put ("# +0o: "); try {putf ("->%# +0o<-\n",0);} catch (invfmt) {err ();}
put ("# +0o: "); try {putf ("->%# +0o<-\n",4);} catch (invfmt) {err ();}
put (" +0o: "); try {putf ("->% +0o<-\n",-4);} catch (invfmt) {err ();}
put (" +0o: "); try {putf ("->% +0o<-\n",0);} catch (invfmt) {err ();}
put (" +0o: "); try {putf ("->% +0o<-\n",4);} catch (invfmt) {err ();}
put ("#0-+0o: "); try {putf ("->%#0-+0o<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+0o: "); try {putf ("->%#0-+0o<-\n",0);} catch (invfmt) {err ();}
put ("#0-+0o: "); try {putf ("->%#0-+0o<-\n",4);} catch (invfmt) {err ();}
put ("0-+0o: "); try {putf ("->%0-+0o<-\n",-4);} catch (invfmt) {err ();}
put ("0-+0o: "); try {putf ("->%0-+0o<-\n",0);} catch (invfmt) {err ();}
put ("0-+0o: "); try {putf ("->%0-+0o<-\n",4);} catch (invfmt) {err ();}
put ("#-+0o: "); try {putf ("->%#-+0o<-\n",-4);} catch (invfmt) {err ();}
put ("#-+0o: "); try {putf ("->%#-+0o<-\n",0);} catch (invfmt) {err ();}
put ("#-+0o: "); try {putf ("->%#-+0o<-\n",4);} catch (invfmt) {err ();}
put ("-+0o: "); try {putf ("->%-+0o<-\n",-4);} catch (invfmt) {err ();}
put ("-+0o: "); try {putf ("->%-+0o<-\n",0);} catch (invfmt) {err ();}
put ("-+0o: "); try {putf ("->%-+0o<-\n",4);} catch (invfmt) {err ();}
put ("#0+0o: "); try {putf ("->%#0+0o<-\n",-4);} catch (invfmt) {err ();}
put ("#0+0o: "); try {putf ("->%#0+0o<-\n",0);} catch (invfmt) {err ();}
put ("#0+0o: "); try {putf ("->%#0+0o<-\n",4);} catch (invfmt) {err ();}
put ("0+0o: "); try {putf ("->%0+0o<-\n",-4);} catch (invfmt) {err ();}
put ("0+0o: "); try {putf ("->%0+0o<-\n",0);} catch (invfmt) {err ();}
put ("0+0o: "); try {putf ("->%0+0o<-\n",4);} catch (invfmt) {err ();}
put ("#+0o: "); try {putf ("->%#+0o<-\n",-4);} catch (invfmt) {err ();}
put ("#+0o: "); try {putf ("->%#+0o<-\n",0);} catch (invfmt) {err ();}
put ("#+0o: "); try {putf ("->%#+0o<-\n",4);} catch (invfmt) {err ();}
put ("+0o: "); try {putf ("->%+0o<-\n",-4);} catch (invfmt) {err ();}
put ("+0o: "); try {putf ("->%+0o<-\n",0);} catch (invfmt) {err ();}
put ("+0o: "); try {putf ("->%+0o<-\n",4);} catch (invfmt) {err ();}
put ("#0- 0o: "); try {putf ("->%#0- 0o<-\n",-4);} catch (invfmt) {err ();}
put ("#0- 0o: "); try {putf ("->%#0- 0o<-\n",0);} catch (invfmt) {err ();}
put ("#0- 0o: "); try {putf ("->%#0- 0o<-\n",4);} catch (invfmt) {err ();}
put ("0- 0o: "); try {putf ("->%0- 0o<-\n",-4);} catch (invfmt) {err ();}
put ("0- 0o: "); try {putf ("->%0- 0o<-\n",0);} catch (invfmt) {err ();}
put ("0- 0o: "); try {putf ("->%0- 0o<-\n",4);} catch (invfmt) {err ();}
put ("#- 0o: "); try {putf ("->%#- 0o<-\n",-4);} catch (invfmt) {err ();}
put ("#- 0o: "); try {putf ("->%#- 0o<-\n",0);} catch (invfmt) {err ();}
put ("#- 0o: "); try {putf ("->%#- 0o<-\n",4);} catch (invfmt) {err ();}
put ("- 0o: "); try {putf ("->%- 0o<-\n",-4);} catch (invfmt) {err ();}
put ("- 0o: "); try {putf ("->%- 0o<-\n",0);} catch (invfmt) {err ();}
put ("- 0o: "); try {putf ("->%- 0o<-\n",4);} catch (invfmt) {err ();}
put ("#0 0o: "); try {putf ("->%#0 0o<-\n",-4);} catch (invfmt) {err ();}
put ("#0 0o: "); try {putf ("->%#0 0o<-\n",0);} catch (invfmt) {err ();}
put ("#0 0o: "); try {putf ("->%#0 0o<-\n",4);} catch (invfmt) {err ();}
put ("0 0o: "); try {putf ("->%0 0o<-\n",-4);} catch (invfmt) {err ();}
put ("0 0o: "); try {putf ("->%0 0o<-\n",0);} catch (invfmt) {err ();}
put ("0 0o: "); try {putf ("->%0 0o<-\n",4);} catch (invfmt) {err ();}
put ("# 0o: "); try {putf ("->%# 0o<-\n",-4);} catch (invfmt) {err ();}
put ("# 0o: "); try {putf ("->%# 0o<-\n",0);} catch (invfmt) {err ();}
put ("# 0o: "); try {putf ("->%# 0o<-\n",4);} catch (invfmt) {err ();}
put (" 0o: "); try {putf ("->% 0o<-\n",-4);} catch (invfmt) {err ();}
put (" 0o: "); try {putf ("->% 0o<-\n",0);} catch (invfmt) {err ();}
put (" 0o: "); try {putf ("->% 0o<-\n",4);} catch (invfmt) {err ();}
put ("#0-0o: "); try {putf ("->%#0-0o<-\n",-4);} catch (invfmt) {err ();}
put ("#0-0o: "); try {putf ("->%#0-0o<-\n",0);} catch (invfmt) {err ();}
put ("#0-0o: "); try {putf ("->%#0-0o<-\n",4);} catch (invfmt) {err ();}
put ("0-0o: "); try {putf ("->%0-0o<-\n",-4);} catch (invfmt) {err ();}
put ("0-0o: "); try {putf ("->%0-0o<-\n",0);} catch (invfmt) {err ();}
put ("0-0o: "); try {putf ("->%0-0o<-\n",4);} catch (invfmt) {err ();}
put ("#-0o: "); try {putf ("->%#-0o<-\n",-4);} catch (invfmt) {err ();}
put ("#-0o: "); try {putf ("->%#-0o<-\n",0);} catch (invfmt) {err ();}
put ("#-0o: "); try {putf ("->%#-0o<-\n",4);} catch (invfmt) {err ();}
put ("-0o: "); try {putf ("->%-0o<-\n",-4);} catch (invfmt) {err ();}
put ("-0o: "); try {putf ("->%-0o<-\n",0);} catch (invfmt) {err ();}
put ("-0o: "); try {putf ("->%-0o<-\n",4);} catch (invfmt) {err ();}
put ("#00o: "); try {putf ("->%#00o<-\n",-4);} catch (invfmt) {err ();}
put ("#00o: "); try {putf ("->%#00o<-\n",0);} catch (invfmt) {err ();}
put ("#00o: "); try {putf ("->%#00o<-\n",4);} catch (invfmt) {err ();}
put ("00o: "); try {putf ("->%00o<-\n",-4);} catch (invfmt) {err ();}
put ("00o: "); try {putf ("->%00o<-\n",0);} catch (invfmt) {err ();}
put ("00o: "); try {putf ("->%00o<-\n",4);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",-4);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",0);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",4);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",-4);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",0);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",4);} catch (invfmt) {err ();}
put ("#0- +0x: "); try {putf ("->%#0- +0x<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +0x: "); try {putf ("->%#0- +0x<-\n",0);} catch (invfmt) {err ();}
put ("#0- +0x: "); try {putf ("->%#0- +0x<-\n",4);} catch (invfmt) {err ();}
put ("0- +0x: "); try {putf ("->%0- +0x<-\n",-4);} catch (invfmt) {err ();}
put ("0- +0x: "); try {putf ("->%0- +0x<-\n",0);} catch (invfmt) {err ();}
put ("0- +0x: "); try {putf ("->%0- +0x<-\n",4);} catch (invfmt) {err ();}
put ("#- +0x: "); try {putf ("->%#- +0x<-\n",-4);} catch (invfmt) {err ();}
put ("#- +0x: "); try {putf ("->%#- +0x<-\n",0);} catch (invfmt) {err ();}
put ("#- +0x: "); try {putf ("->%#- +0x<-\n",4);} catch (invfmt) {err ();}
put ("- +0x: "); try {putf ("->%- +0x<-\n",-4);} catch (invfmt) {err ();}
put ("- +0x: "); try {putf ("->%- +0x<-\n",0);} catch (invfmt) {err ();}
put ("- +0x: "); try {putf ("->%- +0x<-\n",4);} catch (invfmt) {err ();}
put ("#0 +0x: "); try {putf ("->%#0 +0x<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +0x: "); try {putf ("->%#0 +0x<-\n",0);} catch (invfmt) {err ();}
put ("#0 +0x: "); try {putf ("->%#0 +0x<-\n",4);} catch (invfmt) {err ();}
put ("0 +0x: "); try {putf ("->%0 +0x<-\n",-4);} catch (invfmt) {err ();}
put ("0 +0x: "); try {putf ("->%0 +0x<-\n",0);} catch (invfmt) {err ();}
put ("0 +0x: "); try {putf ("->%0 +0x<-\n",4);} catch (invfmt) {err ();}
put ("# +0x: "); try {putf ("->%# +0x<-\n",-4);} catch (invfmt) {err ();}
put ("# +0x: "); try {putf ("->%# +0x<-\n",0);} catch (invfmt) {err ();}
put ("# +0x: "); try {putf ("->%# +0x<-\n",4);} catch (invfmt) {err ();}
put (" +0x: "); try {putf ("->% +0x<-\n",-4);} catch (invfmt) {err ();}
put (" +0x: "); try {putf ("->% +0x<-\n",0);} catch (invfmt) {err ();}
put (" +0x: "); try {putf ("->% +0x<-\n",4);} catch (invfmt) {err ();}
put ("#0-+0x: "); try {putf ("->%#0-+0x<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+0x: "); try {putf ("->%#0-+0x<-\n",0);} catch (invfmt) {err ();}
put ("#0-+0x: "); try {putf ("->%#0-+0x<-\n",4);} catch (invfmt) {err ();}
put ("0-+0x: "); try {putf ("->%0-+0x<-\n",-4);} catch (invfmt) {err ();}
put ("0-+0x: "); try {putf ("->%0-+0x<-\n",0);} catch (invfmt) {err ();}
put ("0-+0x: "); try {putf ("->%0-+0x<-\n",4);} catch (invfmt) {err ();}
put ("#-+0x: "); try {putf ("->%#-+0x<-\n",-4);} catch (invfmt) {err ();}
put ("#-+0x: "); try {putf ("->%#-+0x<-\n",0);} catch (invfmt) {err ();}
put ("#-+0x: "); try {putf ("->%#-+0x<-\n",4);} catch (invfmt) {err ();}
put ("-+0x: "); try {putf ("->%-+0x<-\n",-4);} catch (invfmt) {err ();}
put ("-+0x: "); try {putf ("->%-+0x<-\n",0);} catch (invfmt) {err ();}
put ("-+0x: "); try {putf ("->%-+0x<-\n",4);} catch (invfmt) {err ();}
put ("#0+0x: "); try {putf ("->%#0+0x<-\n",-4);} catch (invfmt) {err ();}
put ("#0+0x: "); try {putf ("->%#0+0x<-\n",0);} catch (invfmt) {err ();}
put ("#0+0x: "); try {putf ("->%#0+0x<-\n",4);} catch (invfmt) {err ();}
put ("0+0x: "); try {putf ("->%0+0x<-\n",-4);} catch (invfmt) {err ();}
put ("0+0x: "); try {putf ("->%0+0x<-\n",0);} catch (invfmt) {err ();}
put ("0+0x: "); try {putf ("->%0+0x<-\n",4);} catch (invfmt) {err ();}
put ("#+0x: "); try {putf ("->%#+0x<-\n",-4);} catch (invfmt) {err ();}
put ("#+0x: "); try {putf ("->%#+0x<-\n",0);} catch (invfmt) {err ();}
put ("#+0x: "); try {putf ("->%#+0x<-\n",4);} catch (invfmt) {err ();}
put ("+0x: "); try {putf ("->%+0x<-\n",-4);} catch (invfmt) {err ();}
put ("+0x: "); try {putf ("->%+0x<-\n",0);} catch (invfmt) {err ();}
put ("+0x: "); try {putf ("->%+0x<-\n",4);} catch (invfmt) {err ();}
put ("#0- 0x: "); try {putf ("->%#0- 0x<-\n",-4);} catch (invfmt) {err ();}
put ("#0- 0x: "); try {putf ("->%#0- 0x<-\n",0);} catch (invfmt) {err ();}
put ("#0- 0x: "); try {putf ("->%#0- 0x<-\n",4);} catch (invfmt) {err ();}
put ("0- 0x: "); try {putf ("->%0- 0x<-\n",-4);} catch (invfmt) {err ();}
put ("0- 0x: "); try {putf ("->%0- 0x<-\n",0);} catch (invfmt) {err ();}
put ("0- 0x: "); try {putf ("->%0- 0x<-\n",4);} catch (invfmt) {err ();}
put ("#- 0x: "); try {putf ("->%#- 0x<-\n",-4);} catch (invfmt) {err ();}
put ("#- 0x: "); try {putf ("->%#- 0x<-\n",0);} catch (invfmt) {err ();}
put ("#- 0x: "); try {putf ("->%#- 0x<-\n",4);} catch (invfmt) {err ();}
put ("- 0x: "); try {putf ("->%- 0x<-\n",-4);} catch (invfmt) {err ();}
put ("- 0x: "); try {putf ("->%- 0x<-\n",0);} catch (invfmt) {err ();}
put ("- 0x: "); try {putf ("->%- 0x<-\n",4);} catch (invfmt) {err ();}
put ("#0 0x: "); try {putf ("->%#0 0x<-\n",-4);} catch (invfmt) {err ();}
put ("#0 0x: "); try {putf ("->%#0 0x<-\n",0);} catch (invfmt) {err ();}
put ("#0 0x: "); try {putf ("->%#0 0x<-\n",4);} catch (invfmt) {err ();}
put ("0 0x: "); try {putf ("->%0 0x<-\n",-4);} catch (invfmt) {err ();}
put ("0 0x: "); try {putf ("->%0 0x<-\n",0);} catch (invfmt) {err ();}
put ("0 0x: "); try {putf ("->%0 0x<-\n",4);} catch (invfmt) {err ();}
put ("# 0x: "); try {putf ("->%# 0x<-\n",-4);} catch (invfmt) {err ();}
put ("# 0x: "); try {putf ("->%# 0x<-\n",0);} catch (invfmt) {err ();}
put ("# 0x: "); try {putf ("->%# 0x<-\n",4);} catch (invfmt) {err ();}
put (" 0x: "); try {putf ("->% 0x<-\n",-4);} catch (invfmt) {err ();}
put (" 0x: "); try {putf ("->% 0x<-\n",0);} catch (invfmt) {err ();}
put (" 0x: "); try {putf ("->% 0x<-\n",4);} catch (invfmt) {err ();}
put ("#0-0x: "); try {putf ("->%#0-0x<-\n",-4);} catch (invfmt) {err ();}
put ("#0-0x: "); try {putf ("->%#0-0x<-\n",0);} catch (invfmt) {err ();}
put ("#0-0x: "); try {putf ("->%#0-0x<-\n",4);} catch (invfmt) {err ();}
put ("0-0x: "); try {putf ("->%0-0x<-\n",-4);} catch (invfmt) {err ();}
put ("0-0x: "); try {putf ("->%0-0x<-\n",0);} catch (invfmt) {err ();}
put ("0-0x: "); try {putf ("->%0-0x<-\n",4);} catch (invfmt) {err ();}
put ("#-0x: "); try {putf ("->%#-0x<-\n",-4);} catch (invfmt) {err ();}
put ("#-0x: "); try {putf ("->%#-0x<-\n",0);} catch (invfmt) {err ();}
put ("#-0x: "); try {putf ("->%#-0x<-\n",4);} catch (invfmt) {err ();}
put ("-0x: "); try {putf ("->%-0x<-\n",-4);} catch (invfmt) {err ();}
put ("-0x: "); try {putf ("->%-0x<-\n",0);} catch (invfmt) {err ();}
put ("-0x: "); try {putf ("->%-0x<-\n",4);} catch (invfmt) {err ();}
put ("#00x: "); try {putf ("->%#00x<-\n",-4);} catch (invfmt) {err ();}
put ("#00x: "); try {putf ("->%#00x<-\n",0);} catch (invfmt) {err ();}
put ("#00x: "); try {putf ("->%#00x<-\n",4);} catch (invfmt) {err ();}
put ("00x: "); try {putf ("->%00x<-\n",-4);} catch (invfmt) {err ();}
put ("00x: "); try {putf ("->%00x<-\n",0);} catch (invfmt) {err ();}
put ("00x: "); try {putf ("->%00x<-\n",4);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",-4);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",0);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",4);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",-4);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",0);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",4);} catch (invfmt) {err ();}
put ("#0- +0X: "); try {putf ("->%#0- +0X<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +0X: "); try {putf ("->%#0- +0X<-\n",0);} catch (invfmt) {err ();}
put ("#0- +0X: "); try {putf ("->%#0- +0X<-\n",4);} catch (invfmt) {err ();}
put ("0- +0X: "); try {putf ("->%0- +0X<-\n",-4);} catch (invfmt) {err ();}
put ("0- +0X: "); try {putf ("->%0- +0X<-\n",0);} catch (invfmt) {err ();}
put ("0- +0X: "); try {putf ("->%0- +0X<-\n",4);} catch (invfmt) {err ();}
put ("#- +0X: "); try {putf ("->%#- +0X<-\n",-4);} catch (invfmt) {err ();}
put ("#- +0X: "); try {putf ("->%#- +0X<-\n",0);} catch (invfmt) {err ();}
put ("#- +0X: "); try {putf ("->%#- +0X<-\n",4);} catch (invfmt) {err ();}
put ("- +0X: "); try {putf ("->%- +0X<-\n",-4);} catch (invfmt) {err ();}
put ("- +0X: "); try {putf ("->%- +0X<-\n",0);} catch (invfmt) {err ();}
put ("- +0X: "); try {putf ("->%- +0X<-\n",4);} catch (invfmt) {err ();}
put ("#0 +0X: "); try {putf ("->%#0 +0X<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +0X: "); try {putf ("->%#0 +0X<-\n",0);} catch (invfmt) {err ();}
put ("#0 +0X: "); try {putf ("->%#0 +0X<-\n",4);} catch (invfmt) {err ();}
put ("0 +0X: "); try {putf ("->%0 +0X<-\n",-4);} catch (invfmt) {err ();}
put ("0 +0X: "); try {putf ("->%0 +0X<-\n",0);} catch (invfmt) {err ();}
put ("0 +0X: "); try {putf ("->%0 +0X<-\n",4);} catch (invfmt) {err ();}
put ("# +0X: "); try {putf ("->%# +0X<-\n",-4);} catch (invfmt) {err ();}
put ("# +0X: "); try {putf ("->%# +0X<-\n",0);} catch (invfmt) {err ();}
put ("# +0X: "); try {putf ("->%# +0X<-\n",4);} catch (invfmt) {err ();}
put (" +0X: "); try {putf ("->% +0X<-\n",-4);} catch (invfmt) {err ();}
put (" +0X: "); try {putf ("->% +0X<-\n",0);} catch (invfmt) {err ();}
put (" +0X: "); try {putf ("->% +0X<-\n",4);} catch (invfmt) {err ();}
put ("#0-+0X: "); try {putf ("->%#0-+0X<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+0X: "); try {putf ("->%#0-+0X<-\n",0);} catch (invfmt) {err ();}
put ("#0-+0X: "); try {putf ("->%#0-+0X<-\n",4);} catch (invfmt) {err ();}
put ("0-+0X: "); try {putf ("->%0-+0X<-\n",-4);} catch (invfmt) {err ();}
put ("0-+0X: "); try {putf ("->%0-+0X<-\n",0);} catch (invfmt) {err ();}
put ("0-+0X: "); try {putf ("->%0-+0X<-\n",4);} catch (invfmt) {err ();}
put ("#-+0X: "); try {putf ("->%#-+0X<-\n",-4);} catch (invfmt) {err ();}
put ("#-+0X: "); try {putf ("->%#-+0X<-\n",0);} catch (invfmt) {err ();}
put ("#-+0X: "); try {putf ("->%#-+0X<-\n",4);} catch (invfmt) {err ();}
put ("-+0X: "); try {putf ("->%-+0X<-\n",-4);} catch (invfmt) {err ();}
put ("-+0X: "); try {putf ("->%-+0X<-\n",0);} catch (invfmt) {err ();}
put ("-+0X: "); try {putf ("->%-+0X<-\n",4);} catch (invfmt) {err ();}
put ("#0+0X: "); try {putf ("->%#0+0X<-\n",-4);} catch (invfmt) {err ();}
put ("#0+0X: "); try {putf ("->%#0+0X<-\n",0);} catch (invfmt) {err ();}
put ("#0+0X: "); try {putf ("->%#0+0X<-\n",4);} catch (invfmt) {err ();}
put ("0+0X: "); try {putf ("->%0+0X<-\n",-4);} catch (invfmt) {err ();}
put ("0+0X: "); try {putf ("->%0+0X<-\n",0);} catch (invfmt) {err ();}
put ("0+0X: "); try {putf ("->%0+0X<-\n",4);} catch (invfmt) {err ();}
put ("#+0X: "); try {putf ("->%#+0X<-\n",-4);} catch (invfmt) {err ();}
put ("#+0X: "); try {putf ("->%#+0X<-\n",0);} catch (invfmt) {err ();}
put ("#+0X: "); try {putf ("->%#+0X<-\n",4);} catch (invfmt) {err ();}
put ("+0X: "); try {putf ("->%+0X<-\n",-4);} catch (invfmt) {err ();}
put ("+0X: "); try {putf ("->%+0X<-\n",0);} catch (invfmt) {err ();}
put ("+0X: "); try {putf ("->%+0X<-\n",4);} catch (invfmt) {err ();}
put ("#0- 0X: "); try {putf ("->%#0- 0X<-\n",-4);} catch (invfmt) {err ();}
put ("#0- 0X: "); try {putf ("->%#0- 0X<-\n",0);} catch (invfmt) {err ();}
put ("#0- 0X: "); try {putf ("->%#0- 0X<-\n",4);} catch (invfmt) {err ();}
put ("0- 0X: "); try {putf ("->%0- 0X<-\n",-4);} catch (invfmt) {err ();}
put ("0- 0X: "); try {putf ("->%0- 0X<-\n",0);} catch (invfmt) {err ();}
put ("0- 0X: "); try {putf ("->%0- 0X<-\n",4);} catch (invfmt) {err ();}
put ("#- 0X: "); try {putf ("->%#- 0X<-\n",-4);} catch (invfmt) {err ();}
put ("#- 0X: "); try {putf ("->%#- 0X<-\n",0);} catch (invfmt) {err ();}
put ("#- 0X: "); try {putf ("->%#- 0X<-\n",4);} catch (invfmt) {err ();}
put ("- 0X: "); try {putf ("->%- 0X<-\n",-4);} catch (invfmt) {err ();}
put ("- 0X: "); try {putf ("->%- 0X<-\n",0);} catch (invfmt) {err ();}
put ("- 0X: "); try {putf ("->%- 0X<-\n",4);} catch (invfmt) {err ();}
put ("#0 0X: "); try {putf ("->%#0 0X<-\n",-4);} catch (invfmt) {err ();}
put ("#0 0X: "); try {putf ("->%#0 0X<-\n",0);} catch (invfmt) {err ();}
put ("#0 0X: "); try {putf ("->%#0 0X<-\n",4);} catch (invfmt) {err ();}
put ("0 0X: "); try {putf ("->%0 0X<-\n",-4);} catch (invfmt) {err ();}
put ("0 0X: "); try {putf ("->%0 0X<-\n",0);} catch (invfmt) {err ();}
put ("0 0X: "); try {putf ("->%0 0X<-\n",4);} catch (invfmt) {err ();}
put ("# 0X: "); try {putf ("->%# 0X<-\n",-4);} catch (invfmt) {err ();}
put ("# 0X: "); try {putf ("->%# 0X<-\n",0);} catch (invfmt) {err ();}
put ("# 0X: "); try {putf ("->%# 0X<-\n",4);} catch (invfmt) {err ();}
put (" 0X: "); try {putf ("->% 0X<-\n",-4);} catch (invfmt) {err ();}
put (" 0X: "); try {putf ("->% 0X<-\n",0);} catch (invfmt) {err ();}
put (" 0X: "); try {putf ("->% 0X<-\n",4);} catch (invfmt) {err ();}
put ("#0-0X: "); try {putf ("->%#0-0X<-\n",-4);} catch (invfmt) {err ();}
put ("#0-0X: "); try {putf ("->%#0-0X<-\n",0);} catch (invfmt) {err ();}
put ("#0-0X: "); try {putf ("->%#0-0X<-\n",4);} catch (invfmt) {err ();}
put ("0-0X: "); try {putf ("->%0-0X<-\n",-4);} catch (invfmt) {err ();}
put ("0-0X: "); try {putf ("->%0-0X<-\n",0);} catch (invfmt) {err ();}
put ("0-0X: "); try {putf ("->%0-0X<-\n",4);} catch (invfmt) {err ();}
put ("#-0X: "); try {putf ("->%#-0X<-\n",-4);} catch (invfmt) {err ();}
put ("#-0X: "); try {putf ("->%#-0X<-\n",0);} catch (invfmt) {err ();}
put ("#-0X: "); try {putf ("->%#-0X<-\n",4);} catch (invfmt) {err ();}
put ("-0X: "); try {putf ("->%-0X<-\n",-4);} catch (invfmt) {err ();}
put ("-0X: "); try {putf ("->%-0X<-\n",0);} catch (invfmt) {err ();}
put ("-0X: "); try {putf ("->%-0X<-\n",4);} catch (invfmt) {err ();}
put ("#00X: "); try {putf ("->%#00X<-\n",-4);} catch (invfmt) {err ();}
put ("#00X: "); try {putf ("->%#00X<-\n",0);} catch (invfmt) {err ();}
put ("#00X: "); try {putf ("->%#00X<-\n",4);} catch (invfmt) {err ();}
put ("00X: "); try {putf ("->%00X<-\n",-4);} catch (invfmt) {err ();}
put ("00X: "); try {putf ("->%00X<-\n",0);} catch (invfmt) {err ();}
put ("00X: "); try {putf ("->%00X<-\n",4);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",-4);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",0);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",4);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",-4);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",0);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",4);} catch (invfmt) {err ();}
put ("#0- +20d: "); try {putf ("->%#0- +20d<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +20d: "); try {putf ("->%#0- +20d<-\n",0);} catch (invfmt) {err ();}
put ("#0- +20d: "); try {putf ("->%#0- +20d<-\n",4);} catch (invfmt) {err ();}
put ("0- +20d: "); try {putf ("->%0- +20d<-\n",-4);} catch (invfmt) {err ();}
put ("0- +20d: "); try {putf ("->%0- +20d<-\n",0);} catch (invfmt) {err ();}
put ("0- +20d: "); try {putf ("->%0- +20d<-\n",4);} catch (invfmt) {err ();}
put ("#- +20d: "); try {putf ("->%#- +20d<-\n",-4);} catch (invfmt) {err ();}
put ("#- +20d: "); try {putf ("->%#- +20d<-\n",0);} catch (invfmt) {err ();}
put ("#- +20d: "); try {putf ("->%#- +20d<-\n",4);} catch (invfmt) {err ();}
put ("- +20d: "); try {putf ("->%- +20d<-\n",-4);} catch (invfmt) {err ();}
put ("- +20d: "); try {putf ("->%- +20d<-\n",0);} catch (invfmt) {err ();}
put ("- +20d: "); try {putf ("->%- +20d<-\n",4);} catch (invfmt) {err ();}
put ("#0 +20d: "); try {putf ("->%#0 +20d<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +20d: "); try {putf ("->%#0 +20d<-\n",0);} catch (invfmt) {err ();}
put ("#0 +20d: "); try {putf ("->%#0 +20d<-\n",4);} catch (invfmt) {err ();}
put ("0 +20d: "); try {putf ("->%0 +20d<-\n",-4);} catch (invfmt) {err ();}
put ("0 +20d: "); try {putf ("->%0 +20d<-\n",0);} catch (invfmt) {err ();}
put ("0 +20d: "); try {putf ("->%0 +20d<-\n",4);} catch (invfmt) {err ();}
put ("# +20d: "); try {putf ("->%# +20d<-\n",-4);} catch (invfmt) {err ();}
put ("# +20d: "); try {putf ("->%# +20d<-\n",0);} catch (invfmt) {err ();}
put ("# +20d: "); try {putf ("->%# +20d<-\n",4);} catch (invfmt) {err ();}
put (" +20d: "); try {putf ("->% +20d<-\n",-4);} catch (invfmt) {err ();}
put (" +20d: "); try {putf ("->% +20d<-\n",0);} catch (invfmt) {err ();}
put (" +20d: "); try {putf ("->% +20d<-\n",4);} catch (invfmt) {err ();}
put ("#0-+20d: "); try {putf ("->%#0-+20d<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+20d: "); try {putf ("->%#0-+20d<-\n",0);} catch (invfmt) {err ();}
put ("#0-+20d: "); try {putf ("->%#0-+20d<-\n",4);} catch (invfmt) {err ();}
put ("0-+20d: "); try {putf ("->%0-+20d<-\n",-4);} catch (invfmt) {err ();}
put ("0-+20d: "); try {putf ("->%0-+20d<-\n",0);} catch (invfmt) {err ();}
put ("0-+20d: "); try {putf ("->%0-+20d<-\n",4);} catch (invfmt) {err ();}
put ("#-+20d: "); try {putf ("->%#-+20d<-\n",-4);} catch (invfmt) {err ();}
put ("#-+20d: "); try {putf ("->%#-+20d<-\n",0);} catch (invfmt) {err ();}
put ("#-+20d: "); try {putf ("->%#-+20d<-\n",4);} catch (invfmt) {err ();}
put ("-+20d: "); try {putf ("->%-+20d<-\n",-4);} catch (invfmt) {err ();}
put ("-+20d: "); try {putf ("->%-+20d<-\n",0);} catch (invfmt) {err ();}
put ("-+20d: "); try {putf ("->%-+20d<-\n",4);} catch (invfmt) {err ();}
put ("#0+20d: "); try {putf ("->%#0+20d<-\n",-4);} catch (invfmt) {err ();}
put ("#0+20d: "); try {putf ("->%#0+20d<-\n",0);} catch (invfmt) {err ();}
put ("#0+20d: "); try {putf ("->%#0+20d<-\n",4);} catch (invfmt) {err ();}
put ("0+20d: "); try {putf ("->%0+20d<-\n",-4);} catch (invfmt) {err ();}
put ("0+20d: "); try {putf ("->%0+20d<-\n",0);} catch (invfmt) {err ();}
put ("0+20d: "); try {putf ("->%0+20d<-\n",4);} catch (invfmt) {err ();}
put ("#+20d: "); try {putf ("->%#+20d<-\n",-4);} catch (invfmt) {err ();}
put ("#+20d: "); try {putf ("->%#+20d<-\n",0);} catch (invfmt) {err ();}
put ("#+20d: "); try {putf ("->%#+20d<-\n",4);} catch (invfmt) {err ();}
put ("+20d: "); try {putf ("->%+20d<-\n",-4);} catch (invfmt) {err ();}
put ("+20d: "); try {putf ("->%+20d<-\n",0);} catch (invfmt) {err ();}
put ("+20d: "); try {putf ("->%+20d<-\n",4);} catch (invfmt) {err ();}
put ("#0- 20d: "); try {putf ("->%#0- 20d<-\n",-4);} catch (invfmt) {err ();}
put ("#0- 20d: "); try {putf ("->%#0- 20d<-\n",0);} catch (invfmt) {err ();}
put ("#0- 20d: "); try {putf ("->%#0- 20d<-\n",4);} catch (invfmt) {err ();}
put ("0- 20d: "); try {putf ("->%0- 20d<-\n",-4);} catch (invfmt) {err ();}
put ("0- 20d: "); try {putf ("->%0- 20d<-\n",0);} catch (invfmt) {err ();}
put ("0- 20d: "); try {putf ("->%0- 20d<-\n",4);} catch (invfmt) {err ();}
put ("#- 20d: "); try {putf ("->%#- 20d<-\n",-4);} catch (invfmt) {err ();}
put ("#- 20d: "); try {putf ("->%#- 20d<-\n",0);} catch (invfmt) {err ();}
put ("#- 20d: "); try {putf ("->%#- 20d<-\n",4);} catch (invfmt) {err ();}
put ("- 20d: "); try {putf ("->%- 20d<-\n",-4);} catch (invfmt) {err ();}
put ("- 20d: "); try {putf ("->%- 20d<-\n",0);} catch (invfmt) {err ();}
put ("- 20d: "); try {putf ("->%- 20d<-\n",4);} catch (invfmt) {err ();}
put ("#0 20d: "); try {putf ("->%#0 20d<-\n",-4);} catch (invfmt) {err ();}
put ("#0 20d: "); try {putf ("->%#0 20d<-\n",0);} catch (invfmt) {err ();}
put ("#0 20d: "); try {putf ("->%#0 20d<-\n",4);} catch (invfmt) {err ();}
put ("0 20d: "); try {putf ("->%0 20d<-\n",-4);} catch (invfmt) {err ();}
put ("0 20d: "); try {putf ("->%0 20d<-\n",0);} catch (invfmt) {err ();}
put ("0 20d: "); try {putf ("->%0 20d<-\n",4);} catch (invfmt) {err ();}
put ("# 20d: "); try {putf ("->%# 20d<-\n",-4);} catch (invfmt) {err ();}
put ("# 20d: "); try {putf ("->%# 20d<-\n",0);} catch (invfmt) {err ();}
put ("# 20d: "); try {putf ("->%# 20d<-\n",4);} catch (invfmt) {err ();}
put (" 20d: "); try {putf ("->% 20d<-\n",-4);} catch (invfmt) {err ();}
put (" 20d: "); try {putf ("->% 20d<-\n",0);} catch (invfmt) {err ();}
put (" 20d: "); try {putf ("->% 20d<-\n",4);} catch (invfmt) {err ();}
put ("#0-20d: "); try {putf ("->%#0-20d<-\n",-4);} catch (invfmt) {err ();}
put ("#0-20d: "); try {putf ("->%#0-20d<-\n",0);} catch (invfmt) {err ();}
put ("#0-20d: "); try {putf ("->%#0-20d<-\n",4);} catch (invfmt) {err ();}
put ("0-20d: "); try {putf ("->%0-20d<-\n",-4);} catch (invfmt) {err ();}
put ("0-20d: "); try {putf ("->%0-20d<-\n",0);} catch (invfmt) {err ();}
put ("0-20d: "); try {putf ("->%0-20d<-\n",4);} catch (invfmt) {err ();}
put ("#-20d: "); try {putf ("->%#-20d<-\n",-4);} catch (invfmt) {err ();}
put ("#-20d: "); try {putf ("->%#-20d<-\n",0);} catch (invfmt) {err ();}
put ("#-20d: "); try {putf ("->%#-20d<-\n",4);} catch (invfmt) {err ();}
put ("-20d: "); try {putf ("->%-20d<-\n",-4);} catch (invfmt) {err ();}
put ("-20d: "); try {putf ("->%-20d<-\n",0);} catch (invfmt) {err ();}
put ("-20d: "); try {putf ("->%-20d<-\n",4);} catch (invfmt) {err ();}
put ("#020d: "); try {putf ("->%#020d<-\n",-4);} catch (invfmt) {err ();}
put ("#020d: "); try {putf ("->%#020d<-\n",0);} catch (invfmt) {err ();}
put ("#020d: "); try {putf ("->%#020d<-\n",4);} catch (invfmt) {err ();}
put ("020d: "); try {putf ("->%020d<-\n",-4);} catch (invfmt) {err ();}
put ("020d: "); try {putf ("->%020d<-\n",0);} catch (invfmt) {err ();}
put ("020d: "); try {putf ("->%020d<-\n",4);} catch (invfmt) {err ();}
put ("#20d: "); try {putf ("->%#20d<-\n",-4);} catch (invfmt) {err ();}
put ("#20d: "); try {putf ("->%#20d<-\n",0);} catch (invfmt) {err ();}
put ("#20d: "); try {putf ("->%#20d<-\n",4);} catch (invfmt) {err ();}
put ("20d: "); try {putf ("->%20d<-\n",-4);} catch (invfmt) {err ();}
put ("20d: "); try {putf ("->%20d<-\n",0);} catch (invfmt) {err ();}
put ("20d: "); try {putf ("->%20d<-\n",4);} catch (invfmt) {err ();}
put ("#0- +20o: "); try {putf ("->%#0- +20o<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +20o: "); try {putf ("->%#0- +20o<-\n",0);} catch (invfmt) {err ();}
put ("#0- +20o: "); try {putf ("->%#0- +20o<-\n",4);} catch (invfmt) {err ();}
put ("0- +20o: "); try {putf ("->%0- +20o<-\n",-4);} catch (invfmt) {err ();}
put ("0- +20o: "); try {putf ("->%0- +20o<-\n",0);} catch (invfmt) {err ();}
put ("0- +20o: "); try {putf ("->%0- +20o<-\n",4);} catch (invfmt) {err ();}
put ("#- +20o: "); try {putf ("->%#- +20o<-\n",-4);} catch (invfmt) {err ();}
put ("#- +20o: "); try {putf ("->%#- +20o<-\n",0);} catch (invfmt) {err ();}
put ("#- +20o: "); try {putf ("->%#- +20o<-\n",4);} catch (invfmt) {err ();}
put ("- +20o: "); try {putf ("->%- +20o<-\n",-4);} catch (invfmt) {err ();}
put ("- +20o: "); try {putf ("->%- +20o<-\n",0);} catch (invfmt) {err ();}
put ("- +20o: "); try {putf ("->%- +20o<-\n",4);} catch (invfmt) {err ();}
put ("#0 +20o: "); try {putf ("->%#0 +20o<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +20o: "); try {putf ("->%#0 +20o<-\n",0);} catch (invfmt) {err ();}
put ("#0 +20o: "); try {putf ("->%#0 +20o<-\n",4);} catch (invfmt) {err ();}
put ("0 +20o: "); try {putf ("->%0 +20o<-\n",-4);} catch (invfmt) {err ();}
put ("0 +20o: "); try {putf ("->%0 +20o<-\n",0);} catch (invfmt) {err ();}
put ("0 +20o: "); try {putf ("->%0 +20o<-\n",4);} catch (invfmt) {err ();}
put ("# +20o: "); try {putf ("->%# +20o<-\n",-4);} catch (invfmt) {err ();}
put ("# +20o: "); try {putf ("->%# +20o<-\n",0);} catch (invfmt) {err ();}
put ("# +20o: "); try {putf ("->%# +20o<-\n",4);} catch (invfmt) {err ();}
put (" +20o: "); try {putf ("->% +20o<-\n",-4);} catch (invfmt) {err ();}
put (" +20o: "); try {putf ("->% +20o<-\n",0);} catch (invfmt) {err ();}
put (" +20o: "); try {putf ("->% +20o<-\n",4);} catch (invfmt) {err ();}
put ("#0-+20o: "); try {putf ("->%#0-+20o<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+20o: "); try {putf ("->%#0-+20o<-\n",0);} catch (invfmt) {err ();}
put ("#0-+20o: "); try {putf ("->%#0-+20o<-\n",4);} catch (invfmt) {err ();}
put ("0-+20o: "); try {putf ("->%0-+20o<-\n",-4);} catch (invfmt) {err ();}
put ("0-+20o: "); try {putf ("->%0-+20o<-\n",0);} catch (invfmt) {err ();}
put ("0-+20o: "); try {putf ("->%0-+20o<-\n",4);} catch (invfmt) {err ();}
put ("#-+20o: "); try {putf ("->%#-+20o<-\n",-4);} catch (invfmt) {err ();}
put ("#-+20o: "); try {putf ("->%#-+20o<-\n",0);} catch (invfmt) {err ();}
put ("#-+20o: "); try {putf ("->%#-+20o<-\n",4);} catch (invfmt) {err ();}
put ("-+20o: "); try {putf ("->%-+20o<-\n",-4);} catch (invfmt) {err ();}
put ("-+20o: "); try {putf ("->%-+20o<-\n",0);} catch (invfmt) {err ();}
put ("-+20o: "); try {putf ("->%-+20o<-\n",4);} catch (invfmt) {err ();}
put ("#0+20o: "); try {putf ("->%#0+20o<-\n",-4);} catch (invfmt) {err ();}
put ("#0+20o: "); try {putf ("->%#0+20o<-\n",0);} catch (invfmt) {err ();}
put ("#0+20o: "); try {putf ("->%#0+20o<-\n",4);} catch (invfmt) {err ();}
put ("0+20o: "); try {putf ("->%0+20o<-\n",-4);} catch (invfmt) {err ();}
put ("0+20o: "); try {putf ("->%0+20o<-\n",0);} catch (invfmt) {err ();}
put ("0+20o: "); try {putf ("->%0+20o<-\n",4);} catch (invfmt) {err ();}
put ("#+20o: "); try {putf ("->%#+20o<-\n",-4);} catch (invfmt) {err ();}
put ("#+20o: "); try {putf ("->%#+20o<-\n",0);} catch (invfmt) {err ();}
put ("#+20o: "); try {putf ("->%#+20o<-\n",4);} catch (invfmt) {err ();}
put ("+20o: "); try {putf ("->%+20o<-\n",-4);} catch (invfmt) {err ();}
put ("+20o: "); try {putf ("->%+20o<-\n",0);} catch (invfmt) {err ();}
put ("+20o: "); try {putf ("->%+20o<-\n",4);} catch (invfmt) {err ();}
put ("#0- 20o: "); try {putf ("->%#0- 20o<-\n",-4);} catch (invfmt) {err ();}
put ("#0- 20o: "); try {putf ("->%#0- 20o<-\n",0);} catch (invfmt) {err ();}
put ("#0- 20o: "); try {putf ("->%#0- 20o<-\n",4);} catch (invfmt) {err ();}
put ("0- 20o: "); try {putf ("->%0- 20o<-\n",-4);} catch (invfmt) {err ();}
put ("0- 20o: "); try {putf ("->%0- 20o<-\n",0);} catch (invfmt) {err ();}
put ("0- 20o: "); try {putf ("->%0- 20o<-\n",4);} catch (invfmt) {err ();}
put ("#- 20o: "); try {putf ("->%#- 20o<-\n",-4);} catch (invfmt) {err ();}
put ("#- 20o: "); try {putf ("->%#- 20o<-\n",0);} catch (invfmt) {err ();}
put ("#- 20o: "); try {putf ("->%#- 20o<-\n",4);} catch (invfmt) {err ();}
put ("- 20o: "); try {putf ("->%- 20o<-\n",-4);} catch (invfmt) {err ();}
put ("- 20o: "); try {putf ("->%- 20o<-\n",0);} catch (invfmt) {err ();}
put ("- 20o: "); try {putf ("->%- 20o<-\n",4);} catch (invfmt) {err ();}
put ("#0 20o: "); try {putf ("->%#0 20o<-\n",-4);} catch (invfmt) {err ();}
put ("#0 20o: "); try {putf ("->%#0 20o<-\n",0);} catch (invfmt) {err ();}
put ("#0 20o: "); try {putf ("->%#0 20o<-\n",4);} catch (invfmt) {err ();}
put ("0 20o: "); try {putf ("->%0 20o<-\n",-4);} catch (invfmt) {err ();}
put ("0 20o: "); try {putf ("->%0 20o<-\n",0);} catch (invfmt) {err ();}
put ("0 20o: "); try {putf ("->%0 20o<-\n",4);} catch (invfmt) {err ();}
put ("# 20o: "); try {putf ("->%# 20o<-\n",-4);} catch (invfmt) {err ();}
put ("# 20o: "); try {putf ("->%# 20o<-\n",0);} catch (invfmt) {err ();}
put ("# 20o: "); try {putf ("->%# 20o<-\n",4);} catch (invfmt) {err ();}
put (" 20o: "); try {putf ("->% 20o<-\n",-4);} catch (invfmt) {err ();}
put (" 20o: "); try {putf ("->% 20o<-\n",0);} catch (invfmt) {err ();}
put (" 20o: "); try {putf ("->% 20o<-\n",4);} catch (invfmt) {err ();}
put ("#0-20o: "); try {putf ("->%#0-20o<-\n",-4);} catch (invfmt) {err ();}
put ("#0-20o: "); try {putf ("->%#0-20o<-\n",0);} catch (invfmt) {err ();}
put ("#0-20o: "); try {putf ("->%#0-20o<-\n",4);} catch (invfmt) {err ();}
put ("0-20o: "); try {putf ("->%0-20o<-\n",-4);} catch (invfmt) {err ();}
put ("0-20o: "); try {putf ("->%0-20o<-\n",0);} catch (invfmt) {err ();}
put ("0-20o: "); try {putf ("->%0-20o<-\n",4);} catch (invfmt) {err ();}
put ("#-20o: "); try {putf ("->%#-20o<-\n",-4);} catch (invfmt) {err ();}
put ("#-20o: "); try {putf ("->%#-20o<-\n",0);} catch (invfmt) {err ();}
put ("#-20o: "); try {putf ("->%#-20o<-\n",4);} catch (invfmt) {err ();}
put ("-20o: "); try {putf ("->%-20o<-\n",-4);} catch (invfmt) {err ();}
put ("-20o: "); try {putf ("->%-20o<-\n",0);} catch (invfmt) {err ();}
put ("-20o: "); try {putf ("->%-20o<-\n",4);} catch (invfmt) {err ();}
put ("#020o: "); try {putf ("->%#020o<-\n",-4);} catch (invfmt) {err ();}
put ("#020o: "); try {putf ("->%#020o<-\n",0);} catch (invfmt) {err ();}
put ("#020o: "); try {putf ("->%#020o<-\n",4);} catch (invfmt) {err ();}
put ("020o: "); try {putf ("->%020o<-\n",-4);} catch (invfmt) {err ();}
put ("020o: "); try {putf ("->%020o<-\n",0);} catch (invfmt) {err ();}
put ("020o: "); try {putf ("->%020o<-\n",4);} catch (invfmt) {err ();}
put ("#20o: "); try {putf ("->%#20o<-\n",-4);} catch (invfmt) {err ();}
put ("#20o: "); try {putf ("->%#20o<-\n",0);} catch (invfmt) {err ();}
put ("#20o: "); try {putf ("->%#20o<-\n",4);} catch (invfmt) {err ();}
put ("20o: "); try {putf ("->%20o<-\n",-4);} catch (invfmt) {err ();}
put ("20o: "); try {putf ("->%20o<-\n",0);} catch (invfmt) {err ();}
put ("20o: "); try {putf ("->%20o<-\n",4);} catch (invfmt) {err ();}
put ("#0- +20x: "); try {putf ("->%#0- +20x<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +20x: "); try {putf ("->%#0- +20x<-\n",0);} catch (invfmt) {err ();}
put ("#0- +20x: "); try {putf ("->%#0- +20x<-\n",4);} catch (invfmt) {err ();}
put ("0- +20x: "); try {putf ("->%0- +20x<-\n",-4);} catch (invfmt) {err ();}
put ("0- +20x: "); try {putf ("->%0- +20x<-\n",0);} catch (invfmt) {err ();}
put ("0- +20x: "); try {putf ("->%0- +20x<-\n",4);} catch (invfmt) {err ();}
put ("#- +20x: "); try {putf ("->%#- +20x<-\n",-4);} catch (invfmt) {err ();}
put ("#- +20x: "); try {putf ("->%#- +20x<-\n",0);} catch (invfmt) {err ();}
put ("#- +20x: "); try {putf ("->%#- +20x<-\n",4);} catch (invfmt) {err ();}
put ("- +20x: "); try {putf ("->%- +20x<-\n",-4);} catch (invfmt) {err ();}
put ("- +20x: "); try {putf ("->%- +20x<-\n",0);} catch (invfmt) {err ();}
put ("- +20x: "); try {putf ("->%- +20x<-\n",4);} catch (invfmt) {err ();}
put ("#0 +20x: "); try {putf ("->%#0 +20x<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +20x: "); try {putf ("->%#0 +20x<-\n",0);} catch (invfmt) {err ();}
put ("#0 +20x: "); try {putf ("->%#0 +20x<-\n",4);} catch (invfmt) {err ();}
put ("0 +20x: "); try {putf ("->%0 +20x<-\n",-4);} catch (invfmt) {err ();}
put ("0 +20x: "); try {putf ("->%0 +20x<-\n",0);} catch (invfmt) {err ();}
put ("0 +20x: "); try {putf ("->%0 +20x<-\n",4);} catch (invfmt) {err ();}
put ("# +20x: "); try {putf ("->%# +20x<-\n",-4);} catch (invfmt) {err ();}
put ("# +20x: "); try {putf ("->%# +20x<-\n",0);} catch (invfmt) {err ();}
put ("# +20x: "); try {putf ("->%# +20x<-\n",4);} catch (invfmt) {err ();}
put (" +20x: "); try {putf ("->% +20x<-\n",-4);} catch (invfmt) {err ();}
put (" +20x: "); try {putf ("->% +20x<-\n",0);} catch (invfmt) {err ();}
put (" +20x: "); try {putf ("->% +20x<-\n",4);} catch (invfmt) {err ();}
put ("#0-+20x: "); try {putf ("->%#0-+20x<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+20x: "); try {putf ("->%#0-+20x<-\n",0);} catch (invfmt) {err ();}
put ("#0-+20x: "); try {putf ("->%#0-+20x<-\n",4);} catch (invfmt) {err ();}
put ("0-+20x: "); try {putf ("->%0-+20x<-\n",-4);} catch (invfmt) {err ();}
put ("0-+20x: "); try {putf ("->%0-+20x<-\n",0);} catch (invfmt) {err ();}
put ("0-+20x: "); try {putf ("->%0-+20x<-\n",4);} catch (invfmt) {err ();}
put ("#-+20x: "); try {putf ("->%#-+20x<-\n",-4);} catch (invfmt) {err ();}
put ("#-+20x: "); try {putf ("->%#-+20x<-\n",0);} catch (invfmt) {err ();}
put ("#-+20x: "); try {putf ("->%#-+20x<-\n",4);} catch (invfmt) {err ();}
put ("-+20x: "); try {putf ("->%-+20x<-\n",-4);} catch (invfmt) {err ();}
put ("-+20x: "); try {putf ("->%-+20x<-\n",0);} catch (invfmt) {err ();}
put ("-+20x: "); try {putf ("->%-+20x<-\n",4);} catch (invfmt) {err ();}
put ("#0+20x: "); try {putf ("->%#0+20x<-\n",-4);} catch (invfmt) {err ();}
put ("#0+20x: "); try {putf ("->%#0+20x<-\n",0);} catch (invfmt) {err ();}
put ("#0+20x: "); try {putf ("->%#0+20x<-\n",4);} catch (invfmt) {err ();}
put ("0+20x: "); try {putf ("->%0+20x<-\n",-4);} catch (invfmt) {err ();}
put ("0+20x: "); try {putf ("->%0+20x<-\n",0);} catch (invfmt) {err ();}
put ("0+20x: "); try {putf ("->%0+20x<-\n",4);} catch (invfmt) {err ();}
put ("#+20x: "); try {putf ("->%#+20x<-\n",-4);} catch (invfmt) {err ();}
put ("#+20x: "); try {putf ("->%#+20x<-\n",0);} catch (invfmt) {err ();}
put ("#+20x: "); try {putf ("->%#+20x<-\n",4);} catch (invfmt) {err ();}
put ("+20x: "); try {putf ("->%+20x<-\n",-4);} catch (invfmt) {err ();}
put ("+20x: "); try {putf ("->%+20x<-\n",0);} catch (invfmt) {err ();}
put ("+20x: "); try {putf ("->%+20x<-\n",4);} catch (invfmt) {err ();}
put ("#0- 20x: "); try {putf ("->%#0- 20x<-\n",-4);} catch (invfmt) {err ();}
put ("#0- 20x: "); try {putf ("->%#0- 20x<-\n",0);} catch (invfmt) {err ();}
put ("#0- 20x: "); try {putf ("->%#0- 20x<-\n",4);} catch (invfmt) {err ();}
put ("0- 20x: "); try {putf ("->%0- 20x<-\n",-4);} catch (invfmt) {err ();}
put ("0- 20x: "); try {putf ("->%0- 20x<-\n",0);} catch (invfmt) {err ();}
put ("0- 20x: "); try {putf ("->%0- 20x<-\n",4);} catch (invfmt) {err ();}
put ("#- 20x: "); try {putf ("->%#- 20x<-\n",-4);} catch (invfmt) {err ();}
put ("#- 20x: "); try {putf ("->%#- 20x<-\n",0);} catch (invfmt) {err ();}
put ("#- 20x: "); try {putf ("->%#- 20x<-\n",4);} catch (invfmt) {err ();}
put ("- 20x: "); try {putf ("->%- 20x<-\n",-4);} catch (invfmt) {err ();}
put ("- 20x: "); try {putf ("->%- 20x<-\n",0);} catch (invfmt) {err ();}
put ("- 20x: "); try {putf ("->%- 20x<-\n",4);} catch (invfmt) {err ();}
put ("#0 20x: "); try {putf ("->%#0 20x<-\n",-4);} catch (invfmt) {err ();}
put ("#0 20x: "); try {putf ("->%#0 20x<-\n",0);} catch (invfmt) {err ();}
put ("#0 20x: "); try {putf ("->%#0 20x<-\n",4);} catch (invfmt) {err ();}
put ("0 20x: "); try {putf ("->%0 20x<-\n",-4);} catch (invfmt) {err ();}
put ("0 20x: "); try {putf ("->%0 20x<-\n",0);} catch (invfmt) {err ();}
put ("0 20x: "); try {putf ("->%0 20x<-\n",4);} catch (invfmt) {err ();}
put ("# 20x: "); try {putf ("->%# 20x<-\n",-4);} catch (invfmt) {err ();}
put ("# 20x: "); try {putf ("->%# 20x<-\n",0);} catch (invfmt) {err ();}
put ("# 20x: "); try {putf ("->%# 20x<-\n",4);} catch (invfmt) {err ();}
put (" 20x: "); try {putf ("->% 20x<-\n",-4);} catch (invfmt) {err ();}
put (" 20x: "); try {putf ("->% 20x<-\n",0);} catch (invfmt) {err ();}
put (" 20x: "); try {putf ("->% 20x<-\n",4);} catch (invfmt) {err ();}
put ("#0-20x: "); try {putf ("->%#0-20x<-\n",-4);} catch (invfmt) {err ();}
put ("#0-20x: "); try {putf ("->%#0-20x<-\n",0);} catch (invfmt) {err ();}
put ("#0-20x: "); try {putf ("->%#0-20x<-\n",4);} catch (invfmt) {err ();}
put ("0-20x: "); try {putf ("->%0-20x<-\n",-4);} catch (invfmt) {err ();}
put ("0-20x: "); try {putf ("->%0-20x<-\n",0);} catch (invfmt) {err ();}
put ("0-20x: "); try {putf ("->%0-20x<-\n",4);} catch (invfmt) {err ();}
put ("#-20x: "); try {putf ("->%#-20x<-\n",-4);} catch (invfmt) {err ();}
put ("#-20x: "); try {putf ("->%#-20x<-\n",0);} catch (invfmt) {err ();}
put ("#-20x: "); try {putf ("->%#-20x<-\n",4);} catch (invfmt) {err ();}
put ("-20x: "); try {putf ("->%-20x<-\n",-4);} catch (invfmt) {err ();}
put ("-20x: "); try {putf ("->%-20x<-\n",0);} catch (invfmt) {err ();}
put ("-20x: "); try {putf ("->%-20x<-\n",4);} catch (invfmt) {err ();}
put ("#020x: "); try {putf ("->%#020x<-\n",-4);} catch (invfmt) {err ();}
put ("#020x: "); try {putf ("->%#020x<-\n",0);} catch (invfmt) {err ();}
put ("#020x: "); try {putf ("->%#020x<-\n",4);} catch (invfmt) {err ();}
put ("020x: "); try {putf ("->%020x<-\n",-4);} catch (invfmt) {err ();}
put ("020x: "); try {putf ("->%020x<-\n",0);} catch (invfmt) {err ();}
put ("020x: "); try {putf ("->%020x<-\n",4);} catch (invfmt) {err ();}
put ("#20x: "); try {putf ("->%#20x<-\n",-4);} catch (invfmt) {err ();}
put ("#20x: "); try {putf ("->%#20x<-\n",0);} catch (invfmt) {err ();}
put ("#20x: "); try {putf ("->%#20x<-\n",4);} catch (invfmt) {err ();}
put ("20x: "); try {putf ("->%20x<-\n",-4);} catch (invfmt) {err ();}
put ("20x: "); try {putf ("->%20x<-\n",0);} catch (invfmt) {err ();}
put ("20x: "); try {putf ("->%20x<-\n",4);} catch (invfmt) {err ();}
put ("#0- +20X: "); try {putf ("->%#0- +20X<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +20X: "); try {putf ("->%#0- +20X<-\n",0);} catch (invfmt) {err ();}
put ("#0- +20X: "); try {putf ("->%#0- +20X<-\n",4);} catch (invfmt) {err ();}
put ("0- +20X: "); try {putf ("->%0- +20X<-\n",-4);} catch (invfmt) {err ();}
put ("0- +20X: "); try {putf ("->%0- +20X<-\n",0);} catch (invfmt) {err ();}
put ("0- +20X: "); try {putf ("->%0- +20X<-\n",4);} catch (invfmt) {err ();}
put ("#- +20X: "); try {putf ("->%#- +20X<-\n",-4);} catch (invfmt) {err ();}
put ("#- +20X: "); try {putf ("->%#- +20X<-\n",0);} catch (invfmt) {err ();}
put ("#- +20X: "); try {putf ("->%#- +20X<-\n",4);} catch (invfmt) {err ();}
put ("- +20X: "); try {putf ("->%- +20X<-\n",-4);} catch (invfmt) {err ();}
put ("- +20X: "); try {putf ("->%- +20X<-\n",0);} catch (invfmt) {err ();}
put ("- +20X: "); try {putf ("->%- +20X<-\n",4);} catch (invfmt) {err ();}
put ("#0 +20X: "); try {putf ("->%#0 +20X<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +20X: "); try {putf ("->%#0 +20X<-\n",0);} catch (invfmt) {err ();}
put ("#0 +20X: "); try {putf ("->%#0 +20X<-\n",4);} catch (invfmt) {err ();}
put ("0 +20X: "); try {putf ("->%0 +20X<-\n",-4);} catch (invfmt) {err ();}
put ("0 +20X: "); try {putf ("->%0 +20X<-\n",0);} catch (invfmt) {err ();}
put ("0 +20X: "); try {putf ("->%0 +20X<-\n",4);} catch (invfmt) {err ();}
put ("# +20X: "); try {putf ("->%# +20X<-\n",-4);} catch (invfmt) {err ();}
put ("# +20X: "); try {putf ("->%# +20X<-\n",0);} catch (invfmt) {err ();}
put ("# +20X: "); try {putf ("->%# +20X<-\n",4);} catch (invfmt) {err ();}
put (" +20X: "); try {putf ("->% +20X<-\n",-4);} catch (invfmt) {err ();}
put (" +20X: "); try {putf ("->% +20X<-\n",0);} catch (invfmt) {err ();}
put (" +20X: "); try {putf ("->% +20X<-\n",4);} catch (invfmt) {err ();}
put ("#0-+20X: "); try {putf ("->%#0-+20X<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+20X: "); try {putf ("->%#0-+20X<-\n",0);} catch (invfmt) {err ();}
put ("#0-+20X: "); try {putf ("->%#0-+20X<-\n",4);} catch (invfmt) {err ();}
put ("0-+20X: "); try {putf ("->%0-+20X<-\n",-4);} catch (invfmt) {err ();}
put ("0-+20X: "); try {putf ("->%0-+20X<-\n",0);} catch (invfmt) {err ();}
put ("0-+20X: "); try {putf ("->%0-+20X<-\n",4);} catch (invfmt) {err ();}
put ("#-+20X: "); try {putf ("->%#-+20X<-\n",-4);} catch (invfmt) {err ();}
put ("#-+20X: "); try {putf ("->%#-+20X<-\n",0);} catch (invfmt) {err ();}
put ("#-+20X: "); try {putf ("->%#-+20X<-\n",4);} catch (invfmt) {err ();}
put ("-+20X: "); try {putf ("->%-+20X<-\n",-4);} catch (invfmt) {err ();}
put ("-+20X: "); try {putf ("->%-+20X<-\n",0);} catch (invfmt) {err ();}
put ("-+20X: "); try {putf ("->%-+20X<-\n",4);} catch (invfmt) {err ();}
put ("#0+20X: "); try {putf ("->%#0+20X<-\n",-4);} catch (invfmt) {err ();}
put ("#0+20X: "); try {putf ("->%#0+20X<-\n",0);} catch (invfmt) {err ();}
put ("#0+20X: "); try {putf ("->%#0+20X<-\n",4);} catch (invfmt) {err ();}
put ("0+20X: "); try {putf ("->%0+20X<-\n",-4);} catch (invfmt) {err ();}
put ("0+20X: "); try {putf ("->%0+20X<-\n",0);} catch (invfmt) {err ();}
put ("0+20X: "); try {putf ("->%0+20X<-\n",4);} catch (invfmt) {err ();}
put ("#+20X: "); try {putf ("->%#+20X<-\n",-4);} catch (invfmt) {err ();}
put ("#+20X: "); try {putf ("->%#+20X<-\n",0);} catch (invfmt) {err ();}
put ("#+20X: "); try {putf ("->%#+20X<-\n",4);} catch (invfmt) {err ();}
put ("+20X: "); try {putf ("->%+20X<-\n",-4);} catch (invfmt) {err ();}
put ("+20X: "); try {putf ("->%+20X<-\n",0);} catch (invfmt) {err ();}
put ("+20X: "); try {putf ("->%+20X<-\n",4);} catch (invfmt) {err ();}
put ("#0- 20X: "); try {putf ("->%#0- 20X<-\n",-4);} catch (invfmt) {err ();}
put ("#0- 20X: "); try {putf ("->%#0- 20X<-\n",0);} catch (invfmt) {err ();}
put ("#0- 20X: "); try {putf ("->%#0- 20X<-\n",4);} catch (invfmt) {err ();}
put ("0- 20X: "); try {putf ("->%0- 20X<-\n",-4);} catch (invfmt) {err ();}
put ("0- 20X: "); try {putf ("->%0- 20X<-\n",0);} catch (invfmt) {err ();}
put ("0- 20X: "); try {putf ("->%0- 20X<-\n",4);} catch (invfmt) {err ();}
put ("#- 20X: "); try {putf ("->%#- 20X<-\n",-4);} catch (invfmt) {err ();}
put ("#- 20X: "); try {putf ("->%#- 20X<-\n",0);} catch (invfmt) {err ();}
put ("#- 20X: "); try {putf ("->%#- 20X<-\n",4);} catch (invfmt) {err ();}
put ("- 20X: "); try {putf ("->%- 20X<-\n",-4);} catch (invfmt) {err ();}
put ("- 20X: "); try {putf ("->%- 20X<-\n",0);} catch (invfmt) {err ();}
put ("- 20X: "); try {putf ("->%- 20X<-\n",4);} catch (invfmt) {err ();}
put ("#0 20X: "); try {putf ("->%#0 20X<-\n",-4);} catch (invfmt) {err ();}
put ("#0 20X: "); try {putf ("->%#0 20X<-\n",0);} catch (invfmt) {err ();}
put ("#0 20X: "); try {putf ("->%#0 20X<-\n",4);} catch (invfmt) {err ();}
put ("0 20X: "); try {putf ("->%0 20X<-\n",-4);} catch (invfmt) {err ();}
put ("0 20X: "); try {putf ("->%0 20X<-\n",0);} catch (invfmt) {err ();}
put ("0 20X: "); try {putf ("->%0 20X<-\n",4);} catch (invfmt) {err ();}
put ("# 20X: "); try {putf ("->%# 20X<-\n",-4);} catch (invfmt) {err ();}
put ("# 20X: "); try {putf ("->%# 20X<-\n",0);} catch (invfmt) {err ();}
put ("# 20X: "); try {putf ("->%# 20X<-\n",4);} catch (invfmt) {err ();}
put (" 20X: "); try {putf ("->% 20X<-\n",-4);} catch (invfmt) {err ();}
put (" 20X: "); try {putf ("->% 20X<-\n",0);} catch (invfmt) {err ();}
put (" 20X: "); try {putf ("->% 20X<-\n",4);} catch (invfmt) {err ();}
put ("#0-20X: "); try {putf ("->%#0-20X<-\n",-4);} catch (invfmt) {err ();}
put ("#0-20X: "); try {putf ("->%#0-20X<-\n",0);} catch (invfmt) {err ();}
put ("#0-20X: "); try {putf ("->%#0-20X<-\n",4);} catch (invfmt) {err ();}
put ("0-20X: "); try {putf ("->%0-20X<-\n",-4);} catch (invfmt) {err ();}
put ("0-20X: "); try {putf ("->%0-20X<-\n",0);} catch (invfmt) {err ();}
put ("0-20X: "); try {putf ("->%0-20X<-\n",4);} catch (invfmt) {err ();}
put ("#-20X: "); try {putf ("->%#-20X<-\n",-4);} catch (invfmt) {err ();}
put ("#-20X: "); try {putf ("->%#-20X<-\n",0);} catch (invfmt) {err ();}
put ("#-20X: "); try {putf ("->%#-20X<-\n",4);} catch (invfmt) {err ();}
put ("-20X: "); try {putf ("->%-20X<-\n",-4);} catch (invfmt) {err ();}
put ("-20X: "); try {putf ("->%-20X<-\n",0);} catch (invfmt) {err ();}
put ("-20X: "); try {putf ("->%-20X<-\n",4);} catch (invfmt) {err ();}
put ("#020X: "); try {putf ("->%#020X<-\n",-4);} catch (invfmt) {err ();}
put ("#020X: "); try {putf ("->%#020X<-\n",0);} catch (invfmt) {err ();}
put ("#020X: "); try {putf ("->%#020X<-\n",4);} catch (invfmt) {err ();}
put ("020X: "); try {putf ("->%020X<-\n",-4);} catch (invfmt) {err ();}
put ("020X: "); try {putf ("->%020X<-\n",0);} catch (invfmt) {err ();}
put ("020X: "); try {putf ("->%020X<-\n",4);} catch (invfmt) {err ();}
put ("#20X: "); try {putf ("->%#20X<-\n",-4);} catch (invfmt) {err ();}
put ("#20X: "); try {putf ("->%#20X<-\n",0);} catch (invfmt) {err ();}
put ("#20X: "); try {putf ("->%#20X<-\n",4);} catch (invfmt) {err ();}
put ("20X: "); try {putf ("->%20X<-\n",-4);} catch (invfmt) {err ();}
put ("20X: "); try {putf ("->%20X<-\n",0);} catch (invfmt) {err ();}
put ("20X: "); try {putf ("->%20X<-\n",4);} catch (invfmt) {err ();}
TEST650
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT650' && $CMP $stdout $ftemp2; then
#0- +d: badformat
#0- +d: badformat
#0- +d: badformat
0- +d: ->-4<-
0- +d: ->+0<-
0- +d: ->+4<-
#- +d: badformat
#- +d: badformat
#- +d: badformat
- +d: ->-4<-
- +d: ->+0<-
- +d: ->+4<-
#0 +d: badformat
#0 +d: badformat
#0 +d: badformat
0 +d: ->-4<-
0 +d: ->+0<-
0 +d: ->+4<-
# +d: badformat
# +d: badformat
# +d: badformat
 +d: ->-4<-
 +d: ->+0<-
 +d: ->+4<-
#0-+d: badformat
#0-+d: badformat
#0-+d: badformat
0-+d: ->-4<-
0-+d: ->+0<-
0-+d: ->+4<-
#-+d: badformat
#-+d: badformat
#-+d: badformat
-+d: ->-4<-
-+d: ->+0<-
-+d: ->+4<-
#0+d: badformat
#0+d: badformat
#0+d: badformat
0+d: ->-4<-
0+d: ->+0<-
0+d: ->+4<-
#+d: badformat
#+d: badformat
#+d: badformat
+d: ->-4<-
+d: ->+0<-
+d: ->+4<-
#0- d: badformat
#0- d: badformat
#0- d: badformat
0- d: ->-4<-
0- d: -> 0<-
0- d: -> 4<-
#- d: badformat
#- d: badformat
#- d: badformat
- d: ->-4<-
- d: -> 0<-
- d: -> 4<-
#0 d: badformat
#0 d: badformat
#0 d: badformat
0 d: ->-4<-
0 d: -> 0<-
0 d: -> 4<-
# d: badformat
# d: badformat
# d: badformat
 d: ->-4<-
 d: -> 0<-
 d: -> 4<-
#0-d: badformat
#0-d: badformat
#0-d: badformat
0-d: ->-4<-
0-d: ->0<-
0-d: ->4<-
#-d: badformat
#-d: badformat
#-d: badformat
-d: ->-4<-
-d: ->0<-
-d: ->4<-
#0d: badformat
#0d: badformat
#0d: badformat
0d: ->-4<-
0d: ->0<-
0d: ->4<-
#d: badformat
#d: badformat
#d: badformat
d: ->-4<-
d: ->0<-
d: ->4<-
#0- +o: badformat
#0- +o: badformat
#0- +o: badformat
0- +o: badformat
0- +o: badformat
0- +o: badformat
#- +o: badformat
#- +o: badformat
#- +o: badformat
- +o: badformat
- +o: badformat
- +o: badformat
#0 +o: badformat
#0 +o: badformat
#0 +o: badformat
0 +o: badformat
0 +o: badformat
0 +o: badformat
# +o: badformat
# +o: badformat
# +o: badformat
 +o: badformat
 +o: badformat
 +o: badformat
#0-+o: badformat
#0-+o: badformat
#0-+o: badformat
0-+o: badformat
0-+o: badformat
0-+o: badformat
#-+o: badformat
#-+o: badformat
#-+o: badformat
-+o: badformat
-+o: badformat
-+o: badformat
#0+o: badformat
#0+o: badformat
#0+o: badformat
0+o: badformat
0+o: badformat
0+o: badformat
#+o: badformat
#+o: badformat
#+o: badformat
+o: badformat
+o: badformat
+o: badformat
#0- o: badformat
#0- o: badformat
#0- o: badformat
0- o: badformat
0- o: badformat
0- o: badformat
#- o: badformat
#- o: badformat
#- o: badformat
- o: badformat
- o: badformat
- o: badformat
#0 o: badformat
#0 o: badformat
#0 o: badformat
0 o: badformat
0 o: badformat
0 o: badformat
# o: badformat
# o: badformat
# o: badformat
 o: badformat
 o: badformat
 o: badformat
#0-o: ->01777777777777777777774<-
#0-o: ->0<-
#0-o: ->04<-
0-o: ->1777777777777777777774<-
0-o: ->0<-
0-o: ->4<-
#-o: ->01777777777777777777774<-
#-o: ->0<-
#-o: ->04<-
-o: ->1777777777777777777774<-
-o: ->0<-
-o: ->4<-
#0o: ->01777777777777777777774<-
#0o: ->0<-
#0o: ->04<-
0o: ->1777777777777777777774<-
0o: ->0<-
0o: ->4<-
#o: ->01777777777777777777774<-
#o: ->0<-
#o: ->04<-
o: ->1777777777777777777774<-
o: ->0<-
o: ->4<-
#0- +x: badformat
#0- +x: badformat
#0- +x: badformat
0- +x: badformat
0- +x: badformat
0- +x: badformat
#- +x: badformat
#- +x: badformat
#- +x: badformat
- +x: badformat
- +x: badformat
- +x: badformat
#0 +x: badformat
#0 +x: badformat
#0 +x: badformat
0 +x: badformat
0 +x: badformat
0 +x: badformat
# +x: badformat
# +x: badformat
# +x: badformat
 +x: badformat
 +x: badformat
 +x: badformat
#0-+x: badformat
#0-+x: badformat
#0-+x: badformat
0-+x: badformat
0-+x: badformat
0-+x: badformat
#-+x: badformat
#-+x: badformat
#-+x: badformat
-+x: badformat
-+x: badformat
-+x: badformat
#0+x: badformat
#0+x: badformat
#0+x: badformat
0+x: badformat
0+x: badformat
0+x: badformat
#+x: badformat
#+x: badformat
#+x: badformat
+x: badformat
+x: badformat
+x: badformat
#0- x: badformat
#0- x: badformat
#0- x: badformat
0- x: badformat
0- x: badformat
0- x: badformat
#- x: badformat
#- x: badformat
#- x: badformat
- x: badformat
- x: badformat
- x: badformat
#0 x: badformat
#0 x: badformat
#0 x: badformat
0 x: badformat
0 x: badformat
0 x: badformat
# x: badformat
# x: badformat
# x: badformat
 x: badformat
 x: badformat
 x: badformat
#0-x: ->0xfffffffffffffffc<-
#0-x: ->0<-
#0-x: ->0x4<-
0-x: ->fffffffffffffffc<-
0-x: ->0<-
0-x: ->4<-
#-x: ->0xfffffffffffffffc<-
#-x: ->0<-
#-x: ->0x4<-
-x: ->fffffffffffffffc<-
-x: ->0<-
-x: ->4<-
#0x: ->0xfffffffffffffffc<-
#0x: ->0<-
#0x: ->0x4<-
0x: ->fffffffffffffffc<-
0x: ->0<-
0x: ->4<-
#x: ->0xfffffffffffffffc<-
#x: ->0<-
#x: ->0x4<-
x: ->fffffffffffffffc<-
x: ->0<-
x: ->4<-
#0- +X: badformat
#0- +X: badformat
#0- +X: badformat
0- +X: badformat
0- +X: badformat
0- +X: badformat
#- +X: badformat
#- +X: badformat
#- +X: badformat
- +X: badformat
- +X: badformat
- +X: badformat
#0 +X: badformat
#0 +X: badformat
#0 +X: badformat
0 +X: badformat
0 +X: badformat
0 +X: badformat
# +X: badformat
# +X: badformat
# +X: badformat
 +X: badformat
 +X: badformat
 +X: badformat
#0-+X: badformat
#0-+X: badformat
#0-+X: badformat
0-+X: badformat
0-+X: badformat
0-+X: badformat
#-+X: badformat
#-+X: badformat
#-+X: badformat
-+X: badformat
-+X: badformat
-+X: badformat
#0+X: badformat
#0+X: badformat
#0+X: badformat
0+X: badformat
0+X: badformat
0+X: badformat
#+X: badformat
#+X: badformat
#+X: badformat
+X: badformat
+X: badformat
+X: badformat
#0- X: badformat
#0- X: badformat
#0- X: badformat
0- X: badformat
0- X: badformat
0- X: badformat
#- X: badformat
#- X: badformat
#- X: badformat
- X: badformat
- X: badformat
- X: badformat
#0 X: badformat
#0 X: badformat
#0 X: badformat
0 X: badformat
0 X: badformat
0 X: badformat
# X: badformat
# X: badformat
# X: badformat
 X: badformat
 X: badformat
 X: badformat
#0-X: ->0XFFFFFFFFFFFFFFFC<-
#0-X: ->0<-
#0-X: ->0X4<-
0-X: ->FFFFFFFFFFFFFFFC<-
0-X: ->0<-
0-X: ->4<-
#-X: ->0XFFFFFFFFFFFFFFFC<-
#-X: ->0<-
#-X: ->0X4<-
-X: ->FFFFFFFFFFFFFFFC<-
-X: ->0<-
-X: ->4<-
#0X: ->0XFFFFFFFFFFFFFFFC<-
#0X: ->0<-
#0X: ->0X4<-
0X: ->FFFFFFFFFFFFFFFC<-
0X: ->0<-
0X: ->4<-
#X: ->0XFFFFFFFFFFFFFFFC<-
#X: ->0<-
#X: ->0X4<-
X: ->FFFFFFFFFFFFFFFC<-
X: ->0<-
X: ->4<-
#0- +0d: badformat
#0- +0d: badformat
#0- +0d: badformat
0- +0d: ->-4<-
0- +0d: ->+0<-
0- +0d: ->+4<-
#- +0d: badformat
#- +0d: badformat
#- +0d: badformat
- +0d: ->-4<-
- +0d: ->+0<-
- +0d: ->+4<-
#0 +0d: badformat
#0 +0d: badformat
#0 +0d: badformat
0 +0d: ->-4<-
0 +0d: ->+0<-
0 +0d: ->+4<-
# +0d: badformat
# +0d: badformat
# +0d: badformat
 +0d: ->-4<-
 +0d: ->+0<-
 +0d: ->+4<-
#0-+0d: badformat
#0-+0d: badformat
#0-+0d: badformat
0-+0d: ->-4<-
0-+0d: ->+0<-
0-+0d: ->+4<-
#-+0d: badformat
#-+0d: badformat
#-+0d: badformat
-+0d: ->-4<-
-+0d: ->+0<-
-+0d: ->+4<-
#0+0d: badformat
#0+0d: badformat
#0+0d: badformat
0+0d: ->-4<-
0+0d: ->+0<-
0+0d: ->+4<-
#+0d: badformat
#+0d: badformat
#+0d: badformat
+0d: ->-4<-
+0d: ->+0<-
+0d: ->+4<-
#0- 0d: badformat
#0- 0d: badformat
#0- 0d: badformat
0- 0d: ->-4<-
0- 0d: -> 0<-
0- 0d: -> 4<-
#- 0d: badformat
#- 0d: badformat
#- 0d: badformat
- 0d: ->-4<-
- 0d: -> 0<-
- 0d: -> 4<-
#0 0d: badformat
#0 0d: badformat
#0 0d: badformat
0 0d: ->-4<-
0 0d: -> 0<-
0 0d: -> 4<-
# 0d: badformat
# 0d: badformat
# 0d: badformat
 0d: ->-4<-
 0d: -> 0<-
 0d: -> 4<-
#0-0d: badformat
#0-0d: badformat
#0-0d: badformat
0-0d: ->-4<-
0-0d: ->0<-
0-0d: ->4<-
#-0d: badformat
#-0d: badformat
#-0d: badformat
-0d: ->-4<-
-0d: ->0<-
-0d: ->4<-
#00d: badformat
#00d: badformat
#00d: badformat
00d: ->-4<-
00d: ->0<-
00d: ->4<-
#0d: badformat
#0d: badformat
#0d: badformat
0d: ->-4<-
0d: ->0<-
0d: ->4<-
#0- +0o: badformat
#0- +0o: badformat
#0- +0o: badformat
0- +0o: badformat
0- +0o: badformat
0- +0o: badformat
#- +0o: badformat
#- +0o: badformat
#- +0o: badformat
- +0o: badformat
- +0o: badformat
- +0o: badformat
#0 +0o: badformat
#0 +0o: badformat
#0 +0o: badformat
0 +0o: badformat
0 +0o: badformat
0 +0o: badformat
# +0o: badformat
# +0o: badformat
# +0o: badformat
 +0o: badformat
 +0o: badformat
 +0o: badformat
#0-+0o: badformat
#0-+0o: badformat
#0-+0o: badformat
0-+0o: badformat
0-+0o: badformat
0-+0o: badformat
#-+0o: badformat
#-+0o: badformat
#-+0o: badformat
-+0o: badformat
-+0o: badformat
-+0o: badformat
#0+0o: badformat
#0+0o: badformat
#0+0o: badformat
0+0o: badformat
0+0o: badformat
0+0o: badformat
#+0o: badformat
#+0o: badformat
#+0o: badformat
+0o: badformat
+0o: badformat
+0o: badformat
#0- 0o: badformat
#0- 0o: badformat
#0- 0o: badformat
0- 0o: badformat
0- 0o: badformat
0- 0o: badformat
#- 0o: badformat
#- 0o: badformat
#- 0o: badformat
- 0o: badformat
- 0o: badformat
- 0o: badformat
#0 0o: badformat
#0 0o: badformat
#0 0o: badformat
0 0o: badformat
0 0o: badformat
0 0o: badformat
# 0o: badformat
# 0o: badformat
# 0o: badformat
 0o: badformat
 0o: badformat
 0o: badformat
#0-0o: ->01777777777777777777774<-
#0-0o: ->0<-
#0-0o: ->04<-
0-0o: ->1777777777777777777774<-
0-0o: ->0<-
0-0o: ->4<-
#-0o: ->01777777777777777777774<-
#-0o: ->0<-
#-0o: ->04<-
-0o: ->1777777777777777777774<-
-0o: ->0<-
-0o: ->4<-
#00o: ->01777777777777777777774<-
#00o: ->0<-
#00o: ->04<-
00o: ->1777777777777777777774<-
00o: ->0<-
00o: ->4<-
#0o: ->01777777777777777777774<-
#0o: ->0<-
#0o: ->04<-
0o: ->1777777777777777777774<-
0o: ->0<-
0o: ->4<-
#0- +0x: badformat
#0- +0x: badformat
#0- +0x: badformat
0- +0x: badformat
0- +0x: badformat
0- +0x: badformat
#- +0x: badformat
#- +0x: badformat
#- +0x: badformat
- +0x: badformat
- +0x: badformat
- +0x: badformat
#0 +0x: badformat
#0 +0x: badformat
#0 +0x: badformat
0 +0x: badformat
0 +0x: badformat
0 +0x: badformat
# +0x: badformat
# +0x: badformat
# +0x: badformat
 +0x: badformat
 +0x: badformat
 +0x: badformat
#0-+0x: badformat
#0-+0x: badformat
#0-+0x: badformat
0-+0x: badformat
0-+0x: badformat
0-+0x: badformat
#-+0x: badformat
#-+0x: badformat
#-+0x: badformat
-+0x: badformat
-+0x: badformat
-+0x: badformat
#0+0x: badformat
#0+0x: badformat
#0+0x: badformat
0+0x: badformat
0+0x: badformat
0+0x: badformat
#+0x: badformat
#+0x: badformat
#+0x: badformat
+0x: badformat
+0x: badformat
+0x: badformat
#0- 0x: badformat
#0- 0x: badformat
#0- 0x: badformat
0- 0x: badformat
0- 0x: badformat
0- 0x: badformat
#- 0x: badformat
#- 0x: badformat
#- 0x: badformat
- 0x: badformat
- 0x: badformat
- 0x: badformat
#0 0x: badformat
#0 0x: badformat
#0 0x: badformat
0 0x: badformat
0 0x: badformat
0 0x: badformat
# 0x: badformat
# 0x: badformat
# 0x: badformat
 0x: badformat
 0x: badformat
 0x: badformat
#0-0x: ->0xfffffffffffffffc<-
#0-0x: ->0<-
#0-0x: ->0x4<-
0-0x: ->fffffffffffffffc<-
0-0x: ->0<-
0-0x: ->4<-
#-0x: ->0xfffffffffffffffc<-
#-0x: ->0<-
#-0x: ->0x4<-
-0x: ->fffffffffffffffc<-
-0x: ->0<-
-0x: ->4<-
#00x: ->0xfffffffffffffffc<-
#00x: ->0<-
#00x: ->0x4<-
00x: ->fffffffffffffffc<-
00x: ->0<-
00x: ->4<-
#0x: ->0xfffffffffffffffc<-
#0x: ->0<-
#0x: ->0x4<-
0x: ->fffffffffffffffc<-
0x: ->0<-
0x: ->4<-
#0- +0X: badformat
#0- +0X: badformat
#0- +0X: badformat
0- +0X: badformat
0- +0X: badformat
0- +0X: badformat
#- +0X: badformat
#- +0X: badformat
#- +0X: badformat
- +0X: badformat
- +0X: badformat
- +0X: badformat
#0 +0X: badformat
#0 +0X: badformat
#0 +0X: badformat
0 +0X: badformat
0 +0X: badformat
0 +0X: badformat
# +0X: badformat
# +0X: badformat
# +0X: badformat
 +0X: badformat
 +0X: badformat
 +0X: badformat
#0-+0X: badformat
#0-+0X: badformat
#0-+0X: badformat
0-+0X: badformat
0-+0X: badformat
0-+0X: badformat
#-+0X: badformat
#-+0X: badformat
#-+0X: badformat
-+0X: badformat
-+0X: badformat
-+0X: badformat
#0+0X: badformat
#0+0X: badformat
#0+0X: badformat
0+0X: badformat
0+0X: badformat
0+0X: badformat
#+0X: badformat
#+0X: badformat
#+0X: badformat
+0X: badformat
+0X: badformat
+0X: badformat
#0- 0X: badformat
#0- 0X: badformat
#0- 0X: badformat
0- 0X: badformat
0- 0X: badformat
0- 0X: badformat
#- 0X: badformat
#- 0X: badformat
#- 0X: badformat
- 0X: badformat
- 0X: badformat
- 0X: badformat
#0 0X: badformat
#0 0X: badformat
#0 0X: badformat
0 0X: badformat
0 0X: badformat
0 0X: badformat
# 0X: badformat
# 0X: badformat
# 0X: badformat
 0X: badformat
 0X: badformat
 0X: badformat
#0-0X: ->0XFFFFFFFFFFFFFFFC<-
#0-0X: ->0<-
#0-0X: ->0X4<-
0-0X: ->FFFFFFFFFFFFFFFC<-
0-0X: ->0<-
0-0X: ->4<-
#-0X: ->0XFFFFFFFFFFFFFFFC<-
#-0X: ->0<-
#-0X: ->0X4<-
-0X: ->FFFFFFFFFFFFFFFC<-
-0X: ->0<-
-0X: ->4<-
#00X: ->0XFFFFFFFFFFFFFFFC<-
#00X: ->0<-
#00X: ->0X4<-
00X: ->FFFFFFFFFFFFFFFC<-
00X: ->0<-
00X: ->4<-
#0X: ->0XFFFFFFFFFFFFFFFC<-
#0X: ->0<-
#0X: ->0X4<-
0X: ->FFFFFFFFFFFFFFFC<-
0X: ->0<-
0X: ->4<-
#0- +20d: badformat
#0- +20d: badformat
#0- +20d: badformat
0- +20d: ->-4                  <-
0- +20d: ->+0                  <-
0- +20d: ->+4                  <-
#- +20d: badformat
#- +20d: badformat
#- +20d: badformat
- +20d: ->-4                  <-
- +20d: ->+0                  <-
- +20d: ->+4                  <-
#0 +20d: badformat
#0 +20d: badformat
#0 +20d: badformat
0 +20d: ->-0000000000000000004<-
0 +20d: ->+0000000000000000000<-
0 +20d: ->+0000000000000000004<-
# +20d: badformat
# +20d: badformat
# +20d: badformat
 +20d: ->                  -4<-
 +20d: ->                  +0<-
 +20d: ->                  +4<-
#0-+20d: badformat
#0-+20d: badformat
#0-+20d: badformat
0-+20d: ->-4                  <-
0-+20d: ->+0                  <-
0-+20d: ->+4                  <-
#-+20d: badformat
#-+20d: badformat
#-+20d: badformat
-+20d: ->-4                  <-
-+20d: ->+0                  <-
-+20d: ->+4                  <-
#0+20d: badformat
#0+20d: badformat
#0+20d: badformat
0+20d: ->-0000000000000000004<-
0+20d: ->+0000000000000000000<-
0+20d: ->+0000000000000000004<-
#+20d: badformat
#+20d: badformat
#+20d: badformat
+20d: ->                  -4<-
+20d: ->                  +0<-
+20d: ->                  +4<-
#0- 20d: badformat
#0- 20d: badformat
#0- 20d: badformat
0- 20d: ->-4                  <-
0- 20d: -> 0                  <-
0- 20d: -> 4                  <-
#- 20d: badformat
#- 20d: badformat
#- 20d: badformat
- 20d: ->-4                  <-
- 20d: -> 0                  <-
- 20d: -> 4                  <-
#0 20d: badformat
#0 20d: badformat
#0 20d: badformat
0 20d: ->-0000000000000000004<-
0 20d: -> 0000000000000000000<-
0 20d: -> 0000000000000000004<-
# 20d: badformat
# 20d: badformat
# 20d: badformat
 20d: ->                  -4<-
 20d: ->                   0<-
 20d: ->                   4<-
#0-20d: badformat
#0-20d: badformat
#0-20d: badformat
0-20d: ->-4                  <-
0-20d: ->0                   <-
0-20d: ->4                   <-
#-20d: badformat
#-20d: badformat
#-20d: badformat
-20d: ->-4                  <-
-20d: ->0                   <-
-20d: ->4                   <-
#020d: badformat
#020d: badformat
#020d: badformat
020d: ->-0000000000000000004<-
020d: ->00000000000000000000<-
020d: ->00000000000000000004<-
#20d: badformat
#20d: badformat
#20d: badformat
20d: ->                  -4<-
20d: ->                   0<-
20d: ->                   4<-
#0- +20o: badformat
#0- +20o: badformat
#0- +20o: badformat
0- +20o: badformat
0- +20o: badformat
0- +20o: badformat
#- +20o: badformat
#- +20o: badformat
#- +20o: badformat
- +20o: badformat
- +20o: badformat
- +20o: badformat
#0 +20o: badformat
#0 +20o: badformat
#0 +20o: badformat
0 +20o: badformat
0 +20o: badformat
0 +20o: badformat
# +20o: badformat
# +20o: badformat
# +20o: badformat
 +20o: badformat
 +20o: badformat
 +20o: badformat
#0-+20o: badformat
#0-+20o: badformat
#0-+20o: badformat
0-+20o: badformat
0-+20o: badformat
0-+20o: badformat
#-+20o: badformat
#-+20o: badformat
#-+20o: badformat
-+20o: badformat
-+20o: badformat
-+20o: badformat
#0+20o: badformat
#0+20o: badformat
#0+20o: badformat
0+20o: badformat
0+20o: badformat
0+20o: badformat
#+20o: badformat
#+20o: badformat
#+20o: badformat
+20o: badformat
+20o: badformat
+20o: badformat
#0- 20o: badformat
#0- 20o: badformat
#0- 20o: badformat
0- 20o: badformat
0- 20o: badformat
0- 20o: badformat
#- 20o: badformat
#- 20o: badformat
#- 20o: badformat
- 20o: badformat
- 20o: badformat
- 20o: badformat
#0 20o: badformat
#0 20o: badformat
#0 20o: badformat
0 20o: badformat
0 20o: badformat
0 20o: badformat
# 20o: badformat
# 20o: badformat
# 20o: badformat
 20o: badformat
 20o: badformat
 20o: badformat
#0-20o: ->01777777777777777777774<-
#0-20o: ->0                   <-
#0-20o: ->04                  <-
0-20o: ->1777777777777777777774<-
0-20o: ->0                   <-
0-20o: ->4                   <-
#-20o: ->01777777777777777777774<-
#-20o: ->0                   <-
#-20o: ->04                  <-
-20o: ->1777777777777777777774<-
-20o: ->0                   <-
-20o: ->4                   <-
#020o: ->01777777777777777777774<-
#020o: ->00000000000000000000<-
#020o: ->00000000000000000004<-
020o: ->1777777777777777777774<-
020o: ->00000000000000000000<-
020o: ->00000000000000000004<-
#20o: ->01777777777777777777774<-
#20o: ->                   0<-
#20o: ->                  04<-
20o: ->1777777777777777777774<-
20o: ->                   0<-
20o: ->                   4<-
#0- +20x: badformat
#0- +20x: badformat
#0- +20x: badformat
0- +20x: badformat
0- +20x: badformat
0- +20x: badformat
#- +20x: badformat
#- +20x: badformat
#- +20x: badformat
- +20x: badformat
- +20x: badformat
- +20x: badformat
#0 +20x: badformat
#0 +20x: badformat
#0 +20x: badformat
0 +20x: badformat
0 +20x: badformat
0 +20x: badformat
# +20x: badformat
# +20x: badformat
# +20x: badformat
 +20x: badformat
 +20x: badformat
 +20x: badformat
#0-+20x: badformat
#0-+20x: badformat
#0-+20x: badformat
0-+20x: badformat
0-+20x: badformat
0-+20x: badformat
#-+20x: badformat
#-+20x: badformat
#-+20x: badformat
-+20x: badformat
-+20x: badformat
-+20x: badformat
#0+20x: badformat
#0+20x: badformat
#0+20x: badformat
0+20x: badformat
0+20x: badformat
0+20x: badformat
#+20x: badformat
#+20x: badformat
#+20x: badformat
+20x: badformat
+20x: badformat
+20x: badformat
#0- 20x: badformat
#0- 20x: badformat
#0- 20x: badformat
0- 20x: badformat
0- 20x: badformat
0- 20x: badformat
#- 20x: badformat
#- 20x: badformat
#- 20x: badformat
- 20x: badformat
- 20x: badformat
- 20x: badformat
#0 20x: badformat
#0 20x: badformat
#0 20x: badformat
0 20x: badformat
0 20x: badformat
0 20x: badformat
# 20x: badformat
# 20x: badformat
# 20x: badformat
 20x: badformat
 20x: badformat
 20x: badformat
#0-20x: ->0xfffffffffffffffc  <-
#0-20x: ->0                   <-
#0-20x: ->0x4                 <-
0-20x: ->fffffffffffffffc    <-
0-20x: ->0                   <-
0-20x: ->4                   <-
#-20x: ->0xfffffffffffffffc  <-
#-20x: ->0                   <-
#-20x: ->0x4                 <-
-20x: ->fffffffffffffffc    <-
-20x: ->0                   <-
-20x: ->4                   <-
#020x: ->0x00fffffffffffffffc<-
#020x: ->00000000000000000000<-
#020x: ->0x000000000000000004<-
020x: ->0000fffffffffffffffc<-
020x: ->00000000000000000000<-
020x: ->00000000000000000004<-
#20x: ->  0xfffffffffffffffc<-
#20x: ->                   0<-
#20x: ->                 0x4<-
20x: ->    fffffffffffffffc<-
20x: ->                   0<-
20x: ->                   4<-
#0- +20X: badformat
#0- +20X: badformat
#0- +20X: badformat
0- +20X: badformat
0- +20X: badformat
0- +20X: badformat
#- +20X: badformat
#- +20X: badformat
#- +20X: badformat
- +20X: badformat
- +20X: badformat
- +20X: badformat
#0 +20X: badformat
#0 +20X: badformat
#0 +20X: badformat
0 +20X: badformat
0 +20X: badformat
0 +20X: badformat
# +20X: badformat
# +20X: badformat
# +20X: badformat
 +20X: badformat
 +20X: badformat
 +20X: badformat
#0-+20X: badformat
#0-+20X: badformat
#0-+20X: badformat
0-+20X: badformat
0-+20X: badformat
0-+20X: badformat
#-+20X: badformat
#-+20X: badformat
#-+20X: badformat
-+20X: badformat
-+20X: badformat
-+20X: badformat
#0+20X: badformat
#0+20X: badformat
#0+20X: badformat
0+20X: badformat
0+20X: badformat
0+20X: badformat
#+20X: badformat
#+20X: badformat
#+20X: badformat
+20X: badformat
+20X: badformat
+20X: badformat
#0- 20X: badformat
#0- 20X: badformat
#0- 20X: badformat
0- 20X: badformat
0- 20X: badformat
0- 20X: badformat
#- 20X: badformat
#- 20X: badformat
#- 20X: badformat
- 20X: badformat
- 20X: badformat
- 20X: badformat
#0 20X: badformat
#0 20X: badformat
#0 20X: badformat
0 20X: badformat
0 20X: badformat
0 20X: badformat
# 20X: badformat
# 20X: badformat
# 20X: badformat
 20X: badformat
 20X: badformat
 20X: badformat
#0-20X: ->0XFFFFFFFFFFFFFFFC  <-
#0-20X: ->0                   <-
#0-20X: ->0X4                 <-
0-20X: ->FFFFFFFFFFFFFFFC    <-
0-20X: ->0                   <-
0-20X: ->4                   <-
#-20X: ->0XFFFFFFFFFFFFFFFC  <-
#-20X: ->0                   <-
#-20X: ->0X4                 <-
-20X: ->FFFFFFFFFFFFFFFC    <-
-20X: ->0                   <-
-20X: ->4                   <-
#020X: ->0X00FFFFFFFFFFFFFFFC<-
#020X: ->00000000000000000000<-
#020X: ->0X000000000000000004<-
020X: ->0000FFFFFFFFFFFFFFFC<-
020X: ->00000000000000000000<-
020X: ->00000000000000000004<-
#20X: ->  0XFFFFFFFFFFFFFFFC<-
#20X: ->                   0<-
#20X: ->                 0X4<-
20X: ->    FFFFFFFFFFFFFFFC<-
20X: ->                   0<-
20X: ->                   4<-
OUTPUT650
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 651.
if test $result = ok -a $start_test_number -le 651; then
	echo test 651: Long format printing
        cat >$test_file <<'TEST651'
fun err {putln ("badformat");}
put ("#0- +d: "); try {putf ("->%#0- +d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +d: "); try {putf ("->%#0- +d<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +d: "); try {putf ("->%#0- +d<-\n",4L);} catch (invfmt) {err ();}
put ("0- +d: "); try {putf ("->%0- +d<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +d: "); try {putf ("->%0- +d<-\n",0L);} catch (invfmt) {err ();}
put ("0- +d: "); try {putf ("->%0- +d<-\n",4L);} catch (invfmt) {err ();}
put ("#- +d: "); try {putf ("->%#- +d<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +d: "); try {putf ("->%#- +d<-\n",0L);} catch (invfmt) {err ();}
put ("#- +d: "); try {putf ("->%#- +d<-\n",4L);} catch (invfmt) {err ();}
put ("- +d: "); try {putf ("->%- +d<-\n",-4L);} catch (invfmt) {err ();}
put ("- +d: "); try {putf ("->%- +d<-\n",0L);} catch (invfmt) {err ();}
put ("- +d: "); try {putf ("->%- +d<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +d: "); try {putf ("->%#0 +d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +d: "); try {putf ("->%#0 +d<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +d: "); try {putf ("->%#0 +d<-\n",4L);} catch (invfmt) {err ();}
put ("0 +d: "); try {putf ("->%0 +d<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +d: "); try {putf ("->%0 +d<-\n",0L);} catch (invfmt) {err ();}
put ("0 +d: "); try {putf ("->%0 +d<-\n",4L);} catch (invfmt) {err ();}
put ("# +d: "); try {putf ("->%# +d<-\n",-4L);} catch (invfmt) {err ();}
put ("# +d: "); try {putf ("->%# +d<-\n",0L);} catch (invfmt) {err ();}
put ("# +d: "); try {putf ("->%# +d<-\n",4L);} catch (invfmt) {err ();}
put (" +d: "); try {putf ("->% +d<-\n",-4L);} catch (invfmt) {err ();}
put (" +d: "); try {putf ("->% +d<-\n",0L);} catch (invfmt) {err ();}
put (" +d: "); try {putf ("->% +d<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+d: "); try {putf ("->%#0-+d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+d: "); try {putf ("->%#0-+d<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+d: "); try {putf ("->%#0-+d<-\n",4L);} catch (invfmt) {err ();}
put ("0-+d: "); try {putf ("->%0-+d<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+d: "); try {putf ("->%0-+d<-\n",0L);} catch (invfmt) {err ();}
put ("0-+d: "); try {putf ("->%0-+d<-\n",4L);} catch (invfmt) {err ();}
put ("#-+d: "); try {putf ("->%#-+d<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+d: "); try {putf ("->%#-+d<-\n",0L);} catch (invfmt) {err ();}
put ("#-+d: "); try {putf ("->%#-+d<-\n",4L);} catch (invfmt) {err ();}
put ("-+d: "); try {putf ("->%-+d<-\n",-4L);} catch (invfmt) {err ();}
put ("-+d: "); try {putf ("->%-+d<-\n",0L);} catch (invfmt) {err ();}
put ("-+d: "); try {putf ("->%-+d<-\n",4L);} catch (invfmt) {err ();}
put ("#0+d: "); try {putf ("->%#0+d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+d: "); try {putf ("->%#0+d<-\n",0L);} catch (invfmt) {err ();}
put ("#0+d: "); try {putf ("->%#0+d<-\n",4L);} catch (invfmt) {err ();}
put ("0+d: "); try {putf ("->%0+d<-\n",-4L);} catch (invfmt) {err ();}
put ("0+d: "); try {putf ("->%0+d<-\n",0L);} catch (invfmt) {err ();}
put ("0+d: "); try {putf ("->%0+d<-\n",4L);} catch (invfmt) {err ();}
put ("#+d: "); try {putf ("->%#+d<-\n",-4L);} catch (invfmt) {err ();}
put ("#+d: "); try {putf ("->%#+d<-\n",0L);} catch (invfmt) {err ();}
put ("#+d: "); try {putf ("->%#+d<-\n",4L);} catch (invfmt) {err ();}
put ("+d: "); try {putf ("->%+d<-\n",-4L);} catch (invfmt) {err ();}
put ("+d: "); try {putf ("->%+d<-\n",0L);} catch (invfmt) {err ();}
put ("+d: "); try {putf ("->%+d<-\n",4L);} catch (invfmt) {err ();}
put ("#0- d: "); try {putf ("->%#0- d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- d: "); try {putf ("->%#0- d<-\n",0L);} catch (invfmt) {err ();}
put ("#0- d: "); try {putf ("->%#0- d<-\n",4L);} catch (invfmt) {err ();}
put ("0- d: "); try {putf ("->%0- d<-\n",-4L);} catch (invfmt) {err ();}
put ("0- d: "); try {putf ("->%0- d<-\n",0L);} catch (invfmt) {err ();}
put ("0- d: "); try {putf ("->%0- d<-\n",4L);} catch (invfmt) {err ();}
put ("#- d: "); try {putf ("->%#- d<-\n",-4L);} catch (invfmt) {err ();}
put ("#- d: "); try {putf ("->%#- d<-\n",0L);} catch (invfmt) {err ();}
put ("#- d: "); try {putf ("->%#- d<-\n",4L);} catch (invfmt) {err ();}
put ("- d: "); try {putf ("->%- d<-\n",-4L);} catch (invfmt) {err ();}
put ("- d: "); try {putf ("->%- d<-\n",0L);} catch (invfmt) {err ();}
put ("- d: "); try {putf ("->%- d<-\n",4L);} catch (invfmt) {err ();}
put ("#0 d: "); try {putf ("->%#0 d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 d: "); try {putf ("->%#0 d<-\n",0L);} catch (invfmt) {err ();}
put ("#0 d: "); try {putf ("->%#0 d<-\n",4L);} catch (invfmt) {err ();}
put ("0 d: "); try {putf ("->%0 d<-\n",-4L);} catch (invfmt) {err ();}
put ("0 d: "); try {putf ("->%0 d<-\n",0L);} catch (invfmt) {err ();}
put ("0 d: "); try {putf ("->%0 d<-\n",4L);} catch (invfmt) {err ();}
put ("# d: "); try {putf ("->%# d<-\n",-4L);} catch (invfmt) {err ();}
put ("# d: "); try {putf ("->%# d<-\n",0L);} catch (invfmt) {err ();}
put ("# d: "); try {putf ("->%# d<-\n",4L);} catch (invfmt) {err ();}
put (" d: "); try {putf ("->% d<-\n",-4L);} catch (invfmt) {err ();}
put (" d: "); try {putf ("->% d<-\n",0L);} catch (invfmt) {err ();}
put (" d: "); try {putf ("->% d<-\n",4L);} catch (invfmt) {err ();}
put ("#0-d: "); try {putf ("->%#0-d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-d: "); try {putf ("->%#0-d<-\n",0L);} catch (invfmt) {err ();}
put ("#0-d: "); try {putf ("->%#0-d<-\n",4L);} catch (invfmt) {err ();}
put ("0-d: "); try {putf ("->%0-d<-\n",-4L);} catch (invfmt) {err ();}
put ("0-d: "); try {putf ("->%0-d<-\n",0L);} catch (invfmt) {err ();}
put ("0-d: "); try {putf ("->%0-d<-\n",4L);} catch (invfmt) {err ();}
put ("#-d: "); try {putf ("->%#-d<-\n",-4L);} catch (invfmt) {err ();}
put ("#-d: "); try {putf ("->%#-d<-\n",0L);} catch (invfmt) {err ();}
put ("#-d: "); try {putf ("->%#-d<-\n",4L);} catch (invfmt) {err ();}
put ("-d: "); try {putf ("->%-d<-\n",-4L);} catch (invfmt) {err ();}
put ("-d: "); try {putf ("->%-d<-\n",0L);} catch (invfmt) {err ();}
put ("-d: "); try {putf ("->%-d<-\n",4L);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",0L);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",4L);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",-4L);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",0L);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",4L);} catch (invfmt) {err ();}
put ("#d: "); try {putf ("->%#d<-\n",-4L);} catch (invfmt) {err ();}
put ("#d: "); try {putf ("->%#d<-\n",0L);} catch (invfmt) {err ();}
put ("#d: "); try {putf ("->%#d<-\n",4L);} catch (invfmt) {err ();}
put ("d: "); try {putf ("->%d<-\n",-4L);} catch (invfmt) {err ();}
put ("d: "); try {putf ("->%d<-\n",0L);} catch (invfmt) {err ();}
put ("d: "); try {putf ("->%d<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +o: "); try {putf ("->%#0- +o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +o: "); try {putf ("->%#0- +o<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +o: "); try {putf ("->%#0- +o<-\n",4L);} catch (invfmt) {err ();}
put ("0- +o: "); try {putf ("->%0- +o<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +o: "); try {putf ("->%0- +o<-\n",0L);} catch (invfmt) {err ();}
put ("0- +o: "); try {putf ("->%0- +o<-\n",4L);} catch (invfmt) {err ();}
put ("#- +o: "); try {putf ("->%#- +o<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +o: "); try {putf ("->%#- +o<-\n",0L);} catch (invfmt) {err ();}
put ("#- +o: "); try {putf ("->%#- +o<-\n",4L);} catch (invfmt) {err ();}
put ("- +o: "); try {putf ("->%- +o<-\n",-4L);} catch (invfmt) {err ();}
put ("- +o: "); try {putf ("->%- +o<-\n",0L);} catch (invfmt) {err ();}
put ("- +o: "); try {putf ("->%- +o<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +o: "); try {putf ("->%#0 +o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +o: "); try {putf ("->%#0 +o<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +o: "); try {putf ("->%#0 +o<-\n",4L);} catch (invfmt) {err ();}
put ("0 +o: "); try {putf ("->%0 +o<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +o: "); try {putf ("->%0 +o<-\n",0L);} catch (invfmt) {err ();}
put ("0 +o: "); try {putf ("->%0 +o<-\n",4L);} catch (invfmt) {err ();}
put ("# +o: "); try {putf ("->%# +o<-\n",-4L);} catch (invfmt) {err ();}
put ("# +o: "); try {putf ("->%# +o<-\n",0L);} catch (invfmt) {err ();}
put ("# +o: "); try {putf ("->%# +o<-\n",4L);} catch (invfmt) {err ();}
put (" +o: "); try {putf ("->% +o<-\n",-4L);} catch (invfmt) {err ();}
put (" +o: "); try {putf ("->% +o<-\n",0L);} catch (invfmt) {err ();}
put (" +o: "); try {putf ("->% +o<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+o: "); try {putf ("->%#0-+o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+o: "); try {putf ("->%#0-+o<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+o: "); try {putf ("->%#0-+o<-\n",4L);} catch (invfmt) {err ();}
put ("0-+o: "); try {putf ("->%0-+o<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+o: "); try {putf ("->%0-+o<-\n",0L);} catch (invfmt) {err ();}
put ("0-+o: "); try {putf ("->%0-+o<-\n",4L);} catch (invfmt) {err ();}
put ("#-+o: "); try {putf ("->%#-+o<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+o: "); try {putf ("->%#-+o<-\n",0L);} catch (invfmt) {err ();}
put ("#-+o: "); try {putf ("->%#-+o<-\n",4L);} catch (invfmt) {err ();}
put ("-+o: "); try {putf ("->%-+o<-\n",-4L);} catch (invfmt) {err ();}
put ("-+o: "); try {putf ("->%-+o<-\n",0L);} catch (invfmt) {err ();}
put ("-+o: "); try {putf ("->%-+o<-\n",4L);} catch (invfmt) {err ();}
put ("#0+o: "); try {putf ("->%#0+o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+o: "); try {putf ("->%#0+o<-\n",0L);} catch (invfmt) {err ();}
put ("#0+o: "); try {putf ("->%#0+o<-\n",4L);} catch (invfmt) {err ();}
put ("0+o: "); try {putf ("->%0+o<-\n",-4L);} catch (invfmt) {err ();}
put ("0+o: "); try {putf ("->%0+o<-\n",0L);} catch (invfmt) {err ();}
put ("0+o: "); try {putf ("->%0+o<-\n",4L);} catch (invfmt) {err ();}
put ("#+o: "); try {putf ("->%#+o<-\n",-4L);} catch (invfmt) {err ();}
put ("#+o: "); try {putf ("->%#+o<-\n",0L);} catch (invfmt) {err ();}
put ("#+o: "); try {putf ("->%#+o<-\n",4L);} catch (invfmt) {err ();}
put ("+o: "); try {putf ("->%+o<-\n",-4L);} catch (invfmt) {err ();}
put ("+o: "); try {putf ("->%+o<-\n",0L);} catch (invfmt) {err ();}
put ("+o: "); try {putf ("->%+o<-\n",4L);} catch (invfmt) {err ();}
put ("#0- o: "); try {putf ("->%#0- o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- o: "); try {putf ("->%#0- o<-\n",0L);} catch (invfmt) {err ();}
put ("#0- o: "); try {putf ("->%#0- o<-\n",4L);} catch (invfmt) {err ();}
put ("0- o: "); try {putf ("->%0- o<-\n",-4L);} catch (invfmt) {err ();}
put ("0- o: "); try {putf ("->%0- o<-\n",0L);} catch (invfmt) {err ();}
put ("0- o: "); try {putf ("->%0- o<-\n",4L);} catch (invfmt) {err ();}
put ("#- o: "); try {putf ("->%#- o<-\n",-4L);} catch (invfmt) {err ();}
put ("#- o: "); try {putf ("->%#- o<-\n",0L);} catch (invfmt) {err ();}
put ("#- o: "); try {putf ("->%#- o<-\n",4L);} catch (invfmt) {err ();}
put ("- o: "); try {putf ("->%- o<-\n",-4L);} catch (invfmt) {err ();}
put ("- o: "); try {putf ("->%- o<-\n",0L);} catch (invfmt) {err ();}
put ("- o: "); try {putf ("->%- o<-\n",4L);} catch (invfmt) {err ();}
put ("#0 o: "); try {putf ("->%#0 o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 o: "); try {putf ("->%#0 o<-\n",0L);} catch (invfmt) {err ();}
put ("#0 o: "); try {putf ("->%#0 o<-\n",4L);} catch (invfmt) {err ();}
put ("0 o: "); try {putf ("->%0 o<-\n",-4L);} catch (invfmt) {err ();}
put ("0 o: "); try {putf ("->%0 o<-\n",0L);} catch (invfmt) {err ();}
put ("0 o: "); try {putf ("->%0 o<-\n",4L);} catch (invfmt) {err ();}
put ("# o: "); try {putf ("->%# o<-\n",-4L);} catch (invfmt) {err ();}
put ("# o: "); try {putf ("->%# o<-\n",0L);} catch (invfmt) {err ();}
put ("# o: "); try {putf ("->%# o<-\n",4L);} catch (invfmt) {err ();}
put (" o: "); try {putf ("->% o<-\n",-4L);} catch (invfmt) {err ();}
put (" o: "); try {putf ("->% o<-\n",0L);} catch (invfmt) {err ();}
put (" o: "); try {putf ("->% o<-\n",4L);} catch (invfmt) {err ();}
put ("#0-o: "); try {putf ("->%#0-o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-o: "); try {putf ("->%#0-o<-\n",0L);} catch (invfmt) {err ();}
put ("#0-o: "); try {putf ("->%#0-o<-\n",4L);} catch (invfmt) {err ();}
put ("0-o: "); try {putf ("->%0-o<-\n",-4L);} catch (invfmt) {err ();}
put ("0-o: "); try {putf ("->%0-o<-\n",0L);} catch (invfmt) {err ();}
put ("0-o: "); try {putf ("->%0-o<-\n",4L);} catch (invfmt) {err ();}
put ("#-o: "); try {putf ("->%#-o<-\n",-4L);} catch (invfmt) {err ();}
put ("#-o: "); try {putf ("->%#-o<-\n",0L);} catch (invfmt) {err ();}
put ("#-o: "); try {putf ("->%#-o<-\n",4L);} catch (invfmt) {err ();}
put ("-o: "); try {putf ("->%-o<-\n",-4L);} catch (invfmt) {err ();}
put ("-o: "); try {putf ("->%-o<-\n",0L);} catch (invfmt) {err ();}
put ("-o: "); try {putf ("->%-o<-\n",4L);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",0L);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",4L);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",-4L);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",0L);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",4L);} catch (invfmt) {err ();}
put ("#o: "); try {putf ("->%#o<-\n",-4L);} catch (invfmt) {err ();}
put ("#o: "); try {putf ("->%#o<-\n",0L);} catch (invfmt) {err ();}
put ("#o: "); try {putf ("->%#o<-\n",4L);} catch (invfmt) {err ();}
put ("o: "); try {putf ("->%o<-\n",-4L);} catch (invfmt) {err ();}
put ("o: "); try {putf ("->%o<-\n",0L);} catch (invfmt) {err ();}
put ("o: "); try {putf ("->%o<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +x: "); try {putf ("->%#0- +x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +x: "); try {putf ("->%#0- +x<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +x: "); try {putf ("->%#0- +x<-\n",4L);} catch (invfmt) {err ();}
put ("0- +x: "); try {putf ("->%0- +x<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +x: "); try {putf ("->%0- +x<-\n",0L);} catch (invfmt) {err ();}
put ("0- +x: "); try {putf ("->%0- +x<-\n",4L);} catch (invfmt) {err ();}
put ("#- +x: "); try {putf ("->%#- +x<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +x: "); try {putf ("->%#- +x<-\n",0L);} catch (invfmt) {err ();}
put ("#- +x: "); try {putf ("->%#- +x<-\n",4L);} catch (invfmt) {err ();}
put ("- +x: "); try {putf ("->%- +x<-\n",-4L);} catch (invfmt) {err ();}
put ("- +x: "); try {putf ("->%- +x<-\n",0L);} catch (invfmt) {err ();}
put ("- +x: "); try {putf ("->%- +x<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +x: "); try {putf ("->%#0 +x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +x: "); try {putf ("->%#0 +x<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +x: "); try {putf ("->%#0 +x<-\n",4L);} catch (invfmt) {err ();}
put ("0 +x: "); try {putf ("->%0 +x<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +x: "); try {putf ("->%0 +x<-\n",0L);} catch (invfmt) {err ();}
put ("0 +x: "); try {putf ("->%0 +x<-\n",4L);} catch (invfmt) {err ();}
put ("# +x: "); try {putf ("->%# +x<-\n",-4L);} catch (invfmt) {err ();}
put ("# +x: "); try {putf ("->%# +x<-\n",0L);} catch (invfmt) {err ();}
put ("# +x: "); try {putf ("->%# +x<-\n",4L);} catch (invfmt) {err ();}
put (" +x: "); try {putf ("->% +x<-\n",-4L);} catch (invfmt) {err ();}
put (" +x: "); try {putf ("->% +x<-\n",0L);} catch (invfmt) {err ();}
put (" +x: "); try {putf ("->% +x<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+x: "); try {putf ("->%#0-+x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+x: "); try {putf ("->%#0-+x<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+x: "); try {putf ("->%#0-+x<-\n",4L);} catch (invfmt) {err ();}
put ("0-+x: "); try {putf ("->%0-+x<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+x: "); try {putf ("->%0-+x<-\n",0L);} catch (invfmt) {err ();}
put ("0-+x: "); try {putf ("->%0-+x<-\n",4L);} catch (invfmt) {err ();}
put ("#-+x: "); try {putf ("->%#-+x<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+x: "); try {putf ("->%#-+x<-\n",0L);} catch (invfmt) {err ();}
put ("#-+x: "); try {putf ("->%#-+x<-\n",4L);} catch (invfmt) {err ();}
put ("-+x: "); try {putf ("->%-+x<-\n",-4L);} catch (invfmt) {err ();}
put ("-+x: "); try {putf ("->%-+x<-\n",0L);} catch (invfmt) {err ();}
put ("-+x: "); try {putf ("->%-+x<-\n",4L);} catch (invfmt) {err ();}
put ("#0+x: "); try {putf ("->%#0+x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+x: "); try {putf ("->%#0+x<-\n",0L);} catch (invfmt) {err ();}
put ("#0+x: "); try {putf ("->%#0+x<-\n",4L);} catch (invfmt) {err ();}
put ("0+x: "); try {putf ("->%0+x<-\n",-4L);} catch (invfmt) {err ();}
put ("0+x: "); try {putf ("->%0+x<-\n",0L);} catch (invfmt) {err ();}
put ("0+x: "); try {putf ("->%0+x<-\n",4L);} catch (invfmt) {err ();}
put ("#+x: "); try {putf ("->%#+x<-\n",-4L);} catch (invfmt) {err ();}
put ("#+x: "); try {putf ("->%#+x<-\n",0L);} catch (invfmt) {err ();}
put ("#+x: "); try {putf ("->%#+x<-\n",4L);} catch (invfmt) {err ();}
put ("+x: "); try {putf ("->%+x<-\n",-4L);} catch (invfmt) {err ();}
put ("+x: "); try {putf ("->%+x<-\n",0L);} catch (invfmt) {err ();}
put ("+x: "); try {putf ("->%+x<-\n",4L);} catch (invfmt) {err ();}
put ("#0- x: "); try {putf ("->%#0- x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- x: "); try {putf ("->%#0- x<-\n",0L);} catch (invfmt) {err ();}
put ("#0- x: "); try {putf ("->%#0- x<-\n",4L);} catch (invfmt) {err ();}
put ("0- x: "); try {putf ("->%0- x<-\n",-4L);} catch (invfmt) {err ();}
put ("0- x: "); try {putf ("->%0- x<-\n",0L);} catch (invfmt) {err ();}
put ("0- x: "); try {putf ("->%0- x<-\n",4L);} catch (invfmt) {err ();}
put ("#- x: "); try {putf ("->%#- x<-\n",-4L);} catch (invfmt) {err ();}
put ("#- x: "); try {putf ("->%#- x<-\n",0L);} catch (invfmt) {err ();}
put ("#- x: "); try {putf ("->%#- x<-\n",4L);} catch (invfmt) {err ();}
put ("- x: "); try {putf ("->%- x<-\n",-4L);} catch (invfmt) {err ();}
put ("- x: "); try {putf ("->%- x<-\n",0L);} catch (invfmt) {err ();}
put ("- x: "); try {putf ("->%- x<-\n",4L);} catch (invfmt) {err ();}
put ("#0 x: "); try {putf ("->%#0 x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 x: "); try {putf ("->%#0 x<-\n",0L);} catch (invfmt) {err ();}
put ("#0 x: "); try {putf ("->%#0 x<-\n",4L);} catch (invfmt) {err ();}
put ("0 x: "); try {putf ("->%0 x<-\n",-4L);} catch (invfmt) {err ();}
put ("0 x: "); try {putf ("->%0 x<-\n",0L);} catch (invfmt) {err ();}
put ("0 x: "); try {putf ("->%0 x<-\n",4L);} catch (invfmt) {err ();}
put ("# x: "); try {putf ("->%# x<-\n",-4L);} catch (invfmt) {err ();}
put ("# x: "); try {putf ("->%# x<-\n",0L);} catch (invfmt) {err ();}
put ("# x: "); try {putf ("->%# x<-\n",4L);} catch (invfmt) {err ();}
put (" x: "); try {putf ("->% x<-\n",-4L);} catch (invfmt) {err ();}
put (" x: "); try {putf ("->% x<-\n",0L);} catch (invfmt) {err ();}
put (" x: "); try {putf ("->% x<-\n",4L);} catch (invfmt) {err ();}
put ("#0-x: "); try {putf ("->%#0-x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-x: "); try {putf ("->%#0-x<-\n",0L);} catch (invfmt) {err ();}
put ("#0-x: "); try {putf ("->%#0-x<-\n",4L);} catch (invfmt) {err ();}
put ("0-x: "); try {putf ("->%0-x<-\n",-4L);} catch (invfmt) {err ();}
put ("0-x: "); try {putf ("->%0-x<-\n",0L);} catch (invfmt) {err ();}
put ("0-x: "); try {putf ("->%0-x<-\n",4L);} catch (invfmt) {err ();}
put ("#-x: "); try {putf ("->%#-x<-\n",-4L);} catch (invfmt) {err ();}
put ("#-x: "); try {putf ("->%#-x<-\n",0L);} catch (invfmt) {err ();}
put ("#-x: "); try {putf ("->%#-x<-\n",4L);} catch (invfmt) {err ();}
put ("-x: "); try {putf ("->%-x<-\n",-4L);} catch (invfmt) {err ();}
put ("-x: "); try {putf ("->%-x<-\n",0L);} catch (invfmt) {err ();}
put ("-x: "); try {putf ("->%-x<-\n",4L);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",0L);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",4L);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",-4L);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",0L);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",4L);} catch (invfmt) {err ();}
put ("#x: "); try {putf ("->%#x<-\n",-4L);} catch (invfmt) {err ();}
put ("#x: "); try {putf ("->%#x<-\n",0L);} catch (invfmt) {err ();}
put ("#x: "); try {putf ("->%#x<-\n",4L);} catch (invfmt) {err ();}
put ("x: "); try {putf ("->%x<-\n",-4L);} catch (invfmt) {err ();}
put ("x: "); try {putf ("->%x<-\n",0L);} catch (invfmt) {err ();}
put ("x: "); try {putf ("->%x<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +X: "); try {putf ("->%#0- +X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +X: "); try {putf ("->%#0- +X<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +X: "); try {putf ("->%#0- +X<-\n",4L);} catch (invfmt) {err ();}
put ("0- +X: "); try {putf ("->%0- +X<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +X: "); try {putf ("->%0- +X<-\n",0L);} catch (invfmt) {err ();}
put ("0- +X: "); try {putf ("->%0- +X<-\n",4L);} catch (invfmt) {err ();}
put ("#- +X: "); try {putf ("->%#- +X<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +X: "); try {putf ("->%#- +X<-\n",0L);} catch (invfmt) {err ();}
put ("#- +X: "); try {putf ("->%#- +X<-\n",4L);} catch (invfmt) {err ();}
put ("- +X: "); try {putf ("->%- +X<-\n",-4L);} catch (invfmt) {err ();}
put ("- +X: "); try {putf ("->%- +X<-\n",0L);} catch (invfmt) {err ();}
put ("- +X: "); try {putf ("->%- +X<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +X: "); try {putf ("->%#0 +X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +X: "); try {putf ("->%#0 +X<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +X: "); try {putf ("->%#0 +X<-\n",4L);} catch (invfmt) {err ();}
put ("0 +X: "); try {putf ("->%0 +X<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +X: "); try {putf ("->%0 +X<-\n",0L);} catch (invfmt) {err ();}
put ("0 +X: "); try {putf ("->%0 +X<-\n",4L);} catch (invfmt) {err ();}
put ("# +X: "); try {putf ("->%# +X<-\n",-4L);} catch (invfmt) {err ();}
put ("# +X: "); try {putf ("->%# +X<-\n",0L);} catch (invfmt) {err ();}
put ("# +X: "); try {putf ("->%# +X<-\n",4L);} catch (invfmt) {err ();}
put (" +X: "); try {putf ("->% +X<-\n",-4L);} catch (invfmt) {err ();}
put (" +X: "); try {putf ("->% +X<-\n",0L);} catch (invfmt) {err ();}
put (" +X: "); try {putf ("->% +X<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+X: "); try {putf ("->%#0-+X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+X: "); try {putf ("->%#0-+X<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+X: "); try {putf ("->%#0-+X<-\n",4L);} catch (invfmt) {err ();}
put ("0-+X: "); try {putf ("->%0-+X<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+X: "); try {putf ("->%0-+X<-\n",0L);} catch (invfmt) {err ();}
put ("0-+X: "); try {putf ("->%0-+X<-\n",4L);} catch (invfmt) {err ();}
put ("#-+X: "); try {putf ("->%#-+X<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+X: "); try {putf ("->%#-+X<-\n",0L);} catch (invfmt) {err ();}
put ("#-+X: "); try {putf ("->%#-+X<-\n",4L);} catch (invfmt) {err ();}
put ("-+X: "); try {putf ("->%-+X<-\n",-4L);} catch (invfmt) {err ();}
put ("-+X: "); try {putf ("->%-+X<-\n",0L);} catch (invfmt) {err ();}
put ("-+X: "); try {putf ("->%-+X<-\n",4L);} catch (invfmt) {err ();}
put ("#0+X: "); try {putf ("->%#0+X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+X: "); try {putf ("->%#0+X<-\n",0L);} catch (invfmt) {err ();}
put ("#0+X: "); try {putf ("->%#0+X<-\n",4L);} catch (invfmt) {err ();}
put ("0+X: "); try {putf ("->%0+X<-\n",-4L);} catch (invfmt) {err ();}
put ("0+X: "); try {putf ("->%0+X<-\n",0L);} catch (invfmt) {err ();}
put ("0+X: "); try {putf ("->%0+X<-\n",4L);} catch (invfmt) {err ();}
put ("#+X: "); try {putf ("->%#+X<-\n",-4L);} catch (invfmt) {err ();}
put ("#+X: "); try {putf ("->%#+X<-\n",0L);} catch (invfmt) {err ();}
put ("#+X: "); try {putf ("->%#+X<-\n",4L);} catch (invfmt) {err ();}
put ("+X: "); try {putf ("->%+X<-\n",-4L);} catch (invfmt) {err ();}
put ("+X: "); try {putf ("->%+X<-\n",0L);} catch (invfmt) {err ();}
put ("+X: "); try {putf ("->%+X<-\n",4L);} catch (invfmt) {err ();}
put ("#0- X: "); try {putf ("->%#0- X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- X: "); try {putf ("->%#0- X<-\n",0L);} catch (invfmt) {err ();}
put ("#0- X: "); try {putf ("->%#0- X<-\n",4L);} catch (invfmt) {err ();}
put ("0- X: "); try {putf ("->%0- X<-\n",-4L);} catch (invfmt) {err ();}
put ("0- X: "); try {putf ("->%0- X<-\n",0L);} catch (invfmt) {err ();}
put ("0- X: "); try {putf ("->%0- X<-\n",4L);} catch (invfmt) {err ();}
put ("#- X: "); try {putf ("->%#- X<-\n",-4L);} catch (invfmt) {err ();}
put ("#- X: "); try {putf ("->%#- X<-\n",0L);} catch (invfmt) {err ();}
put ("#- X: "); try {putf ("->%#- X<-\n",4L);} catch (invfmt) {err ();}
put ("- X: "); try {putf ("->%- X<-\n",-4L);} catch (invfmt) {err ();}
put ("- X: "); try {putf ("->%- X<-\n",0L);} catch (invfmt) {err ();}
put ("- X: "); try {putf ("->%- X<-\n",4L);} catch (invfmt) {err ();}
put ("#0 X: "); try {putf ("->%#0 X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 X: "); try {putf ("->%#0 X<-\n",0L);} catch (invfmt) {err ();}
put ("#0 X: "); try {putf ("->%#0 X<-\n",4L);} catch (invfmt) {err ();}
put ("0 X: "); try {putf ("->%0 X<-\n",-4L);} catch (invfmt) {err ();}
put ("0 X: "); try {putf ("->%0 X<-\n",0L);} catch (invfmt) {err ();}
put ("0 X: "); try {putf ("->%0 X<-\n",4L);} catch (invfmt) {err ();}
put ("# X: "); try {putf ("->%# X<-\n",-4L);} catch (invfmt) {err ();}
put ("# X: "); try {putf ("->%# X<-\n",0L);} catch (invfmt) {err ();}
put ("# X: "); try {putf ("->%# X<-\n",4L);} catch (invfmt) {err ();}
put (" X: "); try {putf ("->% X<-\n",-4L);} catch (invfmt) {err ();}
put (" X: "); try {putf ("->% X<-\n",0L);} catch (invfmt) {err ();}
put (" X: "); try {putf ("->% X<-\n",4L);} catch (invfmt) {err ();}
put ("#0-X: "); try {putf ("->%#0-X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-X: "); try {putf ("->%#0-X<-\n",0L);} catch (invfmt) {err ();}
put ("#0-X: "); try {putf ("->%#0-X<-\n",4L);} catch (invfmt) {err ();}
put ("0-X: "); try {putf ("->%0-X<-\n",-4L);} catch (invfmt) {err ();}
put ("0-X: "); try {putf ("->%0-X<-\n",0L);} catch (invfmt) {err ();}
put ("0-X: "); try {putf ("->%0-X<-\n",4L);} catch (invfmt) {err ();}
put ("#-X: "); try {putf ("->%#-X<-\n",-4L);} catch (invfmt) {err ();}
put ("#-X: "); try {putf ("->%#-X<-\n",0L);} catch (invfmt) {err ();}
put ("#-X: "); try {putf ("->%#-X<-\n",4L);} catch (invfmt) {err ();}
put ("-X: "); try {putf ("->%-X<-\n",-4L);} catch (invfmt) {err ();}
put ("-X: "); try {putf ("->%-X<-\n",0L);} catch (invfmt) {err ();}
put ("-X: "); try {putf ("->%-X<-\n",4L);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",0L);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",4L);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",-4L);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",0L);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",4L);} catch (invfmt) {err ();}
put ("#X: "); try {putf ("->%#X<-\n",-4L);} catch (invfmt) {err ();}
put ("#X: "); try {putf ("->%#X<-\n",0L);} catch (invfmt) {err ();}
put ("#X: "); try {putf ("->%#X<-\n",4L);} catch (invfmt) {err ();}
put ("X: "); try {putf ("->%X<-\n",-4L);} catch (invfmt) {err ();}
put ("X: "); try {putf ("->%X<-\n",0L);} catch (invfmt) {err ();}
put ("X: "); try {putf ("->%X<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +0d: "); try {putf ("->%#0- +0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +0d: "); try {putf ("->%#0- +0d<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +0d: "); try {putf ("->%#0- +0d<-\n",4L);} catch (invfmt) {err ();}
put ("0- +0d: "); try {putf ("->%0- +0d<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +0d: "); try {putf ("->%0- +0d<-\n",0L);} catch (invfmt) {err ();}
put ("0- +0d: "); try {putf ("->%0- +0d<-\n",4L);} catch (invfmt) {err ();}
put ("#- +0d: "); try {putf ("->%#- +0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +0d: "); try {putf ("->%#- +0d<-\n",0L);} catch (invfmt) {err ();}
put ("#- +0d: "); try {putf ("->%#- +0d<-\n",4L);} catch (invfmt) {err ();}
put ("- +0d: "); try {putf ("->%- +0d<-\n",-4L);} catch (invfmt) {err ();}
put ("- +0d: "); try {putf ("->%- +0d<-\n",0L);} catch (invfmt) {err ();}
put ("- +0d: "); try {putf ("->%- +0d<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +0d: "); try {putf ("->%#0 +0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +0d: "); try {putf ("->%#0 +0d<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +0d: "); try {putf ("->%#0 +0d<-\n",4L);} catch (invfmt) {err ();}
put ("0 +0d: "); try {putf ("->%0 +0d<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +0d: "); try {putf ("->%0 +0d<-\n",0L);} catch (invfmt) {err ();}
put ("0 +0d: "); try {putf ("->%0 +0d<-\n",4L);} catch (invfmt) {err ();}
put ("# +0d: "); try {putf ("->%# +0d<-\n",-4L);} catch (invfmt) {err ();}
put ("# +0d: "); try {putf ("->%# +0d<-\n",0L);} catch (invfmt) {err ();}
put ("# +0d: "); try {putf ("->%# +0d<-\n",4L);} catch (invfmt) {err ();}
put (" +0d: "); try {putf ("->% +0d<-\n",-4L);} catch (invfmt) {err ();}
put (" +0d: "); try {putf ("->% +0d<-\n",0L);} catch (invfmt) {err ();}
put (" +0d: "); try {putf ("->% +0d<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+0d: "); try {putf ("->%#0-+0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+0d: "); try {putf ("->%#0-+0d<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+0d: "); try {putf ("->%#0-+0d<-\n",4L);} catch (invfmt) {err ();}
put ("0-+0d: "); try {putf ("->%0-+0d<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+0d: "); try {putf ("->%0-+0d<-\n",0L);} catch (invfmt) {err ();}
put ("0-+0d: "); try {putf ("->%0-+0d<-\n",4L);} catch (invfmt) {err ();}
put ("#-+0d: "); try {putf ("->%#-+0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+0d: "); try {putf ("->%#-+0d<-\n",0L);} catch (invfmt) {err ();}
put ("#-+0d: "); try {putf ("->%#-+0d<-\n",4L);} catch (invfmt) {err ();}
put ("-+0d: "); try {putf ("->%-+0d<-\n",-4L);} catch (invfmt) {err ();}
put ("-+0d: "); try {putf ("->%-+0d<-\n",0L);} catch (invfmt) {err ();}
put ("-+0d: "); try {putf ("->%-+0d<-\n",4L);} catch (invfmt) {err ();}
put ("#0+0d: "); try {putf ("->%#0+0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+0d: "); try {putf ("->%#0+0d<-\n",0L);} catch (invfmt) {err ();}
put ("#0+0d: "); try {putf ("->%#0+0d<-\n",4L);} catch (invfmt) {err ();}
put ("0+0d: "); try {putf ("->%0+0d<-\n",-4L);} catch (invfmt) {err ();}
put ("0+0d: "); try {putf ("->%0+0d<-\n",0L);} catch (invfmt) {err ();}
put ("0+0d: "); try {putf ("->%0+0d<-\n",4L);} catch (invfmt) {err ();}
put ("#+0d: "); try {putf ("->%#+0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#+0d: "); try {putf ("->%#+0d<-\n",0L);} catch (invfmt) {err ();}
put ("#+0d: "); try {putf ("->%#+0d<-\n",4L);} catch (invfmt) {err ();}
put ("+0d: "); try {putf ("->%+0d<-\n",-4L);} catch (invfmt) {err ();}
put ("+0d: "); try {putf ("->%+0d<-\n",0L);} catch (invfmt) {err ();}
put ("+0d: "); try {putf ("->%+0d<-\n",4L);} catch (invfmt) {err ();}
put ("#0- 0d: "); try {putf ("->%#0- 0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- 0d: "); try {putf ("->%#0- 0d<-\n",0L);} catch (invfmt) {err ();}
put ("#0- 0d: "); try {putf ("->%#0- 0d<-\n",4L);} catch (invfmt) {err ();}
put ("0- 0d: "); try {putf ("->%0- 0d<-\n",-4L);} catch (invfmt) {err ();}
put ("0- 0d: "); try {putf ("->%0- 0d<-\n",0L);} catch (invfmt) {err ();}
put ("0- 0d: "); try {putf ("->%0- 0d<-\n",4L);} catch (invfmt) {err ();}
put ("#- 0d: "); try {putf ("->%#- 0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#- 0d: "); try {putf ("->%#- 0d<-\n",0L);} catch (invfmt) {err ();}
put ("#- 0d: "); try {putf ("->%#- 0d<-\n",4L);} catch (invfmt) {err ();}
put ("- 0d: "); try {putf ("->%- 0d<-\n",-4L);} catch (invfmt) {err ();}
put ("- 0d: "); try {putf ("->%- 0d<-\n",0L);} catch (invfmt) {err ();}
put ("- 0d: "); try {putf ("->%- 0d<-\n",4L);} catch (invfmt) {err ();}
put ("#0 0d: "); try {putf ("->%#0 0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 0d: "); try {putf ("->%#0 0d<-\n",0L);} catch (invfmt) {err ();}
put ("#0 0d: "); try {putf ("->%#0 0d<-\n",4L);} catch (invfmt) {err ();}
put ("0 0d: "); try {putf ("->%0 0d<-\n",-4L);} catch (invfmt) {err ();}
put ("0 0d: "); try {putf ("->%0 0d<-\n",0L);} catch (invfmt) {err ();}
put ("0 0d: "); try {putf ("->%0 0d<-\n",4L);} catch (invfmt) {err ();}
put ("# 0d: "); try {putf ("->%# 0d<-\n",-4L);} catch (invfmt) {err ();}
put ("# 0d: "); try {putf ("->%# 0d<-\n",0L);} catch (invfmt) {err ();}
put ("# 0d: "); try {putf ("->%# 0d<-\n",4L);} catch (invfmt) {err ();}
put (" 0d: "); try {putf ("->% 0d<-\n",-4L);} catch (invfmt) {err ();}
put (" 0d: "); try {putf ("->% 0d<-\n",0L);} catch (invfmt) {err ();}
put (" 0d: "); try {putf ("->% 0d<-\n",4L);} catch (invfmt) {err ();}
put ("#0-0d: "); try {putf ("->%#0-0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-0d: "); try {putf ("->%#0-0d<-\n",0L);} catch (invfmt) {err ();}
put ("#0-0d: "); try {putf ("->%#0-0d<-\n",4L);} catch (invfmt) {err ();}
put ("0-0d: "); try {putf ("->%0-0d<-\n",-4L);} catch (invfmt) {err ();}
put ("0-0d: "); try {putf ("->%0-0d<-\n",0L);} catch (invfmt) {err ();}
put ("0-0d: "); try {putf ("->%0-0d<-\n",4L);} catch (invfmt) {err ();}
put ("#-0d: "); try {putf ("->%#-0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#-0d: "); try {putf ("->%#-0d<-\n",0L);} catch (invfmt) {err ();}
put ("#-0d: "); try {putf ("->%#-0d<-\n",4L);} catch (invfmt) {err ();}
put ("-0d: "); try {putf ("->%-0d<-\n",-4L);} catch (invfmt) {err ();}
put ("-0d: "); try {putf ("->%-0d<-\n",0L);} catch (invfmt) {err ();}
put ("-0d: "); try {putf ("->%-0d<-\n",4L);} catch (invfmt) {err ();}
put ("#00d: "); try {putf ("->%#00d<-\n",-4L);} catch (invfmt) {err ();}
put ("#00d: "); try {putf ("->%#00d<-\n",0L);} catch (invfmt) {err ();}
put ("#00d: "); try {putf ("->%#00d<-\n",4L);} catch (invfmt) {err ();}
put ("00d: "); try {putf ("->%00d<-\n",-4L);} catch (invfmt) {err ();}
put ("00d: "); try {putf ("->%00d<-\n",0L);} catch (invfmt) {err ();}
put ("00d: "); try {putf ("->%00d<-\n",4L);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",0L);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",4L);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",-4L);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",0L);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +0o: "); try {putf ("->%#0- +0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +0o: "); try {putf ("->%#0- +0o<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +0o: "); try {putf ("->%#0- +0o<-\n",4L);} catch (invfmt) {err ();}
put ("0- +0o: "); try {putf ("->%0- +0o<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +0o: "); try {putf ("->%0- +0o<-\n",0L);} catch (invfmt) {err ();}
put ("0- +0o: "); try {putf ("->%0- +0o<-\n",4L);} catch (invfmt) {err ();}
put ("#- +0o: "); try {putf ("->%#- +0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +0o: "); try {putf ("->%#- +0o<-\n",0L);} catch (invfmt) {err ();}
put ("#- +0o: "); try {putf ("->%#- +0o<-\n",4L);} catch (invfmt) {err ();}
put ("- +0o: "); try {putf ("->%- +0o<-\n",-4L);} catch (invfmt) {err ();}
put ("- +0o: "); try {putf ("->%- +0o<-\n",0L);} catch (invfmt) {err ();}
put ("- +0o: "); try {putf ("->%- +0o<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +0o: "); try {putf ("->%#0 +0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +0o: "); try {putf ("->%#0 +0o<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +0o: "); try {putf ("->%#0 +0o<-\n",4L);} catch (invfmt) {err ();}
put ("0 +0o: "); try {putf ("->%0 +0o<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +0o: "); try {putf ("->%0 +0o<-\n",0L);} catch (invfmt) {err ();}
put ("0 +0o: "); try {putf ("->%0 +0o<-\n",4L);} catch (invfmt) {err ();}
put ("# +0o: "); try {putf ("->%# +0o<-\n",-4L);} catch (invfmt) {err ();}
put ("# +0o: "); try {putf ("->%# +0o<-\n",0L);} catch (invfmt) {err ();}
put ("# +0o: "); try {putf ("->%# +0o<-\n",4L);} catch (invfmt) {err ();}
put (" +0o: "); try {putf ("->% +0o<-\n",-4L);} catch (invfmt) {err ();}
put (" +0o: "); try {putf ("->% +0o<-\n",0L);} catch (invfmt) {err ();}
put (" +0o: "); try {putf ("->% +0o<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+0o: "); try {putf ("->%#0-+0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+0o: "); try {putf ("->%#0-+0o<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+0o: "); try {putf ("->%#0-+0o<-\n",4L);} catch (invfmt) {err ();}
put ("0-+0o: "); try {putf ("->%0-+0o<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+0o: "); try {putf ("->%0-+0o<-\n",0L);} catch (invfmt) {err ();}
put ("0-+0o: "); try {putf ("->%0-+0o<-\n",4L);} catch (invfmt) {err ();}
put ("#-+0o: "); try {putf ("->%#-+0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+0o: "); try {putf ("->%#-+0o<-\n",0L);} catch (invfmt) {err ();}
put ("#-+0o: "); try {putf ("->%#-+0o<-\n",4L);} catch (invfmt) {err ();}
put ("-+0o: "); try {putf ("->%-+0o<-\n",-4L);} catch (invfmt) {err ();}
put ("-+0o: "); try {putf ("->%-+0o<-\n",0L);} catch (invfmt) {err ();}
put ("-+0o: "); try {putf ("->%-+0o<-\n",4L);} catch (invfmt) {err ();}
put ("#0+0o: "); try {putf ("->%#0+0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+0o: "); try {putf ("->%#0+0o<-\n",0L);} catch (invfmt) {err ();}
put ("#0+0o: "); try {putf ("->%#0+0o<-\n",4L);} catch (invfmt) {err ();}
put ("0+0o: "); try {putf ("->%0+0o<-\n",-4L);} catch (invfmt) {err ();}
put ("0+0o: "); try {putf ("->%0+0o<-\n",0L);} catch (invfmt) {err ();}
put ("0+0o: "); try {putf ("->%0+0o<-\n",4L);} catch (invfmt) {err ();}
put ("#+0o: "); try {putf ("->%#+0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#+0o: "); try {putf ("->%#+0o<-\n",0L);} catch (invfmt) {err ();}
put ("#+0o: "); try {putf ("->%#+0o<-\n",4L);} catch (invfmt) {err ();}
put ("+0o: "); try {putf ("->%+0o<-\n",-4L);} catch (invfmt) {err ();}
put ("+0o: "); try {putf ("->%+0o<-\n",0L);} catch (invfmt) {err ();}
put ("+0o: "); try {putf ("->%+0o<-\n",4L);} catch (invfmt) {err ();}
put ("#0- 0o: "); try {putf ("->%#0- 0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- 0o: "); try {putf ("->%#0- 0o<-\n",0L);} catch (invfmt) {err ();}
put ("#0- 0o: "); try {putf ("->%#0- 0o<-\n",4L);} catch (invfmt) {err ();}
put ("0- 0o: "); try {putf ("->%0- 0o<-\n",-4L);} catch (invfmt) {err ();}
put ("0- 0o: "); try {putf ("->%0- 0o<-\n",0L);} catch (invfmt) {err ();}
put ("0- 0o: "); try {putf ("->%0- 0o<-\n",4L);} catch (invfmt) {err ();}
put ("#- 0o: "); try {putf ("->%#- 0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#- 0o: "); try {putf ("->%#- 0o<-\n",0L);} catch (invfmt) {err ();}
put ("#- 0o: "); try {putf ("->%#- 0o<-\n",4L);} catch (invfmt) {err ();}
put ("- 0o: "); try {putf ("->%- 0o<-\n",-4L);} catch (invfmt) {err ();}
put ("- 0o: "); try {putf ("->%- 0o<-\n",0L);} catch (invfmt) {err ();}
put ("- 0o: "); try {putf ("->%- 0o<-\n",4L);} catch (invfmt) {err ();}
put ("#0 0o: "); try {putf ("->%#0 0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 0o: "); try {putf ("->%#0 0o<-\n",0L);} catch (invfmt) {err ();}
put ("#0 0o: "); try {putf ("->%#0 0o<-\n",4L);} catch (invfmt) {err ();}
put ("0 0o: "); try {putf ("->%0 0o<-\n",-4L);} catch (invfmt) {err ();}
put ("0 0o: "); try {putf ("->%0 0o<-\n",0L);} catch (invfmt) {err ();}
put ("0 0o: "); try {putf ("->%0 0o<-\n",4L);} catch (invfmt) {err ();}
put ("# 0o: "); try {putf ("->%# 0o<-\n",-4L);} catch (invfmt) {err ();}
put ("# 0o: "); try {putf ("->%# 0o<-\n",0L);} catch (invfmt) {err ();}
put ("# 0o: "); try {putf ("->%# 0o<-\n",4L);} catch (invfmt) {err ();}
put (" 0o: "); try {putf ("->% 0o<-\n",-4L);} catch (invfmt) {err ();}
put (" 0o: "); try {putf ("->% 0o<-\n",0L);} catch (invfmt) {err ();}
put (" 0o: "); try {putf ("->% 0o<-\n",4L);} catch (invfmt) {err ();}
put ("#0-0o: "); try {putf ("->%#0-0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-0o: "); try {putf ("->%#0-0o<-\n",0L);} catch (invfmt) {err ();}
put ("#0-0o: "); try {putf ("->%#0-0o<-\n",4L);} catch (invfmt) {err ();}
put ("0-0o: "); try {putf ("->%0-0o<-\n",-4L);} catch (invfmt) {err ();}
put ("0-0o: "); try {putf ("->%0-0o<-\n",0L);} catch (invfmt) {err ();}
put ("0-0o: "); try {putf ("->%0-0o<-\n",4L);} catch (invfmt) {err ();}
put ("#-0o: "); try {putf ("->%#-0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#-0o: "); try {putf ("->%#-0o<-\n",0L);} catch (invfmt) {err ();}
put ("#-0o: "); try {putf ("->%#-0o<-\n",4L);} catch (invfmt) {err ();}
put ("-0o: "); try {putf ("->%-0o<-\n",-4L);} catch (invfmt) {err ();}
put ("-0o: "); try {putf ("->%-0o<-\n",0L);} catch (invfmt) {err ();}
put ("-0o: "); try {putf ("->%-0o<-\n",4L);} catch (invfmt) {err ();}
put ("#00o: "); try {putf ("->%#00o<-\n",-4L);} catch (invfmt) {err ();}
put ("#00o: "); try {putf ("->%#00o<-\n",0L);} catch (invfmt) {err ();}
put ("#00o: "); try {putf ("->%#00o<-\n",4L);} catch (invfmt) {err ();}
put ("00o: "); try {putf ("->%00o<-\n",-4L);} catch (invfmt) {err ();}
put ("00o: "); try {putf ("->%00o<-\n",0L);} catch (invfmt) {err ();}
put ("00o: "); try {putf ("->%00o<-\n",4L);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",0L);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",4L);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",-4L);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",0L);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +0x: "); try {putf ("->%#0- +0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +0x: "); try {putf ("->%#0- +0x<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +0x: "); try {putf ("->%#0- +0x<-\n",4L);} catch (invfmt) {err ();}
put ("0- +0x: "); try {putf ("->%0- +0x<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +0x: "); try {putf ("->%0- +0x<-\n",0L);} catch (invfmt) {err ();}
put ("0- +0x: "); try {putf ("->%0- +0x<-\n",4L);} catch (invfmt) {err ();}
put ("#- +0x: "); try {putf ("->%#- +0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +0x: "); try {putf ("->%#- +0x<-\n",0L);} catch (invfmt) {err ();}
put ("#- +0x: "); try {putf ("->%#- +0x<-\n",4L);} catch (invfmt) {err ();}
put ("- +0x: "); try {putf ("->%- +0x<-\n",-4L);} catch (invfmt) {err ();}
put ("- +0x: "); try {putf ("->%- +0x<-\n",0L);} catch (invfmt) {err ();}
put ("- +0x: "); try {putf ("->%- +0x<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +0x: "); try {putf ("->%#0 +0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +0x: "); try {putf ("->%#0 +0x<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +0x: "); try {putf ("->%#0 +0x<-\n",4L);} catch (invfmt) {err ();}
put ("0 +0x: "); try {putf ("->%0 +0x<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +0x: "); try {putf ("->%0 +0x<-\n",0L);} catch (invfmt) {err ();}
put ("0 +0x: "); try {putf ("->%0 +0x<-\n",4L);} catch (invfmt) {err ();}
put ("# +0x: "); try {putf ("->%# +0x<-\n",-4L);} catch (invfmt) {err ();}
put ("# +0x: "); try {putf ("->%# +0x<-\n",0L);} catch (invfmt) {err ();}
put ("# +0x: "); try {putf ("->%# +0x<-\n",4L);} catch (invfmt) {err ();}
put (" +0x: "); try {putf ("->% +0x<-\n",-4L);} catch (invfmt) {err ();}
put (" +0x: "); try {putf ("->% +0x<-\n",0L);} catch (invfmt) {err ();}
put (" +0x: "); try {putf ("->% +0x<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+0x: "); try {putf ("->%#0-+0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+0x: "); try {putf ("->%#0-+0x<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+0x: "); try {putf ("->%#0-+0x<-\n",4L);} catch (invfmt) {err ();}
put ("0-+0x: "); try {putf ("->%0-+0x<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+0x: "); try {putf ("->%0-+0x<-\n",0L);} catch (invfmt) {err ();}
put ("0-+0x: "); try {putf ("->%0-+0x<-\n",4L);} catch (invfmt) {err ();}
put ("#-+0x: "); try {putf ("->%#-+0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+0x: "); try {putf ("->%#-+0x<-\n",0L);} catch (invfmt) {err ();}
put ("#-+0x: "); try {putf ("->%#-+0x<-\n",4L);} catch (invfmt) {err ();}
put ("-+0x: "); try {putf ("->%-+0x<-\n",-4L);} catch (invfmt) {err ();}
put ("-+0x: "); try {putf ("->%-+0x<-\n",0L);} catch (invfmt) {err ();}
put ("-+0x: "); try {putf ("->%-+0x<-\n",4L);} catch (invfmt) {err ();}
put ("#0+0x: "); try {putf ("->%#0+0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+0x: "); try {putf ("->%#0+0x<-\n",0L);} catch (invfmt) {err ();}
put ("#0+0x: "); try {putf ("->%#0+0x<-\n",4L);} catch (invfmt) {err ();}
put ("0+0x: "); try {putf ("->%0+0x<-\n",-4L);} catch (invfmt) {err ();}
put ("0+0x: "); try {putf ("->%0+0x<-\n",0L);} catch (invfmt) {err ();}
put ("0+0x: "); try {putf ("->%0+0x<-\n",4L);} catch (invfmt) {err ();}
put ("#+0x: "); try {putf ("->%#+0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#+0x: "); try {putf ("->%#+0x<-\n",0L);} catch (invfmt) {err ();}
put ("#+0x: "); try {putf ("->%#+0x<-\n",4L);} catch (invfmt) {err ();}
put ("+0x: "); try {putf ("->%+0x<-\n",-4L);} catch (invfmt) {err ();}
put ("+0x: "); try {putf ("->%+0x<-\n",0L);} catch (invfmt) {err ();}
put ("+0x: "); try {putf ("->%+0x<-\n",4L);} catch (invfmt) {err ();}
put ("#0- 0x: "); try {putf ("->%#0- 0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- 0x: "); try {putf ("->%#0- 0x<-\n",0L);} catch (invfmt) {err ();}
put ("#0- 0x: "); try {putf ("->%#0- 0x<-\n",4L);} catch (invfmt) {err ();}
put ("0- 0x: "); try {putf ("->%0- 0x<-\n",-4L);} catch (invfmt) {err ();}
put ("0- 0x: "); try {putf ("->%0- 0x<-\n",0L);} catch (invfmt) {err ();}
put ("0- 0x: "); try {putf ("->%0- 0x<-\n",4L);} catch (invfmt) {err ();}
put ("#- 0x: "); try {putf ("->%#- 0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#- 0x: "); try {putf ("->%#- 0x<-\n",0L);} catch (invfmt) {err ();}
put ("#- 0x: "); try {putf ("->%#- 0x<-\n",4L);} catch (invfmt) {err ();}
put ("- 0x: "); try {putf ("->%- 0x<-\n",-4L);} catch (invfmt) {err ();}
put ("- 0x: "); try {putf ("->%- 0x<-\n",0L);} catch (invfmt) {err ();}
put ("- 0x: "); try {putf ("->%- 0x<-\n",4L);} catch (invfmt) {err ();}
put ("#0 0x: "); try {putf ("->%#0 0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 0x: "); try {putf ("->%#0 0x<-\n",0L);} catch (invfmt) {err ();}
put ("#0 0x: "); try {putf ("->%#0 0x<-\n",4L);} catch (invfmt) {err ();}
put ("0 0x: "); try {putf ("->%0 0x<-\n",-4L);} catch (invfmt) {err ();}
put ("0 0x: "); try {putf ("->%0 0x<-\n",0L);} catch (invfmt) {err ();}
put ("0 0x: "); try {putf ("->%0 0x<-\n",4L);} catch (invfmt) {err ();}
put ("# 0x: "); try {putf ("->%# 0x<-\n",-4L);} catch (invfmt) {err ();}
put ("# 0x: "); try {putf ("->%# 0x<-\n",0L);} catch (invfmt) {err ();}
put ("# 0x: "); try {putf ("->%# 0x<-\n",4L);} catch (invfmt) {err ();}
put (" 0x: "); try {putf ("->% 0x<-\n",-4L);} catch (invfmt) {err ();}
put (" 0x: "); try {putf ("->% 0x<-\n",0L);} catch (invfmt) {err ();}
put (" 0x: "); try {putf ("->% 0x<-\n",4L);} catch (invfmt) {err ();}
put ("#0-0x: "); try {putf ("->%#0-0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-0x: "); try {putf ("->%#0-0x<-\n",0L);} catch (invfmt) {err ();}
put ("#0-0x: "); try {putf ("->%#0-0x<-\n",4L);} catch (invfmt) {err ();}
put ("0-0x: "); try {putf ("->%0-0x<-\n",-4L);} catch (invfmt) {err ();}
put ("0-0x: "); try {putf ("->%0-0x<-\n",0L);} catch (invfmt) {err ();}
put ("0-0x: "); try {putf ("->%0-0x<-\n",4L);} catch (invfmt) {err ();}
put ("#-0x: "); try {putf ("->%#-0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#-0x: "); try {putf ("->%#-0x<-\n",0L);} catch (invfmt) {err ();}
put ("#-0x: "); try {putf ("->%#-0x<-\n",4L);} catch (invfmt) {err ();}
put ("-0x: "); try {putf ("->%-0x<-\n",-4L);} catch (invfmt) {err ();}
put ("-0x: "); try {putf ("->%-0x<-\n",0L);} catch (invfmt) {err ();}
put ("-0x: "); try {putf ("->%-0x<-\n",4L);} catch (invfmt) {err ();}
put ("#00x: "); try {putf ("->%#00x<-\n",-4L);} catch (invfmt) {err ();}
put ("#00x: "); try {putf ("->%#00x<-\n",0L);} catch (invfmt) {err ();}
put ("#00x: "); try {putf ("->%#00x<-\n",4L);} catch (invfmt) {err ();}
put ("00x: "); try {putf ("->%00x<-\n",-4L);} catch (invfmt) {err ();}
put ("00x: "); try {putf ("->%00x<-\n",0L);} catch (invfmt) {err ();}
put ("00x: "); try {putf ("->%00x<-\n",4L);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",0L);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",4L);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",-4L);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",0L);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +0X: "); try {putf ("->%#0- +0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +0X: "); try {putf ("->%#0- +0X<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +0X: "); try {putf ("->%#0- +0X<-\n",4L);} catch (invfmt) {err ();}
put ("0- +0X: "); try {putf ("->%0- +0X<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +0X: "); try {putf ("->%0- +0X<-\n",0L);} catch (invfmt) {err ();}
put ("0- +0X: "); try {putf ("->%0- +0X<-\n",4L);} catch (invfmt) {err ();}
put ("#- +0X: "); try {putf ("->%#- +0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +0X: "); try {putf ("->%#- +0X<-\n",0L);} catch (invfmt) {err ();}
put ("#- +0X: "); try {putf ("->%#- +0X<-\n",4L);} catch (invfmt) {err ();}
put ("- +0X: "); try {putf ("->%- +0X<-\n",-4L);} catch (invfmt) {err ();}
put ("- +0X: "); try {putf ("->%- +0X<-\n",0L);} catch (invfmt) {err ();}
put ("- +0X: "); try {putf ("->%- +0X<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +0X: "); try {putf ("->%#0 +0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +0X: "); try {putf ("->%#0 +0X<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +0X: "); try {putf ("->%#0 +0X<-\n",4L);} catch (invfmt) {err ();}
put ("0 +0X: "); try {putf ("->%0 +0X<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +0X: "); try {putf ("->%0 +0X<-\n",0L);} catch (invfmt) {err ();}
put ("0 +0X: "); try {putf ("->%0 +0X<-\n",4L);} catch (invfmt) {err ();}
put ("# +0X: "); try {putf ("->%# +0X<-\n",-4L);} catch (invfmt) {err ();}
put ("# +0X: "); try {putf ("->%# +0X<-\n",0L);} catch (invfmt) {err ();}
put ("# +0X: "); try {putf ("->%# +0X<-\n",4L);} catch (invfmt) {err ();}
put (" +0X: "); try {putf ("->% +0X<-\n",-4L);} catch (invfmt) {err ();}
put (" +0X: "); try {putf ("->% +0X<-\n",0L);} catch (invfmt) {err ();}
put (" +0X: "); try {putf ("->% +0X<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+0X: "); try {putf ("->%#0-+0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+0X: "); try {putf ("->%#0-+0X<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+0X: "); try {putf ("->%#0-+0X<-\n",4L);} catch (invfmt) {err ();}
put ("0-+0X: "); try {putf ("->%0-+0X<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+0X: "); try {putf ("->%0-+0X<-\n",0L);} catch (invfmt) {err ();}
put ("0-+0X: "); try {putf ("->%0-+0X<-\n",4L);} catch (invfmt) {err ();}
put ("#-+0X: "); try {putf ("->%#-+0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+0X: "); try {putf ("->%#-+0X<-\n",0L);} catch (invfmt) {err ();}
put ("#-+0X: "); try {putf ("->%#-+0X<-\n",4L);} catch (invfmt) {err ();}
put ("-+0X: "); try {putf ("->%-+0X<-\n",-4L);} catch (invfmt) {err ();}
put ("-+0X: "); try {putf ("->%-+0X<-\n",0L);} catch (invfmt) {err ();}
put ("-+0X: "); try {putf ("->%-+0X<-\n",4L);} catch (invfmt) {err ();}
put ("#0+0X: "); try {putf ("->%#0+0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+0X: "); try {putf ("->%#0+0X<-\n",0L);} catch (invfmt) {err ();}
put ("#0+0X: "); try {putf ("->%#0+0X<-\n",4L);} catch (invfmt) {err ();}
put ("0+0X: "); try {putf ("->%0+0X<-\n",-4L);} catch (invfmt) {err ();}
put ("0+0X: "); try {putf ("->%0+0X<-\n",0L);} catch (invfmt) {err ();}
put ("0+0X: "); try {putf ("->%0+0X<-\n",4L);} catch (invfmt) {err ();}
put ("#+0X: "); try {putf ("->%#+0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#+0X: "); try {putf ("->%#+0X<-\n",0L);} catch (invfmt) {err ();}
put ("#+0X: "); try {putf ("->%#+0X<-\n",4L);} catch (invfmt) {err ();}
put ("+0X: "); try {putf ("->%+0X<-\n",-4L);} catch (invfmt) {err ();}
put ("+0X: "); try {putf ("->%+0X<-\n",0L);} catch (invfmt) {err ();}
put ("+0X: "); try {putf ("->%+0X<-\n",4L);} catch (invfmt) {err ();}
put ("#0- 0X: "); try {putf ("->%#0- 0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- 0X: "); try {putf ("->%#0- 0X<-\n",0L);} catch (invfmt) {err ();}
put ("#0- 0X: "); try {putf ("->%#0- 0X<-\n",4L);} catch (invfmt) {err ();}
put ("0- 0X: "); try {putf ("->%0- 0X<-\n",-4L);} catch (invfmt) {err ();}
put ("0- 0X: "); try {putf ("->%0- 0X<-\n",0L);} catch (invfmt) {err ();}
put ("0- 0X: "); try {putf ("->%0- 0X<-\n",4L);} catch (invfmt) {err ();}
put ("#- 0X: "); try {putf ("->%#- 0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#- 0X: "); try {putf ("->%#- 0X<-\n",0L);} catch (invfmt) {err ();}
put ("#- 0X: "); try {putf ("->%#- 0X<-\n",4L);} catch (invfmt) {err ();}
put ("- 0X: "); try {putf ("->%- 0X<-\n",-4L);} catch (invfmt) {err ();}
put ("- 0X: "); try {putf ("->%- 0X<-\n",0L);} catch (invfmt) {err ();}
put ("- 0X: "); try {putf ("->%- 0X<-\n",4L);} catch (invfmt) {err ();}
put ("#0 0X: "); try {putf ("->%#0 0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 0X: "); try {putf ("->%#0 0X<-\n",0L);} catch (invfmt) {err ();}
put ("#0 0X: "); try {putf ("->%#0 0X<-\n",4L);} catch (invfmt) {err ();}
put ("0 0X: "); try {putf ("->%0 0X<-\n",-4L);} catch (invfmt) {err ();}
put ("0 0X: "); try {putf ("->%0 0X<-\n",0L);} catch (invfmt) {err ();}
put ("0 0X: "); try {putf ("->%0 0X<-\n",4L);} catch (invfmt) {err ();}
put ("# 0X: "); try {putf ("->%# 0X<-\n",-4L);} catch (invfmt) {err ();}
put ("# 0X: "); try {putf ("->%# 0X<-\n",0L);} catch (invfmt) {err ();}
put ("# 0X: "); try {putf ("->%# 0X<-\n",4L);} catch (invfmt) {err ();}
put (" 0X: "); try {putf ("->% 0X<-\n",-4L);} catch (invfmt) {err ();}
put (" 0X: "); try {putf ("->% 0X<-\n",0L);} catch (invfmt) {err ();}
put (" 0X: "); try {putf ("->% 0X<-\n",4L);} catch (invfmt) {err ();}
put ("#0-0X: "); try {putf ("->%#0-0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-0X: "); try {putf ("->%#0-0X<-\n",0L);} catch (invfmt) {err ();}
put ("#0-0X: "); try {putf ("->%#0-0X<-\n",4L);} catch (invfmt) {err ();}
put ("0-0X: "); try {putf ("->%0-0X<-\n",-4L);} catch (invfmt) {err ();}
put ("0-0X: "); try {putf ("->%0-0X<-\n",0L);} catch (invfmt) {err ();}
put ("0-0X: "); try {putf ("->%0-0X<-\n",4L);} catch (invfmt) {err ();}
put ("#-0X: "); try {putf ("->%#-0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#-0X: "); try {putf ("->%#-0X<-\n",0L);} catch (invfmt) {err ();}
put ("#-0X: "); try {putf ("->%#-0X<-\n",4L);} catch (invfmt) {err ();}
put ("-0X: "); try {putf ("->%-0X<-\n",-4L);} catch (invfmt) {err ();}
put ("-0X: "); try {putf ("->%-0X<-\n",0L);} catch (invfmt) {err ();}
put ("-0X: "); try {putf ("->%-0X<-\n",4L);} catch (invfmt) {err ();}
put ("#00X: "); try {putf ("->%#00X<-\n",-4L);} catch (invfmt) {err ();}
put ("#00X: "); try {putf ("->%#00X<-\n",0L);} catch (invfmt) {err ();}
put ("#00X: "); try {putf ("->%#00X<-\n",4L);} catch (invfmt) {err ();}
put ("00X: "); try {putf ("->%00X<-\n",-4L);} catch (invfmt) {err ();}
put ("00X: "); try {putf ("->%00X<-\n",0L);} catch (invfmt) {err ();}
put ("00X: "); try {putf ("->%00X<-\n",4L);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",0L);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",4L);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",-4L);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",0L);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +10d: "); try {putf ("->%#0- +10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +10d: "); try {putf ("->%#0- +10d<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +10d: "); try {putf ("->%#0- +10d<-\n",4L);} catch (invfmt) {err ();}
put ("0- +10d: "); try {putf ("->%0- +10d<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +10d: "); try {putf ("->%0- +10d<-\n",0L);} catch (invfmt) {err ();}
put ("0- +10d: "); try {putf ("->%0- +10d<-\n",4L);} catch (invfmt) {err ();}
put ("#- +10d: "); try {putf ("->%#- +10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +10d: "); try {putf ("->%#- +10d<-\n",0L);} catch (invfmt) {err ();}
put ("#- +10d: "); try {putf ("->%#- +10d<-\n",4L);} catch (invfmt) {err ();}
put ("- +10d: "); try {putf ("->%- +10d<-\n",-4L);} catch (invfmt) {err ();}
put ("- +10d: "); try {putf ("->%- +10d<-\n",0L);} catch (invfmt) {err ();}
put ("- +10d: "); try {putf ("->%- +10d<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +10d: "); try {putf ("->%#0 +10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +10d: "); try {putf ("->%#0 +10d<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +10d: "); try {putf ("->%#0 +10d<-\n",4L);} catch (invfmt) {err ();}
put ("0 +10d: "); try {putf ("->%0 +10d<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +10d: "); try {putf ("->%0 +10d<-\n",0L);} catch (invfmt) {err ();}
put ("0 +10d: "); try {putf ("->%0 +10d<-\n",4L);} catch (invfmt) {err ();}
put ("# +10d: "); try {putf ("->%# +10d<-\n",-4L);} catch (invfmt) {err ();}
put ("# +10d: "); try {putf ("->%# +10d<-\n",0L);} catch (invfmt) {err ();}
put ("# +10d: "); try {putf ("->%# +10d<-\n",4L);} catch (invfmt) {err ();}
put (" +10d: "); try {putf ("->% +10d<-\n",-4L);} catch (invfmt) {err ();}
put (" +10d: "); try {putf ("->% +10d<-\n",0L);} catch (invfmt) {err ();}
put (" +10d: "); try {putf ("->% +10d<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+10d: "); try {putf ("->%#0-+10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+10d: "); try {putf ("->%#0-+10d<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+10d: "); try {putf ("->%#0-+10d<-\n",4L);} catch (invfmt) {err ();}
put ("0-+10d: "); try {putf ("->%0-+10d<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+10d: "); try {putf ("->%0-+10d<-\n",0L);} catch (invfmt) {err ();}
put ("0-+10d: "); try {putf ("->%0-+10d<-\n",4L);} catch (invfmt) {err ();}
put ("#-+10d: "); try {putf ("->%#-+10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+10d: "); try {putf ("->%#-+10d<-\n",0L);} catch (invfmt) {err ();}
put ("#-+10d: "); try {putf ("->%#-+10d<-\n",4L);} catch (invfmt) {err ();}
put ("-+10d: "); try {putf ("->%-+10d<-\n",-4L);} catch (invfmt) {err ();}
put ("-+10d: "); try {putf ("->%-+10d<-\n",0L);} catch (invfmt) {err ();}
put ("-+10d: "); try {putf ("->%-+10d<-\n",4L);} catch (invfmt) {err ();}
put ("#0+10d: "); try {putf ("->%#0+10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+10d: "); try {putf ("->%#0+10d<-\n",0L);} catch (invfmt) {err ();}
put ("#0+10d: "); try {putf ("->%#0+10d<-\n",4L);} catch (invfmt) {err ();}
put ("0+10d: "); try {putf ("->%0+10d<-\n",-4L);} catch (invfmt) {err ();}
put ("0+10d: "); try {putf ("->%0+10d<-\n",0L);} catch (invfmt) {err ();}
put ("0+10d: "); try {putf ("->%0+10d<-\n",4L);} catch (invfmt) {err ();}
put ("#+10d: "); try {putf ("->%#+10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#+10d: "); try {putf ("->%#+10d<-\n",0L);} catch (invfmt) {err ();}
put ("#+10d: "); try {putf ("->%#+10d<-\n",4L);} catch (invfmt) {err ();}
put ("+10d: "); try {putf ("->%+10d<-\n",-4L);} catch (invfmt) {err ();}
put ("+10d: "); try {putf ("->%+10d<-\n",0L);} catch (invfmt) {err ();}
put ("+10d: "); try {putf ("->%+10d<-\n",4L);} catch (invfmt) {err ();}
put ("#0- 10d: "); try {putf ("->%#0- 10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- 10d: "); try {putf ("->%#0- 10d<-\n",0L);} catch (invfmt) {err ();}
put ("#0- 10d: "); try {putf ("->%#0- 10d<-\n",4L);} catch (invfmt) {err ();}
put ("0- 10d: "); try {putf ("->%0- 10d<-\n",-4L);} catch (invfmt) {err ();}
put ("0- 10d: "); try {putf ("->%0- 10d<-\n",0L);} catch (invfmt) {err ();}
put ("0- 10d: "); try {putf ("->%0- 10d<-\n",4L);} catch (invfmt) {err ();}
put ("#- 10d: "); try {putf ("->%#- 10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#- 10d: "); try {putf ("->%#- 10d<-\n",0L);} catch (invfmt) {err ();}
put ("#- 10d: "); try {putf ("->%#- 10d<-\n",4L);} catch (invfmt) {err ();}
put ("- 10d: "); try {putf ("->%- 10d<-\n",-4L);} catch (invfmt) {err ();}
put ("- 10d: "); try {putf ("->%- 10d<-\n",0L);} catch (invfmt) {err ();}
put ("- 10d: "); try {putf ("->%- 10d<-\n",4L);} catch (invfmt) {err ();}
put ("#0 10d: "); try {putf ("->%#0 10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 10d: "); try {putf ("->%#0 10d<-\n",0L);} catch (invfmt) {err ();}
put ("#0 10d: "); try {putf ("->%#0 10d<-\n",4L);} catch (invfmt) {err ();}
put ("0 10d: "); try {putf ("->%0 10d<-\n",-4L);} catch (invfmt) {err ();}
put ("0 10d: "); try {putf ("->%0 10d<-\n",0L);} catch (invfmt) {err ();}
put ("0 10d: "); try {putf ("->%0 10d<-\n",4L);} catch (invfmt) {err ();}
put ("# 10d: "); try {putf ("->%# 10d<-\n",-4L);} catch (invfmt) {err ();}
put ("# 10d: "); try {putf ("->%# 10d<-\n",0L);} catch (invfmt) {err ();}
put ("# 10d: "); try {putf ("->%# 10d<-\n",4L);} catch (invfmt) {err ();}
put (" 10d: "); try {putf ("->% 10d<-\n",-4L);} catch (invfmt) {err ();}
put (" 10d: "); try {putf ("->% 10d<-\n",0L);} catch (invfmt) {err ();}
put (" 10d: "); try {putf ("->% 10d<-\n",4L);} catch (invfmt) {err ();}
put ("#0-10d: "); try {putf ("->%#0-10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-10d: "); try {putf ("->%#0-10d<-\n",0L);} catch (invfmt) {err ();}
put ("#0-10d: "); try {putf ("->%#0-10d<-\n",4L);} catch (invfmt) {err ();}
put ("0-10d: "); try {putf ("->%0-10d<-\n",-4L);} catch (invfmt) {err ();}
put ("0-10d: "); try {putf ("->%0-10d<-\n",0L);} catch (invfmt) {err ();}
put ("0-10d: "); try {putf ("->%0-10d<-\n",4L);} catch (invfmt) {err ();}
put ("#-10d: "); try {putf ("->%#-10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#-10d: "); try {putf ("->%#-10d<-\n",0L);} catch (invfmt) {err ();}
put ("#-10d: "); try {putf ("->%#-10d<-\n",4L);} catch (invfmt) {err ();}
put ("-10d: "); try {putf ("->%-10d<-\n",-4L);} catch (invfmt) {err ();}
put ("-10d: "); try {putf ("->%-10d<-\n",0L);} catch (invfmt) {err ();}
put ("-10d: "); try {putf ("->%-10d<-\n",4L);} catch (invfmt) {err ();}
put ("#010d: "); try {putf ("->%#010d<-\n",-4L);} catch (invfmt) {err ();}
put ("#010d: "); try {putf ("->%#010d<-\n",0L);} catch (invfmt) {err ();}
put ("#010d: "); try {putf ("->%#010d<-\n",4L);} catch (invfmt) {err ();}
put ("010d: "); try {putf ("->%010d<-\n",-4L);} catch (invfmt) {err ();}
put ("010d: "); try {putf ("->%010d<-\n",0L);} catch (invfmt) {err ();}
put ("010d: "); try {putf ("->%010d<-\n",4L);} catch (invfmt) {err ();}
put ("#10d: "); try {putf ("->%#10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#10d: "); try {putf ("->%#10d<-\n",0L);} catch (invfmt) {err ();}
put ("#10d: "); try {putf ("->%#10d<-\n",4L);} catch (invfmt) {err ();}
put ("10d: "); try {putf ("->%10d<-\n",-4L);} catch (invfmt) {err ();}
put ("10d: "); try {putf ("->%10d<-\n",0L);} catch (invfmt) {err ();}
put ("10d: "); try {putf ("->%10d<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +10o: "); try {putf ("->%#0- +10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +10o: "); try {putf ("->%#0- +10o<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +10o: "); try {putf ("->%#0- +10o<-\n",4L);} catch (invfmt) {err ();}
put ("0- +10o: "); try {putf ("->%0- +10o<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +10o: "); try {putf ("->%0- +10o<-\n",0L);} catch (invfmt) {err ();}
put ("0- +10o: "); try {putf ("->%0- +10o<-\n",4L);} catch (invfmt) {err ();}
put ("#- +10o: "); try {putf ("->%#- +10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +10o: "); try {putf ("->%#- +10o<-\n",0L);} catch (invfmt) {err ();}
put ("#- +10o: "); try {putf ("->%#- +10o<-\n",4L);} catch (invfmt) {err ();}
put ("- +10o: "); try {putf ("->%- +10o<-\n",-4L);} catch (invfmt) {err ();}
put ("- +10o: "); try {putf ("->%- +10o<-\n",0L);} catch (invfmt) {err ();}
put ("- +10o: "); try {putf ("->%- +10o<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +10o: "); try {putf ("->%#0 +10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +10o: "); try {putf ("->%#0 +10o<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +10o: "); try {putf ("->%#0 +10o<-\n",4L);} catch (invfmt) {err ();}
put ("0 +10o: "); try {putf ("->%0 +10o<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +10o: "); try {putf ("->%0 +10o<-\n",0L);} catch (invfmt) {err ();}
put ("0 +10o: "); try {putf ("->%0 +10o<-\n",4L);} catch (invfmt) {err ();}
put ("# +10o: "); try {putf ("->%# +10o<-\n",-4L);} catch (invfmt) {err ();}
put ("# +10o: "); try {putf ("->%# +10o<-\n",0L);} catch (invfmt) {err ();}
put ("# +10o: "); try {putf ("->%# +10o<-\n",4L);} catch (invfmt) {err ();}
put (" +10o: "); try {putf ("->% +10o<-\n",-4L);} catch (invfmt) {err ();}
put (" +10o: "); try {putf ("->% +10o<-\n",0L);} catch (invfmt) {err ();}
put (" +10o: "); try {putf ("->% +10o<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+10o: "); try {putf ("->%#0-+10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+10o: "); try {putf ("->%#0-+10o<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+10o: "); try {putf ("->%#0-+10o<-\n",4L);} catch (invfmt) {err ();}
put ("0-+10o: "); try {putf ("->%0-+10o<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+10o: "); try {putf ("->%0-+10o<-\n",0L);} catch (invfmt) {err ();}
put ("0-+10o: "); try {putf ("->%0-+10o<-\n",4L);} catch (invfmt) {err ();}
put ("#-+10o: "); try {putf ("->%#-+10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+10o: "); try {putf ("->%#-+10o<-\n",0L);} catch (invfmt) {err ();}
put ("#-+10o: "); try {putf ("->%#-+10o<-\n",4L);} catch (invfmt) {err ();}
put ("-+10o: "); try {putf ("->%-+10o<-\n",-4L);} catch (invfmt) {err ();}
put ("-+10o: "); try {putf ("->%-+10o<-\n",0L);} catch (invfmt) {err ();}
put ("-+10o: "); try {putf ("->%-+10o<-\n",4L);} catch (invfmt) {err ();}
put ("#0+10o: "); try {putf ("->%#0+10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+10o: "); try {putf ("->%#0+10o<-\n",0L);} catch (invfmt) {err ();}
put ("#0+10o: "); try {putf ("->%#0+10o<-\n",4L);} catch (invfmt) {err ();}
put ("0+10o: "); try {putf ("->%0+10o<-\n",-4L);} catch (invfmt) {err ();}
put ("0+10o: "); try {putf ("->%0+10o<-\n",0L);} catch (invfmt) {err ();}
put ("0+10o: "); try {putf ("->%0+10o<-\n",4L);} catch (invfmt) {err ();}
put ("#+10o: "); try {putf ("->%#+10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#+10o: "); try {putf ("->%#+10o<-\n",0L);} catch (invfmt) {err ();}
put ("#+10o: "); try {putf ("->%#+10o<-\n",4L);} catch (invfmt) {err ();}
put ("+10o: "); try {putf ("->%+10o<-\n",-4L);} catch (invfmt) {err ();}
put ("+10o: "); try {putf ("->%+10o<-\n",0L);} catch (invfmt) {err ();}
put ("+10o: "); try {putf ("->%+10o<-\n",4L);} catch (invfmt) {err ();}
put ("#0- 10o: "); try {putf ("->%#0- 10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- 10o: "); try {putf ("->%#0- 10o<-\n",0L);} catch (invfmt) {err ();}
put ("#0- 10o: "); try {putf ("->%#0- 10o<-\n",4L);} catch (invfmt) {err ();}
put ("0- 10o: "); try {putf ("->%0- 10o<-\n",-4L);} catch (invfmt) {err ();}
put ("0- 10o: "); try {putf ("->%0- 10o<-\n",0L);} catch (invfmt) {err ();}
put ("0- 10o: "); try {putf ("->%0- 10o<-\n",4L);} catch (invfmt) {err ();}
put ("#- 10o: "); try {putf ("->%#- 10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#- 10o: "); try {putf ("->%#- 10o<-\n",0L);} catch (invfmt) {err ();}
put ("#- 10o: "); try {putf ("->%#- 10o<-\n",4L);} catch (invfmt) {err ();}
put ("- 10o: "); try {putf ("->%- 10o<-\n",-4L);} catch (invfmt) {err ();}
put ("- 10o: "); try {putf ("->%- 10o<-\n",0L);} catch (invfmt) {err ();}
put ("- 10o: "); try {putf ("->%- 10o<-\n",4L);} catch (invfmt) {err ();}
put ("#0 10o: "); try {putf ("->%#0 10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 10o: "); try {putf ("->%#0 10o<-\n",0L);} catch (invfmt) {err ();}
put ("#0 10o: "); try {putf ("->%#0 10o<-\n",4L);} catch (invfmt) {err ();}
put ("0 10o: "); try {putf ("->%0 10o<-\n",-4L);} catch (invfmt) {err ();}
put ("0 10o: "); try {putf ("->%0 10o<-\n",0L);} catch (invfmt) {err ();}
put ("0 10o: "); try {putf ("->%0 10o<-\n",4L);} catch (invfmt) {err ();}
put ("# 10o: "); try {putf ("->%# 10o<-\n",-4L);} catch (invfmt) {err ();}
put ("# 10o: "); try {putf ("->%# 10o<-\n",0L);} catch (invfmt) {err ();}
put ("# 10o: "); try {putf ("->%# 10o<-\n",4L);} catch (invfmt) {err ();}
put (" 10o: "); try {putf ("->% 10o<-\n",-4L);} catch (invfmt) {err ();}
put (" 10o: "); try {putf ("->% 10o<-\n",0L);} catch (invfmt) {err ();}
put (" 10o: "); try {putf ("->% 10o<-\n",4L);} catch (invfmt) {err ();}
put ("#0-10o: "); try {putf ("->%#0-10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-10o: "); try {putf ("->%#0-10o<-\n",0L);} catch (invfmt) {err ();}
put ("#0-10o: "); try {putf ("->%#0-10o<-\n",4L);} catch (invfmt) {err ();}
put ("0-10o: "); try {putf ("->%0-10o<-\n",-4L);} catch (invfmt) {err ();}
put ("0-10o: "); try {putf ("->%0-10o<-\n",0L);} catch (invfmt) {err ();}
put ("0-10o: "); try {putf ("->%0-10o<-\n",4L);} catch (invfmt) {err ();}
put ("#-10o: "); try {putf ("->%#-10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#-10o: "); try {putf ("->%#-10o<-\n",0L);} catch (invfmt) {err ();}
put ("#-10o: "); try {putf ("->%#-10o<-\n",4L);} catch (invfmt) {err ();}
put ("-10o: "); try {putf ("->%-10o<-\n",-4L);} catch (invfmt) {err ();}
put ("-10o: "); try {putf ("->%-10o<-\n",0L);} catch (invfmt) {err ();}
put ("-10o: "); try {putf ("->%-10o<-\n",4L);} catch (invfmt) {err ();}
put ("#010o: "); try {putf ("->%#010o<-\n",-4L);} catch (invfmt) {err ();}
put ("#010o: "); try {putf ("->%#010o<-\n",0L);} catch (invfmt) {err ();}
put ("#010o: "); try {putf ("->%#010o<-\n",4L);} catch (invfmt) {err ();}
put ("010o: "); try {putf ("->%010o<-\n",-4L);} catch (invfmt) {err ();}
put ("010o: "); try {putf ("->%010o<-\n",0L);} catch (invfmt) {err ();}
put ("010o: "); try {putf ("->%010o<-\n",4L);} catch (invfmt) {err ();}
put ("#10o: "); try {putf ("->%#10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#10o: "); try {putf ("->%#10o<-\n",0L);} catch (invfmt) {err ();}
put ("#10o: "); try {putf ("->%#10o<-\n",4L);} catch (invfmt) {err ();}
put ("10o: "); try {putf ("->%10o<-\n",-4L);} catch (invfmt) {err ();}
put ("10o: "); try {putf ("->%10o<-\n",0L);} catch (invfmt) {err ();}
put ("10o: "); try {putf ("->%10o<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +10x: "); try {putf ("->%#0- +10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +10x: "); try {putf ("->%#0- +10x<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +10x: "); try {putf ("->%#0- +10x<-\n",4L);} catch (invfmt) {err ();}
put ("0- +10x: "); try {putf ("->%0- +10x<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +10x: "); try {putf ("->%0- +10x<-\n",0L);} catch (invfmt) {err ();}
put ("0- +10x: "); try {putf ("->%0- +10x<-\n",4L);} catch (invfmt) {err ();}
put ("#- +10x: "); try {putf ("->%#- +10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +10x: "); try {putf ("->%#- +10x<-\n",0L);} catch (invfmt) {err ();}
put ("#- +10x: "); try {putf ("->%#- +10x<-\n",4L);} catch (invfmt) {err ();}
put ("- +10x: "); try {putf ("->%- +10x<-\n",-4L);} catch (invfmt) {err ();}
put ("- +10x: "); try {putf ("->%- +10x<-\n",0L);} catch (invfmt) {err ();}
put ("- +10x: "); try {putf ("->%- +10x<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +10x: "); try {putf ("->%#0 +10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +10x: "); try {putf ("->%#0 +10x<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +10x: "); try {putf ("->%#0 +10x<-\n",4L);} catch (invfmt) {err ();}
put ("0 +10x: "); try {putf ("->%0 +10x<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +10x: "); try {putf ("->%0 +10x<-\n",0L);} catch (invfmt) {err ();}
put ("0 +10x: "); try {putf ("->%0 +10x<-\n",4L);} catch (invfmt) {err ();}
put ("# +10x: "); try {putf ("->%# +10x<-\n",-4L);} catch (invfmt) {err ();}
put ("# +10x: "); try {putf ("->%# +10x<-\n",0L);} catch (invfmt) {err ();}
put ("# +10x: "); try {putf ("->%# +10x<-\n",4L);} catch (invfmt) {err ();}
put (" +10x: "); try {putf ("->% +10x<-\n",-4L);} catch (invfmt) {err ();}
put (" +10x: "); try {putf ("->% +10x<-\n",0L);} catch (invfmt) {err ();}
put (" +10x: "); try {putf ("->% +10x<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+10x: "); try {putf ("->%#0-+10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+10x: "); try {putf ("->%#0-+10x<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+10x: "); try {putf ("->%#0-+10x<-\n",4L);} catch (invfmt) {err ();}
put ("0-+10x: "); try {putf ("->%0-+10x<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+10x: "); try {putf ("->%0-+10x<-\n",0L);} catch (invfmt) {err ();}
put ("0-+10x: "); try {putf ("->%0-+10x<-\n",4L);} catch (invfmt) {err ();}
put ("#-+10x: "); try {putf ("->%#-+10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+10x: "); try {putf ("->%#-+10x<-\n",0L);} catch (invfmt) {err ();}
put ("#-+10x: "); try {putf ("->%#-+10x<-\n",4L);} catch (invfmt) {err ();}
put ("-+10x: "); try {putf ("->%-+10x<-\n",-4L);} catch (invfmt) {err ();}
put ("-+10x: "); try {putf ("->%-+10x<-\n",0L);} catch (invfmt) {err ();}
put ("-+10x: "); try {putf ("->%-+10x<-\n",4L);} catch (invfmt) {err ();}
put ("#0+10x: "); try {putf ("->%#0+10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+10x: "); try {putf ("->%#0+10x<-\n",0L);} catch (invfmt) {err ();}
put ("#0+10x: "); try {putf ("->%#0+10x<-\n",4L);} catch (invfmt) {err ();}
put ("0+10x: "); try {putf ("->%0+10x<-\n",-4L);} catch (invfmt) {err ();}
put ("0+10x: "); try {putf ("->%0+10x<-\n",0L);} catch (invfmt) {err ();}
put ("0+10x: "); try {putf ("->%0+10x<-\n",4L);} catch (invfmt) {err ();}
put ("#+10x: "); try {putf ("->%#+10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#+10x: "); try {putf ("->%#+10x<-\n",0L);} catch (invfmt) {err ();}
put ("#+10x: "); try {putf ("->%#+10x<-\n",4L);} catch (invfmt) {err ();}
put ("+10x: "); try {putf ("->%+10x<-\n",-4L);} catch (invfmt) {err ();}
put ("+10x: "); try {putf ("->%+10x<-\n",0L);} catch (invfmt) {err ();}
put ("+10x: "); try {putf ("->%+10x<-\n",4L);} catch (invfmt) {err ();}
put ("#0- 10x: "); try {putf ("->%#0- 10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- 10x: "); try {putf ("->%#0- 10x<-\n",0L);} catch (invfmt) {err ();}
put ("#0- 10x: "); try {putf ("->%#0- 10x<-\n",4L);} catch (invfmt) {err ();}
put ("0- 10x: "); try {putf ("->%0- 10x<-\n",-4L);} catch (invfmt) {err ();}
put ("0- 10x: "); try {putf ("->%0- 10x<-\n",0L);} catch (invfmt) {err ();}
put ("0- 10x: "); try {putf ("->%0- 10x<-\n",4L);} catch (invfmt) {err ();}
put ("#- 10x: "); try {putf ("->%#- 10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#- 10x: "); try {putf ("->%#- 10x<-\n",0L);} catch (invfmt) {err ();}
put ("#- 10x: "); try {putf ("->%#- 10x<-\n",4L);} catch (invfmt) {err ();}
put ("- 10x: "); try {putf ("->%- 10x<-\n",-4L);} catch (invfmt) {err ();}
put ("- 10x: "); try {putf ("->%- 10x<-\n",0L);} catch (invfmt) {err ();}
put ("- 10x: "); try {putf ("->%- 10x<-\n",4L);} catch (invfmt) {err ();}
put ("#0 10x: "); try {putf ("->%#0 10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 10x: "); try {putf ("->%#0 10x<-\n",0L);} catch (invfmt) {err ();}
put ("#0 10x: "); try {putf ("->%#0 10x<-\n",4L);} catch (invfmt) {err ();}
put ("0 10x: "); try {putf ("->%0 10x<-\n",-4L);} catch (invfmt) {err ();}
put ("0 10x: "); try {putf ("->%0 10x<-\n",0L);} catch (invfmt) {err ();}
put ("0 10x: "); try {putf ("->%0 10x<-\n",4L);} catch (invfmt) {err ();}
put ("# 10x: "); try {putf ("->%# 10x<-\n",-4L);} catch (invfmt) {err ();}
put ("# 10x: "); try {putf ("->%# 10x<-\n",0L);} catch (invfmt) {err ();}
put ("# 10x: "); try {putf ("->%# 10x<-\n",4L);} catch (invfmt) {err ();}
put (" 10x: "); try {putf ("->% 10x<-\n",-4L);} catch (invfmt) {err ();}
put (" 10x: "); try {putf ("->% 10x<-\n",0L);} catch (invfmt) {err ();}
put (" 10x: "); try {putf ("->% 10x<-\n",4L);} catch (invfmt) {err ();}
put ("#0-10x: "); try {putf ("->%#0-10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-10x: "); try {putf ("->%#0-10x<-\n",0L);} catch (invfmt) {err ();}
put ("#0-10x: "); try {putf ("->%#0-10x<-\n",4L);} catch (invfmt) {err ();}
put ("0-10x: "); try {putf ("->%0-10x<-\n",-4L);} catch (invfmt) {err ();}
put ("0-10x: "); try {putf ("->%0-10x<-\n",0L);} catch (invfmt) {err ();}
put ("0-10x: "); try {putf ("->%0-10x<-\n",4L);} catch (invfmt) {err ();}
put ("#-10x: "); try {putf ("->%#-10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#-10x: "); try {putf ("->%#-10x<-\n",0L);} catch (invfmt) {err ();}
put ("#-10x: "); try {putf ("->%#-10x<-\n",4L);} catch (invfmt) {err ();}
put ("-10x: "); try {putf ("->%-10x<-\n",-4L);} catch (invfmt) {err ();}
put ("-10x: "); try {putf ("->%-10x<-\n",0L);} catch (invfmt) {err ();}
put ("-10x: "); try {putf ("->%-10x<-\n",4L);} catch (invfmt) {err ();}
put ("#010x: "); try {putf ("->%#010x<-\n",-4L);} catch (invfmt) {err ();}
put ("#010x: "); try {putf ("->%#010x<-\n",0L);} catch (invfmt) {err ();}
put ("#010x: "); try {putf ("->%#010x<-\n",4L);} catch (invfmt) {err ();}
put ("010x: "); try {putf ("->%010x<-\n",-4L);} catch (invfmt) {err ();}
put ("010x: "); try {putf ("->%010x<-\n",0L);} catch (invfmt) {err ();}
put ("010x: "); try {putf ("->%010x<-\n",4L);} catch (invfmt) {err ();}
put ("#10x: "); try {putf ("->%#10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#10x: "); try {putf ("->%#10x<-\n",0L);} catch (invfmt) {err ();}
put ("#10x: "); try {putf ("->%#10x<-\n",4L);} catch (invfmt) {err ();}
put ("10x: "); try {putf ("->%10x<-\n",-4L);} catch (invfmt) {err ();}
put ("10x: "); try {putf ("->%10x<-\n",0L);} catch (invfmt) {err ();}
put ("10x: "); try {putf ("->%10x<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +10X: "); try {putf ("->%#0- +10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +10X: "); try {putf ("->%#0- +10X<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +10X: "); try {putf ("->%#0- +10X<-\n",4L);} catch (invfmt) {err ();}
put ("0- +10X: "); try {putf ("->%0- +10X<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +10X: "); try {putf ("->%0- +10X<-\n",0L);} catch (invfmt) {err ();}
put ("0- +10X: "); try {putf ("->%0- +10X<-\n",4L);} catch (invfmt) {err ();}
put ("#- +10X: "); try {putf ("->%#- +10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +10X: "); try {putf ("->%#- +10X<-\n",0L);} catch (invfmt) {err ();}
put ("#- +10X: "); try {putf ("->%#- +10X<-\n",4L);} catch (invfmt) {err ();}
put ("- +10X: "); try {putf ("->%- +10X<-\n",-4L);} catch (invfmt) {err ();}
put ("- +10X: "); try {putf ("->%- +10X<-\n",0L);} catch (invfmt) {err ();}
put ("- +10X: "); try {putf ("->%- +10X<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +10X: "); try {putf ("->%#0 +10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +10X: "); try {putf ("->%#0 +10X<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +10X: "); try {putf ("->%#0 +10X<-\n",4L);} catch (invfmt) {err ();}
put ("0 +10X: "); try {putf ("->%0 +10X<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +10X: "); try {putf ("->%0 +10X<-\n",0L);} catch (invfmt) {err ();}
put ("0 +10X: "); try {putf ("->%0 +10X<-\n",4L);} catch (invfmt) {err ();}
put ("# +10X: "); try {putf ("->%# +10X<-\n",-4L);} catch (invfmt) {err ();}
put ("# +10X: "); try {putf ("->%# +10X<-\n",0L);} catch (invfmt) {err ();}
put ("# +10X: "); try {putf ("->%# +10X<-\n",4L);} catch (invfmt) {err ();}
put (" +10X: "); try {putf ("->% +10X<-\n",-4L);} catch (invfmt) {err ();}
put (" +10X: "); try {putf ("->% +10X<-\n",0L);} catch (invfmt) {err ();}
put (" +10X: "); try {putf ("->% +10X<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+10X: "); try {putf ("->%#0-+10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+10X: "); try {putf ("->%#0-+10X<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+10X: "); try {putf ("->%#0-+10X<-\n",4L);} catch (invfmt) {err ();}
put ("0-+10X: "); try {putf ("->%0-+10X<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+10X: "); try {putf ("->%0-+10X<-\n",0L);} catch (invfmt) {err ();}
put ("0-+10X: "); try {putf ("->%0-+10X<-\n",4L);} catch (invfmt) {err ();}
put ("#-+10X: "); try {putf ("->%#-+10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+10X: "); try {putf ("->%#-+10X<-\n",0L);} catch (invfmt) {err ();}
put ("#-+10X: "); try {putf ("->%#-+10X<-\n",4L);} catch (invfmt) {err ();}
put ("-+10X: "); try {putf ("->%-+10X<-\n",-4L);} catch (invfmt) {err ();}
put ("-+10X: "); try {putf ("->%-+10X<-\n",0L);} catch (invfmt) {err ();}
put ("-+10X: "); try {putf ("->%-+10X<-\n",4L);} catch (invfmt) {err ();}
put ("#0+10X: "); try {putf ("->%#0+10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+10X: "); try {putf ("->%#0+10X<-\n",0L);} catch (invfmt) {err ();}
put ("#0+10X: "); try {putf ("->%#0+10X<-\n",4L);} catch (invfmt) {err ();}
put ("0+10X: "); try {putf ("->%0+10X<-\n",-4L);} catch (invfmt) {err ();}
put ("0+10X: "); try {putf ("->%0+10X<-\n",0L);} catch (invfmt) {err ();}
put ("0+10X: "); try {putf ("->%0+10X<-\n",4L);} catch (invfmt) {err ();}
put ("#+10X: "); try {putf ("->%#+10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#+10X: "); try {putf ("->%#+10X<-\n",0L);} catch (invfmt) {err ();}
put ("#+10X: "); try {putf ("->%#+10X<-\n",4L);} catch (invfmt) {err ();}
put ("+10X: "); try {putf ("->%+10X<-\n",-4L);} catch (invfmt) {err ();}
put ("+10X: "); try {putf ("->%+10X<-\n",0L);} catch (invfmt) {err ();}
put ("+10X: "); try {putf ("->%+10X<-\n",4L);} catch (invfmt) {err ();}
put ("#0- 10X: "); try {putf ("->%#0- 10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- 10X: "); try {putf ("->%#0- 10X<-\n",0L);} catch (invfmt) {err ();}
put ("#0- 10X: "); try {putf ("->%#0- 10X<-\n",4L);} catch (invfmt) {err ();}
put ("0- 10X: "); try {putf ("->%0- 10X<-\n",-4L);} catch (invfmt) {err ();}
put ("0- 10X: "); try {putf ("->%0- 10X<-\n",0L);} catch (invfmt) {err ();}
put ("0- 10X: "); try {putf ("->%0- 10X<-\n",4L);} catch (invfmt) {err ();}
put ("#- 10X: "); try {putf ("->%#- 10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#- 10X: "); try {putf ("->%#- 10X<-\n",0L);} catch (invfmt) {err ();}
put ("#- 10X: "); try {putf ("->%#- 10X<-\n",4L);} catch (invfmt) {err ();}
put ("- 10X: "); try {putf ("->%- 10X<-\n",-4L);} catch (invfmt) {err ();}
put ("- 10X: "); try {putf ("->%- 10X<-\n",0L);} catch (invfmt) {err ();}
put ("- 10X: "); try {putf ("->%- 10X<-\n",4L);} catch (invfmt) {err ();}
put ("#0 10X: "); try {putf ("->%#0 10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 10X: "); try {putf ("->%#0 10X<-\n",0L);} catch (invfmt) {err ();}
put ("#0 10X: "); try {putf ("->%#0 10X<-\n",4L);} catch (invfmt) {err ();}
put ("0 10X: "); try {putf ("->%0 10X<-\n",-4L);} catch (invfmt) {err ();}
put ("0 10X: "); try {putf ("->%0 10X<-\n",0L);} catch (invfmt) {err ();}
put ("0 10X: "); try {putf ("->%0 10X<-\n",4L);} catch (invfmt) {err ();}
put ("# 10X: "); try {putf ("->%# 10X<-\n",-4L);} catch (invfmt) {err ();}
put ("# 10X: "); try {putf ("->%# 10X<-\n",0L);} catch (invfmt) {err ();}
put ("# 10X: "); try {putf ("->%# 10X<-\n",4L);} catch (invfmt) {err ();}
put (" 10X: "); try {putf ("->% 10X<-\n",-4L);} catch (invfmt) {err ();}
put (" 10X: "); try {putf ("->% 10X<-\n",0L);} catch (invfmt) {err ();}
put (" 10X: "); try {putf ("->% 10X<-\n",4L);} catch (invfmt) {err ();}
put ("#0-10X: "); try {putf ("->%#0-10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-10X: "); try {putf ("->%#0-10X<-\n",0L);} catch (invfmt) {err ();}
put ("#0-10X: "); try {putf ("->%#0-10X<-\n",4L);} catch (invfmt) {err ();}
put ("0-10X: "); try {putf ("->%0-10X<-\n",-4L);} catch (invfmt) {err ();}
put ("0-10X: "); try {putf ("->%0-10X<-\n",0L);} catch (invfmt) {err ();}
put ("0-10X: "); try {putf ("->%0-10X<-\n",4L);} catch (invfmt) {err ();}
put ("#-10X: "); try {putf ("->%#-10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#-10X: "); try {putf ("->%#-10X<-\n",0L);} catch (invfmt) {err ();}
put ("#-10X: "); try {putf ("->%#-10X<-\n",4L);} catch (invfmt) {err ();}
put ("-10X: "); try {putf ("->%-10X<-\n",-4L);} catch (invfmt) {err ();}
put ("-10X: "); try {putf ("->%-10X<-\n",0L);} catch (invfmt) {err ();}
put ("-10X: "); try {putf ("->%-10X<-\n",4L);} catch (invfmt) {err ();}
put ("#010X: "); try {putf ("->%#010X<-\n",-4L);} catch (invfmt) {err ();}
put ("#010X: "); try {putf ("->%#010X<-\n",0L);} catch (invfmt) {err ();}
put ("#010X: "); try {putf ("->%#010X<-\n",4L);} catch (invfmt) {err ();}
put ("010X: "); try {putf ("->%010X<-\n",-4L);} catch (invfmt) {err ();}
put ("010X: "); try {putf ("->%010X<-\n",0L);} catch (invfmt) {err ();}
put ("010X: "); try {putf ("->%010X<-\n",4L);} catch (invfmt) {err ();}
put ("#10X: "); try {putf ("->%#10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#10X: "); try {putf ("->%#10X<-\n",0L);} catch (invfmt) {err ();}
put ("#10X: "); try {putf ("->%#10X<-\n",4L);} catch (invfmt) {err ();}
put ("10X: "); try {putf ("->%10X<-\n",-4L);} catch (invfmt) {err ();}
put ("10X: "); try {putf ("->%10X<-\n",0L);} catch (invfmt) {err ();}
put ("10X: "); try {putf ("->%10X<-\n",4L);} catch (invfmt) {err ();}
TEST651
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT651' && $CMP $stdout $ftemp2; then
#0- +d: badformat
#0- +d: badformat
#0- +d: badformat
0- +d: ->-4<-
0- +d: ->+0<-
0- +d: ->+4<-
#- +d: badformat
#- +d: badformat
#- +d: badformat
- +d: ->-4<-
- +d: ->+0<-
- +d: ->+4<-
#0 +d: badformat
#0 +d: badformat
#0 +d: badformat
0 +d: ->-4<-
0 +d: ->+0<-
0 +d: ->+4<-
# +d: badformat
# +d: badformat
# +d: badformat
 +d: ->-4<-
 +d: ->+0<-
 +d: ->+4<-
#0-+d: badformat
#0-+d: badformat
#0-+d: badformat
0-+d: ->-4<-
0-+d: ->+0<-
0-+d: ->+4<-
#-+d: badformat
#-+d: badformat
#-+d: badformat
-+d: ->-4<-
-+d: ->+0<-
-+d: ->+4<-
#0+d: badformat
#0+d: badformat
#0+d: badformat
0+d: ->-4<-
0+d: ->+0<-
0+d: ->+4<-
#+d: badformat
#+d: badformat
#+d: badformat
+d: ->-4<-
+d: ->+0<-
+d: ->+4<-
#0- d: badformat
#0- d: badformat
#0- d: badformat
0- d: ->-4<-
0- d: -> 0<-
0- d: -> 4<-
#- d: badformat
#- d: badformat
#- d: badformat
- d: ->-4<-
- d: -> 0<-
- d: -> 4<-
#0 d: badformat
#0 d: badformat
#0 d: badformat
0 d: ->-4<-
0 d: -> 0<-
0 d: -> 4<-
# d: badformat
# d: badformat
# d: badformat
 d: ->-4<-
 d: -> 0<-
 d: -> 4<-
#0-d: badformat
#0-d: badformat
#0-d: badformat
0-d: ->-4<-
0-d: ->0<-
0-d: ->4<-
#-d: badformat
#-d: badformat
#-d: badformat
-d: ->-4<-
-d: ->0<-
-d: ->4<-
#0d: badformat
#0d: badformat
#0d: badformat
0d: ->-4<-
0d: ->0<-
0d: ->4<-
#d: badformat
#d: badformat
#d: badformat
d: ->-4<-
d: ->0<-
d: ->4<-
#0- +o: badformat
#0- +o: badformat
#0- +o: badformat
0- +o: badformat
0- +o: badformat
0- +o: badformat
#- +o: badformat
#- +o: badformat
#- +o: badformat
- +o: badformat
- +o: badformat
- +o: badformat
#0 +o: badformat
#0 +o: badformat
#0 +o: badformat
0 +o: badformat
0 +o: badformat
0 +o: badformat
# +o: badformat
# +o: badformat
# +o: badformat
 +o: badformat
 +o: badformat
 +o: badformat
#0-+o: badformat
#0-+o: badformat
#0-+o: badformat
0-+o: badformat
0-+o: badformat
0-+o: badformat
#-+o: badformat
#-+o: badformat
#-+o: badformat
-+o: badformat
-+o: badformat
-+o: badformat
#0+o: badformat
#0+o: badformat
#0+o: badformat
0+o: badformat
0+o: badformat
0+o: badformat
#+o: badformat
#+o: badformat
#+o: badformat
+o: badformat
+o: badformat
+o: badformat
#0- o: badformat
#0- o: badformat
#0- o: badformat
0- o: badformat
0- o: badformat
0- o: badformat
#- o: badformat
#- o: badformat
#- o: badformat
- o: badformat
- o: badformat
- o: badformat
#0 o: badformat
#0 o: badformat
#0 o: badformat
0 o: badformat
0 o: badformat
0 o: badformat
# o: badformat
# o: badformat
# o: badformat
 o: badformat
 o: badformat
 o: badformat
#0-o: ->-04<-
#0-o: ->0<-
#0-o: ->04<-
0-o: ->-4<-
0-o: ->0<-
0-o: ->4<-
#-o: ->-04<-
#-o: ->0<-
#-o: ->04<-
-o: ->-4<-
-o: ->0<-
-o: ->4<-
#0o: ->-04<-
#0o: ->0<-
#0o: ->04<-
0o: ->-4<-
0o: ->0<-
0o: ->4<-
#o: ->-04<-
#o: ->0<-
#o: ->04<-
o: ->-4<-
o: ->0<-
o: ->4<-
#0- +x: badformat
#0- +x: badformat
#0- +x: badformat
0- +x: badformat
0- +x: badformat
0- +x: badformat
#- +x: badformat
#- +x: badformat
#- +x: badformat
- +x: badformat
- +x: badformat
- +x: badformat
#0 +x: badformat
#0 +x: badformat
#0 +x: badformat
0 +x: badformat
0 +x: badformat
0 +x: badformat
# +x: badformat
# +x: badformat
# +x: badformat
 +x: badformat
 +x: badformat
 +x: badformat
#0-+x: badformat
#0-+x: badformat
#0-+x: badformat
0-+x: badformat
0-+x: badformat
0-+x: badformat
#-+x: badformat
#-+x: badformat
#-+x: badformat
-+x: badformat
-+x: badformat
-+x: badformat
#0+x: badformat
#0+x: badformat
#0+x: badformat
0+x: badformat
0+x: badformat
0+x: badformat
#+x: badformat
#+x: badformat
#+x: badformat
+x: badformat
+x: badformat
+x: badformat
#0- x: badformat
#0- x: badformat
#0- x: badformat
0- x: badformat
0- x: badformat
0- x: badformat
#- x: badformat
#- x: badformat
#- x: badformat
- x: badformat
- x: badformat
- x: badformat
#0 x: badformat
#0 x: badformat
#0 x: badformat
0 x: badformat
0 x: badformat
0 x: badformat
# x: badformat
# x: badformat
# x: badformat
 x: badformat
 x: badformat
 x: badformat
#0-x: ->-0x4<-
#0-x: ->0<-
#0-x: ->0x4<-
0-x: ->-4<-
0-x: ->0<-
0-x: ->4<-
#-x: ->-0x4<-
#-x: ->0<-
#-x: ->0x4<-
-x: ->-4<-
-x: ->0<-
-x: ->4<-
#0x: ->-0x4<-
#0x: ->0<-
#0x: ->0x4<-
0x: ->-4<-
0x: ->0<-
0x: ->4<-
#x: ->-0x4<-
#x: ->0<-
#x: ->0x4<-
x: ->-4<-
x: ->0<-
x: ->4<-
#0- +X: badformat
#0- +X: badformat
#0- +X: badformat
0- +X: badformat
0- +X: badformat
0- +X: badformat
#- +X: badformat
#- +X: badformat
#- +X: badformat
- +X: badformat
- +X: badformat
- +X: badformat
#0 +X: badformat
#0 +X: badformat
#0 +X: badformat
0 +X: badformat
0 +X: badformat
0 +X: badformat
# +X: badformat
# +X: badformat
# +X: badformat
 +X: badformat
 +X: badformat
 +X: badformat
#0-+X: badformat
#0-+X: badformat
#0-+X: badformat
0-+X: badformat
0-+X: badformat
0-+X: badformat
#-+X: badformat
#-+X: badformat
#-+X: badformat
-+X: badformat
-+X: badformat
-+X: badformat
#0+X: badformat
#0+X: badformat
#0+X: badformat
0+X: badformat
0+X: badformat
0+X: badformat
#+X: badformat
#+X: badformat
#+X: badformat
+X: badformat
+X: badformat
+X: badformat
#0- X: badformat
#0- X: badformat
#0- X: badformat
0- X: badformat
0- X: badformat
0- X: badformat
#- X: badformat
#- X: badformat
#- X: badformat
- X: badformat
- X: badformat
- X: badformat
#0 X: badformat
#0 X: badformat
#0 X: badformat
0 X: badformat
0 X: badformat
0 X: badformat
# X: badformat
# X: badformat
# X: badformat
 X: badformat
 X: badformat
 X: badformat
#0-X: ->-0X4<-
#0-X: ->0<-
#0-X: ->0X4<-
0-X: ->-4<-
0-X: ->0<-
0-X: ->4<-
#-X: ->-0X4<-
#-X: ->0<-
#-X: ->0X4<-
-X: ->-4<-
-X: ->0<-
-X: ->4<-
#0X: ->-0X4<-
#0X: ->0<-
#0X: ->0X4<-
0X: ->-4<-
0X: ->0<-
0X: ->4<-
#X: ->-0X4<-
#X: ->0<-
#X: ->0X4<-
X: ->-4<-
X: ->0<-
X: ->4<-
#0- +0d: badformat
#0- +0d: badformat
#0- +0d: badformat
0- +0d: ->-4<-
0- +0d: ->+0<-
0- +0d: ->+4<-
#- +0d: badformat
#- +0d: badformat
#- +0d: badformat
- +0d: ->-4<-
- +0d: ->+0<-
- +0d: ->+4<-
#0 +0d: badformat
#0 +0d: badformat
#0 +0d: badformat
0 +0d: ->-4<-
0 +0d: ->+0<-
0 +0d: ->+4<-
# +0d: badformat
# +0d: badformat
# +0d: badformat
 +0d: ->-4<-
 +0d: ->+0<-
 +0d: ->+4<-
#0-+0d: badformat
#0-+0d: badformat
#0-+0d: badformat
0-+0d: ->-4<-
0-+0d: ->+0<-
0-+0d: ->+4<-
#-+0d: badformat
#-+0d: badformat
#-+0d: badformat
-+0d: ->-4<-
-+0d: ->+0<-
-+0d: ->+4<-
#0+0d: badformat
#0+0d: badformat
#0+0d: badformat
0+0d: ->-4<-
0+0d: ->+0<-
0+0d: ->+4<-
#+0d: badformat
#+0d: badformat
#+0d: badformat
+0d: ->-4<-
+0d: ->+0<-
+0d: ->+4<-
#0- 0d: badformat
#0- 0d: badformat
#0- 0d: badformat
0- 0d: ->-4<-
0- 0d: -> 0<-
0- 0d: -> 4<-
#- 0d: badformat
#- 0d: badformat
#- 0d: badformat
- 0d: ->-4<-
- 0d: -> 0<-
- 0d: -> 4<-
#0 0d: badformat
#0 0d: badformat
#0 0d: badformat
0 0d: ->-4<-
0 0d: -> 0<-
0 0d: -> 4<-
# 0d: badformat
# 0d: badformat
# 0d: badformat
 0d: ->-4<-
 0d: -> 0<-
 0d: -> 4<-
#0-0d: badformat
#0-0d: badformat
#0-0d: badformat
0-0d: ->-4<-
0-0d: ->0<-
0-0d: ->4<-
#-0d: badformat
#-0d: badformat
#-0d: badformat
-0d: ->-4<-
-0d: ->0<-
-0d: ->4<-
#00d: badformat
#00d: badformat
#00d: badformat
00d: ->-4<-
00d: ->0<-
00d: ->4<-
#0d: badformat
#0d: badformat
#0d: badformat
0d: ->-4<-
0d: ->0<-
0d: ->4<-
#0- +0o: badformat
#0- +0o: badformat
#0- +0o: badformat
0- +0o: badformat
0- +0o: badformat
0- +0o: badformat
#- +0o: badformat
#- +0o: badformat
#- +0o: badformat
- +0o: badformat
- +0o: badformat
- +0o: badformat
#0 +0o: badformat
#0 +0o: badformat
#0 +0o: badformat
0 +0o: badformat
0 +0o: badformat
0 +0o: badformat
# +0o: badformat
# +0o: badformat
# +0o: badformat
 +0o: badformat
 +0o: badformat
 +0o: badformat
#0-+0o: badformat
#0-+0o: badformat
#0-+0o: badformat
0-+0o: badformat
0-+0o: badformat
0-+0o: badformat
#-+0o: badformat
#-+0o: badformat
#-+0o: badformat
-+0o: badformat
-+0o: badformat
-+0o: badformat
#0+0o: badformat
#0+0o: badformat
#0+0o: badformat
0+0o: badformat
0+0o: badformat
0+0o: badformat
#+0o: badformat
#+0o: badformat
#+0o: badformat
+0o: badformat
+0o: badformat
+0o: badformat
#0- 0o: badformat
#0- 0o: badformat
#0- 0o: badformat
0- 0o: badformat
0- 0o: badformat
0- 0o: badformat
#- 0o: badformat
#- 0o: badformat
#- 0o: badformat
- 0o: badformat
- 0o: badformat
- 0o: badformat
#0 0o: badformat
#0 0o: badformat
#0 0o: badformat
0 0o: badformat
0 0o: badformat
0 0o: badformat
# 0o: badformat
# 0o: badformat
# 0o: badformat
 0o: badformat
 0o: badformat
 0o: badformat
#0-0o: ->-04<-
#0-0o: ->0<-
#0-0o: ->04<-
0-0o: ->-4<-
0-0o: ->0<-
0-0o: ->4<-
#-0o: ->-04<-
#-0o: ->0<-
#-0o: ->04<-
-0o: ->-4<-
-0o: ->0<-
-0o: ->4<-
#00o: ->-04<-
#00o: ->0<-
#00o: ->04<-
00o: ->-4<-
00o: ->0<-
00o: ->4<-
#0o: ->-04<-
#0o: ->0<-
#0o: ->04<-
0o: ->-4<-
0o: ->0<-
0o: ->4<-
#0- +0x: badformat
#0- +0x: badformat
#0- +0x: badformat
0- +0x: badformat
0- +0x: badformat
0- +0x: badformat
#- +0x: badformat
#- +0x: badformat
#- +0x: badformat
- +0x: badformat
- +0x: badformat
- +0x: badformat
#0 +0x: badformat
#0 +0x: badformat
#0 +0x: badformat
0 +0x: badformat
0 +0x: badformat
0 +0x: badformat
# +0x: badformat
# +0x: badformat
# +0x: badformat
 +0x: badformat
 +0x: badformat
 +0x: badformat
#0-+0x: badformat
#0-+0x: badformat
#0-+0x: badformat
0-+0x: badformat
0-+0x: badformat
0-+0x: badformat
#-+0x: badformat
#-+0x: badformat
#-+0x: badformat
-+0x: badformat
-+0x: badformat
-+0x: badformat
#0+0x: badformat
#0+0x: badformat
#0+0x: badformat
0+0x: badformat
0+0x: badformat
0+0x: badformat
#+0x: badformat
#+0x: badformat
#+0x: badformat
+0x: badformat
+0x: badformat
+0x: badformat
#0- 0x: badformat
#0- 0x: badformat
#0- 0x: badformat
0- 0x: badformat
0- 0x: badformat
0- 0x: badformat
#- 0x: badformat
#- 0x: badformat
#- 0x: badformat
- 0x: badformat
- 0x: badformat
- 0x: badformat
#0 0x: badformat
#0 0x: badformat
#0 0x: badformat
0 0x: badformat
0 0x: badformat
0 0x: badformat
# 0x: badformat
# 0x: badformat
# 0x: badformat
 0x: badformat
 0x: badformat
 0x: badformat
#0-0x: ->-0x4<-
#0-0x: ->0<-
#0-0x: ->0x4<-
0-0x: ->-4<-
0-0x: ->0<-
0-0x: ->4<-
#-0x: ->-0x4<-
#-0x: ->0<-
#-0x: ->0x4<-
-0x: ->-4<-
-0x: ->0<-
-0x: ->4<-
#00x: ->-0x4<-
#00x: ->0<-
#00x: ->0x4<-
00x: ->-4<-
00x: ->0<-
00x: ->4<-
#0x: ->-0x4<-
#0x: ->0<-
#0x: ->0x4<-
0x: ->-4<-
0x: ->0<-
0x: ->4<-
#0- +0X: badformat
#0- +0X: badformat
#0- +0X: badformat
0- +0X: badformat
0- +0X: badformat
0- +0X: badformat
#- +0X: badformat
#- +0X: badformat
#- +0X: badformat
- +0X: badformat
- +0X: badformat
- +0X: badformat
#0 +0X: badformat
#0 +0X: badformat
#0 +0X: badformat
0 +0X: badformat
0 +0X: badformat
0 +0X: badformat
# +0X: badformat
# +0X: badformat
# +0X: badformat
 +0X: badformat
 +0X: badformat
 +0X: badformat
#0-+0X: badformat
#0-+0X: badformat
#0-+0X: badformat
0-+0X: badformat
0-+0X: badformat
0-+0X: badformat
#-+0X: badformat
#-+0X: badformat
#-+0X: badformat
-+0X: badformat
-+0X: badformat
-+0X: badformat
#0+0X: badformat
#0+0X: badformat
#0+0X: badformat
0+0X: badformat
0+0X: badformat
0+0X: badformat
#+0X: badformat
#+0X: badformat
#+0X: badformat
+0X: badformat
+0X: badformat
+0X: badformat
#0- 0X: badformat
#0- 0X: badformat
#0- 0X: badformat
0- 0X: badformat
0- 0X: badformat
0- 0X: badformat
#- 0X: badformat
#- 0X: badformat
#- 0X: badformat
- 0X: badformat
- 0X: badformat
- 0X: badformat
#0 0X: badformat
#0 0X: badformat
#0 0X: badformat
0 0X: badformat
0 0X: badformat
0 0X: badformat
# 0X: badformat
# 0X: badformat
# 0X: badformat
 0X: badformat
 0X: badformat
 0X: badformat
#0-0X: ->-0X4<-
#0-0X: ->0<-
#0-0X: ->0X4<-
0-0X: ->-4<-
0-0X: ->0<-
0-0X: ->4<-
#-0X: ->-0X4<-
#-0X: ->0<-
#-0X: ->0X4<-
-0X: ->-4<-
-0X: ->0<-
-0X: ->4<-
#00X: ->-0X4<-
#00X: ->0<-
#00X: ->0X4<-
00X: ->-4<-
00X: ->0<-
00X: ->4<-
#0X: ->-0X4<-
#0X: ->0<-
#0X: ->0X4<-
0X: ->-4<-
0X: ->0<-
0X: ->4<-
#0- +10d: badformat
#0- +10d: badformat
#0- +10d: badformat
0- +10d: ->-4        <-
0- +10d: ->+0        <-
0- +10d: ->+4        <-
#- +10d: badformat
#- +10d: badformat
#- +10d: badformat
- +10d: ->-4        <-
- +10d: ->+0        <-
- +10d: ->+4        <-
#0 +10d: badformat
#0 +10d: badformat
#0 +10d: badformat
0 +10d: ->-000000004<-
0 +10d: ->+000000000<-
0 +10d: ->+000000004<-
# +10d: badformat
# +10d: badformat
# +10d: badformat
 +10d: ->        -4<-
 +10d: ->        +0<-
 +10d: ->        +4<-
#0-+10d: badformat
#0-+10d: badformat
#0-+10d: badformat
0-+10d: ->-4        <-
0-+10d: ->+0        <-
0-+10d: ->+4        <-
#-+10d: badformat
#-+10d: badformat
#-+10d: badformat
-+10d: ->-4        <-
-+10d: ->+0        <-
-+10d: ->+4        <-
#0+10d: badformat
#0+10d: badformat
#0+10d: badformat
0+10d: ->-000000004<-
0+10d: ->+000000000<-
0+10d: ->+000000004<-
#+10d: badformat
#+10d: badformat
#+10d: badformat
+10d: ->        -4<-
+10d: ->        +0<-
+10d: ->        +4<-
#0- 10d: badformat
#0- 10d: badformat
#0- 10d: badformat
0- 10d: ->-4        <-
0- 10d: -> 0        <-
0- 10d: -> 4        <-
#- 10d: badformat
#- 10d: badformat
#- 10d: badformat
- 10d: ->-4        <-
- 10d: -> 0        <-
- 10d: -> 4        <-
#0 10d: badformat
#0 10d: badformat
#0 10d: badformat
0 10d: ->-000000004<-
0 10d: -> 000000000<-
0 10d: -> 000000004<-
# 10d: badformat
# 10d: badformat
# 10d: badformat
 10d: ->        -4<-
 10d: ->         0<-
 10d: ->         4<-
#0-10d: badformat
#0-10d: badformat
#0-10d: badformat
0-10d: ->-4        <-
0-10d: ->0         <-
0-10d: ->4         <-
#-10d: badformat
#-10d: badformat
#-10d: badformat
-10d: ->-4        <-
-10d: ->0         <-
-10d: ->4         <-
#010d: badformat
#010d: badformat
#010d: badformat
010d: ->-000000004<-
010d: ->0000000000<-
010d: ->0000000004<-
#10d: badformat
#10d: badformat
#10d: badformat
10d: ->        -4<-
10d: ->         0<-
10d: ->         4<-
#0- +10o: badformat
#0- +10o: badformat
#0- +10o: badformat
0- +10o: badformat
0- +10o: badformat
0- +10o: badformat
#- +10o: badformat
#- +10o: badformat
#- +10o: badformat
- +10o: badformat
- +10o: badformat
- +10o: badformat
#0 +10o: badformat
#0 +10o: badformat
#0 +10o: badformat
0 +10o: badformat
0 +10o: badformat
0 +10o: badformat
# +10o: badformat
# +10o: badformat
# +10o: badformat
 +10o: badformat
 +10o: badformat
 +10o: badformat
#0-+10o: badformat
#0-+10o: badformat
#0-+10o: badformat
0-+10o: badformat
0-+10o: badformat
0-+10o: badformat
#-+10o: badformat
#-+10o: badformat
#-+10o: badformat
-+10o: badformat
-+10o: badformat
-+10o: badformat
#0+10o: badformat
#0+10o: badformat
#0+10o: badformat
0+10o: badformat
0+10o: badformat
0+10o: badformat
#+10o: badformat
#+10o: badformat
#+10o: badformat
+10o: badformat
+10o: badformat
+10o: badformat
#0- 10o: badformat
#0- 10o: badformat
#0- 10o: badformat
0- 10o: badformat
0- 10o: badformat
0- 10o: badformat
#- 10o: badformat
#- 10o: badformat
#- 10o: badformat
- 10o: badformat
- 10o: badformat
- 10o: badformat
#0 10o: badformat
#0 10o: badformat
#0 10o: badformat
0 10o: badformat
0 10o: badformat
0 10o: badformat
# 10o: badformat
# 10o: badformat
# 10o: badformat
 10o: badformat
 10o: badformat
 10o: badformat
#0-10o: ->-04       <-
#0-10o: ->0         <-
#0-10o: ->04        <-
0-10o: ->-4        <-
0-10o: ->0         <-
0-10o: ->4         <-
#-10o: ->-04       <-
#-10o: ->0         <-
#-10o: ->04        <-
-10o: ->-4        <-
-10o: ->0         <-
-10o: ->4         <-
#010o: ->-000000004<-
#010o: ->0000000000<-
#010o: ->0000000004<-
010o: ->-000000004<-
010o: ->0000000000<-
010o: ->0000000004<-
#10o: ->       -04<-
#10o: ->         0<-
#10o: ->        04<-
10o: ->        -4<-
10o: ->         0<-
10o: ->         4<-
#0- +10x: badformat
#0- +10x: badformat
#0- +10x: badformat
0- +10x: badformat
0- +10x: badformat
0- +10x: badformat
#- +10x: badformat
#- +10x: badformat
#- +10x: badformat
- +10x: badformat
- +10x: badformat
- +10x: badformat
#0 +10x: badformat
#0 +10x: badformat
#0 +10x: badformat
0 +10x: badformat
0 +10x: badformat
0 +10x: badformat
# +10x: badformat
# +10x: badformat
# +10x: badformat
 +10x: badformat
 +10x: badformat
 +10x: badformat
#0-+10x: badformat
#0-+10x: badformat
#0-+10x: badformat
0-+10x: badformat
0-+10x: badformat
0-+10x: badformat
#-+10x: badformat
#-+10x: badformat
#-+10x: badformat
-+10x: badformat
-+10x: badformat
-+10x: badformat
#0+10x: badformat
#0+10x: badformat
#0+10x: badformat
0+10x: badformat
0+10x: badformat
0+10x: badformat
#+10x: badformat
#+10x: badformat
#+10x: badformat
+10x: badformat
+10x: badformat
+10x: badformat
#0- 10x: badformat
#0- 10x: badformat
#0- 10x: badformat
0- 10x: badformat
0- 10x: badformat
0- 10x: badformat
#- 10x: badformat
#- 10x: badformat
#- 10x: badformat
- 10x: badformat
- 10x: badformat
- 10x: badformat
#0 10x: badformat
#0 10x: badformat
#0 10x: badformat
0 10x: badformat
0 10x: badformat
0 10x: badformat
# 10x: badformat
# 10x: badformat
# 10x: badformat
 10x: badformat
 10x: badformat
 10x: badformat
#0-10x: ->-0x4      <-
#0-10x: ->0         <-
#0-10x: ->0x4       <-
0-10x: ->-4        <-
0-10x: ->0         <-
0-10x: ->4         <-
#-10x: ->-0x4      <-
#-10x: ->0         <-
#-10x: ->0x4       <-
-10x: ->-4        <-
-10x: ->0         <-
-10x: ->4         <-
#010x: ->-0x0000004<-
#010x: ->0000000000<-
#010x: ->0x00000004<-
010x: ->-000000004<-
010x: ->0000000000<-
010x: ->0000000004<-
#10x: ->      -0x4<-
#10x: ->         0<-
#10x: ->       0x4<-
10x: ->        -4<-
10x: ->         0<-
10x: ->         4<-
#0- +10X: badformat
#0- +10X: badformat
#0- +10X: badformat
0- +10X: badformat
0- +10X: badformat
0- +10X: badformat
#- +10X: badformat
#- +10X: badformat
#- +10X: badformat
- +10X: badformat
- +10X: badformat
- +10X: badformat
#0 +10X: badformat
#0 +10X: badformat
#0 +10X: badformat
0 +10X: badformat
0 +10X: badformat
0 +10X: badformat
# +10X: badformat
# +10X: badformat
# +10X: badformat
 +10X: badformat
 +10X: badformat
 +10X: badformat
#0-+10X: badformat
#0-+10X: badformat
#0-+10X: badformat
0-+10X: badformat
0-+10X: badformat
0-+10X: badformat
#-+10X: badformat
#-+10X: badformat
#-+10X: badformat
-+10X: badformat
-+10X: badformat
-+10X: badformat
#0+10X: badformat
#0+10X: badformat
#0+10X: badformat
0+10X: badformat
0+10X: badformat
0+10X: badformat
#+10X: badformat
#+10X: badformat
#+10X: badformat
+10X: badformat
+10X: badformat
+10X: badformat
#0- 10X: badformat
#0- 10X: badformat
#0- 10X: badformat
0- 10X: badformat
0- 10X: badformat
0- 10X: badformat
#- 10X: badformat
#- 10X: badformat
#- 10X: badformat
- 10X: badformat
- 10X: badformat
- 10X: badformat
#0 10X: badformat
#0 10X: badformat
#0 10X: badformat
0 10X: badformat
0 10X: badformat
0 10X: badformat
# 10X: badformat
# 10X: badformat
# 10X: badformat
 10X: badformat
 10X: badformat
 10X: badformat
#0-10X: ->-0X4      <-
#0-10X: ->0         <-
#0-10X: ->0X4       <-
0-10X: ->-4        <-
0-10X: ->0         <-
0-10X: ->4         <-
#-10X: ->-0X4      <-
#-10X: ->0         <-
#-10X: ->0X4       <-
-10X: ->-4        <-
-10X: ->0         <-
-10X: ->4         <-
#010X: ->-0X0000004<-
#010X: ->0000000000<-
#010X: ->0X00000004<-
010X: ->-000000004<-
010X: ->0000000000<-
010X: ->0000000004<-
#10X: ->      -0X4<-
#10X: ->         0<-
#10X: ->       0X4<-
10X: ->        -4<-
10X: ->         0<-
10X: ->         4<-
OUTPUT651
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 652.
if test $result = ok -a $start_test_number -le 652; then
	echo test 652: Long ops
        cat >$test_file <<'TEST652'
fun f (i, j) {
  println ("+", i + j);
  println ("-", i - j);
  println ("*", i * j);
  println ("/", i / j);
  println ("%", i % j);
  println ("==", i == j);
  println ("!=", i != j);
  println ("===", i === j);
  println ("!==", i !== j);
  println ("<=", i <= j);
  println ("<", i < j);
  println (">=", i >= j);
  println (">", i > j);
}

f (1, 2L);
f (1., 2L);
f ("1", 2L);
TEST652
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT652' && $CMP $stdout $ftemp2; then
"+"3l
"-"-1l
"*"2l
"/"0l
"%"1l
"=="0
"!="1
"==="0
"!=="1
"<="1
"<"1
">="0
">"0
"+"3
"-"-1
"*"2
"/"0.5
"%"1
"=="0
"!="1
"==="0
"!=="1
"<="1
"<"1
">="0
">"0
"+"3l
"-"-1l
"*"2l
"/"0l
"%"1l
"=="0
"!="1
"==="0
"!=="1
"<="1
"<"1
">="0
">"0
OUTPUT652
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 653.
if test $result = ok -a $start_test_number -le 653; then
	echo test 653: Long div / mod
        cat >$test_file <<'TEST653'
println (3L / 2);
println ((-3L) / 2);
println (3L / (-2));
println ((-3L) / (-2));
println (3L % 2);
println ((-3L) % 2);
println (3L % (-2));
println ((-3L) % (-2));
TEST653
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT653' && $CMP $stdout $ftemp2; then
1l
-1l
-1l
1l
1l
-1l
1l
-1l
OUTPUT653
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 654.
if test $result = ok -a $start_test_number -le 654; then
	echo test 654 Long division by zero
	cat >$test_file <<'TEST654'
println (3L / 0);
TEST654
	echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
	    if test `uname` = AIX && $CMP - $stderr <<'OUTPUT654'; then
OUTPUT654
		    result=ok
	    elif uname -a|fgrep Linux|fgrep ppc && $CMP - $stderr <<'OUTPUT654a'; then
OUTPUT654a
		    result=ok
	    elif uname -a|fgrep Linux|fgrep ia64 && $CMP - $stderr <<'OUTPUT654b'; then
OUTPUT654b
		    result=ok
	    else
		    result=fail
	    fi
	else
	    echo '      ' $CMP - $stderr
	    if cat >$ftemp2 <<'OUTPUT654-1' && $CMP $stderr $ftemp2; then
test.d:1:13: floating point exception
OUTPUT654-1
		    result=ok
# on systems where there is no zero exception division, gmp generates abort
	    elif cat >$ftemp2 <<'OUTPUT654-1a' && $CMP $stderr $ftemp2; then
test.d:1:13: abort
OUTPUT654-1a
		    result=ok
	    else
                    result=fail
	    fi
        fi
fi

# Test 655.
if test $result = ok -a $start_test_number -le 655; then
	echo test 655 Long module by zero
	cat >$test_file <<'TEST655'
println (3L % 0);
TEST655
	echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
	    if test `uname` = AIX && $CMP - $stderr <<'OUTPUT655'; then
OUTPUT655
		    result=ok
	    elif uname -a|fgrep Linux|fgrep ppc && $CMP - $stderr <<'OUTPUT655a'; then
OUTPUT655a
		    result=ok
	    elif uname -a|fgrep Linux|fgrep ia64 && $CMP - $stderr <<'OUTPUT655b'; then
OUTPUT655b
		    result=ok
	    else
		    result=fail
	    fi
	else
	    echo '      ' $CMP - $stderr
	    if cat >$ftemp2 <<'OUTPUT655-1' && $CMP $stderr $ftemp2; then
test.d:1:13: floating point exception
OUTPUT655-1
		    result=ok
# on systems where there is no zero exception division, gmp generates abort
	    elif cat >$ftemp2 <<'OUTPUT654-1a' && $CMP $stderr $ftemp2; then
test.d:1:13: abort
OUTPUT654-1a
		    result=ok
	    else
                    result=fail
	    fi
        fi
fi

# Test 656.
if test $result = ok -a $start_test_number -le 656; then
	echo test 656: Long vector ops
        cat >$test_file <<'TEST656'
var two = 2l, four = 4l;
var v1 = [10:two], v2 = [10:four];

  println ("+", v1[:] + v2[:]);
  println ("-", v1[:] - v2[:]);
  println ("+", v2[:] + v1[:]);
  println ("-", v2[:] - v1[:]);
  putln ("--------------------------------");
 
  println ("+", v1[:] + four);
  println ("-", v1[:] - four);
  println ("+", v2[:] + two);
  println ("-", v2[:] - two);
  putln ("--------------------------------");
  
  println ("+", two + v2[:]);
  println ("-", two - v2[:]);
  println ("+", four + v2[:]);
  println ("-", four - v2[:]);
  putln ("--------------------------------");

  println ("*", v1[:] * v2[:]);
  println ("*", v1[:] * four);
  println ("*", two * v2[:]);
  putln ("--------------------------------");

  println ("/", v1[:] / v2[:]);
  println ("%", v1[:] % v2[:]);
  println ("/", v2[:] / v1[:]);
  println ("%", v2[:] % v1[:]);
  putln ("--------------------------------");
 
  println ("/", v1[:] / four);
  println ("%", v1[:] % four);
  println ("/", v2[:] / two);
  println ("%", v2[:] % two);
  putln ("--------------------------------");
  
  println ("/", two / v2[:]);
  println ("%", two % v2[:]);
  println ("/", four / v2[:]);
  println ("%", four % v2[:]);
  putln ("--------------------------------");
TEST656
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT656' && $CMP $stdout $ftemp2; then
"+"[6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l]
"-"[-2l, -2l, -2l, -2l, -2l, -2l, -2l, -2l, -2l, -2l]
"+"[6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l]
"-"[2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l]
--------------------------------
"+"[6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l]
"-"[-2l, -2l, -2l, -2l, -2l, -2l, -2l, -2l, -2l, -2l]
"+"[6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l]
"-"[2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l]
--------------------------------
"+"[6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l]
"-"[-2l, -2l, -2l, -2l, -2l, -2l, -2l, -2l, -2l, -2l]
"+"[8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l]
"-"[0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l]
--------------------------------
"*"[8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l]
"*"[8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l]
"*"[8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l]
--------------------------------
"/"[0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l]
"%"[2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l]
"/"[2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l]
"%"[0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l]
--------------------------------
"/"[0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l]
"%"[2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l]
"/"[2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l]
"%"[0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l]
--------------------------------
"/"[0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l]
"%"[2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l]
"/"[1l, 1l, 1l, 1l, 1l, 1l, 1l, 1l, 1l, 1l]
"%"[0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l]
--------------------------------
OUTPUT656
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 657.
if test $result = ok -a $start_test_number -le 657; then
	echo test 657: Long vector ops
        cat >$test_file <<'TEST657'
var i, v1 = [10:2L];
for (i = 0; i < 4; i++) {
  println (".+", .+v1[0:10]);
  println (".*", .*v1[0:10]);
  putln ("--------------------------------");

  if (i == 0)
    v1 = [10:2, nil];
  else if (i == 1)
    v1 = [10:2.5, nil];
  else
    v1 = [5:2.0, 5:2, nil];
}

v1 = [];
println (".+", .+v1[:]);
println (".*", .*v1[:]);
TEST657
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT657' && $CMP $stdout $ftemp2; then
".+"20l
".*"1024l
--------------------------------
".+"20
".*"1024
--------------------------------
".+"25
".*"9536.74
--------------------------------
".+"20
".*"1024
--------------------------------
".+"0
".*"1
OUTPUT657
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 658.
if test $result = ok -a $start_test_number -le 658; then
	echo test 658: Long vector ops
        cat >$test_file <<'TEST658'
println (scan (), scanln ());
for (;1;)
{
  try {
    println (scanln ());
  } catch (eof) {putln ("eof"); break;}
    catch (invinput) {putln ("catch invalid input");}
}
TEST658
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1 <<'INPUT658'; then
102L10
[2l]
[2:2l]
[2:[2l]]
tab []
tab [10l, 2:"10"]
INPUT658
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT658' && $CMP $stdout $ftemp2; then
102l10
[2l]
[2l, 2l]
[[2l], [2l]]
tab []
tab [10l:10l, 2:"10"]
eof
OUTPUT658
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 659.
if test $result = ok -a $start_test_number -le 659; then
	echo test 659: Bug with position in dump
        cat >$test_file <<'TEST659'
fun f {}
var i, n;
n = int (argv [0]);
for (i = 0; i < n; i++) f();
TEST659
        echo '      ' $DINO -d $test_file ">$ftemp"
        if $DINO -d $test_file >$ftemp; then
            echo '      ' $DINO -i $ftemp " 2>$stderr >$stdout"
            if $DINO -i $ftemp 2>$stderr >$stdout; then
               result=fail
            else
               echo '      ' $CMP - $stderr
               if cat >$ftemp2 <<'OUTPUT659' && $CMP $stderr $ftemp2; then
test.d:3:15: run time error - index is greater than array bound
OUTPUT659
                   echo '      ' $CMP - $stdout
                   if cat >$ftemp2 <<'OUTPUT659-2' && $CMP $stdout $ftemp2; then
OUTPUT659-2
                         result=ok
                   else
                         result=fail
                   fi
               else
                       result=fail
               fi
            fi
        else
            result=fail
        fi
fi

# Test 660.
if test $result = ok -a $start_test_number -le 660; then
	echo test 660: Octal and hex numbers
        cat >$test_file <<'TEST660'
println (010, 0x10, 10);
println (010l, 0x10l, 10l);
println (" 010 " + 0, " -0X10 " + 0, " +10 " + 0);
println (" 010l " + 0, " -0X10l " + 0, " +10l " + 0);
TEST660
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT660' && $CMP $stdout $ftemp2; then
81610
8l16l10l
8-1610
8l-16l0l
OUTPUT660
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 661.
if test $result = ok -a $start_test_number -le 661; then
	echo test 661: Wrong octal
        cat >$test_file <<'TEST661'
var i = 09;
TEST661
        echo '      ' $DINO $test_file " 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
           result=fail
        else
           echo '      ' $CMP - $stderr
           if cat >$ftemp2 <<'OUTPUT661' && $CMP $stderr $ftemp2; then
test.d:1:9: octal int with non-octal digit
OUTPUT661
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT661-2' && $CMP $stdout $ftemp2; then
OUTPUT661-2
                     result=ok
               else
                     result=fail
               fi
           else
                   result=fail
           fi
        fi
fi

# Test 662.
if test $result = ok -a $start_test_number -le 662; then
	echo test 662: Wrong float
        cat >$test_file <<'TEST662'
var i = 0x1a.0;
TEST662
        echo '      ' $DINO $test_file " 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
           result=fail
        else
           echo '      ' $CMP - $stderr
           if cat >$ftemp2 <<'OUTPUT662' && $CMP $stderr $ftemp2; then
test.d:1:9: float is not in decimal base
OUTPUT662
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT662-2' && $CMP $stdout $ftemp2; then
OUTPUT662-2
                     result=ok
               else
                     result=fail
               fi
           else
                   result=fail
           fi
        fi
fi

# Test 663.
if test $result = ok -a $start_test_number -le 663; then
	echo test 663: Wrong number
        cat >$test_file <<'TEST663'
var i = 1a;
TEST663
        echo '      ' $DINO $test_file " 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
           result=fail
        else
           echo '      ' $CMP - $stderr
           if cat >$ftemp2 <<'OUTPUT663' && $CMP $stderr $ftemp2; then
test.d:1:10: syntax error
OUTPUT663
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT663-2' && $CMP $stdout $ftemp2; then
OUTPUT663-2
                     result=ok
               else
                     result=fail
               fi
           else
                   result=fail
           fi
        fi
fi

# Test 664.
if test $result = ok -a $start_test_number -le 664; then
	echo test 664: Scanning numbers
        cat >$test_file <<'TEST664'
println (scan (), scanln ());
for (;1;)
{
  try {
    println (scanln ());
  } catch (eof) {putln ("eof"); break;}
    catch (invinput) {putln ("catch invalid input");}
}
TEST664
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1 <<'INPUT664'; then
-010L +0x10
09
1a
0x10.1
010e+1
INPUT664
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT664' && $CMP $stdout $ftemp2; then
-8l16
catch invalid input
1
catch invalid input
100
eof
OUTPUT664
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 665.
if test $result = ok -a $start_test_number -le 665; then
	echo test 665: string to number conversion
        cat >$test_file <<'TEST665'
println (" -010L " + 0);
println (" +0x10 " + 0);
try {println (" +09 " + 0);} catch (optype) {putln ("optypes");}
try {println (" 1a" + 0);} catch (optype) {putln ("optypes");}
try {println ("0x10.1" + 0);} catch (optype) {putln ("optypes");}
println ("010e+1" + 0);
try {println ("100000000000000000000" + 0);} catch (syserror) {putln (e.msg);}
try {println ("10e+10000" + 0);} catch (syserror) {putln (e.msg);}
try {println ("10e-10000" + 0);} catch (syserror) {putln (e.msg);}
TEST665
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT665' && $CMP $stdout $ftemp2; then
-8l
16
optypes
optypes
optypes
100
system error - result too big (small): `string-to-int conversion'
system error - result too big (small): `string-to-float conversion'
system error - result too big (small): `string-to-float conversion'
OUTPUT665
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 666.
if test $result = ok -a $start_test_number -le 666; then
	echo test 666: Long min/max and sort
        cat >$test_file <<'TEST666'
println (min (10L, 1, -2l));
println (max (10L, 1, -2l));
println (min (10L, -5, -2l));
println (max (10L, 15, -2l));
println (min (10L, 1.5, -2l));
println (max (10L, 1.5, -2l));
println (min (10L, -5.5, -2l));
println (max (10L, 15.5, -2l));
println (sort ([10L, 5L, 2L, 7L]));
TEST666
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT666' && $CMP $stdout $ftemp2; then
-2l
10l
-5
15
-2l
10l
-5.5
15.5
[2l, 5l, 7l, 10l]
OUTPUT666
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 667.
if test $result = ok -a $start_test_number -le 667; then
	echo test 667: Long as logical and index
        cat >$test_file <<'TEST667'
var v = [1, 2];
println (v[1l]);
v[1l] = 4; println (v);
v[1l] += 5.5; println (v);
println (1l ? 0 : 2);
var c = 1l;
if (!c || c && c) println (1); else println (0);
var v = [2L:3];
println (v);
TEST667
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT667' && $CMP $stdout $ftemp2; then
2
[1, 4]
[1, 9.5]
0
1
[3, 3]
OUTPUT667
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 668.
if test $result = ok -a $start_test_number -le 668; then
	echo test 668: Foreach with vector
        cat >$test_file <<'TEST668'
var i, v = [];
for (i in v);
TEST668
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT669' && $CMP $stderr $ftemp2; then
test.d:2:1: run time error - non table right to `in'
OUTPUT669
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 669.
if test $result = ok -a $start_test_number -le 669; then
	echo test 669: Slice as index  designator in foreach
        cat >$test_file <<'TEST669'
var iv = [10:1], vv = [10:2], t = tab [10:10];
for (iv[:] in t);
TEST669
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT669' && $CMP $stderr $ftemp2; then
test.d:2:8: vector slice is used as foreach-stmt index_designator
OUTPUT669
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 670.
if test $result = ok -a $start_test_number -le 670; then
	echo test 670: Foreach with vector
        cat >$test_file <<'TEST670'
var i, v = ["a", "b", "c"];
for (i in v) putln (i, ":", v[i]);
putln (i, " ", v[i]);
TEST670
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT670' && $CMP $stderr $ftemp2; then
test.d:2:1: run time error - non table right to `in'
OUTPUT670
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 671.
if test $result = ok -a $start_test_number -le 671; then
	echo test 671: Foreach with composite index
        cat >$test_file <<'TEST671'
var i=[1], v=tab[1], t = tab[1:"a", 10: "b", 100:"c"];
for (i[0] in t) putln (i[0], ":", t[i[0]]);
putln (i[0], " ", t[i[0]]);
class c (f) {};
var o = c ("n");
for (o.f in t) putln (o.f, ":", t[o.f]);
putln (o.f, " ", t[o.f]);
TEST671
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT671' && $CMP $stdout $ftemp2; then
1:a
10:b
100:c
100 c
1:a
10:b
100:c
100 c
OUTPUT671
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 672.
if test $result = ok -a $start_test_number -le 672; then
	echo test 672
        cat >$test_file <<'TEST672'
class c {
  val i;
}

class sc {
  use c former i later i;
  val i;
}
TEST672
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT672' && $CMP $stderr $ftemp2; then
test.d:6:16: repeated occurrence of identifier `i' in use items
test.d:6:24: (previous occurrence of identifier `i')
OUTPUT672
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 673.
if test $result = ok -a $start_test_number -le 673; then
	echo test 673
        cat >$test_file <<'TEST673'
class c {
  val i;
}

class sc {
  val i;
  use c former i, i;
}
TEST673
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT673' && $CMP $stderr $ftemp2; then
test.d:7:16: repeated occurrence of identifier `i' in use items
test.d:7:19: (previous occurrence of identifier `i')
OUTPUT673
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 674.
if test $result = ok -a $start_test_number -le 674; then
	echo test 674: A bug in conversion with cmpi ops
        cat >$test_file <<'TEST674'
if (1.30832+0.00898298 > 1) println (1);
if (1 < 1.30832+0.00898298) println (2);
if (1 != 1.30832+0.00898298) println (3);
if (1 == 1.30832+0.00898298) println (4);
TEST674
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT674' && $CMP $stdout $ftemp2; then
1
2
3
OUTPUT674
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 675.
if test $result = ok -a $start_test_number -le 675; then
	echo test 675: A bug in code generation of loop with continue
        cat >$test_file <<'TEST675'
for (var i =0; i <10;i++)continue;
putln (i);

var i, j = 1;
for (i =0; i <10;i++) {
  if (i < 4) continue;
  j *= 2;
}
putln (i, " ", j);
TEST675
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT675' && $CMP $stdout $ftemp2; then
10
10 64
OUTPUT675
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 676.
if test $result = ok -a $start_test_number -le 676; then
	echo test 676: Use with forward
        cat >$test_file <<'TEST676'
class c {
  fun i {putln ("c");}
}

class sc {
  use c later i;
  fun i;
  use c former i;
  fun i {putln ("sc");}
}

val osc = sc ();
osc.i ();
TEST676
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT676' && $CMP $stdout $ftemp2; then
sc
OUTPUT676
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 677.
if test $result = ok -a $start_test_number -le 677; then
	echo test 677  Two wrong uses
        cat >$test_file <<'TEST677'
class c {
  fun i {};
}

class c2 {
  fun i {};
}

class sc {
  use c;
  use c2;
}
TEST677
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT677' && $CMP $stderr $ftemp2; then
test.d:11:7: used decl redefines previous `i' and is not mentioned in former item
test.d:2:7: (previous declaration of identifier `i')
OUTPUT677
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 678.
if test $result = ok -a $start_test_number -le 678; then
	echo test 678  One right use and one wrong use
        cat >$test_file <<'TEST678'
class c {
  fun i {};
}

class sc {
  use c later i;
  fun i {};
  use c;
}
TEST678
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT678' && $CMP $stderr $ftemp2; then
test.d:8:7: used decl redefines previous `i' and is not mentioned in former item
test.d:7:7: (previous declaration of identifier `i')
OUTPUT678
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 679.
if test $result = ok -a $start_test_number -le 679; then
	echo test 679  One right use and one wrong use and forward
        cat >$test_file <<'TEST679'
class c {
  fun i {};
}

class sc {
  use c later i;
  fun i;
  use c;
}
TEST679
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT679' && $CMP $stderr $ftemp2; then
test.d:8:7: used decl redefines previous `i' and is not mentioned in former item
test.d:7:7: (previous declaration of identifier `i')
OUTPUT679
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 680.
if test $result = ok -a $start_test_number -le 680; then
	echo test 680: Two uses with forward without definition
        cat >$test_file <<'TEST680'
class c {
  fun i {};
}

class sc {
  use c later i;
  fun i;
  use c former i;
}
TEST680
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT680' && $CMP $stdout $ftemp2; then
OUTPUT680
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 681.
if test $result = ok -a $start_test_number -le 681; then
	echo test 681: Two uses with later
        cat >$test_file <<'TEST681'
class c {
  fun i {}
  fun c {put ("c -- "); i ();}
}

class c2 {
  fun i {};
  fun c2 {put ("c2 -- "); i ();}
}

class sc {
  use c later i;
  use c2 later i;
  fun i {putln ("sc");}
}

var osc = sc ();
osc.c ();
osc.c2 ();
TEST681
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT681' && $CMP $stdout $ftemp2; then
c -- sc
c2 -- sc
OUTPUT681
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 682.
if test $result = ok -a $start_test_number -le 682; then
	echo test 682: Two uses of one class
        cat >$test_file <<'TEST682'
class c {
  fun i {putln ("ic");}
  fun j {putln ("jc");}
}

class sc {
  use c later i;
  use c former j;
}

var osc = sc ();
osc.i ();
osc.j ();
TEST682
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT682' && $CMP $stdout $ftemp2; then
ic
jc
OUTPUT682
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 683.
if test $result = ok -a $start_test_number -le 683; then
	echo test 683: Func isa
        cat >$test_file <<'TEST683'
class a {
}

class b {
}

class c {
  use b;
  fun i {putln ("i");}
  fun c {put ("c -- "); i ();}
}

putln (isa (c, b));
putln (isa (c (), b));

putln (isa (c, a));
putln (isa (c (), a));
TEST683
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT683' && $CMP $stdout $ftemp2; then
1
1
0
0
OUTPUT683
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 684.
if test $result = ok -a $start_test_number -le 684; then
	echo test 684: wrong number of pars in isa
        cat >$test_file <<'TEST684'
isa ("");
TEST684
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT684' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - unexpected number of parameters for `isa'
OUTPUT684
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 684b.
if test $result = ok -a $start_test_number -le 684; then
	echo test 684b: wrong 1st par in isa
        cat >$test_file <<'TEST684b'
class c {}
isa ("", c);
TEST684b
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT684b' && $CMP $stderr $ftemp2; then
test.d:2:5: run time error - invalid parameter type of `isa'
OUTPUT684b
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 685.
if test $result = ok -a $start_test_number -le 685; then
	echo test 685: wrong 2nd par in isa
        cat >$test_file <<'TEST685'
class c {}
isa (c,"");
TEST685
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT685' && $CMP $stderr $ftemp2; then
test.d:2:5: run time error - invalid parameter type of `isa'
OUTPUT685
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 686.
if test $result = ok -a $start_test_number -le 686; then
	echo test 686: Removing out 0
        cat >$test_file <<'TEST686'
for (var i = 0; i < 1000; i++)
  if (i % 1000 == 3) break;
TEST686
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`' fgrep out $stdout '| fgrep op1=0 | wc -l`' = 0
                if expr `fgrep out $stdout | fgrep op1=0 | wc -l` = 0 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 687.
if test $result = ok -a $start_test_number -le 687; then
	echo test 687: former with renaming
        cat >$test_file <<'TEST687'
class c {
  val v = 0;
  fun i {putln ("1c", v);}
  fun i {putln ("2c", v);}
}

class sc {
  val v = 1;
  fun i {putln ("sc", v);}
  use c former v, i (ic);
}

var osc = sc ();
osc.i();
osc.ic();
TEST687
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT687' && $CMP $stdout $ftemp2; then
sc1
2c1
OUTPUT687
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 688.
if test $result = ok -a $start_test_number -le 688; then
	echo test 688: former with renaming
        cat >$test_file <<'TEST688'
class c {
  val v = 0;
  fun i {putln ("1c", v);}
  fun i {putln ("2c", v);}
}

class sc {
  use c later v, i (ic);
  val v = 1;
  fun i {putln ("sc", v);}
}

var osc = sc ();
osc.i();
osc.ic();
TEST688
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT688' && $CMP $stdout $ftemp2; then
sc1
2c1
OUTPUT688
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 689.
if test $result = ok -a $start_test_number -le 689; then
	echo test 689: Non unique renamed decl with former
        cat >$test_file <<'TEST689'
class c {
  val v = 0;
  fun i {putln ("1c", v);}
  fun i {putln ("2c", v);}
}

class sc {
  val v = 1;
  fun i {putln ("sc", v);}
  fun ic {putln ("ic", v);}
  use c former v, i (ic);
}

var osc = sc ();
osc.i();
osc.ic();
TEST689
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT689' && $CMP $stderr $ftemp2; then
test.d:11:7: alias redefines previous `ic'
test.d:10:7: (previous declaration of identifier `ic')
test.d:11:7: alias redefines previous `ic'
test.d:10:7: (previous declaration of identifier `ic')
OUTPUT689
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 690.
if test $result = ok -a $start_test_number -le 690; then
	echo test 690: Non unique renamed decl with later
        cat >$test_file <<'TEST690'
class c {
  val v = 0;
  fun i {putln ("1c", v);}
  fun i {putln ("2c", v);}
}

class sc {
  use c later v, i (ic);
  val v = 1;
  fun i {putln ("sc", v);}
  fun ic {putln ("ic", v);}
}

var osc = sc ();
osc.i();
osc.ic();
TEST690
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT690' && $CMP $stderr $ftemp2; then
test.d:11:7: alias `ic' is redefined
test.d:8:21: (previous declaration of identifier `ic')
OUTPUT690
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 691.
if test $result = ok -a $start_test_number -le 691; then
	echo test 691: Another non unique renamed decl with former
        cat >$test_file <<'TEST691'
class c {
  val v = 0;
  fun i {putln ("1c", v);}
  fun i {putln ("2c", v);}
}

class sc {
  val v = 1;
  fun i {putln ("sc", v);}
  use c former v, i (ic);
  fun ic {putln ("ic", v);}
}

var osc = sc ();
osc.i();
osc.ic();
TEST691
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT691' && $CMP $stderr $ftemp2; then
test.d:11:7: alias `ic' is redefined
test.d:10:22: (previous declaration of identifier `ic')
OUTPUT691
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 692.
if test $result = ok -a $start_test_number -le 692; then
	echo test 692: Abstract fun call
        cat >$test_file <<'TEST692'
fun f;
f ();
TEST692
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT692' && $CMP $stderr $ftemp2; then
test.d:2:3: run time error - unfinished fun/class `f' call
OUTPUT692
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 693.
if test $result = ok -a $start_test_number -le 693; then
	echo test 693: Abstract method call
        cat >$test_file <<'TEST693'
class c {fun f;}
c ().f ();
TEST693
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT693' && $CMP $stderr $ftemp2; then
test.d:2:5: run time error - undefined class or function `f'
OUTPUT693
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 694.
if test $result = ok -a $start_test_number -le 694; then
	echo test 694: Abstract function access
        cat >$test_file <<'TEST694'
fun f;
val v = f;
TEST694
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT694' && $CMP $stderr $ftemp2; then
test.d:2:9: run time error - undefined class or function `f'
OUTPUT694
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 695.
if test $result = ok -a $start_test_number -le 695; then
	echo test 695: A bug for initialization with redifinition
        cat >$test_file <<'TEST695'
val a = 10, a = a + 10;
putln (a);
TEST695
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT695' && $CMP $stdout $ftemp2; then
20
OUTPUT695
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 696.
if test $result = ok -a $start_test_number -le 696; then
	echo test 696: An object
        cat >$test_file <<'TEST696'
obj a {
  fun p {putln ("obj");}
}

a.p ();
TEST696
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT696' && $CMP $stdout $ftemp2; then
obj
OUTPUT696
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 697.
if test $result = ok -a $start_test_number -le 697; then
	echo test 697: JIT: from C to interpreter
        cat >$test_file <<'TEST697'
fun a {
  putln ("in a");
}

fun b ! jit {
  putln ("in b");
  a ();
  putln ("at b end");
}

b ();
putln ("end");
TEST697
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT697' && $CMP $stdout $ftemp2; then
in b
in a
at b end
end
OUTPUT697
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT697-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 1, their calls - 1
OUTPUT697-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 698.
if test $result = ok -a $start_test_number -le 698; then
	echo test 698: JIT: from interpreter to C
        cat >$test_file <<'TEST698'
fun a ! jit {
  putln ("in a");
}

fun b {
  putln ("in b");
  a ();
  putln ("at b end");
}

b ();
putln ("end");
TEST698
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT698' && $CMP $stdout $ftemp2; then
in b
in a
at b end
end
OUTPUT698
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT698-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 1, their calls - 1
OUTPUT698-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 699.
if test $result = ok -a $start_test_number -le 699; then
	echo test 699: JIT: from C to C
        cat >$test_file <<'TEST699'
fun a ! jit {
  putln ("in a");
}

fun b ! jit {
  putln ("in b");
  a ();
  putln ("at b end");
}

b ();
putln ("end");
TEST699
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT699' && $CMP $stdout $ftemp2; then
in b
in a
at b end
end
OUTPUT699
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT699-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 2, their calls - 2
OUTPUT699-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 700.
if test $result = ok -a $start_test_number -le 700; then
	echo test 700: JIT: Interpreter calls C with throw
        cat >$test_file <<'TEST700'
fun a ! jit {
  putln ("in a");
  throw except ();
}

fun b {
  putln ("in b");
  a ();
  putln ("at b end");
}

try {
  b ();
} catch (except) {putln ("except");}

putln ("end");
TEST700
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT700' && $CMP $stdout $ftemp2; then
in b
in a
except
end
OUTPUT700
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT700-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 1, their calls - 1
OUTPUT700-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 701.
if test $result = ok -a $start_test_number -le 701; then
	echo test 701: JIT: C calls interpreter with throw
        cat >$test_file <<'TEST701'
fun a {
  putln ("in a");
  throw except ();
}

fun b ! jit {
  putln ("in b");
  a ();
  putln ("at b end");
}

try {
  b ();
} catch (except) {putln ("except");}

putln ("end");
TEST701
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT701' && $CMP $stdout $ftemp2; then
in b
in a
except
end
OUTPUT701
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT701-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 1, their calls - 1
OUTPUT701-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 702.
if test $result = ok -a $start_test_number -le 702; then
	echo test 702: JIT: C calls C with throw
        cat >$test_file <<'TEST702'
fun a ! jit {
  putln ("in a");
  throw except ();
}

fun b ! jit {
  putln ("in b");
  a ();
  putln ("at b end");
}

try {
  b ();
} catch (except) {putln ("except");}

putln ("end");
TEST702
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT702' && $CMP $stdout $ftemp2; then
in b
in a
except
end
OUTPUT702
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT702-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 2, their calls - 2
OUTPUT702-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 703.
if test $result = ok -a $start_test_number -le 703; then
	echo test 703: JIT: Interpreter with try calls C with throw
        cat >$test_file <<'TEST703'
fun a ! jit {
  putln ("in a");
  throw except ();
}

fun b {
  putln ("in b");
  try {
    a ();
  } catch (except) {putln ("except");}
  putln ("at b end");
}

b ();
putln ("end");
TEST703
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT703' && $CMP $stdout $ftemp2; then
in b
in a
except
at b end
end
OUTPUT703
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT703-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 1, their calls - 1
OUTPUT703-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 704.
if test $result = ok -a $start_test_number -le 704; then
	echo test 704: JIT: C with try calls C with throw
        cat >$test_file <<'TEST704'
fun a ! jit {
  putln ("in a");
  throw except ();
}

fun b ! jit {
  putln ("in b");
  try {
    a ();
  } catch (except) {putln ("except");}
  putln ("at b end");
}

b ();
putln ("end");
TEST704
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT704' && $CMP $stdout $ftemp2; then
in b
in a
except
at b end
end
OUTPUT704
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT704-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 2, their calls - 2
OUTPUT704-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 705.
if test $result = ok -a $start_test_number -le 705; then
	echo test 705: JIT: C with try calls interpreter with throw
        cat >$test_file <<'TEST705'
fun a {
  putln ("in a");
  throw except ();
}

fun b ! jit {
  putln ("in b");
  try {
    a ();
  } catch (except) {putln ("except");}
  putln ("at b end");
}

b ();
putln ("end");
TEST705
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT705' && $CMP $stdout $ftemp2; then
in b
in a
except
at b end
end
OUTPUT705
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT705-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 1, their calls - 1
OUTPUT705-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 706.
if test $result = ok -a $start_test_number -le 706; then
	echo test 706: JIT: C calls interpreter with exception
        cat >$test_file <<'TEST706'
fun a {
  throw except ();
}

fun b ! jit {
  putln ("in b");
  a ();
  putln ("at b end");
}

b ();
putln ("end");
TEST706
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
           result=fail
	else
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT706' && $CMP $stdout $ftemp2; then
in b
OUTPUT706
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT706-2' && $CMP $stderr $ftemp2; then
test.d:2:3: run time error - exception except has not been processed
OUTPUT706-2
			result=ok
                    else
                        result=fail
                    fi
                else
                   result=fail
                fi
        fi
fi

# Test 707.
if test $result = ok -a $start_test_number -le 707; then
	echo test 707: JIT: Interpreter calls C with exception
        cat >$test_file <<'TEST707'
fun a ! jit {
  throw except ();
}

fun b {
  putln ("in b");
  a ();
  putln ("at b end");
}

b ();
putln ("end");
TEST707
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
           result=fail
	else
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT707' && $CMP $stdout $ftemp2; then
in b
OUTPUT707
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT707-2' && $CMP $stderr $ftemp2; then
test.d:2:3: run time error - exception except has not been processed
OUTPUT707-2
			result=ok
                    else
                        result=fail
                    fi
                else
                   result=fail
                fi
        fi
fi

# Test 708.
if test $result = ok -a $start_test_number -le 708; then
	echo test 708: JIT: C calls C with exception
        cat >$test_file <<'TEST708'
fun a ! jit {
  throw except ();
}

fun b ! jit {
  putln ("in b");
  a ();
  putln ("at b end");
}

b ();
putln ("end");
TEST708
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
           result=fail
	else
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT708' && $CMP $stdout $ftemp2; then
in b
OUTPUT708
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT708-2' && $CMP $stderr $ftemp2; then
test.d:2:3: run time error - exception except has not been processed
OUTPUT708-2
			result=ok
                    else
                        result=fail
                    fi
                else
                   result=fail
                fi
        fi
fi

# Test 709.
if test $result = ok -a $start_test_number -le 709; then
	echo test 709: JIT: C calls interpreter with GC
        cat >$test_file <<'TEST709'
fun a {
  gc ();
}

fun b ! jit {
  putln ("in b");
  try {
    a ();
  } catch (except) {putln ("except");}
  putln ("at b end");
}

b ();
putln ("end");
TEST709
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT709' && $CMP $stdout $ftemp2; then
in b
at b end
end
OUTPUT709
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT709-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 1, their calls - 1
OUTPUT709-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 710.
if test $result = ok -a $start_test_number -le 710; then
	echo test 710: JIT: Interpreter calls C with GC
        cat >$test_file <<'TEST710'
fun a ! jit {
  gc ();
}

fun b {
  putln ("in b");
  try {
    a ();
  } catch (except) {putln ("except");}
  putln ("at b end");
}

b ();
putln ("end");
TEST710
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT710' && $CMP $stdout $ftemp2; then
in b
at b end
end
OUTPUT710
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT710-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 1, their calls - 1
OUTPUT710-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 711.
if test $result = ok -a $start_test_number -le 711; then
	echo test 711: JIT: C calls C with GC
        cat >$test_file <<'TEST711'
fun a ! jit {
  gc ();
}

fun b ! jit {
  putln ("in b");
  try {
    a ();
  } catch (except) {putln ("except");}
  putln ("at b end");
}

b ();
putln ("end");
TEST711
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT711' && $CMP $stdout $ftemp2; then
in b
at b end
end
OUTPUT711
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT711-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 2, their calls - 2
OUTPUT711-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 712.
if test $result = ok -a $start_test_number -le 712; then
	echo test 712: Last expr-stmt as a return
        cat >$test_file <<'TEST712'
fun even;
fun odd  (i) {i == 0 ? 0 : even (i - 1);}
fun even (i) {i == 0 ? 1 : odd (i - 1);}
putln (odd (1000000));
putln (odd (1000001));
TEST712
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT712' && $CMP $stdout $ftemp2; then
0
1
OUTPUT712
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 713
if test $result = ok -a $start_test_number -le 713; then
	echo test 713: Undefined global values
        cat >$test_file <<'TEST713'
var t=tab[], a;
t['0']=a;
TEST713
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT713' && $CMP $stderr $ftemp2; then
test.d:2:7: run time error - undefined value assign
OUTPUT713
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT713-2' && $CMP $stdout $ftemp2; then
OUTPUT713-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 714
if test $result = ok -a $start_test_number -le 714; then
	echo test 714: Undefined return value to vec
        cat >$test_file <<'TEST714'
fun f {}
var v=[1:0];
v[0] = f();
TEST714
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT714' && $CMP $stderr $ftemp2; then
test.d:3:6: run time error - undefined value assign
OUTPUT714
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT714-2' && $CMP $stdout $ftemp2; then
OUTPUT714-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 715
if test $result = ok -a $start_test_number -le 715; then
	echo test 715: Undefined return value to tab
        cat >$test_file <<'TEST715'
fun f {}
var t=tab[];
t['0'] = f();
TEST715
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT715' && $CMP $stderr $ftemp2; then
test.d:3:8: run time error - undefined value assign
OUTPUT715
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT715-2' && $CMP $stdout $ftemp2; then
OUTPUT715-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 716
if test $result = ok -a $start_test_number -le 716; then
	echo test 716: Undefined return value to local
        cat >$test_file <<'TEST716'
fun f {}
var v = f();
TEST716
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT716' && $CMP $stderr $ftemp2; then
test.d:2:7: run time error - undefined value assign
OUTPUT716
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT716-2' && $CMP $stdout $ftemp2; then
OUTPUT716-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 717.
if test $result = ok -a $start_test_number -le 717; then
	echo test 717: Inlining with inside function
        cat >$test_file <<'TEST717'
fun f (x) ! inline {
  fun f2 (y) {x+y;}
  f2 (10);
}

putln (f (5));
TEST717
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT717' && $CMP $stdout $ftemp2; then
15
OUTPUT717
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT717-2' && (fgrep 'Inlined' $stderr | $CMP - $ftemp2); then
Inlined calls - 1
OUTPUT717-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 718.
if test $result = ok -a $start_test_number -le 718; then
	echo test 718: Inlining with clouser
        cat >$test_file <<'TEST718'
fun f (x) ! inline {
  fun f2 (y) {x+y;}
  return f2;
}

putln (f (5) (10));
TEST718
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT718' && $CMP $stdout $ftemp2; then
15
OUTPUT718
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT718-2' && (fgrep 'Inlined' $stderr | $CMP - $ftemp2); then
OUTPUT718-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 719.
if test $result = ok -a $start_test_number -le 719; then
	echo test 719: Nested Inlining
        cat >$test_file <<'TEST719'
fun f (x) ! inline {
  fun f2 (y) ! inline {x+y;}
  f2 (10);
}

putln (f (5));
TEST719
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT719' && $CMP $stdout $ftemp2; then
15
OUTPUT719
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT719-2' && (fgrep 'Inlined' $stderr | $CMP - $ftemp2); then
Inlined calls - 3
OUTPUT719-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 720.
if test $result = ok -a $start_test_number -le 720; then
	echo test 720: Inlining with clouser
        cat >$test_file <<'TEST720'
fun f (x) ! inline {
  fun f2 (y) {x+y;}
  return this;
}

var o = f (5);
TEST720
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT720' && $CMP $stdout $ftemp2; then
OUTPUT720
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT720-2' && (fgrep 'Inlined' $stderr | $CMP - $ftemp2); then
OUTPUT720-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 721.
if test $result = ok -a $start_test_number -le 721; then
	echo test 721: Inlining recursive function
        cat >$test_file <<'TEST721'
fun fact (x) ! inline {
  if (x <= 1)
    return 1;
  return x * fact (x-1);
}

putln (fact (12));
TEST721
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT721' && $CMP $stdout $ftemp2; then
479001600
OUTPUT721
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT721-2' && (fgrep 'Inlined' $stderr | $CMP - $ftemp2); then
Inlined calls - 1
OUTPUT721-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 722.
if test $result = ok -a $start_test_number -le 722; then
	echo test 722: Inlining complex recursive function
        cat >$test_file <<'TEST722'
fun ack (m, n) !inline {
    if (m == 0) return n + 1;
    if (n == 0) return ack (m - 1, 1);
    return ack (m - 1, ack (m, (n - 1)));
}

val n = 5;
putln ("Ack(3,", n, "): ", ack (3, n));
TEST722
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT722' && $CMP $stdout $ftemp2; then
Ack(3,5): 253
OUTPUT722
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT722-2' && (fgrep 'Inlined' $stderr | $CMP - $ftemp2); then
Inlined calls - 1
OUTPUT722-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 723.
if test $result = ok -a $start_test_number -le 723; then
	echo test 723: Inlining tail recursive functions
        cat >$test_file <<'TEST723'
fun even;
fun odd (i) !inline { if (i == 0) return 0; return even (i - 1);}
fun even (i) !inline { if (i == 0) return 1; return odd (i - 1);}
putln (odd (10));
TEST723
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT723' && $CMP $stdout $ftemp2; then
0
OUTPUT723
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT723-2' && (fgrep 'Inlined' $stderr | $CMP - $ftemp2); then
Inlined calls - 4
OUTPUT723-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 724.
if test $result = ok -a $start_test_number -le 724; then
	echo test 724: Inlining tail recursive functions inside another function
        cat >$test_file <<'TEST724'
fun main {
  fun even;
  fun odd (i) !inline { if (i == 0) return 0; return even (i - 1);}
  fun even (i) !inline { if (i == 0) return 1; return odd (i - 1);}
  putln (odd (10));
}
main ();
TEST724
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT724' && $CMP $stdout $ftemp2; then
0
OUTPUT724
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT724-2' && (fgrep 'Inlined' $stderr | $CMP - $ftemp2); then
Inlined calls - 4
OUTPUT724-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 725.
if test $result = ok -a $start_test_number -le 725; then
	echo test 725: Inlining with inside function in another function
        cat >$test_file <<'TEST725'
fun main {
  fun f (x) ! inline {
    fun f2 (y) {x+y;}
    f2 (10);
  }
  putln (f (5));
}
main ();
TEST725
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT725' && $CMP $stdout $ftemp2; then
15
OUTPUT725
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT725-2' && (fgrep 'Inlined' $stderr | $CMP - $ftemp2); then
Inlined calls - 1
OUTPUT725-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 726
if test $result = ok -a $start_test_number -le 726; then
	echo test 726: Inline for thread
        cat >$test_file <<'TEST726'
thread t !inline {}
TEST726
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT726' && $CMP $stderr $ftemp2; then
test.d:1:8: inline or pure hint is permitted only for fun
OUTPUT726
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT726-2' && $CMP $stdout $ftemp2; then
OUTPUT726-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 727
if test $result = ok -a $start_test_number -le 727; then
	echo test 727: Inline for class
        cat >$test_file <<'TEST727'
class t !inline {}
TEST727
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT727' && $CMP $stderr $ftemp2; then
test.d:1:7: inline or pure hint is permitted only for fun
OUTPUT727
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT727-2' && $CMP $stdout $ftemp2; then
OUTPUT727-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 728
if test $result = ok -a $start_test_number -le 728; then
	echo test 728: Pure for thread
        cat >$test_file <<'TEST728'
thread t !pure {}
TEST728
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT728' && $CMP $stderr $ftemp2; then
test.d:1:8: inline or pure hint is permitted only for fun
OUTPUT728
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT728-2' && $CMP $stdout $ftemp2; then
OUTPUT728-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 729
if test $result = ok -a $start_test_number -le 729; then
	echo test 729: Pure for class
        cat >$test_file <<'TEST729'
class t !pure {}
TEST729
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT729' && $CMP $stderr $ftemp2; then
test.d:1:7: inline or pure hint is permitted only for fun
OUTPUT729
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT729-2' && $CMP $stdout $ftemp2; then
OUTPUT729-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 730
if test $result = ok -a $start_test_number -le 730; then
	echo test 730: Pure for thread
        cat >$test_file <<'TEST730'
thread t !jit {}
TEST730
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT730' && $CMP $stderr $ftemp2; then
test.d:1:8: jit hint is not permitted for thread
OUTPUT730
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT730-2' && $CMP $stdout $ftemp2; then
OUTPUT730-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 731
if test $result = ok -a $start_test_number -le 731; then
	echo test 731: Unknown hint
        cat >$test_file <<'TEST731'
fun f !abracadabra {}
TEST731
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT731' && $CMP $stderr $ftemp2; then
test.d:1:8: unknown hint abracadabra
OUTPUT731
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT731-2' && $CMP $stdout $ftemp2; then
OUTPUT731-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 732.
if test $result = ok -a $start_test_number -le 732; then
	echo test 732: multi generation
        cat >$test_file <<'TEST732'
val i = 2;
putln (i * 10);
TEST732
        echo '      ' $DINO -d $test_file ">$stdout 2>$stderr"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep multi $stdout
                if fgrep multi $stdout > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 733.
if test $result = ok -a $start_test_number -le 733; then
	echo test 733: multi generation
        cat >$test_file <<'TEST733'
var i = 0;
i*=2;
i=i*3;
i=4*i;
TEST733
        echo '      ' $DINO -d $test_file ">$stdout 2>$stderr"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`' fgrep multi $stdout '|wc -l`' = 3
                if expr `fgrep " multi" $stdout|wc -l` = 3 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 734.
if test $result = ok -a $start_test_number -le 734; then
	echo test 734: no multi generation for slices
        cat >$test_file <<'TEST734'
var i = [10:0];
i[:]=i[:]*2;
TEST734
        echo '      ' $DINO -d $test_file ">$stdout 2>$stderr"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep -v multi $stdout
                if fgrep -v multi $stdout > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 735.
if test $result = ok -a $start_test_number -le 735; then
	echo test 735: madd generation
        cat >$test_file <<'TEST735'
var i = 0, j = 0;
i=j+i*i;
i=i*i+j;
TEST735
        echo '      ' $DINO -d $test_file ">$stdout 2>$stderr"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`' fgrep madd $stdout '|wc -l`' = 2
                if expr `fgrep " madd" $stdout|wc -l` = 2 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 736.
if test $result = ok -a $start_test_number -le 736; then
	echo test 736: no madd generation for slices
        cat >$test_file <<'TEST736'
var i = [10:0], j = 2;
i[:]=i[:]*j + i[:];
TEST736
        echo '      ' $DINO -d $test_file ">$stdout 2>$stderr"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep -v madd $stdout
                if fgrep -v madd $stdout > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 737.
if test $result = ok -a $start_test_number -le 737; then
	echo test 737: ind2 for vectors
        cat >$test_file <<'TEST737'
val N=5;
var i, j, v, m = [N:0];
for (i = 0; i < N; i++) {
  v = [N:0]; m[i] = v;
  for (j = 0; j < N; j++)
    v[j] = i * j;
}

println (m);
for (i = 0; i < N; i++) for (j = 0; j < N; j++) m[i][j] = i * j;
println (m);
for (i = 0; i < N; i++) for (j = 0; j < N; j++) put (m[i][j]); // ind2
putln ();
for (i = 0; i < N; i++) for (j = 0; j < N; j++) put (m[i+0.0][j]); // ind2
putln ();
for (i = 0; i < N; i++) for (j = 0; j < N; j++) put (m[i][j+0.0]);
putln ();
m[0][0] = 0.5;
println (m);
TEST737
        echo '      ' $DINO -d $test_file ">$stdout 2>$stderr"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`' fgrep ind2 $stdout '|wc -l`' = 2
                if expr `fgrep ind2 $stdout|wc -l` = 2 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 738.
if test $result = ok -a $start_test_number -le 738; then
	echo test 738: ind2 for tables
        cat >$test_file <<'TEST738'
val N=5;
var i, j, v, m = tab[];
for (i = 0; i < N; i++) {
  v = tab[]; m[i] = v;
  for (j = 0; j < N; j++)
    v[j] = i * j;
}

fun pm () {
  for (i = 0; i < N; i++) for (j = 0; j < N; j++) put (m[i][j]); putln (); // ind2
}

pm ();
for (i = 0; i < N; i++) for (j = 0; j < N; j++) m[i][j] = i * j;
pm ();
m[0][0] = 0.5; pm ();
TEST738
        echo '      ' $DINO -d $test_file ">$stdout 2>$stderr"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`' fgrep ind2 $stdout '|wc -l`' = 1
                if expr `fgrep ind2 $stdout|wc -l` = 1 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 739.
if test $result = ok -a $start_test_number -le 739; then
	echo test 739: ind2 for vectors: execution
        cat >$test_file <<'TEST739'
val N=5;
var i, j, v, m = [N:0];
for (i = 0; i < N; i++) {
  v = [N:0]; m[i] = v;
  for (j = 0; j < N; j++)
    v[j] = i * j;
}

println (m);
for (i = 0; i < N; i++) for (j = 0; j < N; j++) m[i][j] = i * j;
println (m);
for (i = 0; i < N; i++) for (j = 0; j < N; j++) put (m[i][j]); // ind2
putln ();
for (i = 0; i < N; i++) for (j = 0; j < N; j++) put (m[i+0.0][j]); // ind2
putln ();
for (i = 0; i < N; i++) for (j = 0; j < N; j++) put (m[i][j+0.0]);
putln ();
m[0][0] = 0.5;
println (m);
TEST739
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT739' && $CMP $stdout $ftemp2; then
[[0, 0, 0, 0, 0], [0, 1, 2, 3, 4], [0, 2, 4, 6, 8], [0, 3, 6, 9, 12], [0, 4, 8, 12, 16]]
[[0, 0, 0, 0, 0], [0, 1, 2, 3, 4], [0, 2, 4, 6, 8], [0, 3, 6, 9, 12], [0, 4, 8, 12, 16]]
0000001234024680369120481216
0000001234024680369120481216
0000001234024680369120481216
[[0.5, 0, 0, 0, 0], [0, 1, 2, 3, 4], [0, 2, 4, 6, 8], [0, 3, 6, 9, 12], [0, 4, 8, 12, 16]]
OUTPUT739
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 740.
if test $result = ok -a $start_test_number -le 740; then
	echo test 740: ind2 for tables: execution
        cat >$test_file <<'TEST740'
val N=5;
var i, j, v, m = tab[];
for (i = 0; i < N; i++) {
  v = tab[]; m[i] = v;
  for (j = 0; j < N; j++)
    v[j] = i * j;
}

fun pm () {
  for (i = 0; i < N; i++) for (j = 0; j < N; j++) put (m[i][j]); putln (); // ind2
}

pm ();
for (i = 0; i < N; i++) for (j = 0; j < N; j++) m[i][j] = i * j;
pm ();
m[0][0] = 0.5; pm ();
TEST740
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT740' && $CMP $stdout $ftemp2; then
0000001234024680369120481216
0000001234024680369120481216
0.5000001234024680369120481216
OUTPUT740
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 741.
if test $result = ok -a $start_test_number -le 741; then
	echo test 741: Check undef usage and type inference
        cat >$test_file <<'TEST741'
var i;
i|1;
i=2;
TEST741
        echo '      ' $DINO -O -d $test_file ">$stdout 2>$stderr"
        if $DINO -O -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`' fgrep ior $stdout '|wc -l`' = 0
                if expr `fgrep ior $stdout|wc -l` = 0 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 742.
if test $result = ok -a $start_test_number -le 742; then
	echo test 742: Check def usage and type inference
        cat >$test_file <<'TEST742'
var i=2;
i|1;
i=2;
TEST742
        echo '      ' $DINO -O -d $test_file ">$stdout 2>$stderr"
        if $DINO -O -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`' fgrep ior $stdout '|wc -l`' = 1
                if expr `fgrep ior $stdout|wc -l` = 1 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 743.
if test $result = ok -a $start_test_number -le 743; then
	echo test 743: Bug in foreach vars allocation
        cat >$test_file <<'TEST743'
fun t (t) {
  var i, k;
  for (i = 0; i < 10; i++) {
    for (k in t)
      if (!(i in t))
        return 1;
  }
  return 0;
}

exit (t (tab [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]));
TEST743
        echo '      ' $DINO $test_file
        if $DINO $test_file; then
                result=ok
        else
                result=fail
        fi
fi


# Test 744.
if test $result = ok -a $start_test_number -le 744; then
	echo test 744: Nbody from computer language shooutout
        cat >$test_file <<'TEST744'

val pi = 3.141592653589793;
val solar_mass = (4 * pi * pi);
val days_per_year = 365.24;

class planet (x, y, z, vx, vy, vz, mass) {}

fun advance (bodies, dt) !jit {
  val lim = #bodies - 1;
  var i, j, b, b2, dx, dy, dz, distance, mag;
    
  for (i = 0; i < lim; i++) {
    b = bodies[i];
    for (j = i + 1; j <= lim; j++) {
      b2 = bodies[j]; dx = b.x - b2.x; dy = b.y - b2.y; dz = b.z - b2.z;
      distance = sqrt (dx * dx + dy * dy + dz * dz);
      mag = dt / (distance * distance * distance);
      b.vx -= dx * b2.mass * mag; b.vy -= dy * b2.mass * mag; b.vz -= dz * b2.mass * mag;
      b2.vx += dx * b.mass * mag; b2.vy += dy * b.mass * mag; b2.vz += dz * b.mass * mag;
    }
  }
  for (i = 0; i <= lim; i++) {
    b = bodies[i];
    b.x += dt * b.vx; b.y += dt * b.vy; b.z += dt * b.vz;
  }
}

fun energy (bodies) {
  val nbodies = #bodies;
  var e, i, j, b, b2, dx, dy, dz, distance;

  e = 0.0;
  for (i = 0; i < nbodies; i++) {
    b = bodies[i];
    e += 0.5 * b.mass * (b.vx * b.vx + b.vy * b.vy + b.vz * b.vz);
    for (j = i + 1; j < nbodies; j++) {
      b2 = bodies[j];
      dx = b.x - b2.x; dy = b.y - b2.y; dz = b.z - b2.z;
      distance = sqrt (dx * dx + dy * dy + dz * dz);
      e -= (b.mass * b2.mass) / distance;
    }
  }
  return e;
}

fun offset_momentum (bodies) {
  val nbodies = #bodies;
  var i,  px = 0.0, py = 0.0, pz = 0.0;

  for (i = 0; i < nbodies; i++) {
    px += bodies[i].vx * bodies[i].mass;
    py += bodies[i].vy * bodies[i].mass;
    pz += bodies[i].vz * bodies[i].mass;
  }
  bodies[0].vx = - px / solar_mass;
  bodies[0].vy = - py / solar_mass;
  bodies[0].vz = - pz / solar_mass;
}

var bodies = [
  /* sun */
  planet (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, solar_mass),
  /* jupiter */
  planet (4.84143144246472090e+00,
	  -1.16032004402742839e+00,
	  -1.03622044471123109e-01,
	  1.66007664274403694e-03 * days_per_year,
	  7.69901118419740425e-03 * days_per_year,
	  -6.90460016972063023e-05 * days_per_year,
	  9.54791938424326609e-04 * solar_mass),
  /* saturn */
  planet (8.34336671824457987e+00,
	  4.12479856412430479e+00,
	  -4.03523417114321381e-01,
	  -2.76742510726862411e-03 * days_per_year,
	  4.99852801234917238e-03 * days_per_year,
	  2.30417297573763929e-05 * days_per_year,
	  2.85885980666130812e-04 * solar_mass),
  /* uranus */
  planet (1.28943695621391310e+01,
	  -1.51111514016986312e+01,
	  -2.23307578892655734e-01,
	  2.96460137564761618e-03 * days_per_year,
	  2.37847173959480950e-03 * days_per_year,
	  -2.96589568540237556e-05 * days_per_year,
	  4.36624404335156298e-05 * solar_mass),
  /* neptune */
  planet (1.53796971148509165e+01,
	  -2.59193146099879641e+01,
	  1.79258772950371181e-01,
	  2.68067772490389322e-03 * days_per_year,
	  1.62824170038242295e-03 * days_per_year,
	  -9.51592254519715870e-05 * days_per_year,
	  5.15138902046611451e-05 * solar_mass)
];

var i, n = int (argv [0] < 1 ? 1 : argv [0]);

offset_momentum (bodies);
putf ("%.9f\n", energy (bodies));
for (i = 1; i <= n; i++)
  advance (bodies, 0.01);
putf ("%.9f\n", energy (bodies));
TEST744
        echo '      ' $DINO '-O' $test_file 10000 "2>$stderr"
        if $DINO -O $test_file 10000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT744' && $CMP $stdout $ftemp2; then
-0.169075164
-0.169016441
OUTPUT744
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 745.
if test $result = ok -a $start_test_number -le 745; then
	echo test 745: Manually optimized nbody
        cat >$test_file <<'TEST745'
val pi = 3.141592653589793;
val solar_mass = (4 * pi * pi);
val days_per_year = 365.24;

class planet (x, y, z, vx, vy, vz, mass) {}

fun advance (bodies, dt) !jit {
  val lim = #bodies - 1;
  var i, j, b, b2, dx, dy, dz, distance, distance2, mag;
  var bmass, bx, by, bz, bvx, bvy, bvz, mass2, mmag, mmag2;
    
  for (i = 0; i < lim; i++) {
    b = bodies[i]; bmass = b.mass;
    bx = b.x; by = b.y; bz = b.z; bvx = b.vx; bvy = b.vy; bvz = b.vz;
    for (j = i + 1; j <= lim; j++) {
      b2 = bodies[j]; dx = bx - b2.x; dy = by - b2.y; dz = bz - b2.z;
      distance2 = dx * dx + dy * dy + dz * dz; distance = sqrt (distance2);
      mag = dt / (distance2 * distance);
      mass2 = b2.mass; mmag2 = -mass2 * mag;
      bvx += dx * mmag2; bvy += dy * mmag2; bvz += dz * mmag2;
      mmag = bmass * mag;
      b2.vx += dx * mmag; b2.vy += dy * mmag; b2.vz += dz * mmag;
    }
    b.x = bx; b.y = by; b.z = bz; b.vx = bvx; b.vy = bvy; b.vz = bvz;
  }
  for (i = 0; i <= lim; i++) {
    b = bodies[i];
    b.x += dt * b.vx; b.y += dt * b.vy; b.z += dt * b.vz;
  }
}

fun energy (bodies) {
  val nbodies = #bodies;
  var e, i, j, b, b2, dx, dy, dz, distance;

  e = 0.0;
  for (i = 0; i < nbodies; i++) {
    b = bodies[i];
    e += 0.5 * b.mass * (b.vx * b.vx + b.vy * b.vy + b.vz * b.vz);
    for (j = i + 1; j < nbodies; j++) {
      b2 = bodies[j];
      dx = b.x - b2.x; dy = b.y - b2.y; dz = b.z - b2.z;
      distance = sqrt (dx * dx + dy * dy + dz * dz);
      e -= (b.mass * b2.mass) / distance;
    }
  }
  return e;
}

fun offset_momentum (bodies) {
  val nbodies = #bodies;
  var i,  px = 0.0, py = 0.0, pz = 0.0;

  for (i = 0; i < nbodies; i++) {
    px += bodies[i].vx * bodies[i].mass;
    py += bodies[i].vy * bodies[i].mass;
    pz += bodies[i].vz * bodies[i].mass;
  }
  bodies[0].vx = - px / solar_mass;
  bodies[0].vy = - py / solar_mass;
  bodies[0].vz = - pz / solar_mass;
}

var bodies = [
  /* sun */
  planet (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, solar_mass),
  /* jupiter */
  planet (4.84143144246472090e+00,
	  -1.16032004402742839e+00,
	  -1.03622044471123109e-01,
	  1.66007664274503694e-03 * days_per_year,
	  7.69901118419740425e-03 * days_per_year,
	  -6.90460016972063023e-05 * days_per_year,
	  9.54791938424326609e-04 * solar_mass),
  /* saturn */
  planet (8.34336671824457987e+00,
	  4.12479856412430479e+00,
	  -4.03523417114321381e-01,
	  -2.76742510726862411e-03 * days_per_year,
	  4.99852801234917238e-03 * days_per_year,
	  2.30417297573763929e-05 * days_per_year,
	  2.85885980666130812e-04 * solar_mass),
  /* uranus */
  planet (1.28943695621391310e+01,
	  -1.51111514016986312e+01,
	  -2.23307578892655734e-01,
	  2.96460137564761618e-03 * days_per_year,
	  2.37847173959480950e-03 * days_per_year,
	  -2.96589568540237556e-05 * days_per_year,
	  4.36624404335156298e-05 * solar_mass),
  /* neptune */
  planet (1.53796971148509165e+01,
	  -2.59193146099879641e+01,
	  1.79258772950371181e-01,
	  2.68067772490389322e-03 * days_per_year,
	  1.62824170038242295e-03 * days_per_year,
	  -9.51592254519715870e-05 * days_per_year,
	  5.15138902046611451e-05 * solar_mass)
];

var i, n = int (argv [0] < 1 ? 1 : argv [0]);

offset_momentum (bodies);
putf ("%.9f\n", energy (bodies));
for (i = 1; i <= n; i++)
  advance (bodies, 0.01);
putf ("%.9f\n", energy (bodies));
TEST745
        echo '      ' $DINO '-O' $test_file 10000 "2>$stderr"
        if $DINO -O $test_file 10000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT745' && $CMP $stdout $ftemp2; then
-0.169075164
-0.169016441
OUTPUT745
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 746.
if test $result = ok -a $start_test_number -le 746; then
	echo test 746: Printing min/max int
        cat >$test_file <<'TEST746'
println (~0 & ~(1<<31));
println (1<<31);
println (~0 & ~(1<<63));
println (1<<63);
TEST746
        echo '      ' $DINO '-O' $test_file "2>$stderr"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT746' && $CMP $stdout $ftemp2; then
-2147483649
2147483648
9223372036854775807
-9223372036854775808
OUTPUT746
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 747.
if test $result = ok -a $start_test_number -le 747; then
	echo test 747: Printing min/max int produced by formated vec
        cat >$test_file <<'TEST747'
println (vec (~0 & ~(1<<31), "%d"));
println (vec (1<<31, "%d"));
println (vec (~0 & ~(1<<63), "%d"));
println (vec (1<<63, "%d"));
TEST747
        echo '      ' $DINO '-O' $test_file "2>$stderr"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT747' && $CMP $stdout $ftemp2; then
"-2147483649"
"2147483648"
"9223372036854775807"
"-9223372036854775808"
OUTPUT747
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 748.
if test $result = ok -a $start_test_number -le 748; then
	echo test 748: Slowest meteor version from Java code
        cat >$test_file <<'TEST748'
val height = 10, width = 5;
val false = 0, true = 1;
val SHIFT = [ 0, 6, 11, 17, 22, 28, 33, 39, 44, 50 ];
val MASK  = [ [ 0x01,      0x02,      0x04,      0x08,      0x10   ],
	      [ 0x01 << 6, 0x02 << 6, 0x04 << 6, 0x08 <<  6,0x10 << 6  ],
	      [ 0x01 << 11,0x02 << 11,0x04 << 11,0x08 << 11,0x10 << 11 ],
	      [ 0x01 << 17,0x02 << 17,0x04 << 17,0x08 << 17,0x10 << 17 ],
	      [ 0x01 << 22,0x02 << 22,0x04 << 22,0x08 << 22,0x10 << 22 ],
	      [ 0x01 << 28,0x02 << 28,0x04 << 28,0x08 << 28,0x10 << 28 ],
	      [ 0x01 << 33,0x02 << 33,0x04 << 33,0x08 << 33,0x10 << 33 ],
	      [ 0x01 << 39,0x02 << 39,0x04 << 39,0x08 << 39,0x10 << 39 ],
	      [ 0x01 << 44,0x02 << 44,0x04 << 44,0x08 << 44,0x10 << 44 ],
	      [ 0x01 << 50,0x02 << 50,0x04 << 50,0x08 << 50,0x10 << 50 ]];
     
class Shape (symbol, vector, bitmap, shift, islet, max_row, min_col, max_col) {}

val PIECE0 = [ Shape ('0',[[3, 5],[2, 4],[1, 3],[0, 2],[0, 0]],0x0000000000082083,0,false,6,0,4),
	       Shape ('0',[[4,-2],[3,-1],[2, 0],[1, 1],[0, 0]],0x0000000000421082,1,false,5,2,8),
	       Shape ('0',[[1,-7],[1,-5],[1,-3],[1,-1],[0, 0]],0x00000000000003D0,4,false,8,7,9),
	       Shape ('0',[[0, 0],[1, 1],[2, 2],[3, 3],[3, 5]],0x00000000000C1041,0,false,6,0,4),
	       Shape ('0',[[0, 0],[1,-1],[2,-2],[3,-3],[4,-2]],0x0000000000821084,2,false,5,3,9),
	       Shape ('0',[[0, 6],[0, 4],[0, 2],[0, 0],[1,-1]],0x000000000000005E,1,false,8,1,3),
	       Shape ('0',[[0, 0],[1, 1],[2, 2],[3, 3],[4, 2]],0x0000000000841041,0,false,5,0,6),
	       Shape ('0',[[0, 0],[1,-1],[2,-2],[3,-3],[3,-5]],0x0000000000062108,3,false,6,5,9),
	       Shape ('0',[[1, 7],[1, 5],[1, 3],[1, 1],[0, 0]],0x00000000000003C1,0,false,8,0,2),
	       Shape ('0',[[4, 2],[3, 1],[2, 0],[1,-1],[0, 0]],0x0000000001041042,1,false,5,1,7),
	       Shape ('0',[[3,-3],[2,-2],[1,-1],[0, 0],[0, 2]],0x000000000002108C,2,false,6,3,7),
	       Shape ('0',[[0, 0],[0, 2],[0, 4],[0, 6],[1, 7]],0x000000000000020F,0,false,8,0,2)];
 
val PIECE1 = [ Shape ('1',[[0, 2],[0, 0],[1,-1],[2, 0],[3,-1]],0x0000000000021046,1,false,6,1,7),
	       Shape ('1',[[1, 3],[0, 2],[0, 0],[1,-1],[1,-3]],0x00000000000002CC,2,false,8,3,6),
	       Shape ('1',[[3, 3],[2, 4],[1, 3],[1, 1],[0, 0]],0x00000000000420C1,0,false,6,0,5),
	       Shape ('1',[[3,-3],[3,-1],[2, 0],[1,-1],[0, 0]],0x0000000000062084,2,false,6,3,9),
	       Shape ('1',[[0, 0],[1, 1],[1, 3],[0, 4],[0, 6]],0x00000000000000CD,0,true, 8,0,3),
	       Shape ('1',[[0, 0],[1,-1],[2, 0],[2, 2],[3, 3]],0x0000000000083042,1,false,6,1,6),
	       Shape ('1',[[0, 6],[1, 5],[1, 3],[0, 2],[0, 0]],0x000000000000018B,0,true, 8,0,3),
	       Shape ('1',[[3, 3],[3, 1],[2, 0],[1, 1],[0, 0]],0x0000000000060841,0,false,6,0,6),
	       Shape ('1',[[3,-3],[2,-4],[1,-3],[1,-1],[0, 0]],0x00000000000208C4,2,false,6,4,9),
	       Shape ('1',[[1,-1],[0, 0],[0, 2],[1, 3],[1, 5]],0x0000000000000346,1,false,8,1,4),
	       Shape ('1',[[0, 0],[0, 2],[1, 3],[2, 2],[3, 3]],0x0000000000041083,0,false,6,0,6),
	       Shape ('1',[[0, 0],[1, 1],[2, 0],[2,-2],[3,-3]],0x0000000000023104,2,false,6,3,8)];

val PIECE2 = [ Shape ('2',[[1, 1],[0, 0],[2, 0],[2,-2],[2,-4]],0x0000000000003904,2,false,7,4,8),
	       Shape ('2',[[2, 4],[1, 5],[2, 2],[1, 1],[0, 0]],0x0000000000003141,0,false,7,0,4),
	       Shape ('2',[[3,-1],[3, 1],[2,-2],[1,-1],[0, 0]],0x0000000000060842,1,false,6,2,8),
	       Shape ('2',[[1,-1],[2, 0],[0, 0],[0, 2],[0, 4]],0x000000000000104E,1,false,7,1,5),
	       Shape ('2',[[0, 0],[1,-1],[0, 2],[1, 3],[2, 4]],0x0000000000004146,1,false,7,1,5),
	       Shape ('2',[[0, 2],[0, 0],[1, 3],[2, 2],[3, 1]],0x0000000000021083,0,true, 6,0,6),
	       Shape ('2',[[0, 2],[1, 3],[0, 0],[1,-1],[2,-2]],0x0000000000000946,1,false,7,2,6),
	       Shape ('2',[[1, 5],[2, 4],[0, 4],[0, 2],[0, 0]],0x0000000000002107,0,false,7,0,4),
	       Shape ('2',[[3, 1],[3,-1],[2, 2],[1, 1],[0, 0]],0x0000000000062082,1,false,6,1,7),
	       Shape ('2',[[2,-4],[1,-5],[2,-2],[1,-1],[0, 0]],0x0000000000003148,3,false,7,5,9),
	       Shape ('2',[[1,-1],[0, 0],[2, 0],[2, 2],[2, 4]],0x0000000000007042,1,false,7,1,5),
	       Shape ('2',[[0, 0],[0, 2],[1,-1],[2, 0],[3, 1]],0x0000000000041046,1,false,6,1,7)];

val PIECE3 = [ Shape ('3',[[0, 0],[2, 0],[1,-1],[2,-2],[2,-4]],0x0000000000003884,2,false,7,4,9),
	       Shape ('3',[[1, 5],[2, 2],[1, 3],[1, 1],[0, 0]],0x00000000000011C1,0,false,7,0,4),
	       Shape ('3',[[3, 1],[2,-2],[2, 0],[1,-1],[0, 0]],0x0000000000041842,1,false,6,2,8),
	       Shape ('3',[[2, 0],[0, 0],[1, 1],[0, 2],[0, 4]],0x0000000000000847,0,false,7,0,5),
	       Shape ('3',[[1,-3],[0, 0],[1,-1],[1, 1],[2, 2]],0x00000000000041C4,2,false,7,3,7),
	       Shape ('3',[[0, 0],[1, 3],[1, 1],[2, 2],[3, 1]],0x00000000000210C1,0,true, 6,0,6),
	       Shape ('3',[[1, 3],[0, 0],[1, 1],[1,-1],[2,-2]],0x00000000000009C2,1,false,7,2,6),
	       Shape ('3',[[2, 4],[0, 4],[1, 3],[0, 2],[0, 0]],0x0000000000002087,0,false,7,0,5),
	       Shape ('3',[[3,-1],[2, 2],[2, 0],[1, 1],[0, 0]],0x0000000000023082,1,false,6,1,7),
	       Shape ('3',[[1,-5],[2,-2],[1,-3],[1,-1],[0, 0]],0x00000000000021C8,3,false,7,5,9),
		Shape ('3',[[0, 0],[2, 0],[1, 1],[2, 2],[2, 4]],0x0000000000003841,0,false,7,0,5),
	       Shape ('3',[[0, 0],[1,-3],[1,-1],[2,-2],[3,-1]],0x00000000000410C4,2,false,6,3,9)];
 
val PIECE4 = [ Shape ('4',[[1, 5],[2, 2],[1, 3],[0, 2],[0, 0]],0x0000000000001183,0,false,7,0,4),
	       Shape ('4',[[3, 1],[2,-2],[2, 0],[1, 1],[0, 0]],0x0000000000041882,1,false,6,2,8),
	       Shape ('4',[[2, 0],[0, 0],[1, 1],[1, 3],[0, 4]],0x00000000000008C5,0,true, 7,0,5),
	       Shape ('4',[[1,-3],[0, 0],[1,-1],[2, 0],[2, 2]],0x00000000000060C4,2,false,7,3,7),
	       Shape ('4',[[0, 0],[1, 3],[1, 1],[2, 0],[3, 1]],0x00000000000208C1,0,false,6,0,6),
	       Shape ('4',[[0, 0],[2, 0],[1,-1],[1,-3],[2,-4]],0x00000000000028C4,2,false,7,4,9),
	       Shape ('4',[[0, 0],[1,-3],[1,-1],[2, 0],[3,-1]],0x00000000000420C4,2,false,6,3,9),
	       Shape ('4',[[1, 3],[0, 0],[1, 1],[2, 0],[2,-2]],0x0000000000001982,1,false,7,2,6),
	       Shape ('4',[[2, 4],[0, 4],[1, 3],[1, 1],[0, 0]],0x00000000000020C5,0,true, 7,0,5),
	       Shape ('4',[[3,-1],[2, 2],[2, 0],[1,-1],[0, 0]],0x0000000000023042,1,false,6,1,7),
	       Shape ('4',[[1,-3],[2, 0],[1,-1],[0, 0],[0, 2]],0x00000000000020CC,2,false,7,3,7),
	       Shape ('4',[[0, 0],[2, 0],[1, 1],[1, 3],[2, 4]],0x00000000000028C1,0,false,7,0,5)];
 
val PIECE5 = [ Shape ('5',[[0, 2],[1, 1],[0, 0],[1,-1],[2,-2]],0x00000000000008C6,1,false,7,2,7),
	       Shape ('5',[[1, 5],[1, 3],[0, 4],[0, 2],[0, 0]],0x0000000000000187,0,false,8,0,4),
	       Shape ('5',[[3, 1],[2, 0],[2, 2],[1, 1],[0, 0]],0x0000000000021841,0,false,6,0,7),
	       Shape ('5',[[2,-4],[1,-3],[2,-2],[1,-1],[0, 0]],0x00000000000018C4,2,false,7,4,9),
	       Shape ('5',[[0, 0],[0, 2],[1, 1],[1, 3],[1, 5]],0x00000000000001C3,0,false,8,0,4),
	       Shape ('5',[[0, 0],[1, 1],[1,-1],[2, 0],[3, 1]],0x00000000000410C2,1,false,6,1,8),
	       Shape ('5',[[0, 2],[0, 0],[1, 1],[1,-1],[1,-3]],0x00000000000001CC,2,false,8,3,7),
	       Shape ('5',[[2, 4],[1, 3],[2, 2],[1, 1],[0, 0]],0x00000000000030C1,0,false,7,0,5),
	       Shape ('5',[[3,-1],[2, 0],[2,-2],[1,-1],[0, 0]],0x0000000000021842,1,false,6,2,9),
	       Shape ('5',[[1,-1],[1, 1],[0, 0],[0, 2],[0, 4]],0x00000000000000CE,1,false,8,1,5),
	       Shape ('5',[[0, 0],[1, 1],[0, 2],[1, 3],[2, 4]],0x00000000000020C3,0,false,7,0,5),
	       Shape ('5',[[0, 0],[1,-1],[1, 1],[2, 0],[3,-1]],0x00000000000210C2,1,false,6,1,8)];

val PIECE6 = [ Shape ('6',[[1, 1],[0, 0],[1,-1],[1,-3],[2,-4]],0x00000000000009C4,2,false,7,4,8),
	       Shape ('6',[[2, 4],[1, 5],[1, 3],[0, 2],[0, 0]],0x0000000000002183,0,false,7,0,4),
	       Shape ('6',[[3,-1],[3, 1],[2, 0],[1, 1],[0, 0]],0x0000000000061082,1,false,6,1,8),
	       Shape ('6',[[1,-5],[2,-4],[1,-3],[1,-1],[0, 0]],0x00000000000011C8,3,false,7,5,9),
	       Shape ('6',[[0, 0],[1,-1],[1, 1],[2, 2],[2, 4]],0x00000000000060C2,1,false,7,1,5),
	       Shape ('6',[[0, 2],[0, 0],[1, 1],[2, 0],[3, 1]],0x0000000000020843,0,false,6,0,7),
	       Shape ('6',[[0, 0],[1, 1],[1,-1],[2,-2],[2,-4]],0x0000000000001984,2,false,7,4,8),
	       Shape ('6',[[1, 5],[2, 4],[1, 3],[1, 1],[0, 0]],0x00000000000021C1,0,false,7,0,4),
	       Shape ('6',[[3, 1],[3,-1],[2, 0],[1,-1],[0, 0]],0x0000000000061042,1,false,6,1,8),
	       Shape ('6',[[2,-2],[1,-3],[1,-1],[0, 0],[0, 2]],0x00000000000010CC,2,false,7,3,7),
	       Shape ('6',[[1,-1],[0, 0],[1, 1],[1, 3],[2, 4]],0x00000000000041C2,1,false,7,1,5),
	       Shape ('6',[[0, 0],[0, 2],[1, 1],[2, 2],[3, 1]],0x0000000000021043,0,false,6,0,7)];
 
val PIECE7 = [ Shape ('7',[[0, 2],[1, 1],[0, 0],[2, 0],[2,-2]],0x0000000000001886,1,false,7,2,7),
	       Shape ('7',[[1, 5],[1, 3],[0, 4],[1, 1],[0, 0]],0x00000000000001C5,0,true, 8,0,4),
	       Shape ('7',[[3, 1],[2, 0],[2, 2],[1,-1],[0, 0]],0x0000000000043042,1,false,6,1,7),
	       Shape ('7',[[2,-2],[1,-1],[2, 0],[0, 0],[0, 2]],0x0000000000001846,1,false,7,2,7),
	       Shape ('7',[[0, 0],[0, 2],[1, 1],[0, 4],[1, 5]],0x0000000000000147,0,false,8,0,4),
	       Shape ('7',[[0, 0],[1, 1],[1,-1],[2, 2],[3, 1]],0x00000000000420C2,1,false,6,1,7),
	       Shape ('7',[[0, 4],[0, 2],[1, 3],[0, 0],[1,-1]],0x000000000000014E,1,false,8,1,5),
	       Shape ('7',[[2, 4],[1, 3],[2, 2],[0, 2],[0, 0]],0x0000000000003083,0,false,7,0,5),
	       Shape ('7',[[3,-1],[2, 0],[2,-2],[1, 1],[0, 0]],0x0000000000021882,1,false,6,2,8),
	       Shape ('7',[[1,-1],[1, 1],[0, 0],[1, 3],[0, 4]],0x00000000000001CA,1,false,8,1,5),
	       Shape ('7',[[0, 0],[1, 1],[0, 2],[2, 2],[2, 4]],0x0000000000003043,0,false,7,0,5),
	       Shape ('7',[[0, 0],[1,-1],[1, 1],[2,-2],[3,-1]],0x00000000000208C2,1,false,6,2,8)];
 
val PIECE8 = [ Shape ('8',[[4, 2],[3, 1],[2, 0],[1, 1],[0, 0]],0x0000000000820841,0,false,5,0,7),
	       Shape ('8',[[3,-5],[2,-4],[1,-3],[1,-1],[0, 0]],0x0000000000021188,3,false,6,5,9),
	       Shape ('8',[[0, 0],[0, 2],[0, 4],[1, 5],[1, 7]],0x0000000000000307,0,false,8,0,2),
	       Shape ('8',[[0, 0],[1, 1],[2, 2],[3, 1],[4, 2]],0x0000000000821041,0,true, 5,0,7),
	       Shape ('8',[[0, 0],[1,-1],[2,-2],[2,-4],[3,-5]],0x0000000000023108,3,false,6,5,9),
	       Shape ('8',[[1, 7],[1, 5],[1, 3],[0, 2],[0, 0]],0x0000000000000383,0,false,8,0,2),
	       Shape ('8',[[0, 0],[1, 1],[2, 2],[2, 4],[3, 5]],0x0000000000083041,0,false,6,0,4),
	       Shape ('8',[[0, 0],[1,-1],[2,-2],[3,-1],[4,-2]],0x0000000000420842,1,false,5,2,9),
	       Shape ('8',[[0, 4],[0, 2],[0, 0],[1,-1],[1,-3]],0x00000000000000DC,2,false,8,3,5),
	       Shape ('8',[[3, 5],[2, 4],[1, 3],[1, 1],[0, 0]],0x00000000000820C1,0,false,6,0,4),
	       Shape ('8',[[4,-2],[3,-1],[2, 0],[1,-1],[0, 0]],0x0000000000421042,1,false,5,2,9),
	       Shape ('8',[[1,-5],[1,-3],[1,-1],[0, 0],[0, 2]],0x00000000000001D8,3,false,8,5,7)];
 
val PIECE9 = [ Shape ('9',[[3, 3],[2, 2],[1, 1],[0, 0],[0, 2]],0x0000000000041043,0,false,6,0,6),
	       Shape ('9',[[3,-3],[2,-2],[1,-1],[0, 0],[1, 1]],0x0000000000021184,2,false,6,3,8),
	       Shape ('9',[[0, 0],[0, 2],[0, 4],[0, 6],[1, 5]],0x000000000000010F,0,false,8,0,3),
	       Shape ('9',[[0, 0],[1, 1],[2, 2],[3, 3],[3, 1]],0x0000000000061041,0,true, 6,0,6),
	       Shape ('9',[[0, 0],[1,-1],[2,-2],[3,-3],[2,-4]],0x0000000000021884,2,false,6,4,9),
	       Shape ('9',[[1, 5],[1, 3],[1, 1],[1,-1],[0, 0]],0x00000000000003C2,1,false,8,1,4),
	       Shape ('9',[[0, 0],[1, 1],[2, 2],[3, 3],[2, 4]],0x0000000000043041,0,false,6,0,5),
	       Shape ('9',[[0, 0],[1,-1],[2,-2],[3,-3],[3,-1]],0x0000000000061084,2,false,6,3,9),
	       Shape ('9',[[0, 6],[0, 4],[0, 2],[0, 0],[1, 1]],0x000000000000004F,0,false,8,0,3),
	       Shape ('9',[[3, 3],[2, 2],[1, 1],[0, 0],[1,-1]],0x00000000000820C2,1,false,6,1,6),
	       Shape ('9',[[3,-1],[2, 0],[1, 1],[0, 2],[0, 0]],0x0000000000021086,1,false,6,1,7),
	       Shape ('9',[[1,-5],[1,-3],[1,-1],[1, 1],[0, 0]],0x00000000000003C8,3,false,8,5,8)];

var solutions = [];
var solution;
var depth     = 0;

fun modified_shape (shape, row, col) {
  Shape (shape.symbol, shape.vector,
	 shape.bitmap << ((SHIFT[row] + (col - (row % 2)) / 2) - shape.shift), 0,
	 shape.islet, shape.max_row, shape.min_col, shape.max_col);
}

class Piece (list) {
  var shapes;

  fun get_shapes (row, col) { shapes[row][col]; }

  { // Initialze shapes:
    var mutant, row, col, i;
    
    shapes = [10: []];
    for (row = 0; row < 10; row++) {
      shapes[row] = [10: []];
      for (col = 0; col < 10; col++)
	shapes[row][col] = [];
    }
    for (i = 0; i < #list; i++) {
      mutant = list[i];
      for (row = 0; row <= mutant.max_row; row++) {
	for (col = mutant.min_col; col <= mutant.max_col; col++) {
	  if (! mutant.islet)
	    ins (shapes[row][col], modified_shape (mutant, row, col), -1);
	  else if (row != 0 || col != 0)
	    ins (shapes[row][col], modified_shape (mutant, row, col), -1);
	}
      }
    }
  }
}
 
val pieces    = [ Piece (PIECE0), Piece (PIECE1), Piece (PIECE2),
		  Piece (PIECE3), Piece (PIECE4), Piece (PIECE5),
		  Piece (PIECE6), Piece (PIECE7), Piece (PIECE8), Piece (PIECE9)];

class Entry (row, col, shape) {}

fun init_solution {
  solution = [];
  for (var i = 0; i < 10; i++) ins (solution, Entry (0, 0, nil), -1);
}

fun serialize (solution) {
  var puzzle = [50 : ' '], shape, row, col, entry, xy, i, j;
           
  for (i = 0; i < #solution; i++) {
    entry = solution[i];
    shape = entry.shape;
    row   = entry.row;
    col   = entry.col;
    for (j = 0; j < #shape.vector; j++) {
      xy = shape.vector[j];
      puzzle[5 * (row + xy[0]) + (col + xy[1])/2] = shape.symbol;
    }
  }
  return puzzle;
}

fun solve_puzzle (puzzle, row, col) !jit {
  var i, j, piece, list, shape, clone, irow, icol, entry;
  for (i = 0; i < #pieces; i++) {
    // ... find shapes that fit
    piece = pieces[i];
    if (piece == nil)
      continue;
    list = piece.get_shapes (row, col);
      
    for (j = #list - 1; j >= 0; j--) { // ... fits badly ?
      shape = list[j];
      if ((shape.bitmap & puzzle) != 0)
	continue;
      clone = puzzle | shape.bitmap;
      // ... find next position
      icol = col / 2 + 1;
      for (irow = row; irow < height; irow++) {
	for (; icol < width; icol++)
	  if ((clone & MASK[irow][icol]) == 0)
	    break;
	if (icol < width)
	  break;
	icol = 0;
      }
      // ... solve next
      pieces[i]  = nil;
      entry   = solution[depth]; depth++;
      entry.row   = row;
      entry.col   = col;
      entry.shape = shape;
      if (depth == 10)
	ins (solutions, serialize (solution), -1);
      else
	solve_puzzle (clone, irow, 2 * icol + (irow % 2));
	  
      depth--;
      pieces[i] = piece;
    }
  }
}

fun solve {solve_puzzle (0x0002004008010020, 0, 0);}

fun print (solution) {
  for (var y = 0; y < height; y++) {
    if (y % 2 == 1) put (" ");
    for (var x = 0; x < width; x++) {
      if (x != 0) put (' ');
      put (solution [x + y * width]);
    }
    putln ();
  }
}

fun str_cmp (s1, s2) {
  for (var i = 0; i < #s1 && i < #s2; i++)
    if (s1[i] < s2[i]) return -1;
    else if (s1[i] > s2[i]) return 1;
  if (#s1 == #s2) return 0;
  return i < #s1 ? 1 : -1;
}

fun main {
  var n = int (#argv == 0 || argv [0] < 1 ? 2098 : argv [0]);
  init_solution ();
         
  solve ();
  if (#solutions > n)
    putln ("Error");
  else if (#solutions < n)
    putln ("Timeout");
  else {
    putln (#solutions,  " solutions found\n");
    solutions = sort (solutions, str_cmp);
    print (solutions[0]);
    putln ();
    print (solutions[#solutions - 1]);
    putln ();
  }
}

main ();
TEST748
        echo '      ' $DINO '-O' $test_file 2098 "2>$stderr"
        if $DINO -O $test_file 2098 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT748' && $CMP $stdout $ftemp2; then
2098 solutions found

0 0 0 0 1
 2 2 2 0 1
2 6 6 1 1
 2 6 1 5 5
8 6 5 5 5
 8 6 3 3 3
4 8 8 9 3
 4 4 8 9 3
4 7 4 7 9
 7 7 7 9 9

9 9 9 9 8
 9 6 6 8 5
6 6 8 8 5
 6 8 2 5 5
7 7 7 2 5
 7 4 7 2 0
1 4 2 2 0
 1 4 4 0 3
1 4 0 0 3
 1 1 3 3 3

OUTPUT748
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 749.
if test $result = ok -a $start_test_number -le 749; then
	echo test 749: Meteor version from Python
        cat >$test_file <<'TEST749'
val width = 5, height = 10;
val E = 0, NE = 1, NW = 2, W = 3, SW = 4, SE = 5;
val rotate      = tab [ E : NE, NE : NW, NW : W, W : SW, SW : SE, SE : E];
val flip        = tab [ E : W, NE : NW, NW : NE, W : E, SW : SE, SE : SW];
val move        = tab [ E : fun (x, y) {[x + 1, y];},
			W : fun (x, y) {[x - 1, y];},
			NE : fun (x, y) {[x + (y % 2), y - 1];},
			NW : fun (x, y) {[x + (y % 2) - 1, y - 1];},
			SE : fun (x, y) {[x + (y % 2), y + 1];},
			SW : fun (x, y) {[x + (y % 2) - 1, y + 1];}];

val pieces = [[E, E, E, SE],
              [SE, SW, W, SW],
              [W, W, SW, SE],
              [E,  E, SW, SE],
              [NW, W, NW, SE, SW],
              [E,  E, NE, W],
              [NW, NE, NE, W],
              [NE, SE, E, NE],
              [SE, SE, E, SE],
              [E, NW, NW, NW]];

var solutions = [];
var masks = [10:0];

fun valid (x, y) !inline { 0 <= x && x < width && 0 <= y && y < height; }
fun legal (mask, board) !inline { (mask & board) == 0; }
fun zerocount (mask) {
  for (var s = 0, x = 0; x < 50; x++) s += ((1 << x) & mask) == 0;
  return s;
}

fun findFreeCell (board) {
  for (var y = 0; y < height; y++)
    for (var x = 0; x < width; x++)
      if ((board & (1 << (x + width * y))) == 0)
	return [x,y];
}


fun floodFill (board, p) {
  var m, x = p[0], y = p[1];

  if (! valid (x, y) || (board & (1 << (x + width * y))) != 0) return board;
  
  board |= 1 << (x + width * y);
  
  for (m in move)
    board |= floodFill (board, move[m] (x, y));
  return board;
}

fun noIslands (mask) {
  var zeroes = zerocount (mask), new_zeroes;
    
  if (zeroes < 5) return 0;
  
  for (; mask != 0x3FFFFFFFFFFFF;) {
    mask = floodFill (mask, findFreeCell (mask));
    new_zeroes = zerocount (mask);
    if (zeroes - new_zeroes < 5) return 0;
    zeroes = new_zeroes;
  }
  return 1;
}

fun getBitmask (x, y, piece) {
  var p, nc, cell, mask = 1 << (x + width * y);
  
  for (nc = 0; nc < #piece; nc++) {
    cell = piece[nc];
    p = move[cell] (x, y);
    x = p[0]; y = p[1];
    if (valid (x, y))
      mask |= 1 << (x + width * y);
    else
      return [0, 0];
  }
  return [1, mask];
}

fun allBitmasks (piece, color) {
  var bitmasks = [], orient, rotation, x, y, p, mask, nc;

  for (orient = 0; orient < 2; orient++) {
    for (rotation = 0; rotation < (6 - 3 * (color == 4)); rotation++) {
      for (y = 0; y < height; y++)
	for (x = 0; x < width; x++) {
	  p = getBitmask (x, y, piece); mask = p[1];
	  if (p[0] && noIslands (mask))
	    ins (bitmasks, mask, -1);
	}
      for (nc = 0; nc < #piece; nc++) piece[nc] = rotate[piece[nc]];
    }
    for (nc = 0; nc < #piece; nc++) piece[nc] = flip[piece[nc]];
  }
  
  return bitmasks;
}

var masksAtCell;

fun generateBitmasks {
  var color = 0, np, piece, masks, cellMask, cellCounter, i, j;

  masksAtCell = [width * height: []];
  for (i = 0; i < width * height; i++) {
    masksAtCell[i] = [10: []];
    for (j = 0; j < 10; j++)
      masksAtCell[i][j] = [];
  }
  for (np = 0; np < #pieces; np++) {
    piece = pieces[np];
    masks = allBitmasks (piece, color);
    masks = sort (masks);
    cellMask = 1 << (width * height - 1);
    cellCounter = width * height - 1;
    for (j = #masks - 1; j >= 0;)
      if ((masks[j] & cellMask) == cellMask) {
	ins (masksAtCell[cellCounter][color], masks[j], -1);
	j--;
      } else {
	cellMask >>= 1;
	cellCounter--;
      }
    color++	;
  }
}

fun stringOfMasks (masks) {
  var s = "", mask = 1, x, y, color;

  for (y = 0; y < height; y++)
    for (x = 0; x < width; x++) {
      for (color = 0; color < 10; color++)
	if ((masks[color] & mask) != 0) {
	  s @= color; break;
	} else if (color == 9)
	  s @= ".";
      mask <<= 1;
    }
  return s;
}

fun inverse (s) {
  var x, y, ns = new s;
  
  for (x = 0; x < width; x++)
    for (y = 0; y < height; y++)
      ns [x + y * width] = s [width - x - 1 + (height - y - 1) * width];
  return s;
}

fun solveCell (cell, board, n) !jit {
  var s, mask, color, m, nm, cell_masks, color_masks;

  if (#solutions >= n) return;

  if (board == 0x3FFFFFFFFFFFF) { // Solved
    s = stringOfMasks (masks);
    ins (solutions, s, -1);
    ins (solutions, inverse (s), -1);
    return;
  }

  if ((board & (1 << cell)) != 0) { // Cell full
    solveCell (cell - 1, board, n);
    return;
  }
  
  if (cell < 0) // Out of board
    return;

  cell_masks = masksAtCell[cell];
  for (color = 0; color < 10; color++)
    if (masks[color] == 0) {
      color_masks = cell_masks[color];
      for (nm = 0; nm < #color_masks; nm++) {
	m = color_masks[nm];
	if (legal (m, board)) {
	  masks[color] = m;
	  solveCell (cell - 1, board | m, n);
	  masks[color] = 0;
	}
      }
    }
}

fun solve (n) {
  generateBitmasks ();
  solveCell (width * height - 1, 0, n);
}

fun printSolution (solution) {
  for (var y = 0; y < height; y++) {
    if (y % 2 == 1) put (" ");
    for (var x = 0; x < width; x++) {
      if (x != 0) put (' ');
      put (solution [x + y * width]);
    }
    putln ();
  }
}

fun str_cmp (s1, s2) {
  for (var i = 0; i < #s1 && i < #s2; i++)
    if (s1[i] < s2[i]) return -1;
    else if (s1[i] > s2[i]) return 1;
  if (#s1 == #s2) return 0;
  return i < #s1 ? 1 : -1;
}

fun main () {
  var n = int (argv [0] < 1 ? 1 : argv [0]);
  solve (n);
  putln (#solutions, " solutions found\n");
  solutions = sort (solutions, str_cmp);
  printSolution (solutions[0]);
  putln ();
  printSolution (solutions[#solutions - 1]);
}

main ();
TEST749
        echo '      ' $DINO '-O' $test_file 2098 "2>$stderr"
        if $DINO -O $test_file 2098 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT749' && $CMP $stdout $ftemp2; then
2098 solutions found

0 0 0 0 1
 2 2 2 0 1
2 6 6 1 1
 2 6 1 5 5
8 6 5 5 5
 8 6 3 3 3
4 8 8 9 3
 4 4 8 9 3
4 7 4 7 9
 7 7 7 9 9

9 9 9 9 8
 9 6 6 8 5
6 6 8 8 5
 6 8 2 5 5
7 7 7 2 5
 7 4 7 2 0
1 4 2 2 0
 1 4 4 0 3
1 4 0 0 3
 1 1 3 3 3
OUTPUT749
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 750.
if test $result = ok -a $start_test_number -le 750; then
	echo test 750: Fastest meteor version from C++
        cat >$test_file <<'TEST750'
val false = 0, true = 1;
val nPieceCount = 10;
val pieces  = [ [[0, 0], [1, 0], [2, 0], [3, 0], [3, 1]],
		[[0, 0], [0, 1], [-2, 2], [-1, 2], [-3, 3]],
		[[0, 0], [1, 0], [2, 0], [-1, 1], [-1, 2]],
		[[0, 0], [1, 0], [2, 0], [1, 1], [1, 2]],
		[[0, 0], [0, 1], [1, 1], [-1, 2], [1, 2]],
		[[0, 0], [1, 0], [-2, 1], [-1, 1], [0, 1]],
		[[0, 0], [1, 0], [0, 1], [-1, 2], [-1, 3]],
		[[0, 0], [2, 0], [-1, 1], [0, 1], [1, 1]],
		[[0, 0], [0, 1], [0, 2], [1, 2], [1, 3]],
		[[0, 0], [0, 1], [0, 2], [-1, 3], [0, 3]]];

var i, g_AllMasks = [8192: 0], g_MaskStart = [50: []];
for (i = 0; i < #g_MaskStart; i++) g_MaskStart[i] = [8: 0];

var g_solutions, g_min_solution = [50: ""], g_max_solution = [50: ""];;

var EvenRowsLookup = [50: 0], LeftBorderLookup = [50: 0];

fun popcount (x) {
  var c;
  for (c = 0; x; x >>>= 1)
    if (x & 1) c++;
  return c;
}
   
fun ctz (x) !inline {
  var c;

  if (! x) {putln ("Internal Error"); exit (1);}
  for (c = 0; (x & 1) == 0; x >>>= 1)
    c++;
  return c;
}
   
fun GoodPiece (mask, pos) {
   var bOK = true;
   val even_rows = 0xf07c1f07c1f07c1f;
   val odd_rows = ~even_rows;   
   val left_border = 0x1084210842108421;
   val right_border = left_border >> 1;
   var a, b, a_old, s1, s2, s3, s4, s5, s6, s7, s8;
   
   b = (mask << pos) | 0xFFFC000000000000;
   b = ~b;

   for (;b;) {
     a = b & -b;
     for (;;) {
         s1 = a << 5;
         s2 = a >>> 5;
         s3 = (a << 1) & (~left_border);
         s4 = (a >>> 1) & (~right_border);
         s5 = ((a & even_rows) >>> 6) & (~right_border);
         s6 = ((a & even_rows) << 4) & (~right_border);
         s7 = ((a & odd_rows) >>> 4) & (~left_border);
         s8 = ((a & odd_rows) << 6) & (~left_border);
         a_old = a;
         a = (a | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8) & b;
	 if (a_old == a)
	   break;
      }
     if (popcount (a) % 5 != 0) {
         bOK = false;
         break;
      }
      b ^= a;
   }
   return bOK;
}

fun Initialise {
  var i;
  for (i = 0; i < 50; i++) {
    EvenRowsLookup[i] = 0xF07C1F07C1F07C1F >>> i;
    LeftBorderLookup[i] = 0x1084210842108421 >>> i;
  }
  
  var nTotalCount = 0;
  var x = [5: 0], y = [5: 0];
  var nXBase, nYBase, nPos, nPiece, j, nCurrentRotation, nMinX, nMinY;
  var mask, bFit, nX, nY, nBit, xnew, ynew, nOrigPos, nFilter, filter_mask;
  var bottom, last_row, pMask;

  for (nYBase = 2; nYBase < 4; nYBase++) {
    for (nXBase = 0; nXBase < 5; nXBase++) {
      nPos = nXBase + 5 * nYBase;
      g_MaskStart[nPos][0] = nTotalCount;
      for (nPiece = 0; nPiece < nPieceCount; nPiece++) {
	for (j = 0; j < 5; j++) {
	  x[j] = pieces[nPiece][j][0]; y[j] = pieces[nPiece][j][1];
	}
         
	for (nCurrentRotation = 0; nCurrentRotation < 12; nCurrentRotation++) {
	  if (nPiece != 3 || (nCurrentRotation / 3) % 2 == 0) {
	    nMinX = x[0]; nMinY = y[0];
	    for (i = 1; i < 5; i++) {
	      if (y[i] < nMinY || (y[i] == nMinY && x[i] < nMinX)) {
		nMinX = x[i]; nMinY = y[i];
	      }
	    }
            
	    mask = 0; bFit = true;
	    for (i = 0; i < 5; i++) {
	      nX = (x[i] - nMinX + (nXBase - nYBase / 2)) + (y[i] - nMinY + nYBase) / 2;
	      nY = y[i] - nMinY + nYBase;
	      if (nX >= 0 && nX < 5) {
		nBit = nX - nXBase +5 * (nY - nYBase); mask |= (1 << nBit);
	      } else
		bFit = false;
	    }
	    if (bFit && GoodPiece (mask, nPos)) {
	      g_AllMasks[nTotalCount] = mask | (1 << (nPiece + 22)); nTotalCount++;
	    }
	  }
	  for (i = 0; i < 5; i++) {
	    xnew = x[i] + y[i]; ynew = -x[i]; x[i] = xnew; y[i] = ynew;
	    if (nCurrentRotation == 5) {
	      xnew = x[i] + y[i]; ynew = -y[i]; x[i] = xnew; y[i] = ynew;
	    }      
	  }
	}
      }
      g_AllMasks[nTotalCount] = 0; nTotalCount++;
    }
  }
   
  // copy rows 2 and 3 to other rows
  for (nYBase = 0; nYBase < 10; nYBase++) {
    if (nYBase != 2 && nYBase != 3) {
      for (nXBase = 0; nXBase < 5; nXBase++) {
	nPos = nXBase + 5 * nYBase;
	nOrigPos = nXBase + 5 * (nYBase % 2 + 2);
	g_MaskStart[nPos][0] = nTotalCount;
	pMask = g_MaskStart[nOrigPos][0];
	bottom = (0xFFFC000000000000 >>> nPos) & 0x003FFFFF;
	last_row = (0xFFFC000000000000 >>> (nPos + 5)) & 0x003FFFFF;
	for (;g_AllMasks[pMask];) {
	  mask = g_AllMasks[pMask]; pMask++;
	  if ((mask & bottom) == 0) {
	    if ((nYBase == 0 || (mask & last_row))
		&& ! GoodPiece (mask & 0x003FFFFF, nPos))
	      continue;
	    g_AllMasks[nTotalCount] = mask; nTotalCount++;
	  }
	}
	g_AllMasks[nTotalCount] = 0; nTotalCount++;
      }
    }
  }
  
  for (nFilter = 1; nFilter < 8; nFilter++) {
    for (nPos = 0; nPos < 50; nPos++) {
      g_MaskStart[nPos][nFilter] = nTotalCount;
      filter_mask = ((nFilter & 1) << 1) | ((nFilter & 6)
					    << (4 - (EvenRowsLookup[nPos] & 1)));
      pMask = g_MaskStart[nPos][0];
      for (;g_AllMasks[pMask];) {
	mask = g_AllMasks[pMask];
	if ((mask & filter_mask) == 0) {
	  g_AllMasks[nTotalCount] = mask; nTotalCount++;
	}
	pMask++;
      }
      g_AllMasks[nTotalCount] = 0; nTotalCount++;
    }
  }
}

fun CompareSolution(board, min_solution, max_solution) {
  var i, j;
   
   for (i = 0; i < 50; i++) {
     if (board[i] < min_solution[i]) {
       for (j = 0; j < 50; j++)
	 min_solution[j] = board[j];
       break;
     } else if (board[i] > min_solution[i])
       break;
   }
   for (i = 0;i < 50; i++) {
     if (board[i] > max_solution[i]) {
       for (j = 0; j < 50; j++)
	 max_solution[j] = board[j];
       break;
      } else if (board[i] < max_solution[i])
       break;
   }
}

fun PrintBoard (board) {
  var i;
  
  for (i = 0; i < 50; i++) {
    putf ("%d ", board[i]);
    if (i % 5 == 4) {
      putln ();
      if ((i & 1) == 0) put (" ");
    }
  }
  putln ();
}

fun RecordSolution (current_solution) {
  var board = [50: 0], flip_board = [50: 0];
  var i, piece, mask, pos = 0, current_bit, b1 = 0, b, count;
  for (i = 0; i < 10; i++) {
    mask = current_solution[i]; piece = ctz (mask >>> 22);
    mask &= 0x003FFFFF; b1 |= mask;
    for (;mask;) {
      current_bit = mask & -mask; count = ctz (current_bit);
      board[count + pos] = piece; flip_board[49 - count - pos] = piece;
      mask ^= current_bit;
    }
    count = ctz (~b1); pos += count; b1 >>>= count;
  }
  if (g_solutions == 0)
    for (i = 0; i < 50; i++) {
      b = board[i]; g_min_solution[i] = b; g_max_solution[i] = b;
    }
  else {
    CompareSolution (board, g_min_solution, g_max_solution);
    CompareSolution (flip_board, g_min_solution, g_max_solution);
  }
  g_solutions += 2;
}
     
fun search1 (board, pos, used, placed, current_solution) !jit {
  var count, even_rows, odd_rows, left_border, right_border;
  var s1, s2, s3, s4, s5, s6, s7, s8, f, board_and_used, masks, mask, pMask;

  if (placed == 10)
    RecordSolution (current_solution);
  else {
    even_rows = EvenRowsLookup[pos]; odd_rows = ~even_rows;
    
    left_border = LeftBorderLookup[pos]; right_border = left_border >>> 1;
    
    s1 = (board << 1) | left_border;
    s2 = (board >>> 1) | right_border;
    s3 = (board << 4) | ((1 << 4) - 1) | right_border;
    s4 = (board >>> 4) | left_border;
    s5 = (board << 5) | ((1 << 5) - 1);
    s6 = (board >>> 5);
    s7 = (board << 6) | ((1 << 6) - 1) | left_border;
    s8 = (board >>> 6) | right_border;
    
    if (~board & s1 & s2 & s5 & s6 & ((even_rows & s4 & s7) | (odd_rows & s3 & s8)))
      return;
    count = ctz (~board); pos += count; board >>>= count;
    
    f = ((board >>> 1) & 1) | ((board >>> (4 - (EvenRowsLookup[pos] & 1))) & 6);   
    board_and_used = board | used;
    for (pMask = g_MaskStart[pos][f]; g_AllMasks[pMask];) {
      for (;g_AllMasks[pMask] & board_and_used;)
	pMask++;
      mask = g_AllMasks[pMask];
      if (mask) {
	current_solution[placed] = mask;
	search1 (board | ((mask & 0x003FFFFF)), pos, used | (mask & 0xFFC00000),
		 placed + 1, current_solution);
	pMask++;
      }
    }
  }
}

fun search {
  var mask, current_solution, pMask;

  for (pMask = g_MaskStart[0][0];; pMask++) {
    mask = g_AllMasks[pMask];
    if (! mask)
      break;
    current_solution = [10: 0]; current_solution[0] = mask;
    search1 (mask & 0x003FFFFF, 0, mask & 0xFFC00000, 1, current_solution);
  }
}

fun main {
  var n = int (#argv == 0 || argv [0] < 1 ? 2098 : argv [0]);

   Initialise ();

   g_solutions = 0;

   search ();
   
   putf ("%d solutions found\n\n", g_solutions);
   PrintBoard (g_min_solution);
   PrintBoard (g_max_solution);
}

main ();
TEST750
        echo '      ' $DINO '-O' $test_file 2098 "2>$stderr"
        if $DINO -O $test_file 2098 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT750' && $CMP $stdout $ftemp2; then
2098 solutions found

0 0 0 0 1 
 2 2 2 0 1 
2 6 6 1 1 
 2 6 1 5 5 
8 6 5 5 5 
 8 6 3 3 3 
4 8 8 9 3 
 4 4 8 9 3 
4 7 4 7 9 
 7 7 7 9 9 

9 9 9 9 8 
 9 6 6 8 5 
6 6 8 8 5 
 6 8 2 5 5 
7 7 7 2 5 
 7 4 7 2 0 
1 4 2 2 0 
 1 4 4 0 3 
1 4 0 0 3 
 1 1 3 3 3 

OUTPUT750
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 751
if test $result = ok -a $start_test_number -le 751; then
	echo test 751: Bug -- aborting on wrong program
        cat >$test_file <<'TEST751'
move        = tab [ 1 : fun (x, y) {[x + (y % 2) - 1, y + 1);}];
TEST751
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT751' && $CMP $stderr $ftemp2; then
test.d:1:1: undeclared identifier `move'
test.d:1:60: syntax error
OUTPUT751
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT751-2' && $CMP $stdout $ftemp2; then
OUTPUT751-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 752.
if test $result = ok -a $start_test_number -le 752; then
	echo test 752: Bug: Returning from JIT to non-function block
        cat >$test_file <<'TEST752'
fun g (i) { i; }
fun f !jit {
  for (var i = 0; i < 1000000; i++) {
    val k = i;
    g (k * 2);
  }
}

f();

putln ("end");
TEST752
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT752' && $CMP $stdout $ftemp2; then
end
OUTPUT752
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 753.
if test $result = ok -a $start_test_number -le 753; then
	echo test 753: Bug: Using decl from the same stmt in anon fun
        cat >$test_file <<'TEST753'
val xs = [1,2,3,4,5];
val x = xs [0], v = map (fun (xx) { x + xx; }, xs);
println (v);
TEST753
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT753' && $CMP $stdout $ftemp2; then
[2, 3, 4, 5, 6]
OUTPUT753
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 754
if test $result = ok -a $start_test_number -le 754; then
	echo test 754: Bug in use of forward declaration
        cat >$test_file <<'TEST754'
class c {fun op;}
class sc {use c;}
val v = sc().op();
TEST754
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT754' && $CMP $stderr $ftemp2; then
test.d:3:13: run time error - undefined class or function `op'
OUTPUT754
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT754-2' && $CMP $stdout $ftemp2; then
OUTPUT754-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 755
if test $result = ok -a $start_test_number -le 755; then
	echo test 755: Bug in abstract definition inheritance
        cat >$test_file <<'TEST755'
class binop (l, r) {
  fun op;
  fun show {put ('('); l.show (); putln (); put (op ()); r.show (); put (')');}
}

class v (i) {
  fun show {put (i);}
}

var o = binop (v(1), v(2));
o.show ();
TEST755
        echo '      ' "$DINO '-O' $test_file 2>$stderr >$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT755' && $CMP $stderr $ftemp2; then
test.d:3:53: run time error - unfinished fun/class `op' call
OUTPUT755
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT755-2' && $CMP $stdout $ftemp2; then
(1
OUTPUT755-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 756
if test $result = ok -a $start_test_number -le 756; then
	echo test 756: Bug in abstract definition access
        cat >$test_file <<'TEST756'
class c {fun op;}
val v = c().op ();
TEST756
        echo '      ' "$DINO '-O' $test_file 2>$stderr >$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT756' && $CMP $stderr $ftemp2; then
test.d:2:12: run time error - undefined class or function `op'
OUTPUT756
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT756-2' && $CMP $stdout $ftemp2; then
OUTPUT756-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 757.
if test $result = ok -a $start_test_number -le 757; then
	echo test 757: Bug in abstract definition inheritance: write/read dump
        cat >$test_file <<'TEST757'
class binop (l, r) {
  fun op;
  fun show {put ('('); l.show (); putln (); put (op ()); r.show (); put (')');}
}

class v (i) {
  fun show {put (i);}
}

var o = binop (v(1), v(2));
o.show ();
TEST757
        echo '      ' $DINO '-d -O' $test_file ">$stdout"
        if $DINO -d -O $test_file 2>$stderr >$stdout; then
            echo '      ' $DINO -i "$stdout" ">$ftemp"
            if $DINO -i "$stdout" > "$ftemp" 2>$stderr; then
                result=fail
            else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT757' && $CMP $stderr $ftemp2; then
test.d:3:53: run time error - unfinished fun/class `op' call
OUTPUT757
                    echo '      ' $CMP $ftemp2 $ftemp
                    if cat >$ftemp2 <<'OUTPUT757-2' && $CMP $ftemp $ftemp2; then
(1
OUTPUT757-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
            fi
        else
                result=fail
        fi
fi

# Test 758.
if test $result = ok -a $start_test_number -le 758; then
	echo test 758: Bug in abstract definition access: write/read dump
        cat >$test_file <<'TEST758'
class c {fun op;}
val v = c().op ();
TEST758
        echo '      ' $DINO '-d -O' $test_file ">$stdout"
        if $DINO -d -O $test_file 2>$stderr >$stdout; then
            echo '      ' $DINO -i "$stdout" ">$ftemp"
            if $DINO -i "$stdout" > "$ftemp" 2>$stderr; then
                result=fail
            else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT758' && $CMP $stderr $ftemp2; then
test.d:2:12: run time error - undefined class or function `op'
OUTPUT758
                    echo '      ' $CMP $ftemp2 $ftemp
                    if cat >$ftemp2 <<'OUTPUT758-2' && $CMP $ftemp $ftemp2; then
OUTPUT758-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
            fi
        else
                result=fail
        fi
fi

# Test 759.
if test $result = ok -a $start_test_number -le 759; then
	echo test 759: Countdown problem without pattern matching
        cat >$test_file <<'TEST759'
val false = 0, true = 1;
// Expressions:
class binop (l, r) {
  fun op;
  fun show {put ('('); l.show (); put (op ()); r.show (); put (')');}
}
class add (l, r) { use binop former l, r later op; fun op {"+";} }
class sub (l, r) { use binop former l, r later op; fun op {"-";} }
class mul (l, r) { use binop former l, r later op; fun op {"*";} }
class div (l, r) { use binop former l, r later op; fun op {"/";} }
class value (i) { fun show { put (i); } }

fun valid (op, l, r) {
  if (isa (op, sub)) return l > r;
  else if (isa (op, div)) return l % r == 0;
  return true;
}

fun apply (op, l, r) {
  if (isa (op, add)) return l + r;
  if (isa (op, sub)) return l - r;
  if (isa (op, mul)) return l * r;
  if (isa (op, div)) return l / r;
}

fun values (e) {
  if (isa (e, value)) return [e.i];
  if (isa (e, binop)) return values (e.l) @ values (e.r);
}

fun eval (e) {
  if (isa (e, value)) return e.i > 0 ? e.i : nil;
  if (isa (e, binop)) {
    var x, y, re, res = nil;
    x = eval (e.l); y = eval (e.r);
    if (x != nil && y != nil) {
      val c = closure (e);
      if (valid (c, x, y))
        res = apply (c, x, y);
    }
    return res;
  }
}

// Combinatorial functions:
fun subs (xs) {
  if (#xs == 0) return [[]];
  val x = xs[0], yss = subs (xs[1:]);
  yss @ map (fun (ys) { [x] @ ys; }, yss);
}

fun interleave (x, ys) {
  if (#ys == 0) return [[x]];
  val y = ys[0], ys = ys[1:];
  [[x, y] @ ys] @ map (fun (l) { [y] @ l; }, interleave (x, ys));
}

fun perms (xs) {
  if (#xs == 0) return [[]];
  val x = xs[0], xs = xs[1:];
  var res = [], rs = map (fun (xx) { interleave (x, xx); }, perms (xs));
  for (var i = 0; i < #rs; i++)
    res @= rs[i];
  res;
}

fun choices (xs) {
  var res = [], yss = subs (xs);
  for (var i = 0; i < #yss; i++)
    res @= perms (yss[i]);
  res;
}

fun solution_p (e, ns, n) {
  val vs = values (e), css = choices (ns);
  for (var i = 0; i < #css; i++)
    if (vs == css[i]) return eval (e) == n;
  return false;
}

fun split (xs) {
  if (#xs <= 1) return [];
  val x = xs[0], xs = xs[1:], xsss = split (xs);
  [[[x], xs]] @ map (fun (xss) { [[x] @ xss[0], xss[1]]; }, xsss);
}

fun ops { [add, sub, mul, div]; }
fun combine (e1, e2) {
  var res = [], ops = ops ();
  for (var i = 0; i < #ops; i++)
    ins (res, ops[i] (e1, e2), -1);
  res;
}

fun exprs (xs) {
  if (#xs == 0) return [];
  if (#xs == 1) return [value (xs[0])];
  val nss = split (xs); var res = [];
  for (var i = 0; i < #nss; i++) {
    var ls = nss[i][0], rs = nss[i][1], ls = exprs (ls), rs = exprs (rs);
    for (var j = 0; j < #ls; j++)
      for (var k = 0; k < #rs; k++)
        insv (res, combine (ls[j], rs[k]), -1);
  }
  res;
}

fun solutions (ns, n) {
  val nss = choices (ns); var res = [];
  for (var i = 0; i < #nss; i++) {
    val es = exprs (nss[i]);
    for (var j = 0; j < #es; j++)
      if (eval (es[j]) == n)
	res @= [es[j]];
  }
  res;
}

var valid_fun;

fun combine2 (lv, rv) !jit {
  val l = lv[0], x = lv[1], r = rv[0], y = rv[1], res = [], ops = ops ();
  for (var i = 0; i < #ops; i++) {
    var o = ops[i];
    if (valid_fun (o, x, y))
      ins (res, [o (l, r), apply (o, x, y)], -1);
  }
  res;
}

fun results (ns) {
  if (#ns == 0) return [];
  if (#ns == 1) return (ns[0] <= 0 ? [] : [[value (ns[0]), ns[0]]]);
  val res = [], xsss = split (ns);
  for (var i = 0; i < #xsss; i++) {
    val lx = results (xsss[i][0]), ry = results (xsss[i][1]);
    for (var j = 0; j < #lx; j++)
      for (var k = 0; k < #ry; k++)
        insv (res, combine2 (lx[j], ry[k]), -1);
  }
  res;
}

fun common_solutions (ns, n) {
  val nss = choices (ns); var res = [];
  for (var i = 0; i < #nss; i++) {
    val rs = results (nss[i]);
    for (var j = 0; j < #rs; j++)
      if (rs[j][1] == n)
	ins (res, rs[j][0], -1);
  }
  res;
}

fun solutions2 (ns, n) {
  valid_fun = valid;
  common_solutions (ns, n);
}

fun valid2 (op, l, r) !jit {
  if (isa (op, add)) return l <= r;
  if (isa (op, sub)) return l > r;
  if (isa (op, mul)) return l != 1 && r != 1 && l <= r;
  if (isa (op, div)) return r != 1 && l % r == 0;
}

fun solutions3 (ns, n) {
  valid_fun = valid2;
  common_solutions (ns, n);
}

val ss = solutions3 ([1, 3, 7, 10, 25, 50], 765);
putln (#ss, " expressions found.  The first one:");
ss[0].show ();putln ();
TEST759
        echo '      ' $DINO '-O' $test_file "2>$stderr"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT759' && $CMP $stdout $ftemp2; then
49 expressions found.  The first one:
(3*((7*(50-10))-25))
OUTPUT759
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 760.
if test $result = ok -a $start_test_number -le 760; then
	echo test 760: Undefined destroy
        cat >$test_file <<'TEST760'
class object {
  priv fun destroy;
}

var i;
for (i = 0; i < 20; i++)
  object ();
gc ();
TEST760
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT760' && $CMP $stderr $ftemp2; then
test.d:2:12: run time error - unfinished fun/class `destroy' call
OUTPUT760
                    echo '      ' $CMP $ftemp2 $stdout
                    if cat >$ftemp2 <<'OUTPUT760-2' && $CMP $stdout $ftemp2; then
OUTPUT760-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 761.
if test $result = ok -a $start_test_number -le 761; then
	echo test 761: Wrong ... place a in pattern
        cat >$test_file <<'TEST761'
var [i, ..., j] = [4, 2, 5, 6];
println (i, j);
TEST761
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT761' && $CMP $stderr $ftemp2; then
test.d:1:9: `...' in the list middle
OUTPUT761
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 762.
if test $result = ok -a $start_test_number -le 762; then
	echo test 762: ... with repetition/key in a pattern
        cat >$test_file <<'TEST762'
var [i, j, 1 : ...] = [4, 2, 5, 6];
println (i, j);
TEST762
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT762' && $CMP $stderr $ftemp2; then
test.d:1:16: `...' with repetition/key
OUTPUT762
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 763.
if test $result = ok -a $start_test_number -le 763; then
	echo test 763: Pattern w/o variables
        cat >$test_file <<'TEST763'
var [4, ...] = [4, 2, 5, 6];
TEST763
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT763' && $CMP $stderr $ftemp2; then
test.d:1:14: Pattern in assignment has no variables
OUTPUT763
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 764.
if test $result = ok -a $start_test_number -le 764; then
	echo test 764: Smaller vector than pattern
        cat >$test_file <<'TEST764'
var [i, j] = [4];
println (i, j);
TEST764
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT764' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - expr does not match vector pattern
OUTPUT764
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 765.
if test $result = ok -a $start_test_number -le 765; then
	echo test 765: Bigger vector than pattern
        cat >$test_file <<'TEST765'
var [i, j] = [4, 2, 0];
println (i, j);
TEST765
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT765' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - expr does not match vector pattern
OUTPUT765
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 766.
if test $result = ok -a $start_test_number -le 766; then
	echo test 766: Vector element does not equal one in pattern
        cat >$test_file <<'TEST766'
var [i, 1] = [4, 2];
println (i);
TEST766
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT766' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - expr does not match vector pattern
OUTPUT766
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 767.
if test $result = ok -a $start_test_number -le 767; then
	echo test 767: Vector elements do not equal ones with repetition in pattern
        cat >$test_file <<'TEST767'
var [2:i, j] = [4, 2, 5];
println (i, j);
TEST767
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT767' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - expr does not match vector pattern
OUTPUT767
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 768.
if test $result = ok -a $start_test_number -le 768; then
	echo test 768: Vector elements do not equal ones with repetition in pattern
        cat >$test_file <<'TEST768'
var [2:2, i] = [2, 3, 5];
println (i);
TEST768
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT768' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - expr does not match vector pattern
OUTPUT768
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 769.
if test $result = ok -a $start_test_number -le 769; then
	echo test 769: Non-matching nested vector pattern 
        cat >$test_file <<'TEST769'
var [2, [i, 3], j] = [2, [3, 4], 5];
println (i, j);
TEST769
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT769' && $CMP $stderr $ftemp2; then
test.d:1:13: run time error - expr does not match vector pattern
OUTPUT769
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 770.
if test $result = ok -a $start_test_number -le 770; then
	echo test 770: Non-matching nested vector pattern
        cat >$test_file <<'TEST770'
var [2, [i, 4]] = [2, [3, 4], 5];
println (i);
TEST770
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT770' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - expr does not match vector pattern
OUTPUT770
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 771.
if test $result = ok -a $start_test_number -le 771; then
	echo test 771: Non-matching pattern
        cat >$test_file <<'TEST771'
var [i, j] = tab [4, 2];
println (i, j);
TEST771
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT771' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - expr does not match vector pattern
OUTPUT771
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 772.
if test $result = ok -a $start_test_number -le 772; then
	echo test 772: ... as repetition
        cat >$test_file <<'TEST772'
var [i, j, ... : 6] = [4, 2, 5, 6];
println (i, j);
TEST772
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT772' && $CMP $stderr $ftemp2; then
test.d:1:12: `...' in expression
OUTPUT772
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 773.
if test $result = ok -a $start_test_number -le 773; then
	echo test 773: _ as repetition
        cat >$test_file <<'TEST773'
var [i, j, _ : 6] = [4, 2, 5, 6];
println (i, j);
TEST773
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT773' && $CMP $stderr $ftemp2; then
test.d:1:12: `_' in expression
OUTPUT773
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 774.
if test $result = ok -a $start_test_number -le 774; then
	echo test 774: Wrong table pattern matching vector
        cat >$test_file <<'TEST774'
var tab [4:i, 2:j] = [4, 2];
println (i, j);
TEST774
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT774' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - expr does not match table pattern
OUTPUT774
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 775.
if test $result = ok -a $start_test_number -le 775; then
	echo test 775: Wrong table pattern matching table smaller size
        cat >$test_file <<'TEST775'
var tab [4:i, 0:j] = tab [4];
println (i, j);
TEST775
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT775' && $CMP $stderr $ftemp2; then
test.d:1:17: run time error - expr does not match table pattern
OUTPUT775
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 776.
if test $result = ok -a $start_test_number -le 776; then
	echo test 776: Wrong table pattern matching table bigger size
        cat >$test_file <<'TEST776'
var tab [4:i, 2:j] = tab [4, 2, 0];
println (i, j);
TEST776
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT776' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - expr does not match table pattern
OUTPUT776
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 777.
if test $result = ok -a $start_test_number -le 777; then
	echo test 777: Wrong table pattern matching table with different element
        cat >$test_file <<'TEST777'
var tab [4:i, 1:_] = tab [4, 2];
println (i);
TEST777
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT777' && $CMP $stderr $ftemp2; then
test.d:1:17: run time error - expr does not match table pattern
OUTPUT777
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 778.
if test $result = ok -a $start_test_number -le 778; then
	echo test 778: ... as repetition
        cat >$test_file <<'TEST778'
var tab [4: i, ...:2] = tab [4, 2, 5, 6];
TEST778
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT778' && $CMP $stderr $ftemp2; then
test.d:1:20: `...' as key with value in the table pattern
OUTPUT778
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 779.
if test $result = ok -a $start_test_number -le 779; then
	echo test 779: No vars in pattern assignment
        cat >$test_file <<'TEST779'
var tab [4, ...] = tab [4, 2, 5, 6];
TEST779
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT779' && $CMP $stderr $ftemp2; then
test.d:1:18: Pattern in assignment has no variables
OUTPUT779
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 780.
if test $result = ok -a $start_test_number -le 780; then
	echo test 780: ... as value in table pattern
        cat >$test_file <<'TEST780'
var tab [4:i, 2:j, 6 : ...] = tab [4:4, 2:2, 5, 6];
println (i, j);
TEST780
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT780' && $CMP $stderr $ftemp2; then
test.d:1:24: `...' with repetition/key
OUTPUT780
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 781.
if test $result = ok -a $start_test_number -le 781; then
	echo test 781: _ as key
        cat >$test_file <<'TEST781'
var tab [2, _, 5:i] = tab[2, 3, 5];
println (i);
TEST781
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT781' && $CMP $stderr $ftemp2; then
test.d:1:13: `_' in expression
OUTPUT781
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 782.
if test $result = ok -a $start_test_number -le 782; then
	echo test 782: Wrong table pattern matching involving vars in expr
        cat >$test_file <<'TEST782'
var tab[2:_, [3:i, 4:j], 5:k] = tab[2, [3, 4], 5];
println (i, j, k);
TEST782
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT782' && $CMP $stderr $ftemp2; then
test.d:1:17: undeclared identifier `i'
test.d:1:22: undeclared identifier `j'
OUTPUT782
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 783.
if test $result = ok -a $start_test_number -le 783; then
	echo test 783: Wrong nested table pattern matching
        cat >$test_file <<'TEST783'
var tab [2, 0:tab[3:i, 4]] = tab[2, 0:tab[3, 4], 5];
println (i);
TEST783
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT783' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - expr does not match table pattern
OUTPUT783
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 784.
if test $result = ok -a $start_test_number -le 784; then
	echo test 784: Stack pattern matching vector
        cat >$test_file <<'TEST784'
class c (i, j) {}
var c (i,j) = [2,4];
println (i, j);
TEST784
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT784' && $CMP $stderr $ftemp2; then
test.d:2:7: run time error - expr does not match stack pattern
OUTPUT784
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 785.
if test $result = ok -a $start_test_number -le 785; then
	echo test 785: Stack pattern has more params
        cat >$test_file <<'TEST785'
class c (i, j) {}
class s (i, j) {use c former i, j;}
var c (i, j, k) = s (2, 4);
println (i, j);
TEST785
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT785' && $CMP $stderr $ftemp2; then
test.d:3:14: run time error - expr does not match stack pattern
OUTPUT785
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 786.
if test $result = ok -a $start_test_number -le 786; then
	echo test 786: Stack pattern has less params
        cat >$test_file <<'TEST786'
class c (i, j) {}
class s (i, j) {use c former i, j;}
var c (i) = s (2, 4);
println (i);
TEST786
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT786' && $CMP $stderr $ftemp2; then
test.d:3:7: run time error - expr does not match stack pattern
OUTPUT786
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 787.
if test $result = ok -a $start_test_number -le 787; then
	echo test 787: Non-matching parameter value
        cat >$test_file <<'TEST787'
class c (i, j) {}
class s (i, j) {use c former i, j;}
var c (i, 5) = s (2, 4);
println (i);
TEST787
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT787' && $CMP $stderr $ftemp2; then
test.d:3:11: run time error - expr does not match stack pattern
OUTPUT787
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 788.
if test $result = ok -a $start_test_number -le 788; then
	echo test 788: Non-matching parameter value
        cat >$test_file <<'TEST788'
class c (i, j) {}
class s (i, j) {use c former i, j;}
var c (i, 5, ...) = s (2, 4);
println (i);
TEST788
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT788' && $CMP $stderr $ftemp2; then
test.d:3:11: run time error - expr does not match stack pattern
OUTPUT788
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 789.
if test $result = ok -a $start_test_number -le 789; then
	echo test 789: No vars in stack pattern
        cat >$test_file <<'TEST789'
class c (i, j) {}
class s (i, j, k) {use c former i, j;}
var c (2, 4, ...) = s (2, 4, 5);
TEST789
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT789' && $CMP $stderr $ftemp2; then
test.d:3:19: Pattern in assignment has no variables
OUTPUT789
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 790.
if test $result = ok -a $start_test_number -le 790; then
	echo test 790: Non-matching elem in nested stack pattern
        cat >$test_file <<'TEST790'
class c (i, j) {}
class s (i, j, k) {use c former i, j;}
var c (2, s (i, _, _), 6) = s (2, s(3, 4, 6), 5);
println (i);
TEST790
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT790' && $CMP $stderr $ftemp2; then
test.d:3:24: run time error - expr does not match stack pattern
OUTPUT790
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 791.
if test $result = ok -a $start_test_number -le 791; then
	echo test 791: Less params in nested stack pattern
        cat >$test_file <<'TEST791'
class c (i, j) {}
class s (i, j, k) {use c former i, j;}
var c (2, s (i, _, _)) = s (2, s(3, 4, 6), 5);
println (i);
TEST791
        echo '      ' $DINO '-O' $test_file "2>$stderr"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT792' && $CMP $stdout $ftemp2; then
3
OUTPUT792
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 792.
if test $result = ok -a $start_test_number -le 792; then
	echo test 792: Less params in pattern for stack with args
        cat >$test_file <<'TEST792'
class c (i, ...) {}
var c (i) = c (2);
println (i);
TEST792
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT792' && $CMP $stderr $ftemp2; then
test.d:2:7: run time error - expr does not match stack pattern
OUTPUT792
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 793.
if test $result = ok -a $start_test_number -le 793; then
	echo test 793: More params in pattern for stack with args
        cat >$test_file <<'TEST793'
class c (i, ...) {}
var c (i, _, _) = c (2);
println (i);
TEST793
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT793' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - expr does not match stack pattern
OUTPUT793
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 794.
if test $result = ok -a $start_test_number -le 794; then
	echo test 794: No isa pattern
        cat >$test_file <<'TEST794'
class c (i, j) {}
class s (i, j) {use c former i, j;}
var s (i,  _) = c (10, 5);
println (i);
TEST794
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT794' && $CMP $stderr $ftemp2; then
test.d:3:7: run time error - expr does not match stack pattern
OUTPUT794
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 795.
if test $result = ok -a $start_test_number -le 795; then
	echo test 795: Different pattern assignments
        cat >$test_file <<'TEST795'
var [i, j] = [4, 2];
println (i, j);

var [i, j, ...] = [4, 2, 5];
println (i, j);

var k = 2, [i, k + 1 : 2] = [4, 2, 2, 2];
println (i);

var [2:i, j] = [2, 2, 5];
println (i, j);

var [2:2, i] = [2, 2, 5];
println (i);

var [2, [i, j], k] = [2, [3, 4], 5];
println (i, j, k);

var [2, [i, 4, ...], j] = [2, [3, 4], 5];
println (i, j);

var [2, [i, _], j] = [2, [3, 4], 5];
println (i, j);

var k = 2, [i, k + 1 : _] = [4, 2, 2, 2];
println (i);
putln ("------------------------------");
//--------------------------------------------------------------------
var tab [4:i, 2:j] = tab [4, 2];
println (i, j);

var tab [4:i, 2:j, ...] = tab [4, 2, 5];
println (i, j);

var tab [4, 2, 3:i] = tab [4, 2, 3:3];
println (i);

var tab [2:i, 3:_, 5:j] = tab [2, 3, 5];
println (i, j);

var tab [3:_, 2:_, 5:i] = tab [2, 3, 5];
println (i);

var tab [2, 0:tab [3:i, 4:j], 5:k] = tab [2, 0:tab [3:3, 4:4], 5:5];
println (i, j, k);

var tab [2, 0:tab[3:i, 4, ...], 5:j] = tab [2, 0:tab [3, 4], 5:5];
println (i, j);

var tab [2, 0: tab [3:i, 4:_], 5:j] = tab [2, 0: tab [3:3, 4], 5:5];
println (i, j);

var tab [4:i, 2 : _, 3 : _, ...] = tab [4, 2, 3, 5];
println (i);
//--------------------------------------------------------------------
putln ("------------------------------");
class c (i, j) {}
class s (i, j, k) {use c former i, j;}
var c (i, j) = s (10, 5, 2);
println (i, j);

var c (i, j, ...) = s (10, 5, 2);
println (i, j);

var c (i, j, ...) = s (10, 5, 2);
println (i, j);

var c (i, j) = s (10, 5, 2);
println (i, j);

var c (10, i) = s (10, 5, 2);
println (i);

var c (i, 5) = s (10, 5, 2);
println (i);

var c (10, c (i, j)) = s (10, c (1, 3), 2);
println (i, j);

var c (10, c (i, 3, ...)) = s (10, c (1, 3), 2);
println (i, j);

var c (10, c (i, _)) = s (10, c (1, 3), 2);
println (i);

class c (i, ...) {}
var c (10, i) = c (10, 5, 6);
println (i);

var c (10, i) = c (10);
println (i);
TEST795
        echo '      ' $DINO '-O' $test_file "2>$stderr"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT795' && $CMP $stdout $ftemp2; then
42
42
4
25
5
345
35
35
4
------------------------------
nilnil
nilnil
3
nilnil
nil
345
nil5
35
nil
------------------------------
105
105
105
105
5
10
13
13
1
[5, 6]
[]
OUTPUT795
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 796.
if test $result = ok -a $start_test_number -le 796; then
	echo test 796: Different switch statements
        cat >$test_file <<'TEST796'
class c (a1, a2) {}
switch (c (2, 3)) {
 case c (i,j): putln (i, j);
 case _: putln ("default");
}

switch (c (4, 5)) {
 case c (i,j): putln (i, j);continue;putln (i + j);
 case _: putln ("default");
}

switch (c (6, 7)) {
 case c (i,j): putln (i, j);break;putln (i + j);
 case _: putln ("default");
}

switch (10) {
 case 1: putln (1);
 case 2: putln (2);
 case 10: putln (10);
 case _: putln ("_");
}

switch ("aa") {
 case "ab": putln ("ab");
 case "ac": putln ("ac");
 case "aa": putln ("aa");
 case _: putln ("_");
}

class c (a1, a2) {}
switch (c (2, 3)) {
 case c (i,j) if i==j: putln ("eq=", i, j);
 case c (i,j) if i!=j: putln ("neq=", i, j);
 case _: putln ("default");
}
TEST796
        echo '      ' $DINO '-O' $test_file "2>$stderr"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT796' && $CMP $stdout $ftemp2; then
23
45
default
67
10
aa
neq=23
OUTPUT796
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 797.
if test $result = ok -a $start_test_number -le 797; then
	echo test 797: Nested switch statements
        cat >$test_file <<'TEST797'
switch ([4, 5]) {
 case [i,j, ...]:
   switch (j) {
     case 1: putln (1);
     case 2: putln (2);
     case 5:
       putln (j);
       for (i in tab[2,3,4]) putln (i);
     case _: putln ("_");
   }
   continue;
   putln (i + j);
 case _:
  putln ("default");
}
TEST797
        echo '      ' $DINO '-O' $test_file "2>$stderr"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT797' && $CMP $stdout $ftemp2; then
5
2
3
4
default
OUTPUT797
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 798.
if test $result = ok -a $start_test_number -le 798; then
	echo test 798: Pattern vars scope in switch-stmt
        cat >$test_file <<'TEST798'
switch ([4, 5]) {
 case [i,j, ...]:
   switch (j) {
     case 5: putln (5);
     case _: putln ("_");
   }
   continue;
   putln (i + j);
 case _:
  putln (i);
}
TEST798
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT798' && $CMP $stderr $ftemp2; then
test.d:10:10: undeclared identifier `i'
OUTPUT798
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 799.
if test $result = ok -a $start_test_number -le 799; then
	echo test 799: Countdown problem with pattern matching
        cat >$test_file <<'TEST799'
val false = 0, true = 1;
// Expressions:
class binop (l, r) {
  fun op;
  fun show {put ('('); l.show (); put (op ()); r.show (); put (')');}
}
class add (l, r) { use binop former l, r later op; fun op {"+";} }
class sub (l, r) { use binop former l, r later op; fun op {"-";} }
class mul (l, r) { use binop former l, r later op; fun op {"*";} }
class div (l, r) { use binop former l, r later op; fun op {"/";} }
class value (i) { fun show { put (i); } }

fun valid (op, l, r) {
  if (isa (op, sub)) return l > r;
  else if (isa (op, div)) return l % r == 0;
  return true;
}

fun apply (op, l, r) {
  if (isa (op, add)) return l + r;
  if (isa (op, sub)) return l - r;
  if (isa (op, mul)) return l * r;
  if (isa (op, div)) return l / r;
}

fun values (e) {
  if (isa (e, value)) return [e.i];
  if (isa (e, binop)) return values (e.l) @ values (e.r);
}

fun eval (e) {
  if (isa (e, value)) return e.i > 0 ? e.i : nil;
  if (isa (e, binop)) {
    var x, y, re, res = nil;
    x = eval (e.l); y = eval (e.r);
    if (x != nil && y != nil) {
      val c = closure (e);
      if (valid (c, x, y))
        res = apply (c, x, y);
    }
    return res;
  }
}

// Combinatorial functions:
fun subs (xs) {
  if (#xs == 0) return [[]];
  val x = xs[0], yss = subs (xs[1:]);
  yss @ map (fun (ys) { [x] @ ys; }, yss);
}

fun interleave (x, ys) {
  if (#ys == 0) return [[x]];
  val y = ys[0], ys = ys[1:];
  [[x, y] @ ys] @ map (fun (l) { [y] @ l; }, interleave (x, ys));
}

fun perms (xs) {
  if (#xs == 0) return [[]];
  val x = xs[0], xs = xs[1:];
  var res = [], rs = map (fun (xx) { interleave (x, xx); }, perms (xs));
  for (var i = 0; i < #rs; i++)
    res @= rs[i];
  res;
}

fun choices (xs) {
  var res = [], yss = subs (xs);
  for (var i = 0; i < #yss; i++)
    res @= perms (yss[i]);
  res;
}

fun solution_p (e, ns, n) {
  val vs = values (e), css = choices (ns);
  for (var i = 0; i < #css; i++)
    if (vs == css[i]) return eval (e) == n;
  return false;
}

fun split (xs) {
  if (#xs <= 1) return [];
  val x = xs[0], xs = xs[1:], xsss = split (xs);
  [[[x], xs]] @ map (fun (xss) { [[x] @ xss[0], xss[1]]; }, xsss);
}

fun ops { [add, sub, mul, div]; }
fun combine (e1, e2) {
  var res = [], ops = ops ();
  for (var i = 0; i < #ops; i++)
    ins (res, ops[i] (e1, e2), -1);
  res;
}

fun exprs (xs) {
  if (#xs == 0) return [];
  if (#xs == 1) return [value (xs[0])];
  val nss = split (xs); var res = [];
  for (var i = 0; i < #nss; i++) {
    var ls = nss[i][0], rs = nss[i][1], ls = exprs (ls), rs = exprs (rs);
    for (var j = 0; j < #ls; j++)
      for (var k = 0; k < #rs; k++)
        insv (res, combine (ls[j], rs[k]), -1);
  }
  res;
}

fun solutions (ns, n) {
  val nss = choices (ns); var res = [];
  for (var i = 0; i < #nss; i++) {
    val es = exprs (nss[i]);
    for (var j = 0; j < #es; j++)
      if (eval (es[j]) == n)
	res @= [es[j]];
  }
  res;
}

var valid_fun;

fun combine2 (lv, rv) !jit {
  val l = lv[0], x = lv[1], r = rv[0], y = rv[1], res = [], ops = ops ();
  for (var i = 0; i < #ops; i++) {
    var o = ops[i];
    if (valid_fun (o, x, y))
      ins (res, [o (l, r), apply (o, x, y)], -1);
  }
  res;
}

fun results (ns) {
  if (#ns == 0) return [];
  if (#ns == 1) return (ns[0] <= 0 ? [] : [[value (ns[0]), ns[0]]]);
  val res = [], xsss = split (ns);
  for (var i = 0; i < #xsss; i++) {
    val lx = results (xsss[i][0]), ry = results (xsss[i][1]);
    for (var j = 0; j < #lx; j++)
      for (var k = 0; k < #ry; k++)
        insv (res, combine2 (lx[j], ry[k]), -1);
  }
  res;
}

fun common_solutions (ns, n) {
  val nss = choices (ns); var res = [];
  for (var i = 0; i < #nss; i++) {
    val rs = results (nss[i]);
    for (var j = 0; j < #rs; j++)
      if (rs[j][1] == n)
	ins (res, rs[j][0], -1);
  }
  res;
}

fun solutions2 (ns, n) {
  valid_fun = valid;
  common_solutions (ns, n);
}

fun valid2 (op, l, r) !jit {
  if (isa (op, add)) return l <= r;
  if (isa (op, sub)) return l > r;
  if (isa (op, mul)) return l != 1 && r != 1 && l <= r;
  if (isa (op, div)) return r != 1 && l % r == 0;
}

fun solutions3 (ns, n) {
  valid_fun = valid2;
  common_solutions (ns, n);
}

val ss = solutions3 ([1, 3, 7, 10, 25, 50], 765);
putln (#ss, " expressions found.  The first one:");
ss[0].show ();putln ();
TEST799
        echo '      ' $DINO '-O' $test_file "2>$stderr"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT799' && $CMP $stdout $ftemp2; then
49 expressions found.  The first one:
(3*((7*(50-10))-25))
OUTPUT799
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 800.
if test $result = ok -a $start_test_number -le 800; then
	echo test 800: Usage pattern vars in anon fun in the same declaration
        cat >$test_file <<'TEST800'
val xs = [1,2,3,4,5];
val [x, y, ...] = xs, v = map (fun (xx) { x + y + xx; }, xs);
println (v);
TEST800
        echo '      ' $DINO '-O' $test_file "2>$stderr"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT800' && $CMP $stdout $ftemp2; then
[4, 5, 6, 7, 8]
OUTPUT800
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 801.
if test $result = ok -a $start_test_number -le 801; then
	echo test 801: Bug in REPL
        cat >$test_file <<'TEST801'
class c(a) {} class sc (a, b){use c former a;}
switch (sc (10, 15)) { case c(10): putln ("ok")}
switch (sc (10, 15)) { case c(10,15): putln ("fail");}
TEST801
        echo '      ' $DINO "<" $test_file "2>&1 | egrep -v 'version|Copyright|if-stmt' >$stdout"
        if $DINO < $test_file 2>&1 | egrep -v 'version|Copyright|if-stmt' >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT801' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino> dino>       switch (sc (10, 15)) { case c(10): putln ("ok")}
                                                     ^
      syntax error
dino> dino> 
OUTPUT801
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 802.
if test $result = ok -a $start_test_number -le 802; then
	echo test 802: Bug in access to pattern variables.
        cat >$test_file <<'TEST802'
fun f(pub a){pub val b = a + 10;return this;}
val k = f(10);
putln (k.a, " ", k.b);
TEST802
        echo '      ' $DINO '-O' $test_file "2>$stderr"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT802' && $CMP $stdout $ftemp2; then
10 20
OUTPUT802
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 803.
if test $result = ok -a $start_test_number -le 803; then
	echo test 803: Bug in access to object in REPL.
        cat >$test_file <<'TEST803'
class c(a){}
val o = c(10);
o.a;
TEST803
        echo '      ' $DINO "<" $test_file "2>&1 | egrep -v 'version|Copyright|if-stmt' >$stdout"
        if $DINO < $test_file 2>&1 | egrep -v 'version|Copyright|if-stmt' >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT803' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino> dino> dino> 10
dino> 
OUTPUT803
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 804.
if test $result = ok -a $start_test_number -le 804; then
	echo test 804: default value param and ...
        cat >$test_file <<'TEST804'
fun f (a, b= 1, ...) {a + b;}
fun (a, b= 1, ...) {a + b;};
TEST804
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT804' && $CMP $stderr $ftemp2; then
test.d:1:12: usage of parameter default value and `...'
test.d:2:10: usage of parameter default value and `...'
OUTPUT804
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 805.
if test $result = ok -a $start_test_number -le 805; then
	echo test 805: default value param in the middle
        cat >$test_file <<'TEST805'
fun f (a, b= 1, c) {a + c + b;}
fun (a, b= 1, c) {a + c + b;};
TEST805
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT805' && $CMP $stderr $ftemp2; then
test.d:1:12: default value formal parameters should be the last ones
test.d:2:10: default value formal parameters should be the last ones
OUTPUT805
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 806.
if test $result = ok -a $start_test_number -le 806; then
	echo test 806: Zero slice step
        cat >$test_file <<'TEST806'
var v=[10:1];
putln (v[1:20:0]);
TEST806
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT806' && $CMP $stderr $ftemp2; then
test.d:2:9: run time error - slice step is zero (dimension = 1)
OUTPUT806
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 807.
if test $result = ok -a $start_test_number -le 807; then
	echo test 807: Negative slice start
        cat >$test_file <<'TEST807'
var v=[10:1];
putln (v[-1:2]);
TEST807
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT807' && $CMP $stderr $ftemp2; then
test.d:2:9: run time error - slice start is negative (dimension = 1)
OUTPUT807
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 808.
if test $result = ok -a $start_test_number -le 808; then
	echo test 808: Empty slice bug
        cat >$test_file <<'TEST808'
val v=[1,2,3,4];
println (v[3:1:-1]);
println (v[3:1:1]);
TEST808
        echo '      ' $DINO '-O' $test_file "2>$stderr"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT808' && $CMP $stdout $ftemp2; then
[]
[]
OUTPUT808
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 809.
if test $result = ok -a $start_test_number -le 809; then
	echo test 809: Bug in a call from high order function
        cat >$test_file <<'TEST809'
fun f (a, b) {a > b;}
filter (f, [2]);
TEST809
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT809' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - unexpected number of parameters for `f'
OUTPUT809
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 810.
if test $result = ok -a $start_test_number -le 810; then
	echo test 810: Bug in a call from high order function
        cat >$test_file <<'TEST810'
fun f () {1;}
filter (f, [2]);
TEST810
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT810' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - unexpected number of parameters for `f'
OUTPUT810
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 811.
if test $result = ok -a $start_test_number -le 811; then
	echo test 811: Bug in a call from high order function
        cat >$test_file <<'TEST811'
fun f (a, b) {a > b;}
map (f, [2]);
TEST811
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT811' && $CMP $stderr $ftemp2; then
test.d:2:11: run time error - unexpected number of parameters for `f'
OUTPUT811
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 812.
if test $result = ok -a $start_test_number -le 812; then
	echo test 812: Bug in a call from high order function
        cat >$test_file <<'TEST812'
fun f () {1;}
map (f, [2]);
TEST812
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT812' && $CMP $stderr $ftemp2; then
test.d:2:11: run time error - unexpected number of parameters for `f'
OUTPUT812
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 813.
if test $result = ok -a $start_test_number -le 813; then
	echo test 813: Bug in a call from high order function
        cat >$test_file <<'TEST813'
fun f (a, b, c) {a + b + c;}
fold (f, [2], 0);
TEST813
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT813' && $CMP $stderr $ftemp2; then
test.d:2:13: run time error - unexpected number of parameters for `f'
OUTPUT813
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 814.
if test $result = ok -a $start_test_number -le 814; then
	echo test 814: Bug in a call from high order function
        cat >$test_file <<'TEST814'
fun f () {1;}
fold (f, [2], 0);
TEST814
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT814' && $CMP $stderr $ftemp2; then
test.d:2:13: run time error - unexpected number of parameters for `f'
OUTPUT814
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 815.
if test $result = ok -a $start_test_number -le 815; then
	echo test 815: Stress test for fold/filter/map
        cat >$test_file <<'TEST815'
var v;
for (var i = 10; i < 100000; i++)
  v = filter (fun (a) {a > 0;}, [2, 5, 7]);

println (v);
for (var i = 10; i < 100000; i++)
  v = map (fun (a) {a + 1;}, [2, 3, 4]);

println (v);
for (var i = 10; i < 100000; i++)
  v = fold (fun (a, b) {a + b;}, [2, 3, 4], 0);

println (v);
TEST815
        echo '      ' $DINO '-O' $test_file "2>$stderr"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT815' && $CMP $stdout $ftemp2; then
[2, 5, 7]
[3, 4, 5]
9
OUTPUT815
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 816.
if test $result = ok -a $start_test_number -le 816; then
	echo test 816: Bug REPL printing
        cat >$test_file <<'TEST816'
filter (fun (e) {e > 0;}, [2]);
TEST816
        echo '      ' $DINO "<" $test_file "2>&1 | egrep -v 'version|Copyright|if-stmt' >$stdout"
        if $DINO < $test_file 2>&1 | egrep -v 'version|Copyright|if-stmt' >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT816' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino> [2]
dino> 
OUTPUT816
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 817.
if test $result = ok -a $start_test_number -le 817; then
	echo test 817: ovfld generation
        cat >$test_file <<'TEST817'
obj o {
  obj o2 { var a2; }
  var a;
  obj o {}
}

print (o.o2.a2, o.a, o.o);
TEST817
        echo '      ' $DINO '-d' $test_file "2>$stderr"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep ovfld $stdout
                if expr `fgrep ovfld $stdout | wc -l` == 4 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 818.
if test $result = ok -a $start_test_number -le 818; then
	echo test 818: lovfld generation
        cat >$test_file <<'TEST818'
obj o {
  obj o2 { var a2; }
  var a;
}

o.o2.a2 = 42; o.a = 23;
TEST818
        echo '      ' $DINO '-d' $test_file "2>$stderr"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep lovfld $stdout
                if expr `fgrep lovfld $stdout | wc -l` == 2 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 819.
if test $result = ok -a $start_test_number -le 819; then
	echo test 819: lovfldv generation
        cat >$test_file <<'TEST819'
obj o {
  obj o2 { var a2 = 0; }
  var a = 41;
}

o.o2.a2 += 42; o.a++;
TEST819
        echo '      ' $DINO '-d' $test_file "2>$stderr"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep lovfldv $stdout
                if expr `fgrep lovfldv $stdout | wc -l` == 2 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 820.
if test $result = ok -a $start_test_number -le 820; then
	echo test 820: ofun generation
        cat >$test_file <<'TEST820'
obj o {
  fun f { 42; }
}

print (o.f);
TEST820
        echo '      ' $DINO '-d' $test_file "2>$stderr"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep ofun $stdout
                if expr `fgrep ofun $stdout | wc -l` == 1 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 821.
if test $result = ok -a $start_test_number -le 821; then
	echo test 821: oclass generation
        cat >$test_file <<'TEST821'
obj o { class c {}}
print (o.c);
TEST821
        echo '      ' $DINO '-d' $test_file "2>$stderr"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep oclass $stdout
                if expr `fgrep oclass $stdout | wc -l` == 1 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 822.
if test $result = ok -a $start_test_number -le 822; then
	echo test 822: Bug in a call from high order function
        cat >$test_file <<'TEST822'
class c {var u;}
obj o { var v;}
print (o.u);
TEST822
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT822' && $CMP $stderr $ftemp2; then
test.d:3:9: no public declaration `u' in the object
OUTPUT822
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 823.
if test $result = ok -a $start_test_number -le 823; then
	echo test 823: omcall generation
        cat >$test_file <<'TEST823'
obj o { fun f (...) { 42;} }
println (o.f ());
TEST823
        echo '      ' $DINO '-d' $test_file "2>$stderr"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep omcall $stdout
                if expr `fgrep omcall $stdout | wc -l` == 1 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 824.
if test $result = ok -a $start_test_number -le 824; then
	echo test 824: omicall generation
        cat >$test_file <<'TEST824'
obj o { fun f { 42;} }
println (o.f ());
TEST824
        echo '      ' $DINO '-d' $test_file "2>$stderr"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep omicall $stdout
                if expr `fgrep omicall $stdout | wc -l` == 1 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 825.
if test $result = ok -a $start_test_number -le 825; then
	echo test 825: Object access
        cat >$test_file <<'TEST825'
obj o {
  obj o2 { var a2 = 0; }
  var a = 0;
  fun f1 (...){ 42;}
  fun f2 (...){ 42;}
}
o.a = 41;
o.o2.a2 += 42; o.a++;
putln (o.a, " ", o.o2.a2);
putln (o.f1 (), " ", o.f2 ());
TEST825
        echo '      ' $DINO '-O' $test_file "2>$stderr"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT825' && $CMP $stdout $ftemp2; then
42 42
42 42
OUTPUT825
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 826.
if test $result = ok -a $start_test_number -le 826; then
	echo test 826: Expose inside the object
        cat >$test_file <<'TEST826'
obj o {
  var a;
  expose o;
}
TEST826
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT826' && $CMP $stderr $ftemp2; then
test.d:3:10: expose-clause inside refering object `o'
OUTPUT826
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 827.
if test $result = ok -a $start_test_number -le 827; then
	echo test 827: Another expose inside the object
        cat >$test_file <<'TEST827'
obj o {
  var a;
  expose o.*;
}
TEST827
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT827' && $CMP $stderr $ftemp2; then
test.d:3:10: expose-clause inside refering object `o'
OUTPUT827
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 828.
if test $result = ok -a $start_test_number -le 828; then
	echo test 828: Expose of undeclared ident
        cat >$test_file <<'TEST828'
obj o { var v = 42;}
expose o2;
TEST828
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT828' && $CMP $stderr $ftemp2; then
test.d:2:8: undeclared identifier `o2'
OUTPUT828
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 829.
if test $result = ok -a $start_test_number -le 829; then
	echo test 829: Expose of undeclared ident
        cat >$test_file <<'TEST829'
obj o { var v = 42;}
expose o.v2;
TEST829
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT829' && $CMP $stderr $ftemp2; then
test.d:2:10: no public declaration `v2' in the object
OUTPUT829
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 830.
if test $result = ok -a $start_test_number -le 830; then
	echo test 830: Expose of private decl
        cat >$test_file <<'TEST830'
obj o { priv var v = 42;}
expose o.v;
v += 10;
TEST830
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT830' && $CMP $stderr $ftemp2; then
test.d:2:10: no public declaration `v' in the object
OUTPUT830
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 831.
if test $result = ok -a $start_test_number -le 831; then
	echo test 831: Expose of val and modifying it
        cat >$test_file <<'TEST831'
obj o { val v = 42;}
expose o.v;
v += 10;
TEST831
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT831' && $CMP $stderr $ftemp2; then
test.d:3:1: constant `v' in assignment statement
OUTPUT831
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 832.
if test $result = ok -a $start_test_number -le 832; then
	echo test 832: Different expose-clauses
        cat >$test_file <<'TEST832'
var v = 0;
obj o {var v = 42;}
expose o.*;
putln (v);

var v = 0;
obj o {var v = 42*42;}
expose o.v;
putln (v);

v -= 42;
expose o.v (va);
putln (v, " ", va);

fun f {0;}
obj o { fun f {42;} }
expose o.*;
putln (f ());
TEST832
        echo '      ' $DINO '-O' $test_file "2>$stderr"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT832' && $CMP $stdout $ftemp2; then
42
1764
1722 1722
42
OUTPUT832
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 833.
if test $result = ok -a $start_test_number -le 833; then
	echo test 833: Access through '.' and expose
        cat >$test_file <<'TEST833'
obj o {
  obj o2 {var v = 42;}
}
expose o.*;
o2.v *= 2;
putln (o2.v);
TEST833
        echo '      ' $DINO '-O' $test_file "2>$stderr"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT833' && $CMP $stdout $ftemp2; then
84
OUTPUT833
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 834.
if test $result = ok -a $start_test_number -le 834; then
	echo test 834: Expose of val and modifying it
        cat >$test_file <<'TEST834'
obj o { fun v {}}
expose o.v;
v += 10;
TEST834
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT834' && $CMP $stderr $ftemp2; then
test.d:3:1: non variable in assignment statement
OUTPUT834
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 835.
if test $result = ok -a $start_test_number -le 835; then
	echo test 835: Access to decl not in object
        cat >$test_file <<'TEST835'
var v = 0;
expose v;
v+=42;
println (v);
var v2 = 0;
expose v2 (v);
v+=84;
println (v);
TEST835
        echo '      ' $DINO '-O' $test_file "2>$stderr"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT835' && $CMP $stdout $ftemp2; then
42
84
OUTPUT835
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 836.
if test $result = ok -a $start_test_number -le 836; then
	echo test 836: Expose through non-public object
        cat >$test_file <<'TEST836'
obj o { priv obj o2 {var v = 42;}}
expose o.o2.v;
TEST836
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT836' && $CMP $stderr $ftemp2; then
test.d:2:10: no public declaration `o2' in the object
OUTPUT836
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 837.
if test $result = ok -a $start_test_number -le 837; then
	echo test 837: Undeclared obj member: one error only
        cat >$test_file <<'TEST837'
obj o {}
o.v2;
TEST837
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT837' && $CMP $stderr $ftemp2; then
test.d:2:2: no public declaration `v2' in the object
OUTPUT837
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 838.
if test $result = ok -a $start_test_number -le 838; then
	echo test 838: Qualified identifier in use
        cat >$test_file <<'TEST838'
obj o { class c (p) {} }
class s (p) {use o.c2 former p;}
TEST838
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT838' && $CMP $stderr $ftemp2; then
test.d:2:19: no public declaration `c2' in the object
OUTPUT838
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 839.
if test $result = ok -a $start_test_number -le 839; then
	echo test 839:  Qualified identifier in use
        cat >$test_file <<'TEST839'
class o2 { class c (p) {} }
class s (p) {use o2.c former p;}
TEST839
        echo '      ' $DINO '-O' $test_file ">$stdout"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $ftemp2 $stderr
                if cat >$ftemp2 <<'OUTPUT839' && $CMP $stderr $ftemp2; then
test.d:2:18: o2 is not an object in qualified identifier of use-clause
OUTPUT839
			result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 840.
if test $result = ok -a $start_test_number -le 840; then
	echo test 840: Qualified identifier in use
        cat >$test_file <<'TEST840'
obj o { class c (p) {fun pr {putln ("hello, ", p);} } }
class s (p) {use o.c former p;}
s (42).pr ();
TEST840
        echo '      ' $DINO '-O' $test_file "2>$stderr"
        if $DINO -O $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT840' && $CMP $stdout $ftemp2; then
hello, 42
OUTPUT840
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Final message

if test $result = ok; then
        echo $script_file: it is all ok
        rm -f $test_file $test_file_1 $stderr a.out $stdout $ftemp $ftemp2
	rm -rf $tempdir
        exit 0
else
        echo '***' $script_file:test is failed
        echo '   '  see files $test_file, $stdout, $test_file_1, $stderr, $ftemp, $ftemp2, $tempdir
        exit 1
fi
