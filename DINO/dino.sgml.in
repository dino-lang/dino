<!doctype linuxdoc system>
<article>

<!-- Title information -->

<title>The Programming Language DINO
<author>Vladimir Makarov, <tt>vmakarov@gcc.gnu.org</tt>.
<date>Apr 2, 2016
<abstract>
This document describes the programming language DINO -- the
current language version.
</abstract>
<toc>

<sect>Introduction
<p>
DINO is a high level dynamically-typed scripting language.  DINO is
designed taking such design principles as simplicity, uniformity, and
expressiveness into account.  Dino is oriented on the same domain of
applications as the famous scripting languages Perl, Python, and Lua.
Most programmers know the C programming language.  Therefore Dino aims
to look like C where it is possible.  Dino is an object oriented
language with garbage collection and pattern matching.  Dino has
possibilities of a concurrency execution and exception handling.  Dino
is an extensible language with the possibility of dynamic compilation
and loading of a code written on the C language.  The high level
structures of Dino are
    <itemize>
    <item>heterogenous extensible vectors
    <item>extensible associative tables with the ability to delete
      table elements
    <item>objects
    </itemize>
<p>
Originally, Dino was used in the Russian graphics company ANIMATEK for
a description of the movement of dinosaurs in a project.  It has been
considerably redesigned and has been re-implemented with the aid of
the COCOM tool set.
<p>
This document is not intended for use as a programmer's tutorial.  It
is a concise description of the language DINO and can be used as a
programmer's reference.

<sect>Syntax
<p>
An extended Backus-Naur Formalism (EBNF) is used to describe the
syntax of Dino.  Alternatives are separated by <tt>|</tt>.  Brackets
<tt>[</tt> and <tt>]</tt> denote optionality of the enclosed
expression, and braces <tt>{</tt> and <tt>}</tt> denote repetition
(zero or more times).  Parentheses <tt>(</tt> and <tt>)</tt> are used
for grouping a EBNF construction containing alternatives inside it as
one construction.
<p>
Terminal symbols denoting a class of terminals (e.g. identifier)
consist of only upper-case letters (e.g. IDENT).  The remaining
terminal symbols either start with a lower-case letter (e.g. the keyword
<tt>else</tt>), or are denoted by ASCII character sequences in double
quotes (e.g. <tt>"=="</tt>).  Non-terminal symbols start with an
upper-case letter and contain at least one lower-case letter
(e.g. FormalParameters).


<sect>Vocabulary and Representation
<p>
Wherever it is possible, we use also the EBNF for description of
lexical symbols through ASCII set characters.  Otherwise, we will use
natural language sentences in <tt><</tt> and <tt>></tt>.
<p>
Lexical symbols are identifiers, numbers, character constants,
strings, operators, delimiters, and comments.  White characters
(blanks and line breaks) must not occur within the symbols (except in
comments, and as the blanks in strings).  The white characters are
ignored unless they are essential to separate two consecutive lexical
symbols.  Upper- and lower-case letters are considered to be distinct.
     <enum>
     <item>An <em>identifier</em> is a sequence of letters and digits
        starting with a letter.  The underline is believed to be a
        valid letter in an identifier.  A single underline is fixed
        for other usage (see a wildcard in section "Patterns").
<tscreen><verb>
          Ident = Letter {Letter | Digit}

          Letter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j"
                 | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t"
                 | "u" | "v" | "w" | "x" | "y" | "z"
                 | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
                 | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
                 | "U" | "V" | "W" | "X" | "Y" | "Z"
                 | "_"

          OctalDigit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7"

          Digit = OctalDigit | "8" | "9"

          HexDigit = Digit | "a" | "A" | "b" | "B" | "c" | "C"
	           | "d" | "D" | "e" | "E" | "f" | "F"
	            
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          line  line2  next_line  NextLine
</verb></tscreen>
     <item><em>Numbers</em> are (unsigned) integer or floating point
        numbers.  Numbers start with a digit.  Numbers starting with
        the prefix <tt>0x</tt> or <tt>0X</tt> are hexadecimal integer
        numbers.  Otherwise, integer numbers starting with <tt>0</tt>
        are octal integer numbers.  Octal integer numbers should not
        contain <tt>8</tt> or <tt>9</tt>.  If an integer number has
        the suffix <tt>l</tt> or <tt>L</tt>, it is a long number (see
        long values in the section "Types and Values").  Floating
        point numbers are distinguished from decimal integer numbers
        by the presence of the decimal point <tt>.</tt> or an exponent
        in the number representation.  You can put <tt>_</tt> in
        number digit sequences unless it is the first symbol of the
        sequence.  It can be useful for readability of long digit
        sequences.
<tscreen><verb>
          Number = Integer | Long | FloatingPointNumber

	  DigitSeq = Digit { Digit | "_" }

	  HexDigitSeq = HexDigit { HexDigit "_" }
	  
          Integer = DigitSeq | "0" ("x" | "X") HexDigitSeq

          Long = Integer ("l" | "L")

          FloatingPointNumber = DigitSeq "." [ DigitSeq ] [Exponent]
                              | DigitSeq [Exponent]

          Exponent = ("e" | "E") [ "+" | "-" ] DigitSeq
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          10
          10L
          222_222_222_222_222_222_222_222_222_222_222_222_222_222_222_222l
          100.
          1e2
          1000.000_1E+0
	  1___000__000_000
	  0xafad_1f34_17ff_
</verb></tscreen>
     <item>A Dino <em>character constant</em> denotes an Unicode
        character.  The following sequences starting with the ASCII
        backslash have a special meaning inside a Dino character
        constant:
          <itemize>
          <item><tt><bf>\a</bf>       -</tt> ASCII character alert
          <item><tt><bf>\b</bf>       -</tt> ASCII character backspace
          <item><tt><bf>\f</bf>       -</tt> ASCII character form feed
          <item><tt><bf>\n</bf>       -</tt> ASCII character new line
          <item><tt><bf>\r</bf>       -</tt> ASCII character carriage return
          <item><tt><bf>\t</bf>       -</tt> ASCII character horizontal tab
          <item><tt><bf>\v</bf>       -</tt> ASCII character vertical tab
          <item><tt><bf>\code</bf>    -</tt> A character with the code
            given by up to tree octal digits
          <item><tt><bf>\xcode</bf>   -</tt> A character with the code
            given by two hexdecimal digits
          <item><tt><bf>\ucode</bf>   -</tt> A character with the code
            given by four hexdecimal digits
          <item><tt><bf>\Ucode</bf>   -</tt> A character with the code
            given by eight hexdecimal digits
          <item><tt><bf>\char</bf>    -</tt> The character char for all
            remaining characters
          </itemize>
        <p>
        To denote a single quote mark use the sequence <tt>\'</tt>.
        The double quote mark can be represented either by <tt>\"</tt>
        or simply by <tt>"</tt>.  To represent a backslash inside the
        character constant, use two consecutive ASCII backslashes.
<tscreen><verb>
          Character = "'" Char "'"

          Char = <any character except for the single quote ',
                  backslash \, or line break>
               | SimpleEscapeSeq
               | OctalEscapeSeq

          SimpleEscapeSeq = <one of  \'  \"  \\  \a  \b  \f  \n  \r  \t  \v>

          OctalEscapeSeq = "\" OctalDigit [ OctalDigit [ OctalDigit ] ]
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          'a'  '\''  '\\'  '\12'  '"'
</verb></tscreen>
     <item>A <em>string</em> is a sequence of characters enclosed in
        double quotes. There are the same sequences of characters with
        special meaning as in a character constant.  To denote a
        double quote mark use the sequence <tt>\"</tt>.  The single
        quote mark can be represented either by <tt>\'</tt> or simply
        by <tt>'</tt>.  To represent a backslash inside the character
        constant, use two consecutive ASCII backslashes.
<tscreen><verb>
          String = '"' {Char} '"'
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          "This is Dino"  "Don't worry\n"
</verb></tscreen>
<p>
        Another variant of a string representation uses
        back-quotes <tt>`</tt>.  A character inside the back-quotes
        are present in the string as it is, in other words, the escape
        sequences do not work in such representation.  To denote the
        back-quote in such string representation use double
        back-qoutes.  The newline may not be in such string
        representation.  It means that a string with back-quotes can
        reside only on one program line.
<tscreen><verb>
          String = '`' {Char} '`'
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          `\p{Greek}+`  `back qoute `` is here`
</verb></tscreen>
     <item>A <em>C code</em> is a sequence of characters enclosed in
        the special brackets <tt>%{</tt> and <tt>%}</tt>.  It represents a
        C code fragment which is compiled and loaded into Dino
        interpreter during the program execution
<tscreen><verb>
          C_CODE = "%{" <any char sequence not containing pair %}> "%}"
</verb></tscreen>
<p>
        An example:
<tscreen><verb>
          %{ static val_t dino_var; %}
</verb></tscreen>
     <item>The remaining essential lexical symbols are called
        <em>operators</em> and <em>delimiters</em>.  Operators are
        used for forming expressions, delimiters are used for forming
        syntax constructions.  There is a special kind of operators
        and delimiters which look like identifiers containing only
        lower-case letters.  They are reserved identifiers (keywords).
        Keywords can not be used in the place of an identifier.
<tscreen><verb>
          OperatorOrDelimeter = "?" | ":" | "|" | "||" | "&" | "&&" | "^"
	                      | "==" | "!=" | "===" | "!==" | "<" | ">"
			      | "<=" | ">=" | "<<" | ">>" | ">>>" | "@"
	                      | "+" | "-" | "/" | "*" | "%" | "!" | "~"
     			      | "#" | ".+" | ".*" | ".&" | ".^" | ".|"
			      | "(" | ")" | "[" | "]" | "{" | "}"
                              | "." | "," | ";" | "=" | "*=" | "/="
                              | "%=" | "+=" | "-=" | "@=" | "<<=" | ">>="
                              | ">>>=" | "&=" | "^=" | "|=" | "++" | "--"
			      | "..." | Keyword

          Keyword = "_" | "break" | "case" | "catch" | "char" | "class"
                  | "continue" | "else" | "expose" | "extern" | "final"
                  | "fiber" | "float" | "for" | "former" | "friend" | "fun"
                  | "hide" | "hideblock" | "if" | "in" | "int"
                  | "later" | "long" | "new" | "nil" | "obj"
                  | "pmatch" | "priv" | "pub" | "return" | "rmatch" 
                  | "tab" | "thread" | "this" | "throw" | "try" | "type"
                  | "use" | "val" | "var" | "vec" | "wait"
</verb></tscreen>
     <item><em>Comments</em> are considered analogous to blanks on the
        syntax level of the program.  There are two types of the
        comments.  The first type is an arbitrary character sequence
        starting with <tt>/*</tt> and finishing with <tt>*/</tt>.  The
        second type comment starts with <tt>//</tt> and finishes with
        the first line break or with the end of file.
<tscreen><verb>
          Comment = "/*" <arbitrary char. sequence not containing pair */> "*/"
                  | "//" <arbitrary char. sequence finishing on line break>
</verb></tscreen>
     </enum>


<sect>Declarations and Scope Rules
<p>
A Dino program is block structured.  Each block introduces a new
identifier scope.  A block consists of executive statements and
declarations and may contain nested blocks.  There are also implicit
blocks containing each <em>case</em>-part of match statements (see
below). Each identifier used in a program should be declared in a
declaration in the program, unless it is a predeclared identifier.
<tscreen><verb>
          Block = "{"  StmtList "}"

          StmtList = { Stmt }
       	
          Stmt = ExecutiveStmt
               | Declaration
</verb></tscreen>
<p>
When declaring an identifier, you also specify certain permanent
properties of a declaration, such as whether it is a variable, a
function, a class, or a singleton object.  The identifier is then used
to refer to the associated declaration (more correctly to the
declaration instance).
<tscreen><verb>
          Declaration = VarDeclarations
                      | AccessClause
                      | ExternDeclarations
                      | FuncClassDeclaration
                      | SingletonObject
                      | ForwardDeclaration
                      | IncludeDeclaration
</verb></tscreen>
<p>
The scope of a declaration is textually from the point of the
declaration to the end of the block to which the declaration belongs
and hence to which the declaration is local.  The declaration scope
can stop earlier at the point of another declaration with the same
identifier in the same block.  The declaration scope excludes the
scopes of declarations with the same identifier which are in nested
blocks.
<p>
It is important to understand the notion of <em>instantiation</em> of
the declaration.  This notion reflects a program execution, not the
static structure of the program.  An instance exists in
a <em>context</em>.  Actually, a context is an execution environment
consisting of the covering block instances and/or class objects.  A
new instance of the block is created when an execution of the block
starts.  There may be more than one instance of the same block,
e.g. when the block is a function or class body (in this case the
block instance is a class object), or when the block is executed on
different threads (concurrently executed parts of the program) or when
there is a reference to a block instance after its execution.  When a
new instance of the block starts, all the block declarations are
instantiated too.  For a variable declaration, it means a new instance
of the variable is created in the given context.  For a function or class
declaration, it means that the function or class is bound to the given
context.
<p>
        Example: 
          The following program illustrates a case when a reference to
          a block instance exists after its execution.  The program
          outputs the result 8.
<tscreen><verb>
          var i, f;
        
          for (i = 0; i < 10; i++)
            if (i % 4 == 0)
              {
                var j = i;
                fun r () {return j;}
                f = r;
              }
          putln (f ());
</verb></tscreen>
<p>
There are certain rules for declaration accessibility.  Declaration is
always either <em>private</em> or <em>public</em>.  Private
declaration is accessible only inside the declaration scope or inside
functions or classes which are declared as a <em>friend</em> in the
declaration block.  A public declaration instance is always accessible
when association (see below) of the identifier is successful.  By
default, (instances of) declarations in a class block are public.  In
all other places, the (instances of) declarations are private by
default.  The following constructions are used for declaring an
identifier to be a friend:
<tscreen><verb>
          FriendClause = friend IDENT { "," IDENT } ";"
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          friend class2;
</verb></tscreen>
<p>
Association of an identifier and the corresponding declaration
instance is performed by the following rules:
     <itemize>
     <item>The corresponding declaration instance is searched for a
       separate identifier occurrence in the instance of the block in
       which the identifier occurs.  The identifier should be in the
       scope of the corresponding declaration.  If there is no such
       declaration, the declaration is searched in the covering block
       instance of the current block instance back from the current
       block, and so on.  In any case, the identifier should be in the
       scope of the corresponding declaration.
     <item>Declaration instance for an identifier in the following
       construction
<tscreen><verb>
       designator.identifier
</verb></tscreen>
<p>
       is searched in the block instance (e.g. in a class object)
       whose value is in the designator.  The scope of the found
       declaration should always include the block end.  The
       exception <tt>accessop</tt> occurs if the declaration is not
       found with such identifier, or the declaration is private and
       the construction is not inside a friend of the declaration
       scope.
     </itemize>
<p>
The following identifiers are predeclared on the top level (in an
implicit block covering the whole program).  They are described in
more detail later in the report.
<tscreen><verb>
  lang           io             sys            math
  re             yaep
</verb></tscreen>

<sect1>Variable Declarations
<p>
Dino is an imperative language. In other words it has
<em>variables</em> which are named containers of values.  A variable
can contain any value.  This means that DINO is a dynamically-typed
language.  The declaration of a variable also may define the initial
value of the variable.  In this case a <em>pattern</em> can stand on
the left side of the assignment instead of just an identifier.  The
pattern should contain at least one variable.  The pattern variables
are declared at the assignment point.  The pattern should match the
assigned value, otherwise the exception <tt>patternmatch</tt> is
generated.  More details about the patterns, the pattern variables,
and pattern matching are decribed later in this document.
<p>
Assigning of the initial value to the variable instance is made after
execution of the previous statements of the block and after execution
of previous assignments in the variable list.  By default the initial
value of variables is undefined.  Nothing can be done with this value.
This value even can not be assigned.
<p>
The value of the variable is final and can not be changed after its
initialization if its declaration is in a list starting with
keyword <tt>val</tt>.
<p>
Keywords <tt>pub</tt> and <tt>priv</tt> can be used to redefine the
default accessibility.  They make the declared variables
correspondingly public and private.
<tscreen><verb>
          VarDeclarations = [pub | priv] (val | var) VarList ";"

          VarList = Var { "," Var }
       	
          Var = IDENT | Pattern "="  Expr
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          var i = 0, [el1, el2] = [2, 5], j, k;
          val constant = 10, nil_constant = nil;
</verb></tscreen>

<sect1>External Declarations
<p>
Dino permits to use functions written on the programming language C.
The functions should have special prototypes and can use the DINO
standard procedural interface (SPI).  Dino can also have an access to
variables of a special type declared in the C source code.  The
details of the implementation of such features and the DINO SPI are
not described here (some details are given in appendix B).  As a rule,
the external functions and variables will be implemented as
dynamically loaded libraries.  This is a powerful instrument of DINO
extension.  The external functions and variables are declared after
keyword <tt>extern</tt>.  An external function identifier is followed
by <tt>()</tt>.  All external declarations (e.g. in different blocks)
with the same identifier refer the the same external function or
variable.  As in the variable declaration, keywords <tt>pub</tt>
and <tt>priv</tt> can be used to redefine the default accessibility of
the external functions and variables..
<tscreen><verb>
          ExternDeclarations = [pub | priv] extern ExternItems ";"

          ExternItems = ExternItem { "," ExternItem }

          ExternItem = IDENT 
                     | IDENT  "(" ")"
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          extern function (), variable;
</verb></tscreen>

<sect1>Functions and Classes
<p>
A function/class declaration consists of a
function/class <em>header</em>, <em>formal parameters</em>, and a
function/class block (<em>body</em>).  The header specifies the
function/class identifier.
<p>
A function can return the result with the aid of the
statement <em>return</em>.  If the result value after the
keyword <em>return</em> is absent or the return statement is not
executed, the function result is undefined vlaue.  An
expression-statement as the textually last statement in the function
block is actually abbreviation of a return with the expression.
<p>
A class call returns the class block instance (an <em>object</em> of
the class).  Any return-statement in a class must be without a result.
<p>
<em>Fiber-functions</em> (we call them also simply <em>fibers</em> for
brevity) are analogous to general functions.  The difference is in
that a new execution <em>thread</em> is created during the fiber call,
the return-statement inside the fiber must be without an expression,
and the fiber returns the corresponding thread.  The thread finishes
when the corresponding fiber block finishes.  Threads are executed
concurrently.  Originally only one thread (called the <em>main
thread</em>) exists in a DINO program.
<p>
The formal parameters are considered to be declared in a
function/class block and to be initialized by values of the
corrsponding <em>actual parameters</em> during a call of the
function/class.  By default they can change their value.
Keyword <tt>val</tt> prevents changing value of the corresponding
formal parameter after the initialization.
<p>
Default accessibility of the formal parameter can be changed by using
keywords <tt>pub</tt> or <tt>priv</tt> (see accessibility in the
section "Declarations and Scope Rules").
<p>
The number of <em>actual parameters</em> should be the same as the
number of formal parameters.  There are two exclusions to this
requirement.  One exclusion is formal parameters initialized by a
default value in a way analogous to the variable initialization.  The
actual parameters corresponding to the formal parameters with default
values can be omitted.  In this case, the formal parameters will have
the default value.  Another exclusion is an usage of <tt>...</tt> at
the end of the list of formal parameter declarations, the number of
actual parameters can be more the number of formal parameters.
Using <tt>...</tt> results in that the formal parameter with the
identifier <tt>args</tt> will be declared implicitly.  The value of
the parameter will be a vector whose elements will be the remaining
actual parameter values.  If the number of actual parameters is equal
to the number of formal parameters (not taking the implicit
parameter <tt>args</tt> into account), the value of <tt>args</tt> will
be the empty vector.
<p>
All formal parameters with default values should be at the end of the
parameter list.  Usage of formal parameters with default values is
prohibited in a case when <tt>...</tt> is used.
<p>
If a class contains a function with the name <tt>destroy</tt>, the
function will be called when the class object becomes garbage during
the garbage collection process or at the end of the program.  The
function can also be called explicitly from outside if it is declared
as public.  You should remember that the function is called by the
garbage collector without actual parameters and the garbage collector
(or finishing the program) ignores the result value.  So the function
should satisfy the above rules to be called without actual parameters.
<p>
You may prevent removing the corresponding object by the garbage
collector in the function destroy by assigning the object to a
variable.  It means that the function can be called several times
(during several garbage collections) for the same object.  But you
should also avoid creation of objects during the call of
function <tt>destroy</tt> because it may result in uncontrolled
increase of the heap.
<p>
A function/class declaration can have optional qualifiers.  The
qualifier <tt>final</tt> can not be mentioned in an use-clause (see
the section "Use-Clause").  Qualifiers <tt>pub</tt> and <tt>priv</tt>
change the default accessibility of declarations.
<tscreen><verb>
          FuncClassDeclaration = Header FormalParameters Hint Block

          Header = [Qualifiers] FuncFiberClass IDENT

          Qualifiers = pub | priv | final
	              | pub final | priv final
	              | final pub | final priv

          FuncFiberClass = fun 
                 	 | fiber 
                 	 | class 
      	
          FormalParameters =
	                   | "(" [ ParList ] ")"
                 	   | "(" ParList "," "..." ")"
                 	   | "(" "..." ")"

	  ParList = Par { "," Par}

	  Par = [pub | priv] [val | var] IDENT [ "=" Expr]

          Hint = [ "!" IDENT ]
</verb></tscreen>
<p>
        Examples:
<p>
        The following is parameterless class:
<tscreen><verb>
          class stack () {}
          class stack {}
</verb></tscreen>
<p>
        The following is a class header with initialization parameters:
<tscreen><verb>
          class stack (max_height = variable,
                       val a = 1, priv val b = 2)
</verb></tscreen>
<p>
        The following is a function with a variable number of parameters:
<tscreen><verb>
          fun print_args (...) {
              for (i = 0; i < #args; i++)
                println (args[i]);
          }
</verb></tscreen>
<p>
        The following example is a class with the function <tt>destroy</tt>:
<tscreen><verb>
          var objs_number = 0;
          class object () {
            priv var n = objs_number;
            objs_number++;
            priv fun destroy () {objs_number--;}
          }
</verb></tscreen>
<p>
        The following example illustrates the threads:
<tscreen><verb>
          class buffer (length = 3) {
            var b = [length:nil], first = 0, free = 0, empty = 1;
            priv b, first, free, length;
            fun consume () {
              var res;
          
              wait (!empty);
              res = b [first];
              first = (first + 1) % length;
              wait (1) empty = first == free;
              return res;
            }
            fun produce (value) {
              wait (empty || free != first);
              b [free] = value;
              free = (free + 1) % length;
              wait (1) empty = 0;
            }
          }
          
          fiber consumer (buffer) {
              fun produce (value) {
                buffer.produce (value);
                put ("produce: ");
                println (value);
              }
              produce (10);
              produce (10.5);
              produce ("string");
              produce ('c');
              produce (nil);
          }
          
          fiber producer (buffer) {
            var value;
          
            for (;;) {
              value = buffer.consume ();
              if (value == nil)
                break;
              put ("consume: ");
              println (value);
            }
          }
          
          var queue = buffer ();
          consumer (queue);
          producer (queue);
</verb></tscreen>
<p>
According to Dino scope rules, a declaration should be present before
any usage of the declared identifier.  Sometimes we need to use
function/class identifier before its declaration, e.g. in the case of
mutually recursive functions.  To do this, Dino has forward
declarations.
<p>
  A forward declaration is just a function/class header followed by
semicolon:
<tscreen><verb>
            ForwardDeclaration = Header ";"
</verb></tscreen>
<p>
A forward declaration denotes the first declaration with the same
identifier in the same block after the forward declaration.  The
forward and the corresponding declaration should be the same
declaration type (function, class, or fiber), and have the same
accessibility and the same qualifier <tt>final</tt>.
<p>
The corresponding declaration of a forward declaration may be absent.
In this case a call of the function/class results in occuring the
exception <tt>abstrcall</tt>.  When accessing to such function through
the corresponding object, exception <tt>accessvalue</tt> is generated.
A forward declaration without the corresponding declaration can be
usefull to describe <em>abstract classes</em>.  The following are
examples of forward declarations:
<tscreen><verb>
          fun even;
          fun odd (i) { if (i == 0) return 0; return even (i - 1);}
          fun even (i) { if (i == 0) return 1; return odd (i - 1);}
	  class operation { // abstract class
            fun print_op (); fun apply ();
	  }
</verb></tscreen>
<p>
A function/class declaration may have an optimization hint.
Currently, there are only 3 hints.  Hint <tt>!pure</tt> means that the
function is pure, i.e. it has no side effects and returns a result
depending only on the call arguments.  Hint <tt>!inline</tt> means
inlining all the function calls.  Hint <tt>!jit</tt> means a usage of
a JIT compiler for the function/class execution.

<sect1>Use-Clause
<p>
Dino has a powerful block composition operator <em>use</em>.  Using it
inside a class block can emulate <em>(multiple) inheritance, traits,
duck typing, and dynamic dispatching</em>.  The use-clause has the
following syntax:
<tscreen><verb>
          UseClause = use IDENT { UseItemClause }

          UseItemClause = [former | later] UseItem { "," UseItem }

          Item = IDENT [ "(" IDENT ")"]
</verb></tscreen>
<p>
Use-clause provides a safe way to support object oriented programming.
It has the following semantics:
<itemize>
  <item>Declarations of class/function with the identifier given after
    the keyword <em>use</em> are inlayed.
  <item>Declarations before the use-clause rewrite the corresponding
    inlayed declarations mentioned in <em>former</em>-items.
  <item>Declarations after the use-clause rewrite the corresponding
    inserted declarations mentioned in <em>later</em>-items.
  <item>The original (rewritten) and new (rewritting) declarations
    should be <em>present</em> if they are given in former- or
    later-items.
  <item>The original and new declarations should be <em>matched</em>.
    It means that they should be the same declaration type (variable,
    function, class, fiber, and external), they should have the same
    accessibility, they should have the same final attribute for
    functions, classes, and fibers.
  <item>A rewritten original declaration can be still used in the
    block if it is <em>renamed</em>.  The declaration is renamed when
    a identfier in parentheses is given.  The original declaration can
    be used with this identfier.
</itemize>
<p>
The above rules are necessary for correct <em>duck-typing</em> or
class <em>sub-typing</em>.
<p>
As a class containing an use-clause provides the same interface as the
class mentioned in the use-clause, we also call the using class an
<em>immediate sub-class</em> of the used class and the used class as
an <em>immediate super-class</em> of the using class.  A class can be
used through a chain of several use-clauses.  In this more general
case we simply use notions of <em>sub-class</em>
and <em>super-class</em>.
<p>
        The following example illustrates use-clause:
<tscreen><verb>
           class point (x, y) {
           }
           class circle (x, y, radius) {
             use point former x, y;
	     fun square () {3.14 * radius * radius;}
           }
           class ellipse (x, y, radius, width) {
             use circle former x, y, radius later square;
             fun square () {
               ...
             }
           }
</verb></tscreen>

<sect1>Singleton Object
<p>
Sometimes it is usefull to guarantee that there is only single object
(called <em>singleton object</em>) of a class.  Although it can be
achieved by creating of an object of an anonymous class (see the
section "Anonymous Functions and Classes") and assigning it to a
variable declared as <tt>val</tt>, Dino has a special declaration for
singleton object:
<tscreen><verb>
        SingletonObject = [pub | priv] obj IDENT block
</verb></tscreen>
<p>
The keywords <tt>pub</tt> and <tt>priv</tt> can be used to redefine
the default accessibility.  They make the declared object
correspondingly public and private.  Example of singleton object
declaration:
<tscreen><verb>
           priv obj coord {
             val x = 0, y = 10;
           }
</verb></tscreen> 
<p>
You can not refers to a singleton object by its name inside the
singleton object as the declaration actually occurs after the object
block.

<sect1>Expose-clause
<p>
Signleton object declarations can be accessed through designator
with <tt>.</tt> -- see <em>Designators</em>.  Sometimes it can be too
verbose.  The expose-clause can make access to public object declarations
more concise by introducing declarations on the clause place which are
actually aliases to the corresponding object declarations.
<tscreen><verb>
          ExposeClause = expose ExposeItem { "," ExposeItem }

          ExposeItem = QualIdent ["(" IDENT ")"] | QaulIdent ".*"

          QualIdent = IDENT {"." IDENT}
</verb></tscreen>
<p>
You can expose one declaration by using QualIdent with an optional
alias identfier in parentheses.  If the alias is not given, the
declaration identifier will be used for the alias.  The qualident
designates the declaration which is inside one signleton object or
inside the nested singleton objects.
<p>
You can also expose all public declarations of a signleton object by
their identifiers.  In this case, you need to add <tt>.*</tt> after
the qualident designating the corresponding object.
<p>
It is a good practise to put all package declarations in a singleton
object which in this case behaves as <em>name space</em> or modules in
other programming langiages.
<p>
  Example of use-clauses:
<tscreen><verb>
          expose sys.system (shell), math.*;
          shell ("echo sin:" @ sin (3.14) @ "cos: " @ cos (3.14));
</verb></tscreen>
<p>
In the above example, we make the function <tt>system</tt> from
singleton object <tt>sys</tt> accessible through
identifier <tt>shell</tt> and all public declarations from singleton
object <tt>math</tt> including
<tt>sin</tt> and <tt>cos</tt> accessible by their identifiers.

<sect>Expressions
<p>
Expressions are constructs denoting rules of computation of a value
from other values by the application of <em>operators</em>.
Expressions consist of <em>operands</em> and operators.  Parentheses
may be used to express specific associations of operators and
operands.

<sect1>Types and Values
<p>
All Dino values are <em>first class values</em>, i.e. they can be
assigned to a variable, can be passed as a parameter of a
function/class, and can be returned by functions.  Operators require
operands whose values are of given type and return the value of the
result type.  Most values have a representation in Dino.  When a value
representation is encountered in an expression during the expression
evaluation, the new value is generated.
<p>
There are values of <em>structured types</em>, i.e. values which are
built from other values.  The value of a structured type may be
<em>mutable</em> or <em>immutable</em>.  A value or sub-value of a
mutable value can be changed.  An immutable value can not be changed
after its generation.  You can make a mutable value immutable as a
side effect by applying the operator <tt>final</tt> (the table key is
also made immutable as a side effect of writing to the table).  In all
cases, the operator returns the operand value as the result.  If you
try to change an immutable value, the exception <tt>immutable</tt> is
generated.  You can make a new mutable value as a side effect of
applying operator <tt>new</tt>.  The operator returns a new value
equal to the operand value.
<tscreen><verb>
          Expr = final  Expr
               | new  Expr
</verb></tscreen>
<p>
Structured value types are also <em>shared value types</em>.  This
notion means that if two or more different variables (array elements
or table elements) refer to the same value and the value is changed
through one variable, the value which is referred through the other
variables is changed too.  There is no difference between the notion
"the same value" and the notion "equal values" for non-shared type
values.  For the shared type operands, equality means that the
operands have the same structure (e.g. vectors with the same length)
and the corresponding element values are the same.
<p>
        Examples:
<tscreen><verb>
          new 5
          new ['a', 'b', 'c']
          new "abc"
          new tab ["key0" : 10, "key1" : 20]
          final 5
          final ['a', 'b', 'c']
          final "abc"
          final tab["key0" : 10, "key1" : 20]
</verb></tscreen>
<p>
Dino has the following types of values:
          <itemize>
          <item>the special value <em>nil</em>.  The value is
            represented by the keyword <tt>nil</tt>.
<tscreen><verb>
                 Expr = nil
</verb></tscreen>
          <item>A <em>character</em> which represents unicode characters.
            For the representation see <tt>Character</tt> in the
            section <em>Vocabulary and Representation</em>.
<tscreen><verb>
                 Expr = CHARACTER
</verb></tscreen>
          <item>An <em>integer</em>.  For its representation see
            <tt>Integer</tt> in the section <em>Vocabulary and
            Representation</em>.  It is always stored as a 64-bit
            integer value.
<tscreen><verb>
                 Expr = INTEGER
</verb></tscreen>
          <item>A <em>long</em> integer.  For its representation see
            <tt>Long</tt> in the section <em>Vocabulary and
            Representation</em>.  Long values are signed
            multi-precision integer.  The maximal and minimimal values
            are constrained only by the overall computer memory size.
<tscreen><verb>
                 Expr = LONG
</verb></tscreen>
          <item>A <em>floating point number</em>.  For its
            representation see <tt>FloatingPointNumber</tt> in the
            section <em>Vocabulary and Representation</em>.  It is
            always stored as an IEEE double (64-bit) floating point
            value.
<tscreen><verb>
                 Expr = FLOATINGPOINTNUMBER
</verb></tscreen>
          <item>A <em>vector</em>.  This is a structured shared type
            value.  A vector value is represented by a list of values
            (or expressions) in brackets with optional repetitions of
            the vector elements preceded by <tt>:</tt>.  The
            repetition value is converted into an integer value by
            default.  If the repetition value after the conversion is
            not integer, the exception <tt>optype</tt> is
            generated. If the repetition value is negative or zero,
            the element value will be absent in the vector.  Elements
            of a vector are accessed by their indexes.  Indexes always
            starts with 0.  Vectors in Dino are <em>heterogenous</em>,
            i.e. elements of a vector may be of different types.  A
            string represents an immutable vector all of whose
            elements are characters in the string.  Elements of
            mutable vectors can be added to or removed from the vector
            (see predefined functions <em>ins, insv, and del</em>).
<tscreen><verb>
                 Expr = "["  ElistPartsList "]"
                      | STRING
                 ElistPartsList = [ Expr [":" Expr ] {"," Expr [":" Expr ] } ]
</verb></tscreen>
<p>
            Examples:
<tscreen><verb>
               "aaab"
               ['a', 'a', 'a', 'b']
               [3 : 'a', 'b']
               [3.0 : 'a', 'b']
               ["3" : 'a', 'b']
               ['a', 10, 10.0, "abcd", {}]
               []
</verb></tscreen>
          <item>A <em>table</em>.  This is a structured shared type
            value.  A table value is represented by keyword tab,
            followed by a list of key values (expression values) in
            brackets <tt>[</tt> and <tt>]</tt> with optional element
            values with a preceding <tt>:</tt>.  By default the
            element value is equal to <tt>nil</tt>.  It is not allowed
            to have elements with equal keys in a table.  If this
            constraint is violated in a table constructor, the
            exception <tt>keyvalue</tt> is generated.  Elements of
            tables are accessed by their keys.  Elements of mutable
            tables can be added to or removed from the table
            correspondingly by assigning values and with the aid of
            the function <em>del</em>.  The side effect of the table
            constructor execution is that the keys
            become <em>immutable</em>.
<tscreen><verb>
                 Expr = tab "["  ElistPartsList "]"
</verb></tscreen>
<p>
            Examples:
<tscreen><verb>
               tab ['a', 'b', 10:[10]]
               tab ['a' : nil, 'b' : nil, 10 : [10]]
               tab [[10, 'a', tab [10]] : 10, [10] : tab [20:20]]
               tab []
</verb></tscreen>
          <item>A <em>function</em>.  Its value is represented by the
            function designator.  It is important to remember that the
            function is bound to a context.
          <item>A <em>fiber-function</em>.  Its value is represented by
            the fiber-function designator.  It is important to
            remember that the fiber is bound to a context.
          <item>A <em>class</em>.  Its value is represented by the
            class designator.  It is important to remember that the
            class is bound to a context.
          <item>A <em>thread</em>.  There is no literal Dino
            representation of such values.  A thread is generated by
            calling a fiber.
          <item>An <em>object</em> (a block instance, usually a class
            block instance).  This is a structured shared type value.
            There is no literal Dino representation of such values.
            Objects are generated by the class block instantiation and
            can be accessed by value <tt>this</tt> immediately inside
            the class.
          <item>A <em>hide value</em>.  A hide value can not be
            generated by a Dino code.  They are generated by external
            functions.
          <item>A <em>hide block</em>.  This value is analogous to a
            hide value.  The differences are in that the size of a
            hide value is constrained by a C program pointer.  The
            size of a hideblock value has no such constraint.  Also a
            hideblock is of shared type.
          <item>A <em>type</em>.  The values of such types are returned
            by the special operator <tt>type (expression)</tt>.
<tscreen><verb>
                 Expr = char
                      | int
                      | long
                      | float
                      | hide
                      | hideblock
                      | vec
                      | tab
                      | fun
                      | fiber
                      | class
                      | thread
                      | obj
                      | type
</verb></tscreen>
<p>
            There are the following type values:
            <itemize>
            <item>The type of <tt>nil</tt>.  There is no value
              representing type of <tt>nil</tt>.  So use the
              construction <tt>type (nil)</tt> to get it.
            <item>The type of characters.  The value is represented by
              the Dino keyword <tt>char</tt>.
            <item>The type of integers.  The value is represented by
              the Dino keyword <tt>int</tt>.
            <item>The type of long integers.  The value is represented
              by the Dino keyword <tt>long</tt>.
            <item>The type of floating point numbers.  The value is
              represented by the Dino keyword <tt>float</tt>.
            <item>The type of vectors.  The value is represented by
              the Dino keyword <tt>vec</tt>.
            <item>The type of tables.  The value is represented by the
              Dino keyword <tt>tab</tt>.
            <item>The type of functions.  The value is represented by
              the Dino keyword <tt>fun</tt>.
            <item>The type of fiber-functions.  The value is
              represented by the Dino keyword <tt>fiber</tt>.
            <item>The type of classes.  The value is represented by
              the Dino keyword <tt>class</tt>.
            <item>The type of block instances (objects).  The value is
              represented by the Dino keyword <tt>obj</tt>.
            <item>The type of threads.  The value is represented by
              the Dino keyword <tt>thread</tt>.
            <item>The type of hide values.  The value is represented
              by the Dino keyword <tt>hide</tt>.
            <item>The type of hideblocks.  The value is represented by
              the Dino keyword <tt>hideblock</tt>.
            <item>The type of types.  The value is represented by the
              Dino keyword <tt>type</tt>.
            </itemize>
          </itemize>

<sect1>Designators
<p>
There is a special Dino construction called a <em>designator</em>.  A
designator refers for a vector or table element or for a declaration.
If the designator refers to a vector or table element or for a
variable declaration, it can stand in the left hand side of an
assignment statement.  If the designator stands in an expression, the
corresponding value is used (the vector/table element value, variable
value, function, fiber, or class).  When the designator referring to a
table element stands up in the left hand side of an assignment
statement, <em>its key value becomes immutable</em>.
<p>
A designator referring to a vector or table element has the following
syntax:
<tscreen><verb>
           Designator = (Designator | Call) "["  Expr "]"
</verb></tscreen>
<p>
The value of the construction before the brackets must be a vector or table.
Otherwise, the exception <tt>indexop</tt> is generated.
<p>
If the value of the construction before the brackets is a vector, the
value of expression in the brackets (so called <em>index</em>) is
converted to an integer value.  If this is not possible, the
exception <tt>indextype</tt> is generated.  If the index is negative
or greater than or equal to the vector length, the
exception <tt>indexvalue</tt> is generated.  The value of the
designator will be the vector element value with given index (the
indexes starts with zero).  Examples:
<tscreen><verb>
          vector [1]
          vector ["1"]
          vector [1.0]
</verb></tscreen>
<p>
If the value of the construction before the brackets is a table, the
value of expression in the brackets is called <em>key</em>.  The value
of the designator will be the table element value with the key which
is equal to given key.  If the element with the given key is absent in
the table, the exception <tt>keyvalue</tt> is generated.  Examples:
<tscreen><verb>
          table ['c']
          table [10]
          table ["1"]
          table [1.0]
</verb></tscreen>
<p>
The remaining forms of designator refer to a declaration.  See the
section <em>Declarations and Scope Rules</em> for a description on how
they work.
<tscreen><verb>
          Designator = (Designator | Call) "."  IDENT
                     | IDENT
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          value
          value.f
</verb></tscreen>
<p>
Dino also has an extended form of the designator described above.
This form is called a <em>vector slice</em>:
<tscreen><verb>
          Expr = ExtDesignator

          ExtDesignator = Designator {Slice}

          Slice = "["  [Expr] ":" [Expr] [":" Expr] "]"
</verb></tscreen>
<p>
The slice is applied to a vector, otherwise the
exception <tt>sliceform</tt> is generated.  The slice refers for a
part of vector given by the start index, the bound, and the step.  If
they are not integer, the exception <tt>slicetype</tt> is generated.
<p>
The negative bound means counting the index from the vector
end.  <tt>-1</tt> corresponds to the vector length, <tt>-2</tt>
corresponds to the vector length - 1, <tt>-3</tt> corresponds to the
vector length -2, and so on.  If the bound is more than the vector
length, the bound is assumed to be equal to the vector length.  If the
bound is omitted, it is believed to be equal <tt>-1</tt>, or in other
words, to the vector length.
<p>
If the start index is less than zero, the exception <tt>sliceform</tt>
is generated.  If the start index is omitted, it is believed to be
zero.  If the step is omitted, it is believed to be one.
<p>
The slice refers to vector elements with
indexes <tt>start</tt>, <tt>start + abs (step)</tt>, <tt>start + 2 *
abs (step)</tt>, <tt>start + 3 * abs (step)</tt> and so on while the
index is less than the bound.  If the step value is negative, the
elements are considered in the reverse order.  Examples:
<tscreen><verb>
          v[:]    // all vector elements
          v[1:]   // all vector elements except the first one
	  v[:-2]  // all vector elements except the last one
	  v[::-1] // all vector elements in reverse order
	  v[0::2] // all vector elements with even indexes
</verb></tscreen>
<p>
More one slice can be given after the designator.  In this case, next
slice is applicable to each element of the previous slice.  That means that
each element and the next slice should abide by the above rules.  The
first slice is called the first <em>dimension</em> slice, the second one is
called the second dimension slice and so on.
        Examples of multi-dimensional slices:
<tscreen><verb>
          m[:][:]     // all matrix elements
          m[:][::2]   // matrix elements with even columns
          m[::2][::]  // matrix elements with even rows
          m[::2][::]  // matrix elements with even rows and columns
</verb></tscreen>
<p>
The slices are actually not real reference values.  They can be
considered as an attribute which exists in a statement at most.  If
vector with slices is an operand of an operation which has a slice
variant, the operation is applied to each element of the vector
referenced by the slices in given order.  The result is a new vector
with the same dimension slices referencing all elements with the step
value equal to one.
<p>
When a vector with slices is an operand of an operation, the new
vector consisting of elements referenced by the slices is created.
The new vector will have the same dimension slices referencing for all
new vector elements with the step equal one.  This is done to avoid
unexpected side-effects of function-calls inside a statement with
slices.

<sect1>Calls
<p>
One form of expression is a call of a function, a fiber, or a class.
The value of the designator before the actual parameters should be a
function, a fiber, or a class.  Otherwise, the
exception <tt>callop</tt> is generated.  An instance of the block
corresponding to the body of the function, fiber, or class is created.
The actual parameter values are assigned to the corresponding formal
parameters.  If the corresponding function, fiber, or class has no
default formal parameter <tt>args</tt> or parameters with default
values (see the section <em>Declarations</em>), the number of the
actual parameters should be equal to the formal parameter number.
Otherwise, a vector whose elements are the remaining parameter values
is created and assigned to the parameter <tt>args</tt>.  If there is
no corresponding actual parameter for a formal parameter with a
default value, the default parameter value (see the
section <em>Declarations</em>) is assigned to the formal parameter.
After the parameter initialization the statements in the block are
executed.  If it is the call of a fiber, a new execution thread is
created, and the statements of the block is executed in the new
thread.  The value of call of the fiber is the corresponding thread.
It is returned before starting the execution of statements in the new
thread.
<p>
The execution of the body is finished by reaching the block end or by
execution of a return-statement.  Finishing of the fiber results in
finishing the corresponding thread.  The return-statement in a fiber
or in class should be without an expression.  The call of a class
returns the created object.  A function call returns the value of the
expression in the executed return-statement.  Otherwise, the function
return value is undefined.
<tscreen><verb>
          Expr = Call

          Call = Designator ActualParameters

          ActualParameters = "(" [ Expr { "," Expr } ] ")"
</verb></tscreen>
<p>
       Examples:
<tscreen><verb>
          f ()
          f (10, 11, ni, [])
          obj.objf ()
</verb></tscreen>

<sect1>Operators
<p>
Expressions consist of operands and operators.  The order in which
operators are executed in an expression is defined by their
<em>priority</em> and <em>associativity</em>.  That means that the
expression <tt>a op1 b op2 c</tt> when the operator
<tt>op2</tt> has higher priority than <tt>op1</tt> is analogous to
<tt>a op1 (b op2 c)</tt>.  Dino operators have analogous priorities to
the ones in the language C.  The following Dino operators are placed
in the order of their priority (the higher the line on which the
operator is placed, the higher its priority).
<tscreen><verb>
          !  #  ~  final  new
          *  /  %
          +  -
          @
          <<  >>  >>>
          <  >  <=  >=
          ==  !=  ===  !==
          &
          ^
          |
          in
          &&
          ||
          :
          ?
</verb></tscreen>
<p>
All binary operators have left associativity in Dino.  That means that
the expression <tt>a op1 b op2 c</tt> when operators <tt>op1</tt> and
<tt>op2</tt> have the same priority is analogous to <tt>(a op1 b) op2
c</tt>.  Parentheses may be used to express specific associations of
operators and operands.
<tscreen><verb>
          Expr = "(" Expr ")"
</verb></tscreen>
<p>
Most of the Dino operators require the operands to be of given types.
If an operand is not of given type, the conversion of it into a value
of the type needed may be made.  If after the possible conversions the
operands are still not of necessary types, the
exception <tt>optype</tt> is generated.  The following conversions may
be made by default:
    <itemize>
    <item>An <em>integer conversion</em>.  If the operand is a
      character, its code becomes integer.  If the operand is a long
      integer, it becomes integer.  If the long integer requires more
      64 bits, the exception <tt>opvalue</tt> is generated.  If the
      operand is a floating point number, its fractional part is
      thrown away and integral part becomes integer.  If the operand
      is a vector of characters, the corresponding string is believed
      to be the decimal representation of an integer and is converted
      into the corresponding integer value.  If the corresponding
      string is not a correct integer representation, the result is
      undefined.  If the corresponding string represents an integer
      whose representation requires more 64 bits, the
      exception <tt>erange</tt> may be generated.  In all remaining
      cases the results of conversion coincide with the operand.
    <item>An <em>arithmetic conversion</em>.  Analogous to integer
      conversion except for that the conversion of a long integer or a
      float pointing number to integer is not made and if the string
      represents a long integer (i.e. contains suffix <tt>l</tt>
      or <tt>L</tt>) or a floating point number (i.e. contains an
      exponent or fraction), the result will be the corresponding long
      integer or floating point number instead of an integer.  If the
      result of conversion to an integer from the string is out of
      range of 64-bit representation or the result of conversion to
      floating-point number from the string is out of IEEE double
      format range, the exception <tt>erange</tt> may be generated.
      <p>
      Additionally if the operand is in a non-short circuit binary
      operator (non-logical operators) and another operand is a
      floating point number after the conversion, the first operand is
      converted into a floating point number too.  In this case, if
      the first operand is a long integer out of IEEE double format
      range, the result is undefined.  Otherwise, if another operand
      is a long integer after the conversion, the first operand is
      converted into long integer too.
    <item><em>String conversion</em>.  If the operand is a character,
      the result will be a new string (immutable vector of characters)
      with one element which is the character.  If the operand is an
      integer, a long integer, or a floating point number, the result
      will be a new string of characters which is a decimal string
      representation of the number (long will have no suffix).
    </itemize>

<sect2>Logical operators
<p>
Logical operators produce the integer result 1 which means
<em>true</em> or 0 which means <em>false</em>.  Logical `or'
<tt>||</tt> and logical `and' <tt>&&</tt> are <em>short circuit</em>
operators.  That means that the second operand is evaluated depending
on the result of the first operand.  When the operands of the
operators are evaluated, the arithmetic conversion is made.
<p>
If the first operand of logical `or' is nonzero (integer, long
integer, or floating point), the result will be 1.  Otherwise, the
second operand is evaluated.  If the second operand is nonzero, the
result will be 1.  Otherwise, the result will be 0.
<p>
If the first operand of logical `and' is zero (integer, long integer,
or floating point), the result will be 0.  Otherwise, the second
operand is evaluated.  If the second operand is nonzero, the result
will be 1.  Otherwise, the result will be 0.
<p>
Logical negation <tt>!</tt> makes an implicit arithmetic conversion of
the operand.  If the operand is zero (integer, long integer or
floating point), the result will be 1.  Otherwise, the result will be
0.
<p>
Operator <tt>in</tt> checks that there is an element with the given
key (the first operand) in the given table (the second operand).  If
the element is in the table, the result will be 1.  Otherwise the
result will be 0.  If the second operand is not a table, the exception
<tt>keyop</tt> is generated.
<tscreen><verb>
          Expr = Expr "||"  Expr
               | Expr "&&"  Expr
               | Expr in  Expr
               | "!"  Expr
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          !(type (i) == int && type (a) == tab && i >= 0 && i < #a)
          k in t && t[k] == 0
          0.0  || another_try
          0  || another_try
</verb></tscreen>

<sect2>Bit operators
<p>
The following operators work on integers (implicit integer conversion
is made) and return an integer result.  Operators <tt>| ^ & ~</tt>
denote correspondingly <em>bitwise or, bitwise exclusive or, bitwise
and</em>, and <em>bitwise negation</em> of 64-bit integers.
<p>
Operators <tt><< >>> >></tt> denote correspondingly <em>logical left
bit shift, logical right bit shift</em>, and <em>arithmetic right bit
shift</em> (with sign extension) of given number (the first operand)
by given number of the bits (the second operand).  The value of the
second operand must be non-negative, otherwise the result is
undefined.
<tscreen><verb>
          Expr = Expr "|"  Expr
               | Expr "^"  Expr
               | Expr "&"  Expr 
               | Expr "<<"  Expr
               | Expr ">>"  Expr
               | Expr ">>>"  Expr
               | "~"  Expr
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          (i >> shift) & mask
          i & ~mask | (value << shift) & mask
          i >>> 2
          i << 2
</verb></tscreen>

<sect2>Comparison operators
<p>
All comparison operators return a logical value (integer 0 which means
false or integer 1 which means true).
<p>
Operators equality <tt>==</tt> and inequality <tt>!=</tt> may make
some conversion of the operands.  If one of the two operands is
string, then the string conversion is applied to the other operand
before the comparison.  Otherwise, standard arithmetic conversion is
applied to the operands if one operand is of an arithmetic type.  The
operators do not generate exceptions (but the conversions may).  The
operands are equal if they have the same type and equal values (see
the section <em>Types and Values</em>).  For instances, functions and
classes, the equality requires also the same context.
<p>
Operator identity <tt>===</tt> or unidentity <tt>!==</tt> returns 1 if
the operands have (or not) the same value or 0 otherwise.  The
operators never generate exceptions and no any conversion is made.
<p>
By default the arithmetic conversion is applied to the operands of
operators <tt>< > <= >=</tt>.  There is no exception if the operands
after the conversion are of integer, long integer, or floating point
type.  So the operands should be characters, integers, long integers,
floating point numbers, or strings representing integers, long
integers, or floating point numbers.
<tscreen><verb>
          Expr = Expr "=="  Expr  
               | Expr "!="  Expr  
               | Expr "==="  Expr  
               | Expr "!=="  Expr  
               | Expr "<"  Expr
               | Expr ">"  Expr  
               | Expr "<="  Expr
               | Expr ">="  Expr 
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          10 == 10
          10 === 10
          10 == 10l
          10 == 10.0
          10 !== 10l
          10 !== 10.0
          10 <= 'c'
          p != nil
          'c' == "c"
          10 < "20.0"
          [10, 20] == [10, 20]
          [10, 20] !== [10, 20]
</verb></tscreen>

<sect2>Arithmetic operators
<p>
The following operators return integer, long integer, or floating
point numbers.  Before the operator execution, an implicit arithmetic
conversion is made on the operands.  The binary operators <tt>+ - * /
%</tt> denote correspondingly integer, long integer, or floating point
addition, subtraction, multiplication, division, and evaluation of
remainder.  Unary operator <tt>-</tt> denotes arithmetic negation.
The unary operator <tt>+</tt> is given for symmetry and it returns
simply the operand after the conversion.  It can be used for
conversion of a string into an integer, a long integer, or floating
point number.
<tscreen><verb>
          Expr = Expr "+"  Expr
               | Expr "-"  Expr
               | Expr "*"  Expr
               | Expr "/"  Expr
               | Expr "%"  Expr
               | "+"  Expr
               | "-"  Expr
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          +"0"
          +"10l"
          +"10."
          +"1e1"
          -i
          (value + m - 1) / m * m
          index % bound 
</verb></tscreen>

<sect2>Miscellaneous operators
<p>
The Dino conditional expression is analogous to the language C one.
An implicit arithmetic conversion is made for the first expression
followed by <tt>?</tt>.  If the value of the expression is non zero
(integer, long integer, or floating point value), the second
expression with following <tt>:</tt> is evaluated and it will be the
result of the condition expression.  Otherwise, the third expression
is evaluated and it becomes the result.
<p>
The operator <tt>#</tt> can be applied to a vector or a table.  It returns
the length of the vector or the number of elements in the table.
<p>
The operator <tt>@</tt> denotes a concatenation of two vectors into a
new vector.  Before the concatenation an implicit string conversion of
the operands is made.
<p>
The remaining operators look like function calls.  Operator
<tt>type</tt> returns the expression type.  Never is an exception
generation possible during the operator evaluation.
<p>
The operator <tt>char</tt> is used to conversion of a value into a
character.  First, an implicit integer conversion is applied to the
operand.  The operand should be an integer after the conversion.
Otherwise, the exception <tt>optype</tt> will be generated.  The
integer is transformed into the character with the corresponding code.
If the code is too big to be a character or is negative, the exception
<tt>erange</tt> is generated.
<p>
The operator <tt>int</tt> is used for a conversion of a value into an
integer.  Implicit integer conversion is applied to the operand.  The
operand should be an integer after the conversion.  Otherwise, the
exception <tt>optype</tt> will be generated.  If the code is too big
to be an integer, the exception <tt>erange</tt> is generated.
<p>
The operator <tt>float</tt> is used for a conversion of a value into a
floating-point number.  The first, an implicit arithmetic conversion
is applied to the operand.  The operand should be an integer, an long
integer, or a floating-point number after the conversion.  Otherwise,
the exception <tt>optype</tt> will be generated.  An integer is
transformed the corresponding floating-point number.  The same is done
for a long integer but if the number is too big or too small to be a
floating-point number, the result is undefined.
<p>
The operator <tt>vec</tt> is used for a conversion of a value into a
vector.  First, an implicit string conversion is applied to the
operand.  The optional second expression defines the format used only
for the string conversion of a character, an integer, a long integer,
a floating point number, or a string.  The second parameter value
should be a string after an implicit string conversion.  The format
should not be given for a table.  The first operand should be a table
or a vector after the conversion.  The table is transformed into a new
vector which consists of pairs (one pair for each element in the
table).  The first element of the pair is a key of the corresponding
element, and the second one is the element itself.  The order of pairs
in the result vector is undefined.
<p>
The operator <tt>tab</tt> is used for a conversion of a value into
table.  First, a string conversion is applied to the operand.  The
operand should be a vector or a table after the conversion.  The
vector is transformed into a new table whose elements are equal to the
vector elements that have integer keys equal to the corresponding
vector indexes.
<tscreen><verb>
          Expr = Expr "?"  Expr ":" Expr
               | "#"  Expr
               | Expr "@"  Expr
               | type "(" Expr ")"
               | char "(" Expr ")"
               | int "(" Expr ")"
               | float "(" Expr ")"
               | vec "(" Expr ["," Expr] ")"
               | tab "(" Expr ")"
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          i < 10 ? i : 10
          #tab ["a", 'b']
          #["a", 'b']
          "concat this " @ "and this"
          type (type)
          type (10)
          char (12)
          vec  (10)
          vec  (10, "%x")
          vec (tab ["1":1, "2":2])
          tab ([1, 2, 3, 4])
</verb></tscreen>

<sect2>Slice Operators
<p>
There are slice variants of all operators of mentioned above except
for the short circuit operators <tt>&&</tt> and <tt>||</tt> and
the conditional expression.
<p>
For unary operators, operator execution on slices creates a new
vector structure consisting of elements referenced by the slices in
given order, creates the same dimension slices referencing all elements of the new
vector structure and execute the operator on each element of the
created slices which will be the result of the operator.  Examples:
<tscreen><verb>
          var v = [1, 2, "3"], m = [[1, 2.], [3, 4, 5]];
          ! v[:];
	  - m[1:][::2];
	  float (m[:][:]);
</verb></tscreen>
<p>
Binary operators on the slices are a bit more complicated.  If the
both operands have slices, they should have the same <em>form</em>
(dimension, number of elements in each corresponding sub-vector
referenced by the slices), otherwise the exception <tt>sliceform</tt>
is generated.  The operator execution can be considered as creating a
new vector structure consisting of elements referenced by the slices
in and creating the same dimension slices referencing all elements of
the new vector structure.  The same is done for the second slice.
Than the elements of the new vector structure created for the first
operand is changed by the result of the operator applied to this
element and the corresponding element from the slices created for the
second operand.  The slices created for the first operand will be the
result.  Examples:
<tscreen><verb>
          var v = [1, 2, 3], m = [[4, 5], [6, 7]];
          v[:] * v[:];
	  m[:][0::2] + m[:][1::2];
</verb></tscreen>
<p>
If only one operand has the slices, the operator execution can be
considered as creating a new vector structure consisting of elements
referenced by the slices and creating the same dimension slice
referencing all elements of the new vector structure.  Than the
elements of the new vector structure is changed by the result of the
operator applied to this element and another operand in given operand
order.  The created slices will be the result.  Examples:
<tscreen><verb>
          var v = [1, 2, 3], m = [[4, 5], [6, 7]];
          1 - v[:];
	  v[:] * v[:] * 2;
	  m[:][0::2] + 1;
</verb></tscreen>
<p>
Dino has additional unary operators which work only on the slices:
<tscreen><verb>
          Expr = ".+"  Expr
               | ".*"  Expr
               | ".&"  Expr
               | ".^"  Expr
               | ".|"  Expr
</verb></tscreen>
<p>
The are called <em>fold operators</em>.  If the operand has no
slices, the exception <tt>vecform</tt> is generated.  The operator execution
is to apply the corresponing non-fold operator to all elements
referenced by the slices.  Examples:
<tscreen><verb>
          var v = [1, 2, 3], m = [[4, 5], [6, 7]];
          .+ v[:];
	  .* v[:];
	  .& m[:][:];
</verb></tscreen>

<sect1>Current block instance
<p>
The instance of the block immediately surrounding the current program
point can be accessed by using the keyword <tt>this</tt>.
<tscreen><verb>
          Expr = this
</verb></tscreen>
<p>
        Example of usage of <tt>this</tt>:
<tscreen><verb>
          class c (x) { putln (this.x, "===", x); }
          fun f (pub x) { return this; }
</verb></tscreen>

<sect1>Anonymous Functions and Classes
<p>
Instead of declaring a function/class and using its identifier once in
an expression, an anonymous function/class can be used.  The anonymous
functions/classes are regular expressions.  They have the same syntax
as the corresponding declarations.  The only difference is an absence
of the function/class identifier:
<tscreen><verb>
          Expr = AnonHeader FormalParameters Block

          AnonHeader = [Qualifiers] FuncFiberClass
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          fun (a) {a > 0;}
          class (x, y) {}
          fiber (n) {for (var i = 0; i < n; i++) putln (i);}
</verb></tscreen>
<p>
        An example of anonymous function usage:
<tscreen><verb>
          fold (fun (a, b) {a * b;}, v, 1);
</verb></tscreen>

<sect1>Try-operator
<p>
Dino has two ways to process the exceptions.  One way is described in
the section <em>Try-block</em>.  Another way is to use a try-operator.
The try-operator has the following syntax:
<p>
<tscreen><verb>
          Expr = try "(" ExecutiveStmt [ "," ExceptClassList] ")"
</verb></tscreen>
<p>
The operator returns non-zero if no exceptions occurs in the statement
given as the first operand.  The operator returns zero if an exception
occurs and its class is a sub-class (see the function <tt>isa</tt>) of
one exception class given by the subsequent operands.  If there is no
matched operand class, the exception is propagated further (see
the <em>try-block</em> description for more details).  If the optional
subsequent operands are omitted, any occured exception in the
statement results in the zero result value.
<p>
Here is the example of usage of the try-operator:
<tscreen><verb>
            var ln;
            for (; try (ln = getln (), eof);) putln (ln);
</verb></tscreen>

<sect>Patterns
<p>
Patterns have a form of expressions.  They are used to match an
expression and decompose it.  Pattern can have form a vector value, a
table value, a function call, an identifier, or a special
<em>wildcard</em> symbol <tt>"_"</tt>.  Anything else in the pattern
is treated as an expression.  The simplest way is to treat a pattern,
e.g. identfier, as an expression is to put it into paretheses.
<tscreen><verb>
           Pattern = Expr
           Expr = "_" | "..."
</verb></tscreen>
<p>
A separate wildcard matches any value.  Identifier also matches any
value but additionally the matched value is assigned to
the <em>pattern variable</em> denoted by the identifier.  An
expression in a pattern matches any value equal to the the expression
value.
<p>
A <em>vector pattern</em> matches a <em>vector value</em>.  All vector
pattern elements should match all subsequent elements of the vector
value.  If a vector pattern element has a form of another pattern than
it matches the corresponding vector value element iff the element
pattern matches the corresponding element value of the vector value.
<p>
A vector pattern element can also have a form <tt>expr ":"
pattern</tt>.  The value of the expression before <tt>":"</tt> is
converted into an integer value by default.  If the value after the
conversion is not integer, the exception <tt>optype</tt> is generated.
The value can be zero or negative.  In this case matching the pattern
element is always successful and this matching does not correspond any
element of the matched vector value.  Othewise, the pattern
after <tt>":"</tt> should match the corresponding elements in the vector
value.  The exact number of the elements is defined by the expression
value before <tt>":"</tt>.  The matched element values should be equal
unless the pattern after <tt>":"</tt> is a wildcard <tt>"_"</tt>.
<p>
The last element of the vector pattern can be <tt>"..."</tt>.  It
matches the rest elements in the matched vector value.  The following
are examples of vector patterns (a, b, and c are identifies of pattern
variables):
<tscreen><verb>
           [a, b]   // a and b are pattern variables
           [(a), b] // value of earlier declared a is used
	   [a, ...]
	   [2, [a, b], 3 : c, 4 : _]
</verb></tscreen>
<p>
A <em>table pattern</em> matches a <em>table value</em>.  All table
pattern elements should match all elements of the table value.  If a
table pattern element has a form <tt>expr</tt>, then the table value
should have an element with a key given by the expression.
<p>
A table pattern element can also have a form <tt>expr ":"
pattern</tt>.  In this case the table value also should have an
element with a key given by the expression.  Additionally the element
value with given key should match the pattern after <tt>":"</tt>.
<p>
The last element of the table pattern can be <tt>"..."</tt>.  It
matches the rest elements in the matched table value.  The following
are examples of table patterns (a, b, and c are identifies of the
pattern variables):
<tscreen><verb>
           tab ["k1", "k2"]
	   tab ["k1" : _, ...]
	   tab ["k" @ 1, [a, b], "k2" : c, ...]
</verb></tscreen>
<p>
An object pattern has a form of function/class call.  An <em>object
pattern</em> matches a class/function instance.  The function/class
should be a subtype of class/function given by the value of the
expression in the pattern before <tt>"("</tt>.  The parameters in the
pattern should match all corresponding instance parameter values.  The
number of the values is taken from function/class given by the
expression in the pattern before <tt>"("</tt>, not from function class
of the instance.  Remember that the arguments corresponding
to <tt>"..."</tt> in function/class parameter definitions become one
array value.
<p>
The last parameter of the object pattern can be <tt>"..."</tt>.  It
matches the rest arguments of the corresponding object.  The following
are examples of object patterns (<tt>a, b</tt>, and <tt>c</tt> are
identifies of the pattern variables):
<tscreen><verb>
	   leaf (10)
           node (_, a)
	   node (node (a, b), leaf (c))
</verb></tscreen>
<p>
Symbols <tt>"_"</tt> and <tt>"..."</tt> can be used only in patterns - they
can not be used in expressions.

<sect>Executive statements
<p>
Statements denote actions.  There are <em>simple</em> and
<em>compound</em> statements.  Simple statements do not consist of any
parts that are statements themselves.  They are the assignment,
procedure call, return, break, continue, throw, and the wait
statements.  Analogous to the language C the last symbol of a Dino
simple statement is semicolon <tt>;</tt>.  Compound statements
consists of parts that are statements themselves.  They are used to
express sequencing, exception handling, conditional, and repetitive
execution.

<sect1>Empty statement
<p>
There is an empty statement in Dino.  It denotes no action.  The
empty statement is included in Dino for convenience.
<tscreen><verb>
          ExecutiveStmt = ";"
</verb></tscreen>
<p>
        Example: Usage of an empty statement in a for-statement:
<tscreen><verb>
          for (i = 0; a[i] == 0; i++)
            ;
</verb></tscreen>

<sect1>Block-statement
<p>
A block-statement is simply a block and can used to group statements
into one statement and/or describe local declarations.  For details on
how the block is executed see the section <em>Declaration and Scope
Rules</em>.
<tscreen><verb>
          ExecutiveStmt = BlockStmt

          BlockStmt = Block
</verb></tscreen>
<p>
        Example: Usage of a block-statement in a for-statement:
<tscreen><verb>
          sum = 0;
          for (i = 0; i < #a; i++)
            {
	      var value = a[i];
              if (value > 0)
                sum += value;
            }
</verb></tscreen>

<sect1>Expression-statement
<p>
Dino has an expression statement.  Although it seems that the
expression value is not used, the expression evaluation can results in
side-effects, e.g. through calling a function/class.  An
expression-statement as textually the last statement in the function
block means a return of the expression value as the function call
result.  In REPL (see Appendix B. Implementation), execution of an
expression-statement results in printing the expression value.
<tscreen><verb>
          ExecutiveStmt = Expr ";"
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          putln ("percent=" @ percent @ "%");
          newfiber ();
	  5 + 10;
</verb></tscreen>
    
<sect1>Assignment statements
<p>
Assignment-statements are used to change variable values or element
values of a structured value which are referred through a designator
(see sub-section <em>Designator</em> in section <em>Expressions</em>.
The designator can not denote a final variable (see the section
<em>Variable Declaration</em>).  You can not change the element value
of an immutable value (see the section <em>Types and Values</em>).  In
this case the exception <tt>immutable</tt> is generated.  Assignment
to a table element has a side effect, the element key becomes
immutable.
<p>
A simple assignment statement looks like <tt>Designator = Expr;</tt>.
That means that the expression value is assigned to a variable or
element of a structured type value denoted by the designator.  For the
convenience of C programmers there are also the Dino assignments
<tt>Designator op= Expr;</tt>, <tt>Designator++;</tt>,
<tt>++Designator;</tt>, <tt>Designator--;</tt>, and
<tt>--Designator;</tt>.  They are analogous correspondingly to
<tt>Designator = Designator op Expr;</tt>, <tt>Designator = Designator
+ 1;</tt>, and <tt>Designator = Designator - 1;</tt>.  The only
difference is in the fact that the designator is evaluated only once,
not twice as in the analogous form.  It is important to know if you
have <em>side effects</em> in the statement.
<tscreen><verb>
          ExecutiveStmt = Designator Assign Expr ";"
                        | Designator ("++" | "--")  ";"
                        | ("++" | "--")  Designator ";"
          Assign = "="
                 | "*="
                 | "/="
                 | "%="
                 | "+="
                 | "-="
                 | "@="
                 | "<<="
                 | ">>="
                 | ">>>="
                 | "&="
                 | "^="
                 | "|="
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          v = [10, 20];
          i = 1;
          i++;
          --i;
          i *= 20;
</verb></tscreen>
<p>
If the designator is a slice and the expression value is a slice too,
they both should have the same <em>form</em>, otherwise the
exception <tt>sliceform</tt> is generated.  In this case each element
referenced by the designator slice gets value of the corresponding
element referenced by the expression slice.  If the designator is a
slice but the expression value is not, each element referenced by the
designator slice gets the expression value.  Examples of the slice
assignment:
<tscreen><verb>
          v = [1, 2, 3, 4];
          v[:] += 1;
          v[::-1] = v[:]; // reverse v
</verb></tscreen>

<sect1>If-statement
<p>
The Dino if-statement is analogous to the C language one.  First, the
expression after <tt>if</tt> is evaluated and an arithmetic conversion
is done to it.  The value should be an integer, a long integer, or a
floating-point number, otherwise the exception <tt>optype</tt> is
generated.  If the value is nonzero the first statement is executed,
otherwise the statement after <tt>else</tt> is executed (if any).  The
problem with <em>dangling else</em> is resolved analogous to the
language C -- <tt>else</tt> part is associated with the
closest <tt>if</tt>.
<tscreen><verb>
          ExecutiveStmt = if  "(" Expr ")" Stmt [ else Stmt ]
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          if (i < 0) i = 0;
          if (i < j) return -1; else if (i > 0) return 1; else return 0;
</verb></tscreen>

<sect1>For-statement
<p>
The Dino for-statement is analogous to the C language one.  The
statement is executed in the following way.
     <enum>
     <item>Execution of the first statement in the parentheses is
        done.
     <item>The expression (<em>for-guard</em>) is evaluated and an
        implicit arithmetic conversion is applied to its value.  The
        result value should be an integer, a long integer, or a
        floating point number.  If this is not true, the
        exception <tt>optype</tt> is generated.
     <item>If the value of for-guard is nonzero, the body of the loop
        (the last statement) is executed.  Otherwise, the
        for-statement execution finishes.
     <item>When the body has been executed, the second statement in
        the parentheses is executed and steps 2,3,4 (one iteration)
        are repeated again.
     </enum>
If the second statement is a simple statement, the statement semicolon
can be omitted.  The for-statement also can be finished by an
execution of the statement <tt>break</tt> in the body.  The rest body
execution can be skipped by an execution of the
statement <tt>continue</tt>.  In this case, the for-statement
execution continues with the step 4.
<tscreen><verb>
          ExecutiveStmt = for  "(" Stmt ForGuardExpr ";"  Stmt ")" Stmt

          ForGuardExpr = [Expr]
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          for (i = 0; i < 10; i++;) sum += v [i];
          for (i = 0; i < 10; i++) sum += v [i];
          for ({sum = 0; i = 0;} i < 10; i++) sum += v [i];
</verb></tscreen>

<sect1>Foreach-statement
<p>
This statement is used to execution of the foreach-statement body (the
statement) for all keys of table which is a value of the expression.
The expression value should be a table.  If this is not true, the
exception <tt>keyop</tt> is generated.  The current key value on each
iteration is assigned to the designator.  The order in which the key
values are assigned on each iteration is undefined.  One iteration can
be finished with the aid of the statement <tt>continue</tt> and a
foreach-statement can be finished by execution of statement
<tt>break</tt>.
<tscreen><verb>
          ExecutiveStmt = for  "(" Designator in Expr ")" Stmt
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          putln ("The table is");
          for (k in t) {
            put ("key=");
            print (k);
            put (", element=");
            println (t{k});
          }
</verb></tscreen>

<sect1>Match-statements
<p>
There are two kinds of the match-statement.  One is used for pattern
matching and another one is used for regular expression matching.
They have practically the same syntax.  They differ in usage of
different start keywords <tt>pmatch</tt> and <tt>rmatch</tt>
correspondingly for the pattern and regular expression matching.
<p>
The pattern or regular expression match statement is used to try
matching the match-expression value (it is evaluated only once) and
the patterns or regular expressions in given order and execute the
statements corresponding to the first matched case.
<p>
Each case forms an own scope.  The pattern variables in the pattern
match statement are declared in the corresponding case scope.  Each
case scope of the regular expression match statement contains an
implicitly declared variable <tt>m</tt>.  If a regular expression in
the case successfully matches the match-expression, value of the
corresponding variable <tt>m</tt> is a vector of indexes describing
matched substrings (see the result of function <tt>match</tt> for
details).
<p>
In the case of regular expression matching the string conversion is
implicitly applied to the match-expression and the case expression
values.  The exception <tt>optype</tt> occurs if the conversion
results are not strings.  A case with wildcard <tt>_</tt> also can
occur in a rmatch-statement.  Matching with such case is always
successful but the value of the variable <tt>m</tt> is undefined in
this case.
<p>
Execution of a continue-statement in the case-statements results in
continuing the process of matching the match-expression value with the
subsequent patterns or regular expressions.  Execution of a
break-statement in the case-statements results in finishing the
match-statement execution.  There is an implicit break at the end of
each case statement list.
<p>
If an optional case condition is given, then it is evaluated after the
succesfull matching with the corresponding pattern and an arithmetic
conversion is done to it.  The value should be an integer, a long
integer, or a floating-point number, otherwise the
exception <tt>optype</tt> is generated.  If the value is nonzero the
all match is considered successfull, otherwise the subsequent case
patterns are tried.
<tscreen><verb>
          ExecutiveStmt = (pmatch | rmatch) "(" Expr ")" "{" CaseList "}"
          CaseList = { case Pattern [CaseCond] ":" StmtList }
	  CaseCond = if Expr
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          class c (a1, a2) {}
          pmatch (c (2, 3)) {
            case c (i, j): putln (i, j);
            case _: putln ("default");
          }
          pmatch (c (2, 3)) {
            case c (i, j) if i == j: putln ("eq=", i, j);
            case c (i, j) if i != j: putln ("neq=", i, j);
            case _: putln ("default");
          }

          rmatch (str) {
	    case "[a-zA-Z]+": putln ("word starting at ", m[0]);
	    case "[0-9]+": putln ("number starting at ", m[0]);
            case _: putln ("anything else, m is undefined");
          }
</verb></tscreen>

<sect1>Break- and continue-statement
<p>
The statements <tt>break</tt> and <tt>continue</tt> are used
correspondingly to finish execution of the closest-containing for-,
foreach-, or match-statement covering the statement and to finish one
iteration of the body of the for- or foreach-statement and to continue
trying subsequent cases for the match-statement.  These statement can
be used only inside a for-, foreach-, or match-statement.
<tscreen><verb>
          ExecutiveStmt = break ";"
                        | continue ";"
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          for (i = 0; i < 10; i++) {
             if (ind [i] < 0)
               continue;
             val = v [ind[i]];
          }
          for (i in t)
            if (t{i} == elval)
              break;
          match (tree) {
	    case leaf (n):
              putln ("leaf");
              if (n == 10) continue;
            case node (n1, n2):
              if (n1 != n2) break;
              putln ("special node");
	    case _: putln ("might be a leaf with 10");		   
          }
</verb></tscreen>

<sect1>Return-statement
<p>
A return-statement is used to finish execution of a function, a fiber,
or class block.  The statement corresponds to the closest-containing
function, fiber, or class covering the statement, so the
return-statement can be placed only in a function, a fiber, or a
class.  The expression in a return-statement can be given only for
functions.  In this case, the expression value will be the value of
the function call (instead of undefined value).
<tscreen><verb>
          ExecutiveStmt = return  [ Expr ] ";"
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          return;
          return [10, 2:0]
</verb></tscreen>

<sect1>Throw-statement
<p>
This statement generates an exception which is given by value of the
expression.  The expression should evaluate to an object of
predeclared class <tt>except</tt> or of its sub-class.  If this is not
true, the exception <tt>optype</tt> is generated.  How exceptions are
processed is described in the following section.
<tscreen><verb>
          ExecutiveStmt = throw  Expr ";"
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          class myexcept (msg) {use error former msg;}
          throw myexcept ("this is an user defined exception");
</verb></tscreen>

<sect1>Try-block
<p>
Exceptions can be generated by the Dino interpreter when some
conditions are not satisfied, by predeclared Dino functions, by other
OS processes, by user interruptions, or by the user with the aid of a
throw-statement.  Actually, the exceptions are represented by an
object of the predeclared class <tt>except</tt> or by an object of its
sub-class.  All predeclared exceptions are described in the
section <em>Predeclared Identifiers</em>.  To detect and process
exceptions, a try-block can be used.
<p>
When an exception is generated, the closest-containing try-block which
is covering the statement generating the exception or currently being
executed (when this is is generated by an OS process or by an user
interruption) is searched for.  Then, expressions in the catch list
elements are processed.  The expression value in the catch list
element being currently processed should be the predeclared class
<tt>except</tt> or its sub-class.  If the expression being processed
is a class and the exception is an object of the class or an object of
a sub-class of the class, the block corresponding to the given catch
list element is executed.  If there is no such catch expression, the
closest-containing try-block covering the current try-block is
searched for and processing the exception is repeated.  If there are
no more try-blocks, the program finishes with a diagnostic message
which is dependent on the generated exception.
<p>
Blocks corresponding to catch list elements have a predeclared
variable <tt>e</tt>.  When the block execution starts, the variable
contains the object representing the exception.
<tscreen><verb>
          ExecutiveStmt = TryBlockStmt

          TryBlockStmt = try Block { Catch }
       	
          Catch = catch  "(" ExceptClassList ")" Block

          ExceptClassList = Expr { "," Expr }
</verb></tscreen>
<p>
        Examples:
<tscreen><verb>
          try {
            var ln;
            for (;;)
              ln = getln ();
          } catch (eof) {
          }
          try {
            var v = [];
            v {1} = 0;
          } catch (except) {
            put ("catching and propagating exception"); println (class (e));
            throw e;
          }
</verb></tscreen>

<sect1>Wait-statement
<p>
This statement is used for the synchronization of different threads in
a Dino program.  The expression can not contain a function, class, or
a fiber call.  The thread in which the statement has been executed
waits until the expression value becomes nonzero.  The expression
value (after an implicit arithmetic conversion) should be an integer,
a long integer, or a floating point number.  Otherwise the
exception <tt>optype</tt> is generated.  When the expression value
becomes nonzero, the statement after the expression (it is called a
sync-statement) is executed without interruption by other threads.  It
is used as a critical region for the thread synchronization.  In a
critical region an execution of wait-statement is prohibited (it
results in generation of the exception <tt>syncwait</tt>).  Also fiber
calls inside a critical region result in generation of the
exception <tt>syncthreadcall</tt>.
<tscreen><verb>
          ExecutiveStmt = wait  "(" Expr ")" Stmt
</verb></tscreen>
<p>
        An example:
<tscreen><verb>
          wait (!empty);
</verb></tscreen>

<sect1>C code
<p>
All C code between pairs of brackets <tt>%{</tt> and <tt>%}</tt> in
one Dino file is <em>concatenated</em> in the same order as they occur
in the file.  The result code with some pre-appended C code providing
an interface to the Dino interpreter internal data representation is
compiled when the execution <em>the first time</em> achieves the
location of the first
<tt>%{</tt> in the file.  The result shared object is loaded and
external variables and functions are searched lately in the same order
as the shared objects are loaded.
<tscreen><verb>
          ExecutiveStmt = C_CODE
</verb></tscreen>
<p>
If an error during the compilation or loading the shared object file
occurs, the exception <tt>compile</tt> is generated.
<p>
        An example:
<tscreen><verb>
          %{
            #include <math.h>
            val_t isnan_p (int npars, val_t *vals) {
              val_t val;
              ER_node_t res = (ER_node_t) & val;

	      ER_SET_MODE (res, ER_NM_int);
              ER_set_i (res, 0);
	      if (npars == 1
                  && ER_NODE_MODE ((ER_node_t) vals) == ER_NM_float
                  && isnan (ER_f ((ER_node_t) vals)))
                ER_set_i (res, 1);
              return val;
            }
          %}

          extern isnan_p ();
          putln (isnan_p (10.0));
</verb></tscreen>

<sect>Program
<p>
A Dino program is simply a sequence of statements.  There is a special
declaration useful for writing programs consisting of several files or
for making Dino packages.  This is an include-declaration.  Before
execution of any statements all include-declarations are replaced by
files whose base names are given by the strings.  It is made
recursively, i.e. the files themselves can contain other
include-declarations.  There should be no infinite recursion in this.
If <tt>+</tt> is present in the include-declaration, the file is
inserted in any case.  Without <tt>+</tt> the file is inserted only if
it has been yet not inserted into the block of the declaration.
<tscreen><verb>
          Program = StmtList

          IncludeDeclaration = include ["+"] STRING ";"
</verb></tscreen>
<p>
        Examples:
<p>
        The following program outputs the first 24 Fibonachi numbers:
<tscreen><verb>
          // Recursive function to compute Fibonacci numbers
          fun fibonacci (n) {
               if (n <= 1) return 1;
               return (fibonacci(n-1) + fibonacci(n-2));
          }
          
          var i, fibnum;
          
          fibnum = 0;
          for (i = 0; i <= 24; i++) {
              fibnum = fibonacci(i);
              putln (i @ " " @ fibnum); 
          }
</verb></tscreen>
<p>
        The following program outputs the number of prime numbers less
        than 8190:
<tscreen><verb>
          var i, prime, k, count, flags;
          var final SieveSize = 8190;

          flags = [SieveSize + 1 : 0];
          count = 0;
          for (i = 0; i <= SieveSize; i++)
            flags[i] = 1;
          for (i = 0; i <= SieveSize; i++)
            if (flags[i]) {
                prime = i + i + 3;
                k = i + prime;
                for (;1;) {
          	      if (k > SieveSize)
                        break;
                    flags[k] = 0;
                    k += prime;
                }
                count++;
            }
          println (count);
</verb></tscreen>
<p>
        The following program outputs the number of occurrences of
        different numbers and identifiers in stdin:
<tscreen><verb>
          var i, key, voc = tab[];
          for (;;)
            try {
              var ln, a;

              ln = getln ();
              if (ln == "")
                continue;
              a = split (ln, "[^[:alnum:]]");
              for (i = 0; i < #a; i++)
                voc {a[i]} = (a[i] in voc ? voc [a[i]] + 1 : 1);
            } catch (eof) {
              break;
            }
          fun comp (el1, el2) {
            return cmpv (tolower (el1), tolower (el2));
          }
          key = sort (keys (voc), comp);
          for (i = 0; i < #key; i++)
            putln (key[i], " : ", voc[key[i]]);
</verb></tscreen>
<p>
        The following program uses the Dino package <tt>socket</tt>:
<tscreen><verb>
          include "socket";
          var s, cl, str, l = 0;
          s = sockets.stream_server (10003, 4);
          cl = s.accept ();
          try {
            for (;;) {
               str = cl.read (64); l += #str; cl.write (str);
            }
          } catch (sockets.socket_eof_except) {
            putln ("i got ", l, " bytes");
          }
</verb></tscreen>

<sect>Predeclared identifiers
<p>
Dino has quite a lot of predeclared identifiers.  They are combined in
in a few signleton objects also called spaces -- see the
section <em>Declarations and Scope Rules</em>.  Most of predeclared
identifiers refer for functions. The predeclared functions expect a
given number of actual parameters (may be a variable number of
parameters).  If the actual parameter number is an unexpected one, the
exception <tt>parnumber</tt> is generated.  The predeclared functions
expect that the actual parameters (may be after implicit conversions)
are of the required type.  If this is not true, the
exception <tt>partype</tt> is generated.  To show how many parameters
the function requires, we will write the names of the parameters and
use the brackets <tt>[</tt> and <tt>]</tt> for the optional parameters
in the description of the functions.
<p>
        Examples:  The following description
<tscreen><verb>
          strtime ([format [, time]])
</verb></tscreen>
<p>
        describes that the function can accept zero, one, or two
        parameters.  If only one parameter is given, then this is
        parameter <tt>format</tt>.
<p>
If nothing is said about the returned result, the function return
value is undefined.
<p>
The predeclared identifiers are describe below according to their
spaces.

<sect1>Space <tt>lang</tt>
<p>
The space contains fundamental Dino declarations.  All declarations of
the space are always exposed.

<sect2>Predeclared variables
<p>
Space <tt>lang</tt> has some predeclared variables which contain
useful information or can be used to control the behaviour of the Dino
interpreter.

<sect3>Arguments and environment
<p>
To access arguments to the program and the environment, the following
variables can be used:
     <itemize>
     <item><tt>argv</tt>.  The variable value is an immutable vector
       whose elements are strings (immutable vectors of characters)
       representing the arguments to the program (see the
       appendix <em>Implementation</em>).
     <item><tt>env</tt>.  The variable value is an immutable table
       whose elements are strings (immutable vectors of characters)
       representing values of the environment variables whose names
       are the keys of the table.
     </itemize>

<sect3>Versions
<p>
As Dino is a live programming language, it and its interpreter are in
the process of development.  To access the Dino interpreter's version
number and the language version, the final variables
<tt>version</tt> and <tt>lang_version</tt> can be used
correspondingly.  The variable values are the versions as floating
point numbers.  For example, if the current Dino interpreter version
is 0.98 and the Dino language version is 0.5, the variable values will
be 0.98 and 0.5.

<sect3>Threads
<p>
To access some information about threads in Dino program, the
following variables can be used.
     <itemize>
     <item><tt>main_thread</tt>.  The variable value is the main
       thread.  When the program starts, there is only one thread
       which is called <em>the main thread</em>.
     <item><tt>curr_thread</tt>.  The variable value is the thread in
       which you reference for the variable.
     </itemize>
<p>
All these variables are final, so you can not change their values.

<sect2>Exception classes
<p>
All predeclared classes in the space <tt>lang</tt> describe exceptions
which may be generated in a Dino program.  All Dino exceptions are
represented by objects of the predeclared class <tt>except</tt> or of
a sub-class of the class <tt>except</tt>.  The class <tt>except</tt>
has no parameters.  There is only one predeclared sub-class
<tt>error</tt> of the class <tt>except</tt>.  All classes
corresponding to user-defined exceptions are suggested to be declared
as a sub-class of <tt>except</tt>.  All other exceptions
(e.g. generated by the Dino interpreter itself or by predeclared
functions) are objects of the class <tt>error</tt> or predeclared
classes which are sub-classes of <tt>error</tt>.  The class
<tt>error</tt> and all its sub-classes has one parameter
<tt>msg</tt> which contains a readable message about the exception.
The following classes are declared in the space <tt>lang</tt> as a
sub-class of <tt>error</tt>:
     <itemize>
     <item><tt>invop</tt>.  The following sub-classes of this class
       describe exceptions when operands of an operation have an
       incorrect type or value.
         <itemize>
         <item><tt>optype</tt>.  This class describes that an operand
           of an operation is not of the required type (possibly after
           implicit conversions).
         <item><tt>opvalue</tt>.  This class is reserved for the error
           of that an operand of an operation has invalid value.
         </itemize>
     <item><tt>invindex</tt>.  Sub-classes of this class describe
       exceptions in referring for a vector element.
         <itemize>
         <item><tt>indextype</tt>.  This class describes that the
           index is not of integer type (possibly after implicit
           integer conversion).
         <item><tt>indexvalue</tt>.  This class describes that the
           index is negative or equal to or more than the vector
           length.
         <item><tt>indexop</tt>.  This class describes that the first
           operand in referring to a vector element is not a vector.
         </itemize>
     <item><tt>invslice</tt>.  Sub-classes of this class describe
       exceptions in referring for a vector slice.
         <itemize>
         <item><tt>slicetype</tt>.  This class describes that the
           start index, bound, or step is not of integer type
           (possibly after implicit integer conversion).
         <item><tt>sliceform</tt>.  This class describes that the
           slice has a wrong form, e.g. the start index is negative,
           the step is zero or the slice is applied not to a vector.
         </itemize>
     <item><tt>invector</tt>.  Sub-classes inside this class mostly
       describe exceptions in slice operations.
         <itemize>
         <item><tt>veclen</tt>.  This class describes that operands in
           a slice operator have different length.
         <item><tt>vecform</tt>.  This class describes that operands
           in a slice operator have different dimensions.
         <item><tt>matrixform</tt>.  This class describes error when a
           matrix transposition (function <tt>transpose</tt>) is
           applied to a vector of different length vectors.
         </itemize>
     <item><tt>invkey</tt>.  Sub-classes inside this class describe
       exceptions in referring to a table element.
         <itemize>
         <item><tt>keyvalue</tt>.  This class describes that there is
           no such element in the table with the given key when we
           need the value of the element.  The exception does not
           occur when a table element reference stands in the left
           hand side of an assignment-statement.
         <item><tt>keyop</tt>.  This class describes that the first
           operand in referring to a table element is not a table.
         </itemize>
     <item><tt>invcall</tt>.  Sub-classes of this class describe
       exceptions in calling functions (mainly predeclared ones).
         <itemize>
         <item><tt>abstrcall</tt>.  This class describes that we try
           to call a declared but not defined function.
         <item><tt>callop</tt>.  This class describes that we try to
           call something which is not a function, class, or fiber.
           The exception is also generated when we try to create a
           class <tt>file</tt> instance by calling the class.
         <item><tt>partype</tt>.  This class describes that a
           parameter value of a predeclared function is not of
           the required type.
         <item><tt>parvalue</tt>.  This class describes that a
           parameter value of a predeclared function is not one of
           the permitted values (see functions <tt>set_encoding</tt>,
           <tt>set_file_encoding</tt>).
         <item><tt>parnumber</tt>.  This class describes that the
           number of actual parameters is not valid when we call a
           predeclared function.
	 <item><tt>syncthreadcall</tt>.  This class describes that a
           fiber call occurs inside a critical region -- see the
           wait-statement.
         <item><tt>invresult</tt>.  This class describes that the
           result value of a function call is not of the required
           type, e.g. the comparison function used in a call of the
           function <tt>sort</tt> returns a non integer value.
         <item><tt>internal</tt>.  This class describes all other
           (nonspecified) exceptions in calling predeclared functions.
         </itemize>
     <item><tt>invaccess</tt>.  Sub-classes of this class describe
       exceptions in accessing or changing values.
         <itemize>
         <item><tt>accessop</tt>.  This class describes that a given
           class declaration can not be found or is private when
           accessing to it through the corresponding object.
         <item><tt>accessvalue</tt>.  This class describes that we try
           to access to a declared but not defined through the
           corresponding object -- see <em>abstract classes</em>.
         <item><tt>immutable</tt>.  This class describes that we try
           to change an immutable value.
         <item><tt>patternmatch</tt>.  This class describes that the
           pattern in a variable declaration does not match the
           assigned value.
         </itemize>
     <item><tt>deadlock</tt>.  This class describes that a deadlock is
       recognized in a multi-threaded program.
     <item><tt>syncwait</tt>.  This class describes that we try to
       execute a wait-stmt inside a critical region.
     </itemize>

<sect2>Functions of the space <tt>lang</tt>
<p>
The following functions are declared in the space <tt>lang</tt>:
     <itemize>
     <item><tt>tolower (str)</tt>.  The function expects that the
       parameter <tt>str</tt> (after an implicit string conversion) is
       a string.  The function returns a new string <tt>str</tt> in
       which upper case letters are changed to the corresponding lower
       case letters.
     <item><tt>toupper (str)</tt>.  The function expects that the
       parameter <tt>str</tt> (after an implicit string conversion) is
       a string.  The function returns a new string <tt>str</tt> in
       which lower case letters are changed to the corresponding upper
       case letters.
     <item><tt>translit (str, what, subst)</tt>.  The function
       transliterates charactes in a string.  The function expects
       that the parameters <tt>str</tt> (after an implicit string
       conversion), <tt>what</tt>, and <tt>subst</tt> are strings.
       The function returns the new string <tt>str</tt> in which its
       characters which are present in <tt>what</tt> are changed to
       the corresponding characters in <tt>subst</tt>.  The last two
       strings should have the same length.  The second string may
       contain more than one occurence of a character.  In this case
       the last correspondence is taken.
     <item><tt>eltype (vect)</tt>.  The function expects that the
       parameter value is a vector.  The function returns <tt>nil</tt>
       if the vector is heterogenous, otherwise the function returns
       the type of the vector elements (type of <tt>nil</tt> if the
       vector is empty).
     <item><tt>keys (tab)</tt>.  The function expects that the
       parameter value is a table.  The function returns a new mutable
       vector containing all the keys in the table.  The order of keys
       in the vector is undefined.
     <item><tt>closure (par)</tt>.  The function accepts any parameter
       value.  If the parameter value is an object or a block instance
       of a function, the function <tt>closure</tt> returns the
       corresponding class or function which contains also its
       context.  That is why it is called a closure.  In all other
       cases, the function returns <tt>nil</tt>.
     <item><tt>context (par)</tt>. The function returns the context
       (see the section <em>Declarations and Scope Rules</em>)
       represented by a block instance or an object for the given
       parameter value which should be a function, a class, a fiber, a
       block instance, or an object.
     <item><tt>inside (par1, par2, flag = 0)</tt>.  The goal for the
       function usage is to check that something is declared inside
       something other.
       <p>
       If the third parameter value after an implicit integer
       conversion is given and nonzero, it is checked with taking
       contexts into account.  The second parameter value should be a
       function, class, object, or a block instance.  In the last two
       cases of the second parameter value, the corresponding class,
       function, or block is used.  The first parameter value should
       be a function, a class, an object, or a block instance.  In the
       last two cases, they define the corresponding function, class, or
       block.
       <p>
       If the function, class, or block defined by the first parameter
       is declared inside the function, class, or block given by the
       second parameter, the function <tt>inside</tt> returns 1.  The
       function <tt>inside</tt> also returns 1 if the function, class,
       or block defined by the first parameter is the same as the
       function, class, or block given by the second parameter.
       Otherwise the function <tt>inside</tt> returns 0.  The
       following example illustrates the difference between checking
       with taking contexts into account and without it.
<tscreen><verb>
          class c () {
            class subc () {
            }
          }
          inside (c ().subc (), c ().subc);  // returns 1
          inside (c ().subc (), c ().subc, 1); // returns 0
</verb></tscreen>
       <p>
       The first call of <tt>inside</tt> returns 1, while the second
       one returns 0.
     <item><tt>isa (fco, fc)</tt>.  The goal for function usage is to
       check that a function, a class, or an object given by the first
       parameter <tt>fco</tt> uses declarations (through a use-clause)
       of a function or a class given by the second
       parameter <tt>fc</tt>, in other words the first is a subtype of
       the second (or a sub-class of the class).  If it is true, the
       function returns 1, otherwise it returns zero.  If the
       parameter types are wrong, the function generates the
       exception <tt>partype</tt>.  The following example illustrates
       usage of <tt>isa</tt>.
<tscreen><verb>
          class c () {}
          class subc () { use c;}
          isa (subc, c);
          isa (subc (), c);
</verb></tscreen>
       <p>The calls of <tt>isa</tt> in the example return 1.
     <item><tt>subv (vect, index, length = -1)</tt>.  The function is
       used to extract a sub-vector.  The first parameter value should
       be a vector after an implicit string conversion.  The second
       and third parameter values should be integers after an implicit
       integer conversion.
       <p>
       The function extracts only an element or the part of the
       sub-vector existing in the vector (so you can use any values of
       the index and the length).  If the index is negative, it refers
       to an element anologous to a slice bound.  In other
       words, <tt>-1</tt> corresponds to the vector
       length, <tt>-2</tt> corresponds to the vector length-1,
       <tt>-3</tt> corresponds to the vector length-2, and so on.  If
       the length is negative, the sub-vector will finish on the
       vector end.  The function returns a new vector which is the
       sub-vector.  The result vector is immutable only when the
       original vector is immutable.
     <item><tt>del (vect, index, length = 1) or del (tab, key)</tt>.
       The first form of the function is used to remove the vector
       element or a sub-vector from the mutable vector
       <tt>vect</tt>.  The second and the third parameter values
       should be integers after an implicit integer conversion.
       <p>
       The function removes only an element or the part of the
       sub-vector existing in the vector (so you can use any values of
       the index and the length).  A negative index has the same meaning
       as in <tt>subv</tt>.  If the length is negative, the sub-vector
       will finish on the vector end.
       <p>
       The second form of the function is used to remove an element
       (if it exists) with the given key from a mutable table.
       <p>
       The function generates the exception <tt>immutable</tt> if we
       are trying to remove from an immutable vector or table.  The
       function returns the modified vector/table.
     <item><tt>ins (vect, el, index = -1)</tt>.  The function inserts
       an element given by the second parameter into a vector given by
       the first parameter on the place given by the third parameter.
       The third parameter should be an integer after an implicit
       integer conversion.  Negative index has the same meaning as
       in <tt>subv</tt>.  The function generates the
       exception <tt>immutable</tt> if we are trying to insert into an
       immutable vector.  The function returns the modified vector.
     <item><tt>insv (vect, vect, index = -1)</tt>.  The function is
       analogous to the function <tt>ins</tt> but it is used for
       insertion of all vector elements into the vector given as the
       first parameter.  So the second parameter value should be a
       vector.  The function returns the modified vector.
     <item><tt>rev (vect)</tt>.  The function returns a reversion of
       the given vector.
     <item><tt>cmpv (vect, vect)</tt>.  The function makes ab implicit
       string conversion of the parameter values.  After that, the
       parameter values should be vectors whose first corresponding
       equal elements should have the same type (character, integer,
       or floating point type).  The first corresponding unequal
       elements should have the same type too (the remaining elements
       can have different types).  As usual, if this is not true, the
       exception <tt>partype</tt> is generated.
       <p>
       The function returns 1 if the first unequal element value of
       the first vector is greater than the corresponding element in
       the second vector, -1 if less, and 0 if the all corresponding
       vector elements are equal.  If the first vector is a prefix of
       the second vector, the function returns -1.  If the second
       vector is a prefix of the first vector, the function returns 1,
       so it uses in fact a generalized lexicographical order.
     <item><tt>filter (f, v, d = 1)</tt>.  The function expects
       function <tt>f</tt>, vector <tt>v</tt>, and optional
       integer <tt>d</tt> after an integer conversion.  Otherwise the
       exception <tt>partype</tt> is generated.
       <p>
       The function processes v's elements if <tt>d</tt> is equal
       one, elements of vectors which are v's elements if <tt>d</tt>
       is equal to 2 and so on.  In other words, <tt>d</tt> is a level
       on which the vector elements are processed.  If <tt>v</tt> has
       no structure necessary for processing, the
       exception <tt>vecform</tt> is generated.  If <tt>d</tt> is zero
       or negative, the function just returns <tt>v</tt>.  Otherwise
       the function creates a new mutable vector having the same
       structure as <tt>v</tt> with only elements on level <tt>d</tt>
       for which the function <tt>f</tt> returns nonzero value after
       an integer conversion.
       <p>
       If the result of function <tt>f</tt> calls after the integer
       conversion is not integer, the exception <tt>invresult</tt> is
       generated.  The following example illustrates an usage
       of <tt>filter</tt>.
<tscreen><verb>
          var i, v = [0, 1, -2, 3, -4];
          println (filter (fun (a) {a > 0;}, v));
          v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
          println (filter (fun (a) {a > 0;}, v, 2));
</verb></tscreen>
    <item><tt>map (f, v, d = 1)</tt>.  The meaning of the function
       parameters and constraints to their values are analogous to
       ones of the function <tt>filter</tt>.  Only the
       function <tt>f</tt> can return any value.  The elements
       processed by the function <tt>f</tt> are changed onto the
       results of function <tt>f</tt> calls.  The following example
       illustrates usage of <tt>map</tt>.
<tscreen><verb>
          var i, v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
          println (map (fun (a) {a < 0 ? nil : a;}, v, 2));
</verb></tscreen>
     <item><tt>fold (f, v, init, d = 1)</tt>.  The meaning of function
       parameters <tt>f</tt>, <tt>v</tt>, and <tt>d</tt> and
       constraints to their values are analogous to ones of the
       function <tt>filter</tt>.  The function processes all elements
       of the vectors on level <tt>d</tt> and returns value
       <tt>f (f (f (f (init, el0), el1), ...) , eln)</tt> where
       <tt>el0</tt>, ..., <tt>eln</tt> are vector elements on
       level <tt>d</tt> taken from left to right.  If <tt>d</tt> is
       zero or negative or the vectors are empty, the function
       returns <tt>init</tt>.  The following example illustrates usage
       of <tt>fold</tt>.
<tscreen><verb>
          var v = [1,2,3,4];
          println (fold (fun (a, b) {a + b;}, v, 0));
</verb></tscreen> 
     <item><tt>sort (vect[, compare_function])</tt>.  The function
       returns a new sorted vector.  The original vector given as the
       first parameter value should be a homogeneous vector whose
       elements are of character, integer, long integer, or floating
       point type.  If the second parameter is not given, the standard
       arithmetic order (see the comparison operators) is used.  To
       use a special ordering, use the second parameter which should be
       a function which compares two elements of the vector and
       returns a negative integer if the first parameter value
       (element) is less than the second one, a positive integer if
       the first parameter value is greater than the second one, and
       zero if they are equal.
     <item><tt>transpose (m)</tt>.  The function expects
       matrix <tt>m</tt>.  It means that <tt>m</tt> should be a vector
       (each element is a matrix row) of vectors of equal length.
       If <tt>m</tt> is not a vector, the exception <tt>partype</tt>
       is generated.  If the elements of <tt>m</tt> are not vectors of
       the same length, the exceptions <tt>matrixform</tt> is
       generated.  The function returns a new mutable vector of
       mutable vectors which is a matrix transposition of <tt>m</tt>.
     <item><tt>gc ()</tt>.  The function forces a garbage collection
       and heap compaction.  Usually the Dino interpreter itself
       invokes a garbage collection when it believes that it needs to
       this.
     <item><tt>exit (code)</tt>.  The function finishes the work of
       the interpreter with the given code which should be an integer
       value after an implicit integer conversion.
     </itemize>

<sect1>Space <tt>io</tt>
<p>
The space contains functions for input and output and for work with
files and directories.  All declarations of the space are always
exposed.

<sect2>Exception classes of the space <tt>io</tt>
<p>
The following classes are declared in the space <tt>io</tt> as
sub-classes of <tt>invcall</tt>:
     <itemize>
     <item><tt>invinput</tt>.  This class describes that the file
       input is not of the required format.  Usually the exception is
       generated by the function <tt>scan</tt> etc.
     <item><tt>invfmt</tt>.  This class describes that a format of a
       format output function is wrong (see the
       function <tt>putf</tt>).
     <item><tt>eof</tt>.  This class describes that the end of file is
       encountered.  Usually the exception is generated by functions
       reading files (<tt>get</tt>, <tt>scan</tt> etc).
     <item><tt>invencoding</tt>.  This class describes different
       exceptions with the used encodings, e.g. a file contains bytes
       not corresponding to the expected encoding or in some cases the
       encoding should contain ASCII characters.
     </itemize>

<sect2>Class <tt>file</tt>
<p>
Dino has a predeclared final class <tt>file</tt>.  Work with files in
a Dino program are made through objects of the class.  All
declarations inside of the class are private.  The objects of the
class can be created only by the predeclared functions <tt>open</tt>
or <tt>popen</tt>.  If you create an object of the class by calling
the class, the exception <tt>callop</tt> will be generated.  The file
encoding is defined by the current DINO encoding at the file creation
time (see thefunctions <tt>set_encoding</tt>,
<tt>set_file_encoding</tt>).  If you want to work with files on the
byte level without any encoding/decoding, you can use an encoding
called <tt>"RAW"</tt>.

<sect2>Files
<p>
To output something into the standard output streams or to input
something from the standard input stream, the following variables can
be used:
     <itemize>
     <item><tt>stdin</tt>.  The variable value is an object of the
       class <tt>file</tt> which corresponds to the standard input
       stream.
     <item><tt>stdout</tt>.  The variable value is an object of the
       class <tt>file</tt> which corresponds to the standard output
       stream.
     <item><tt>stderr</tt>.  The variable value is an object of the
       class <tt>file</tt> which corresponds to the standard error
       stream.
     </itemize>
<p>
All these variables are final, so you can not change their values.
Encoding of the files is DINO current encoding at the program start
(see the function <tt>set_encoding</tt>).

<sect2>Functions for work with files
<p>
The following functions (besides the input/output functions) work with
OS files.  The functions may generate an exception declared in the
class <tt>syserror</tt> (e.g. <tt>eaccess</tt>, <tt>enametoolong</tt>,
<tt>eisdir</tt> and so on) besides the standard <tt>partype</tt>,
and <tt>parnumber</tt>.  The function <tt>rename</tt> can be used for
renaming a directory, not only a file.
     <itemize>
     <item><tt>rename (old_path, new_path)</tt>.  The function renames
       the file (directory) given by its path name.  The old and new
       names are given by the parameter values which should be strings
       after an implicit string conversion.
     <item><tt>remove (file_path)</tt>.  The function removes the OS
       file given by its path name.  The file path name should be a
       string after an implicit string conversion.
     <item><tt>open (file_path, mode)</tt>.  The function opens the
       file for work in the given <em>mode</em>, creates a new class
       <tt>file</tt> instance, associates the opened file with the
       instance, and returns the instance.  The parameter values
       should be strings after an implicit string conversions.  The first
       parameter value is a string representing the file path.  The
       second parameter value is a string representing the mode for work
       with the file (for all possible modes see the ANSI C function
       <tt>fopen</tt> documentation).  All work with the opened file
       is made through the file instance.
     <item><tt>close (fileinstance)</tt>.  The function closes a file
       opened by the function <tt>open</tt>.  The file is given by the
       class <tt>file</tt> instance.  The function also removes all
       association of the instance with the file.
     <item><tt>flush (fileinstance)</tt>.  The function flushes any
       output that has been buffered for the opened file given by
       the class <tt>file</tt> instance.
     <item><tt>popen (command, mode)</tt>.  The function starts a
       shell command given by the first parameter value (which should
       be a string after an implicit string conversion), creates a
       pipe, creates a new class <tt>file</tt> instance, associates
       the pipe with the instance, and returns the instance.  Writing
       to such a pipe (through the class file instance) writes to the
       standard input of the command.  Conversely, reading from the
       pipe reads the command's standard output.  After an implicit
       string conversion the second parameter value should be the
       string "r" (for reading from the pipe) or "w" (for writing to
       the pipe).  The pipe should be closed by the
       function <tt>pclose</tt>.
     <item><tt>pclose (fileinstance)</tt>.  The function waits for the
       command connected to a pipe to terminate.  The pipe is given by
       the class <tt>file</tt> instance returned by the function
       <tt>popen</tt>.  The function also removes the association of
       the instance with the pipe.
     <item><tt>tell (fileinstance)</tt>.  The function returns the
       current value of the file position indicator for the file
       (opened by function <tt>open</tt>) given by the class
       <tt>file</tt> instance.
     <item><tt>seek (fileinstance, offset, whence)</tt>.  The function
       sets up the current file position indicator for the file
       (opened by function <tt>open</tt>) given by the class
       <tt>file</tt> instance.  The position is given by
       <tt>offset</tt> which should be an integer after an implicit
       arithmetic conversion and <tt>whence</tt> which should be a
       string after an implicit string conversion.  The first character
       of the string should be <tt>'s'</tt>, <tt>'c'</tt>, or
       <tt>'e'</tt> (these characters mean that the offset is relative
       to the start of the file, the current position indicator, or
       the end-of-file, respectively).
     <item><tt>get_file_encoding (fileinstance)</tt>.  The function
       returns a new mutable string which is a name of the current file
       encoding.
     <item><tt>set_file_encoding (fileinstance, name)</tt>.  The
       function accepts a file and a string and changes the current
       file encoding.  If the name represents an unknown encoding
       name, the function generates the exception <tt>parvalue</tt>.
     </itemize>

<sect2>File output functions
<p>
The following functions are used to output something into opened
files.  All the function return values are undefined.  The
functions may generate an exception declared in the class <tt>syserror</tt>
(e.g. <tt>eio</tt>, <tt>enospc</tt> and so on) besides the standard
<tt>partype</tt> and <tt>parnumber</tt>.
     <itemize>
     <item><tt>put (...)</tt>.  All parameters should be strings after
       an implicit string conversion.  The function outputs all
       strings into the standard output stream.
     <item><tt>putln (...)</tt>.  The function is analogous to the
       function <tt>put</tt> except for the fact that it additionally
       outputs a new line character after output of all the strings.
     <item><tt>fput (fileinstance, ...)</tt>.  The function is
       analogous to the function <tt>put</tt> except for the fact that
       it outputs the string into an opened file associated with a
       class <tt>file</tt> instance which is the first parameter
       value.
     <item><tt>fputln (fileinstance, ...)</tt>.  The function is
       analogous to function <tt>fput</tt> except for the fact that it
       additionally outputs a new line character after output of all
       the strings.

     <item><tt>putf (format, ...)</tt>.  The first parameter should be
       a string after an implicit string conversion.  The function
       outputs the rest of parameters according to the format.  The
       number of the rest parameters should be exactly equal to the
       conversions (including parameterized widths and precisions) in
       the format.  Otherwise, the exception <tt>parnumber</tt> will
       be generated.  The types of the parameter should correspond to
       the corresponding conversion specifier (or to be an integer for
       parameterized widths and precisions).  If it is not true, the
       exception <tt>partype</tt> will be generated.  The format is
       mostly a subset of one of standard C function <tt>printf</tt>
       but it can also deal with multi-precision integers (of the Dino
       type long).  The format has the following syntax:
       <tscreen><verb>
          format : <any character except %>
                 | '%' flags [width] [precision]
                       conversion_specifier
          flags :
                | flag

          flag : '#' | '0' | '-' | ' ' | '+'

          width : '*' | <a decimal number starting with non-zero>

          precision : '.' ['*' | <decimal number>]

          conversion_specifier : 'd' | 'o' | 'x' | 'X'
                               | 'e' | 'E' | 'f' | 'g'
                               | 'G' | 'c' | 's' | '%'
       </verb></tscreen>
       <p>
       If the format syntax is wrong, the exception <tt>invfmt</tt> is
       generated.
       <p>
       The flag '#' means that the value should be converted into an
       alternative form.  It can be present only for the conversion
       specifiers 'o', 'x', 'X', 'e', 'E', 'f', 'g', and 'G'.  If the
       flag is used for the conversion specifier 'o', the output will
       be prefixed by '0'.  For 'x' and 'X' the output will be
       prefixed by '0x' and '0X' correspondingly. For the conversions
       'e', 'E', 'f', 'g', and 'G' the output will always contain a
       decimal point.  For the conversions 'g' and 'G' it also means
       that trailing zeros are not removed from the output as they
       would be without the flag.  The following code using the flag
       '#' in a format
<tscreen><verb>
         putf ("->%#o %#x %#x %#.0e %#.0f %#g<-\n",
               8, 10, 16l, 2., 3., 4.);
</verb></tscreen>
<p>
       will output
<tscreen><verb>
         ->010 0xa 0x10 2.e+00 3. 4.00000<-
</verb></tscreen>
       <p>
       The flag '0' means that the output value will be zero padded on
       the left. If both flags '0' and '-' appear, the flag '0' is
       ignored.  It is also ignored for the conversions 'd', 'o', 'x', and
       'X' if a precision is given.  The flag is prohibited for
       the conversions 'c' and 's'.  The following code using the flag '0' in
       a format
<tscreen><verb>
         putf ("->%04d %04x %04x %09.2e %05.2f %05.2g<-\n",
               8, 10, 16l, 2., 3., 4.);
</verb></tscreen>
       <p>
       will output
<tscreen><verb>
         ->0008 000a 0010 02.00e+00 03.00 00004<-
</verb></tscreen>
       <p>
       The flag '-' means that the output will be left adjusted on the
       field boundary.  (The default is a justification to the right).
       The flag '-' overrides the flag '0' if the both are given.  The
       following code using the flag '-' in a format
<tscreen><verb>
         putf ("->%-04d %-04x %-04x %-09.2e %-05.2f %-05.2g<-\n",
               8, 10, 16l, 2., 3., 4.);
</verb></tscreen>
       <p>
       will output
<tscreen><verb>
         ->8    a    10    2.00e+00  3.00  4    <-
</verb></tscreen>
       <p>
       The flag ' ' means that the output of a signed number will
       start with a blank for positives number.  The flag can be used
       only for the conversions 'd', 'e', 'E', 'f', 'g', and 'G'.  If
       both flags ' ' and '+' appear, the flag ' ' is ignored.  The
       following code using the flag ' ' in a format
<tscreen><verb>
         putf ("->% d % d % .2e % .2f % .2g<-\n",
               8, 16l, 2., 3., 4.);
</verb></tscreen>
       <p>
       will output
<tscreen><verb>
         -> 8  16  2.00e+00  3.00  4<-
</verb></tscreen>
       <p>
       The flag '+' means that the output of a signed number will
       start with a plus for a positives number.  The flag can be used
       only for the conversions 'd', 'e', 'E', 'f', 'g', and 'G'.  The
       flag '+' overrides the flag ' ' if both are given.  The
       following code using the flag '+' in a format
<tscreen><verb>
         putf ("->%+d %+d %+.2e %+.2f %+.2g<-\n",
               8, 16l, 2., 3., 4.);
</verb></tscreen>
       <p>
       will output
<tscreen><verb>
         ->+8 +16 +2.00e+00 +3.00 +4<-
</verb></tscreen>
       <p>
       The width defines a minimum width of the output value.  If the
       output is smaller, it is padded with spaces (or zeros -- see
       the flag '0') on the left (if the flag '-' is used) or on the
       right.  The output is never truncated.  The width should be no
       more than maximal integer value, otherwise teh
       exception <tt>invfmt</tt> is generated.  The width can be given
       as a parameter of the integer type if '*' is used.  If the
       value of the width given by the parameter is negative, the flag
       '-' is believed to be given and the width is believed to be
       equal to zero.  The following code using the width in a format
<tscreen><verb>
         putf ("->%5d %05d %-5d %5d %*d %*d<-\n",
               8, 9, 10, 16l, 5, 8, -5, 10);
</verb></tscreen>
       <p>
       will output
<tscreen><verb>
         ->    8 00009 10       16     8 10   <-
</verb></tscreen>
       <p>
       The precision is prohibited for the conversion 'c'.  If the
       number after the period is absent, its value will be zero.  The
       precision can be given as a parameter of the integer type if
       '*' is used after the period.  If the value of precision given
       by the parameter is negative, its value is believed to be zero
       too.  For the conversions 'd', 'o', 'x', and 'X' the precision
       means a minimum number of the output digits.  For the
       conversions 'e', 'E', and 'f' it means the number of the digits
       to appear after the decimal point.  For 'g' and 'G' it means
       the maximum number of significant digits.  For 's' it means the
       maximum number of characters to be output from a string.  The
       following code using precisions in a format
<tscreen><verb>
         putf ("->%.d %.0d %.5d %.d %.0f %.0e %.2g<-\n",
               8, 8, 9, 16l, 2.3, 2.3, 3.53);
         putf ("->%.2s %.0d %.*d %.*d %.*d<-\n",
               "long", 0, 5, 8, -5, 8, 5, 16l);
</verb></tscreen>
       <p>
       will output
<tscreen><verb>
         ->8 8 00009 16 2 2e+00 3.5<-
         ->lo  00008 8 00016<-
</verb></tscreen>
       <p>
       The conversion 'd' should be used to output integer or long
       integer.  The default precision is 1.  When 0 is output with an
       explicit precision equal to 0, the output is empty.
       <p>
       The conversions 'o', 'x', and 'X' should be used to output an
       integer or long integer value as an unsigned in the octal and
       hexadecimal form.  The lower case letters <tt>abcdef</tt> are
       used for 'x' and the upper case letters <tt>ABCDEF</tt> are
       used for 'X'.  The precision gives the minimum number of digits
       that must appear. If the output value requires fewer digits, it
       is padded on the left with zeros.  The default precision is 1.
       When 0 is output with an explicit precision equal to 0, the
       output is empty.
       <p>
       The conversion 'f' should be used to output floating point values.
       The output value has a form <tt>[-]ddd.ddd</tt> where the
       number of digits after the decimal point is given by the
       precision specification.  The default precision value is 6.  If
       the precision is explicitly zero, no decimal-point character
       appears.
       <p>
       The conversions 'e' and 'E' should be used to output floating point
       values with an exponent in the form <tt>[-]d.ddd[e|E][+|-]dd</tt>.
       There is always one digit before the decimal-point.  The number
       of digits after the decimal point is defined by the precision.
       The default precision value is 6.  If the precision is zero, no
       decimal-point appears.  The conversion 'E' uses the letter
       <tt>E</tt> (rather than <tt>e</tt>) to introduce the exponent.
       The exponent always contains at least two digits.  If the
       exponent value is zero, the exponent is output as <tt>00</tt>.
       <p>
       The conversions 'g' and 'G' should be used to output floating
       point values in the style 'f' or 'e' (or 'E' for conversion 'G').
       The precision defines the number of significant digits.  The
       default value of the precision is 6.  If the precision is zero,
       it is treated as 1.  The conversion 'e' is used if the exponent
       from the conversion is less than -4 or not less than the
       precision.  Trailing zeros are removed from the fractional part
       of the output.  If all fractional part is zero, the decimal
       point is removed too.
       <p>
       The conversion 'c' should be used to output a character value.
       <p>
       The conversion 's' should be used to output strings.
       <p>
       The conversion '%' should be used to output <tt>%</tt>.
       <p>
       The following code using different conversions in a format
<tscreen><verb>
         putf ("->%% %c %s %d %o %x %X %d %o %x %X<-\n",
               'c', "string", 7, 8, 20, 20, 8l, 9l, 21l, 21l);
         putf ("->%f<-\n", 1.5);
         putf ("->%e %E %g %G %g %G<-\n",
               2.8, 2.8, 3.7, 3.7, 455555555.555, 5.9e-5);
</verb></tscreen>
       <p>
       will output
<tscreen><verb>
         ->% c string 7 10 14 14 8 11 15 15<-
         ->1.500000<-
         ->2.800000e+00 2.800000E+00 3.7 3.7 4.55556e+08 5.9E-05<-
</verb></tscreen>

     <item><tt>fput (fileinstance, format, ...)</tt>.  The function is
       analogous to the function <tt>putf</tt> except for the fact
       that it outputs the operands into an opened file associated
       with a class <tt>file</tt> instance which is the first
       parameter value.
     <item><tt>print (...)</tt>.  The function outputs all parameter
       values into the standard output stream.  The function never
       makes an implicit conversions of the parameter values.  The
       parameter values are output as they could be represented in
       Dino itself (e.g. character <tt>'c'</tt> is output
       as <tt>'c'</tt>, vector <tt>['a', 'b', 'c']</tt> is output
       as <tt>"abc"</tt>, vector
       <tt>[10, 20]</tt> as <tt>[10, 20]</tt> and so on).  As you know
       some values (functions, classes, block instances, class
       instances, threads) are not represented fully in DINO.  Such
       values are represented schematically.  For example, the output
       <tt>fun f {}.g(unique_number)</tt> would mean the function
       <tt>f</tt> in the call of function (or class) <tt>g</tt> with
       the given unique number and the function g is in the instance of
       the implicit block covering the whole program.  For the
       function <tt>g</tt>, output would look simply like <tt>fun
       g</tt> because there is only one instance of the implicit block
       covering the whole program.  Output for an instance of the
       class <tt>c</tt> in the function <tt>f</tt> looks like
       <tt>instance {}.f(unique_number).c(unique_number)</tt>.  Output
       for a block instance of the function <tt>f</tt> looks like
       <tt>stack {}.f(unique_number)</tt>.  Output for a thread whose
       fiber <tt>t</tt> is declared in the function
       <tt>f</tt> would look like <tt>thread unique_number
       {}.f(unique_number).t(unique_number)</tt>.
     <item><tt>println (...)</tt>.  The function is analogous to the
       function <tt>print</tt> except for the fact that it
       additionally outputs a new line character after output of all
       parameters.
     <item><tt>fprint (fileinstance, ...)</tt>.  The function is
       analogous to the function <tt>print</tt> except for the fact
       that it outputs the parameters into an opened file associated
       with a class <tt>file</tt> instance which is the value of first
       parameter.
     <item><tt>fprintln (fileinstance, ...)</tt>.  The function is
       analogous to function <tt>fprint</tt> except for the fact that
       it additionally outputs a new line character after the output
       of all the parameters.
     </itemize>

<sect2>File input functions
<p>
The following functions are used to input something from opened files.
The functions may generate an exception declared in the
class <tt>syserror</tt> (e.g. <tt>eio</tt>, <tt>enospc</tt> and so on)
or <tt>eof</tt> besides the standard <tt>partype</tt>,
and <tt>parnumber</tt>.
     <itemize>
     <item><tt>get ()</tt>.  The function reads one character from the
       standard input stream and returns it.  The function generates
       the exception <tt>eof</tt> if the function tries to read the
       end of file.
     <item><tt>getln ()</tt>.  The function reads one line from the
       standard input stream and returns it as a new string.  The end
       of line is the newline character or end of file.  The returned
       string does not contain the newline character.  The function
       generates the exception <tt>eof</tt> only when the file
       position indicator before the function call stands exactly at
       the end of file.
     <item><tt>getf ([ln_flag])</tt>.  The function reads the whole
       standard input stream and returns it as a new string.  The
       function generates the exception <tt>eof</tt> only when the
       file position indicator before the function call stands exactly
       at the end of file.  The function has an optional parameter
       which should be integer after an implicit integer conversion.
       If the parameter value is nonzero, the function returns a
       vector of strings.  Otherwise it behaves as usually.  Each
       string is a line in the input stream.  The strings do not
       contain the newline characters.
     <item><tt>fget (fileinstance)</tt>.  The function is analogous to
       the function <tt>get</tt> except for the fact that it reads
       from an opened file associated with the class <tt>file</tt>
       instance which is the parameter's value.
     <item><tt>fgetln (fileinstance)</tt>.  The function is analogous
       to the function <tt>getln</tt> except for the fact that it
       reads from an opened file associated with a class <tt>file</tt>
       instance which is the parameter value.
     <item><tt>fgetf (fileinstance [, ln_flag])</tt>.  The function is
       analogous to the function <tt>getf</tt> except for the fact
       that it reads from an opened file associated with a class
       <tt>file</tt> instance which is the parameter's value.
     <item><tt>scan ()</tt>.  The functions reads a character,
       integer, floating point number, string, vector, or table and
       returns it as the result.  The input values should be
       represented in the file as the ones in the Dino language
       (except for the fact that there should be no identifiers in the
       input values and there should be no operators in the values,
       although the signs <tt>+</tt> and <tt>-</tt> are possible in an
       integer or floating point represenation).  The table or vector
       should contains only values of the types mentioned above.  The
       values in the file can be separated by white characters.  If
       there is an error (e.g. unbalanced brackets in a vector value)
       in the read value representation the function generates the
       exception <tt>invinput</tt>.  The functions generates the
       exception <tt>eof</tt> if only white characters are still
       unread in the file.
     <item><tt>scanln ()</tt>.  The function is analogous to the
       function <tt>scan</tt> except for the fact that it skips all
       characters until the end of line or the end of file after
       reading the value.  Skipping is made even if the exception
       <tt>invinput</tt> is generated.
     <item><tt>fscan (fileinstance)</tt>.  The function is analogous
       to the function <tt>scan</tt> except for the fact that it reads
       from an opened file associated with a class <tt>file</tt>
       instance which is the parameter's value.
     <item><tt>fscanln (fileinstance)</tt>.  The function is analogous
       to the function <tt>scanln</tt> except for that it reads from
       an opened file associated with a class <tt>file</tt> instance
       which is the parameter value.
     </itemize>

<sect2>Encoding functions
<p>
Dino internally uses Unicode for characters.  To provide a
communication with the rest of world, it can use different encodings.
The default encoding is UTF-8.  Dino has two functions to get and
change the current encoding:
     <itemize>
     <item><tt>get_encoding ()</tt>.  The function returns a new
       mutable string which is a name of the current encoding.
     <item><tt>set_encoding (name)</tt>.  The function accepts a
       string and changes the current encoding.  If the name
       represents an unknown encoding name, the function generates
       the exception <tt>parvalue</tt>.
     </itemize>
       <p>
       Examples:
<tscreen><verb>
          putln (get_encoding ());
          set_encoding ("KOI8-R");
</verb></tscreen>

<sect2>Functions for work with directories
<p>
The following functions work with directories.  The functions may
generate an exception declared in the class <tt>syserror</tt>
(e.g. <tt>eaccess</tt>, <tt>enametoolong</tt>, <tt>enotdir</tt> and so
on) besides the standard <tt>partype</tt> and <tt>parnumber</tt>.
     <itemize>
     <item><tt>readdir (dirpath)</tt>.  The function makes an implicit
       string conversion of the parameter value which should be a
       string (representing a directory path).  The function returns a
       new mutable vector with elements which are strings representing
       the names of all files and sub-directories
       (including <tt>"."</tt> and <tt>".."</tt> for the current and
       parent directory respectively) in given directory.
     <item><tt>mkdir (dirpath)</tt>.  The function creates a directory
       with the given name represented by a string (the parameter
       value after an implicit string conversion).  The directory has
       read/write/execute rights for all.  You can change it with the
       aid of the functions <tt>ch*mod</tt>.
     <item><tt>rmdir (dirpath)</tt>.  The function removes the
       directory given by a string which is a parameter value after
       an implicit string conversion.
     <item><tt>getcwd ()</tt>.  The function returns a new string
       representing the full path of the current directory.
     <item><tt>chdir (dirpath)</tt>.  The function makes the directory
       given by <tt>dirpath</tt> (which should be a string after
       an implicit string conversion) the current directory.
     </itemize>

<sect2>Functions for access to file/directory information
<p>
The following predeclared functions can be used for accessing file or
directory information.  The functions may generate an exception
declared in the class <tt>syserror</tt> (e.g. <tt>eaccess</tt>,
<tt>enametoolong</tt>, <tt>enfile</tt> and so on) besides the standard
<tt>partype</tt> and <tt>parnumber</tt>.  The functions expect one
parameter which should be a file instance (see the predeclared class
<tt>file</tt>) or the path name of a file represented by a string (the
functions make an implicit string conversion of the parameter value).
The single exception to this is <tt>isatty</tt> which expects a file
instance.
     <itemize>
     <item><tt>ftype (fileinstance_or_filename)</tt>.  The function
       returns one the following characters:
       <itemize>
       <item><tt>'f'</tt>.  A regular file.
       <item><tt>'d'</tt>.  A directory.
       <item><tt>'L'</tt>.  A symbolic link.
       <item><tt>'c'</tt>.  A character device.
       <item><tt>'b'</tt>.  A block device.
       <item><tt>'p'</tt>.  A fifo.
       <item><tt>'S'</tt>.  A socket.
       </itemize>
       <p>
       Under some OSes the function never returns some of the
       characters (e.g. 'c' or 'b').  The function may return nil if
       it can not categorize the file as above.
     <item><tt>fuidn (fileinstance_or_filename)</tt>.  The function
       returns a new string representing a name of the owner of the
       file (directory).  Under some OSes the function may return the
       new string <tt>"Unknown"</tt> if there is no notion "owner" in
       the OS file system.
     <item><tt>fgrpn (fileinstance_or_filename)</tt>.  Analogous to
       the previous function except for it returns a new string
       representing a name of the group of the file (directory).
       Under some OSes the function may return the new string
       <tt>"Unknown"</tt> if there is no notion "group" in the OS file
       system.
     <item><tt>fsize (fileinstance_or_filename)</tt>.  The function
       returns an integer value which is the length of the file in
       bytes.
     <item><tt>fatime (fileinstance_or_filename)</tt>.  The function
       returns an integer value which is time of the last access to the
       file (directory).  The time is measured in seconds since the
       fixed time (usually since January 1, 1970).  See also <em>time
       functions</em>.
     <item><tt>fmtime (fileinstance_or_filename)</tt>.  Analogous to
       the previous functions but returns the time of the last
       modification.
     <item><tt>fctime (fileinstance_or_filename)</tt>.  Analogous to
       the previous functions but it returns the time of the last
       change.  Here `change' usually means changing the file
       attributes (owner, modes and so on), while `modification' means
       usually changing the file itself.
     <item><tt>fumode (fileinstance_or_filename)</tt>.  The function
       returns a new string representing the rights of the owner of
       the file (directory).  The string may contain the following
       characters (in the following order if the string contains more
       than one character):
       <itemize>
       <item><tt>'s'</tt>.  Sticky bit of the file (directory).
       <item><tt>'r'</tt>.  Right to read.
       <item><tt>'w'</tt>.  Right to write.
       <item><tt>'x'</tt>.  Right to execute.
       </itemize>
     <item><tt>fgmode (fileinstance_or_filename)</tt>.  Analogous to
       the previous function except for the fact that it returns
       information about the file (directory) group user rights and
       that the function never returns a string containing the
       character <tt>'s'</tt>.
     <item><tt>fomode (fileinstance_or_filename)</tt>.  Analogous to
       the previous function except for the act that it returns
       information about the rights of all other users.
     <item><tt>isatty (fileinstance)</tt>.  The function returns 1 if
       the file instance given as the parameter is an open file
       connected to a terminal and 0 otherwise.
     </itemize>
<p>
The following functions can be used to change the rights of usage of
the file (directory) for different users.  The function expects two
strings (after an implicit string conversion).  The first one is the
path name of the file (directory).  The second one is the rights.  For
instance, if the string contains the character 'r', this is a right to
read (see characters used to denote different rights in the
description of the function <tt>fumode</tt>).  The function return
values are always undefined.
     <itemize>
     <item><tt>chumod (path, mode)</tt>.  The function sets up rights
       for the file (directory) owner according to the given mode.
     <item><tt>chgmod (path, mode)</tt>.  Analogous to the previous
       function except for the fact that it sets up rights for the
       file (directory) group users and that the function ignores the
       character <tt>'s'</tt>.
     <item><tt>chomod (path, mode)</tt>.  Analogous to the previous
       function except for the fact that it sets up rights for all
       other users.
     </itemize>

<sect2>Miscellaneous functions
<p>
There are the following miscellaneous functions in space <tt>io</tt>:
     <itemize>
     <item><tt>sput (...), sputln (...), sputf (format, ...)</tt> The
       functions are analogous to the functions <tt>put, putln,
       print</tt>, and <tt>println</tt> but they return the result
       string instead of output of the formed string into the standard
       output stream.
     <item><tt>sprint (...), sprintln (...)</tt>.  The functions are
       analogous to the functions <tt>print</tt> and <tt>println</tt>
       but they return the result string instead of output of the
       formed string into the standard output stream.
     </itemize>

<sect1>Space <tt>sys</tt>
<p>
This space contains declarations to work with the underlying execution
environment (OS) and related exceptions.

<sect2>Exceptions in space <tt>sys</tt>
<p>
The space contains a lot of exceptions:
     <itemize>
     <item><tt>signal</tt>.  This class is a sub-class of the
       class <tt>error</tt>.  Sub-classes of the class <tt>signal</tt>
       describe exceptions from receiving a signal from other OS
       processes.  They are
         <itemize>
         <item><tt>sigint</tt>.  This class describes the exception
           generated by the user's interrupt from the keyboard.
         <item><tt>sigill</tt>.  This class describes the exception
           generated by illegal execution of an instruction .
         <item><tt>sigabrt</tt>.  This class describes the exception
           generated by the signal abort.
         <item><tt>sigfpe</tt>.  This class describes a floating point
           exception.
         <item><tt>sigterm</tt>.  This class describes the exception
           generated by the termination signal.
         <item><tt>sigsegv</tt>.  This class describes the exception
           generated by an invalid memory reference.
         </itemize>
     <item><tt>invenv</tt>.  This class is a sub-class of the
       class <tt>error</tt>.  The class <tt>invenv</tt> describes a
       corruption of the Dino program environment (see the predeclared
       variable <tt>env</tt>).
     <item><tt>syserror</tt>.  This class is a sub-class of the
       class <tt>invcall</tt>.  Sub-classes of the
       class <tt>syserror</tt> describe exceptions in predeclared
       functions which call OS system functions.  Some exceptions are
       never generated but may be generated in the future on some
       OSes.
       <itemize>
       <item><tt>eaccess</tt>.  This describes the system error
         "Permission denied".
       <item><tt>eagain</tt>.  This describes the system error
         "Resource temporarily unavailable".
       <item><tt>ebadf</tt>.  This describes the system error "Bad
         file descriptor".
       <item><tt>ebusy</tt>.  This describes the system error
         "Resource busy".
       <item><tt>echild</tt>.  This describes the system error "No
         child processes".
       <item><tt>edeadlk</tt>.  This describes the system error
         "Resource deadlock avoided".
       <item><tt>edom</tt>.  This describes the system error "Domain
         error".
       <item><tt>eexist</tt>.  This describes the system error "File
         exists".
       <item><tt>efault</tt>.  This describes the system error "Bad
         address".
       <item><tt>efbig</tt>.  This describes the system error "File
         too large".
       <item><tt>eintr</tt>.  This describes the system error
         "Interrupted function call".
       <item><tt>einval</tt>.  This describes the system error
         "Invalid argument".
       <item><tt>eio</tt>.  This describes the system error
         "Input/output error".
       <item><tt>eisdir</tt>.  This describes the system error "Is a
         directory".
       <item><tt>emfile</tt>.  This describes the system error "Too
         many open files".
       <item><tt>emlink</tt>.  This describes the system error "Too
         many links".
       <item><tt>enametoolong</tt>.  This describes the system error
         "Filename too long".
       <item><tt>enfile</tt>.  This describes the system error "Too
         many open files in system".
       <item><tt>enodev</tt>.  This describes the system error "No
         such device".
       <item><tt>enoent</tt>.  This describes the system error "No
         such file or directory".
       <item><tt>enoexec</tt>.  This describes the system error "Exec
         format error".
       <item><tt>enolck</tt>.  This describes the system error "No
         locks available".
       <item><tt>enomem</tt>.  This describes the system error "Not
         enough space".
       <item><tt>enospc</tt>.  This describes the system error "No
         space left on device".
       <item><tt>enosys</tt>.  This describes the system error
         "Function not implemented".
       <item><tt>enotdir</tt>.  This describes the system error "Not a
         directory".
       <item><tt>enotempty</tt>.  This describes the system error
         "Directory not empty".
       <item><tt>enotty</tt>.  This describes the system error
         "Inappropriate I/O control operation".
       <item><tt>enxio</tt>.  This describes the system error "No such
         device or address".
       <item><tt>eperm</tt>.  This describes the system error
         "Operation not permitted".
       <item><tt>epipe</tt>.  This describes the system error "Broken
         pipe".
       <item><tt>erange</tt>.  This describes the system error "Result
         too large".
       <item><tt>erofs</tt>.  This describes the system error
         "Read-only file system".
       <item><tt>espipe</tt>.  This describes the system error
         "Invalid seek".
       <item><tt>esrch</tt>.  This describes the system error "No such
         process".
       <item><tt>exdev</tt>.  This describes the system error
         "Improper link".
       </itemize>
     <item><tt>systemcall</tt>.  This is a sub-class of the
       class <tt>invcall</tt>.  Sub-classes of the
       class <tt>systemcall</tt> describe exceptions in calling the
       predeclared function <tt>system</tt>.
       <itemize>
       <item><tt>noshell</tt>.  This class describes the exception
         that the function <tt>system</tt> can not find the OS command
         interpreter (the shell).
       <item><tt>systemfail</tt>.  This class describes all remaining
         exceptions in calling the OS function
         <tt>system</tt>.
       </itemize>
     <item><tt>invextern</tt>.  This is a sub-class of the
       class <tt>invcall</tt>.  Sub-classes of the
       class <tt>invextern</tt> describe exceptions in calling
       external functions or in accessing an external variable.
       <itemize>
       <item><tt>noextern</tt>.  This class describes the exception
         that the given external can not be found.
       <item><tt>libclose</tt>.  This class describes the exception
         that there is an error in closing a shared library.
       <item><tt>noexternsupp</tt>.  This class describes an exception
         in the usage of external objects when they are not
         implemented under this OS.
       <item><tt>compile</tt>.  This class describes an exception
         in a compilation of C code or loading the result shared
         object file.
       </itemize>
     <item><tt>invenvar</tt>.  This is a sub-class of the
       class <tt>invcall</tt>.  The class <tt>invenvar</tt> describes
       corruption in the type of variables <tt>split_regex</tt> and
       <tt>time_format</tt> (e.g. their values are not strings).
     </itemize>

<sect2>Variable <tt>time_format</tt>
<p>
The variable value is a string which is the output format of time used
by the function <tt>strtime</tt> when it is called without parameters.
The initial value of the variable is the string <tt>"%a %b %d %H:%M:%S
%Z %Y"</tt>.

<sect2>Time functions
<p>
The following functions from the space <tt>sys</tt> can be used to get
information about real time.
     <itemize>
     <item><tt>time ()</tt>.  The function returns the time in seconds
       since the fixed time (usually since January 1, 1970).
     <item><tt>strtime ([format [, time]])</tt>.  The function returns
       a string representing the <tt>time</tt> (an integer
       representing time in seconds since the fixed time) according to
       the <tt>format</tt> (a string).  If the format is not given,
       the value of the variable <tt>time_format</tt> is used.  In
       this case if the value of <tt>time_format</tt> is corrupted (it
       is not a string), the function generates the
       exception <tt>invenvar</tt>.  If the time is not given, the
       current time is used.  The format is the same as in C library
       function <tt>strftime</tt>.  Here is an extraction from the OS
       function documentation.  The following format specifiers can be
       used in the format:
         <itemize>
         <item><tt>%a</tt> - the abbreviated weekday name according to
           the current locale.
         <item><tt>%A</tt> - the full weekday name according to the
           current locale.
         <item><tt>%b</tt> - the abbreviated month name according to
           the current locale.
         <item><tt>%B</tt> - the full month name according to the
           current locale.
         <item><tt>%c</tt> - the preferred date and time
           representation for the current locale.
         <item><tt>%d</tt> - the day of the month as a decimal number
           (range 01 to 31).
         <item><tt>%H</tt> - the hour as a decimal number using a
           24-hour clock (range 00 to 23).
         <item><tt>%I</tt> - the hour as a decimal number using a
           12-hour clock (range 01 to 12).
         <item><tt>%j</tt> - the day of the year as a decimal number
           (range 001 to 366).
         <item><tt>%m</tt> - the month as a decimal number (range 01
           to 12).
         <item><tt>%M</tt> - the minute as a decimal number.
         <item><tt>%p</tt> - either `am' or `pm' according to the given time
           value, or the corresponding strings for the current locale.
         <item><tt>%S</tt> - the second as a decimal number.
         <item><tt>%U</tt> - the week number of the current year as a
           decimal number, starting with the first Sunday as the first
           day of the first week.
         <item><tt>%W</tt> - the week number of the current year as a
           decimal number, starting with the first Monday as the first
           day of the first week.
         <item><tt>%w</tt> - the day of the week as a decimal, Sunday
           being 0.
         <item><tt>%x</tt> - the preferred date representation for
           the current locale without the time.
         <item><tt>%X</tt> - the preferred time representation for
           the current locale without the date.
         <item><tt>%y</tt> - the year as a decimal number without a
           century (range 00 to 99).
         <item><tt>%Y</tt> - the year as a decimal number including
           the century.
         <item><tt>%Z</tt> - the time zone or the name or an
           abbreviation.
         <item><tt>%%</tt> - the character '%'.
         </itemize>
     </itemize>

<sect2>Functions for access to information about OS processes
<p>
The space <tt>sys</tt> contains predeclared functions which are used
to get information about the current OS process (the Dino interpreter
which executes the program).  Each OS process has unique identifier
and usually the OS processes are called by a concrete user and group
and are executed on behalf of the concrete user and group (so called
effective identifiers).  The following functions return such
information.  On some OSes the function may return string "Unknown" as
a name if there are no notions of user and group identifiers.
     <itemize>
     <item><tt>getpid ()</tt>.  The function returns an integer value
       which is the process ID of the current OS process.
     <item><tt>getun ()</tt>.  The function returns a new string which
       is the user name for the current OS process.
     <item><tt>geteun ()</tt>.  The function returns a new string
       which is the effective user name for the current OS process.
     <item><tt>getgn ()</tt>.  The function returns a new string which
       is the group name for the current OS process.
     <item><tt>getegn ()</tt>.  The function returns a new string
       which is the effective group name for the current OS process.
     <item><tt>getgroups ()</tt>.  The function returns a new vector
       of strings (possibly the empty vector) representing
       supplementary group names for the current OS process.
     </itemize>

<sect2>Function <tt>system (command)</tt>
<p>
The function executes the command given by a string (the parameter
value) in the OS command interpreter.  Besides the standard exceptions
<tt>parnumber</tt> and <tt>partype</tt> the function may generate the
exceptions <tt>noshell</tt> and <tt>systemfail</tt>.

<sect1>Space <tt>re</tt>
<p>
This space contains declarations which can be useful for working with
the regular expressions and for pattern matching -- see also
the <em>match-statements</em>.

<sect2>Exception class <tt>invregex</tt>
<p>
This class describes exceptions specific for executing the
<em>pmatch-statement</em> and for calling predeclared functions
implementing regular expression pattern matching.  Although there is
only one class for this, the messages which are in the class parameter
can be different and explain more details.

<sect2>Variable <tt>split_regex</tt>
<p>
The variable value is a string which represents a regular expression
which is used by the predeclared function <tt>split</tt> when the
second parameter is not given.  The initial value of the variable is
the string <tt>"[ \t]+"</tt>.

<sect2>Pattern matching
<p>
The space <tt>re</tt> contains predeclared functions which are used
for <em>pattern matching</em>.  The pattern is described
by <em>regular expressions</em> (<em>regex</em>) and actually a small
program describing a string matching.  The pattern
has <em>default</em> syntax of ONIGURUMA package for Unicode.  It is
hard to describe formally the pattern syntax.  Here is an incomplete
strict description.  For the full reference, please see OINGURUMA
package documentation.  The regular expressions have the following
syntax:
<tscreen><verb>
          Regex = Branch {"|" Branch}
</verb></tscreen>
<p>
The regex matches anything that matches one of the <em>branches</em>.
<tscreen><verb>
          Branch = {Piece}
</verb></tscreen>
<p>
The branch matches the first <em>piece</em>, followed by the second
piece, etc.  If the pieces are omitted, the branch matches the null
string.
<tscreen><verb>
          Piece = Anchor | Unit

          Unit = Atom
               | Unit Quantifier

          Quantifier = Greedy
                     | Reluctant
                     | Possesive

          Greedy = "?"                 // 0 or 1 times
                 | "*"                 // 0 or more times
                 | "+"                 // 1 or more times
                 | Bound

          Bound = "{" Min "," Max "}" // from Min to Max times
                | "{" Min "," "}"     // at least Min times
                | "{" "," Max "}"     // equivalent to {0, Max}
                | "{" Min "}"         // given number times

          Reluctant = "??"
                    | "*?"
                    | "+?"
                    | Bound "?"

          Possesive : "?+"
                    | "*+"
                    | "++"

          Min = <unsigned integer>

          Max = <unsigned integer>
</verb></tscreen>
<p>
The <em>unit</em> followed by <tt>*</tt> matches a sequence of 0 or
more matches of the unit.  An unit followed by <tt>+</tt> matches a
sequence of 1 or more matches of the unit.  An unit followed by
<tt>?</tt> matches a sequence of 0 or 1 matches of the unit.
<p>
There is a more general construction (a <em>bound</em>) for describing
repetitions of an unit.  An unit followed by a bound containing only
one integer <tt>Min</tt> matches a sequence of exactly <tt>Min</tt>
matches of the unit.  An unit followed by a bound containing one
integer <tt>Min</tt> and a comma matches a sequence of <tt>Min</tt> or
more matches of the unit.  An unit followed by a bound containing a
comma and one integer <tt>Max</tt> matches at most <tt>Max</tt>
repetitions of the unit.  An unit followed by a bound containing two
integers <tt>Min</tt> and <tt>Max</tt> matches a sequence of
<tt>Min</tt> through <tt>Max</tt> (inclusive) matches of the unit.
<p>
The described above qualifiers are <em>greedy</em> ones.  A gready
qualifier first matches as much as possible and can back-track in a
case of the whole regex matching failure to try shorter sequence.
There are <em>reluctant</em> qualifiers too.  They have additional
suffix <tt>?</tt> and first they match as little as possible.  The
last type of the qualifiers is possesive.  Such qualifiers have
additional suffix <tt>+</tt> and behave like the corresponding greedy
ones, but they do not back-track.
<p>
       Examples:
<tscreen><verb>
          `.?foo` // matches first "xfoo" in "xfooxxxxfoo"
          `.*foo` // matches all "xfooxxxxfoo"
          `.+foo` // matches all "xfooxxxxfoo"
          `.{1,8}foo` // matches all "xfooxxxxfoo"
          `.*?foo` // matches first "xfoo" in "xfooxxxxfoo"
          `.+?foo` // Ditto
          `.{1,8}?foo` // Ditto
	  `.*+foo` // fail to match in "xfooxxxxfoo"
	  `.++foo` // fail to match in "xfooxxxxfoo"
</verb></tscreen>
<tscreen><verb>
         Atom =  Anchors
	       | Character
               | CharacterType
               | CharacterProperty
               | CharacterClass
               | Group
               | BackReference
	       | SubexpCall
	 
	  Character = "\t"     // horizontal tab (0x09)
	            | "\v"     // vertical tab (0x0B)
	            | "\n"     // newline tab (0x0A)
	            | "\r"     // return (0x0D)
	            | "\f"     // form feed (0x0C)
	            | "\a"     // bell (0x07)
	            | "\e"     // escape (0x1B)
	            | "\" OctalCode // char with given octal code
	            | "\x" HexCode  // char with given hexadecimal code
                    | <any but special character \ ? * + ^ $ [ ( ) >
                    | "\" <special character>
      
          OctalCode = <3 octal digits>
	
	  HexCode = <2 heaxadecimal digits>
	  
          CharacterType = '.'  // any character but newline
                        | "\w" // Unicode Letter, Mark, Number, or
                               //   Connector_Punctuation
                        | "\W" // opposite to the above 
                        | "\s" // Unicode Line_Separator, 
                               //   Paragraph_Separator, or
                               //   Space_Separator
                        | "\S" // opposite to the above 
                        | "\d" // Unicode decimal number 
                        | "\D" // opposite to the above 
                        | "\h" // hexadecimal digit char [0-9a-fA-F] 
                        | "\H" // opposite to the above 

          CharacterProperty = "\p{" PropertyName "}"
                            | "\p{^" PropertyName "}"
                            | "\P{" PropertyName "}"

         PropertyName = "Alnum" | "Alpha" | "Blank" | "Cntrl"
                      | "Digit" | "Graph" | "Lower" | "Print"
                      | "Punct" | "Space" | "Upper" | "XDigit"
                      | "Word" | "ASCII"
                      | "Any" | "Assigned" | "C" | "Cc" | "Cf"
                      | "Cn" | "Co" | "Cs" | "L" | "Ll" | "Lm"
                      | "Lo" | "Lt" | "Lu" | "M" | "Mc" | "Me"
                      | "Mn" | "N" | "Nd" | "Nl" | "No" | "P"
                      | "Pc" | "Pd" | "Pe" | "Pf" | "Pi" | "Po"
                      | "Ps" | "S" | "Sc" | "Sk" | "Sm" | "So"
                      | "Z" | "Zl" | "Zp" | "Zs" | "Arabic"
                      | "Armenian" | "Bengali" | "Bopomofo"
                      | "Braille" | "Buginese" |  "Buhid"
                      | "Canadian_Aboriginal" | "Cherokee"
                      | "Common" | "Coptic" | "Cypriot"
                      | "Cyrillic" | "Deseret" | "Devanagari"
                      | "Ethiopic" | "Georgian" |  "Glagolitic"
                      | "Gothic" | "Greek" | "Gujarati"
                      | "Gurmukhi" | "Han" | "Hangul" | "Hanunoo"
                      | "Hebrew" | "Hiragana" | "Inherited"
                      | "Kannada" | "Katakana" | "Kharoshthi"
                      | "Khmer" | "Lao" | "Latin" | "Limbu"
                      | "Linear_B" | "Malayalam" | "Mongolian"
                      | "Myanmar" | "New_Tai_Lue" | "Ogham"
                      | "Old_Italic" | "Old_Persian" | "Oriya"
                      | "Osmanya" | "Runic" | "Shavian" | "Sinhala"
                      | "Syloti_Nagri" | "Syriac" | "Tagalog"
                      | "Tagbanwa" | "Tai_Le" | "Tamil" | "Telugu"
                      | "Thaana" | "Thai" | "Tibetan" | "Tifinagh"
                      | "Ugaritic" | "Yi"

          Anchors = "^"           // beginning of the line
                  | "$"           // end of the line
                  | "\b"          // word boundary
                  | "\B"          // not word boundary
                  | "\A"          // beginning of string
                  | "\Z"          // end of string, or before newline
                                  //   at the end
                  | "\z"          // end of string
</verb></tscreen>
<p>
The atom can be a character.  Some characters has a special meaning in
regex (see comments in the character syntax).  The rest characters
match the same character in the matching string.  To match a special
character, use <tt>\</tt> before the character.  Some characters can
be represented by a sequence starting with <tt>\</tt> (see the syntax
comments).
<p>
       Examples:
<tscreen><verb>
          `\t`        // matches "\\t"
          `\x65`      // matches "e"
	  `\p{Alpha}` // matches "a"
	  `\w`        // matches "a"
	  `b$`        // matches "b" in "b\na"
</verb></tscreen>
<p>
The atom can be an anchor.  Matching anchors succeeds only if their
positions correspond a specific place at the matching string (see
comments in the anchor syntax).
<p>
       Examples:
<tscreen><verb>
	  `b$`        // matches "b" in "b\na"
          `abc\Z`     // matches "abc" in "abc"
          `abc\Z`     // matches "abc" in "abc\n"
</verb></tscreen>
<p>
The atom which is a character type matches a specific class of
character (see comments in the character type syntax).
<p>
The atom which is a character property matches a specific class of
characters.  For meaning <tt>Alnum</tt> - <tt>ASCII</tt>, please see
the corresponding <tt>BracketClass</tt>.  For meaning <tt>C</tt>
- <tt>Zs</tt>, please see Unicode categories.  For
meaning <tt>Armenian</tt> - <tt>Yi</tt>, please see the Unicode
scripts (alphabets).  If the property contains <tt>p</tt>
with <tt>^</tt> or <tt>P</tt>, the match succeeds when the matching
character is not of the class.
<p>
       Examples:
<tscreen><verb>
          `\p{Alpha}` // matches "a"
          `\p{ASCII}` // matches ";"
</verb></tscreen>
<p>
<tscreen><verb>
          CharacterClass = "[" Intersections "]"
                         | "[^" Intersections "]"

	  Intersections = Set
                        | Intersections "&&" Set

	  Set = SetElement
              | Set SetElement
	  
          SetElement = ElementChar ["-" ElementChar]
                     | "[:" BracketClass ":]"
                     | "[:^" BracketClass ":]"
                     | CharacterClass

	  ElementChar = Character
                      | "\b"       // backspace 0x08

          BracketClass = "alnum"   // Unicode letter, mark,
		                   //   or decimal number
                       | "alpha"   // Unicode letter or mark
                       | "ascii"   // character in range 0 - 0x7f
                       | "blank"   // Unicode space separator
       		                   //   or \t (0x09)
                       | "ctrl"    // Unicode control, format,
	                           //   unassigned, private use,
	                           //   or surrogate
                       | "digit"   // Unicode decimal number 
                       | "graph"   // not a space class and not an
	                           //   Unicode control, unassigned,
                                   //   or surrogate
                       | "lower"   // Unicode lower case letter
                       | "print"   // graph or space class
                       | "punct"   // any Unicode punctuation
                       | "space"   // any Unicode separator,
        		           //   \t (0x09), \n (0x0A), \v (0x0B),
                                   //   \f (0x0C), \r (0x0D),
	                           //   or 0x85 (next line)
                       | "upper"   // Unicode upper case letter
                       | "xdigit"  // ascii 0-9, a-f, or a-f
                       | "word"    // Unicode letter, mark, decimal
	                           //   number or punctuation connector
</verb></tscreen>
<p>
The atom can be a bracket expression which is a <em>list</em> of
intersections of character sets separated by <tt>&&</tt> and enclosed
in <tt>[]</tt>.  If the character class contains <tt>^</tt> right
after <tt>[</tt>, it matches any character which does match the
corresponding character class without <tt>^</tt>.  A set is a sequence
of set elements.
<p>
The element given by a character denotes the character itself.  An
element given by two characters in the list separated by <tt>-</tt> is
shorthand for the full <em>range</em> of characters between those two
(inclusive) in the sequence of the unicode codes, e.g. <tt>[0-9]</tt>
matches any decimal digit.  Besides the usual character representation
you can use here also <tt>\b</tt> which is a backspace representation.
<p>
The element given by a bracket class enclosed in <tt>[[::]]</tt> matches a
character from this class (see comments in BracketClass).  If
character <tt>^</tt> is present right after <tt>[[:</tt>, the match
succeeds if the character is not in this class.
<p>
The element can be given by a character class, in other words the
character clases can be nested.
<p>
If you need to use <tt>[</tt>, <tt>-</tt>, or <tt>]</tt> as a normal
character in a character class, you can use prefix <tt>\</tt> for
this.
<p>
       Examples:
<tscreen><verb>
          `[[:alpha:]]`  // matches "a"
          `[[[:lower:]]&&[^a-x]]` // matches "y" or "z"
</verb></tscreen>
<p>
The atom can be a group, a regular expression enclosed in <tt>()</tt>.
There are several types of groups:
<tscreen><verb>
          Group = CapturedGroup
                | NonCapturedGroup
                | "(?#" <any characters but )> ")" // a comment
                | "(?" Options ")"
                | Context
          
          Options =
                  | Options Option

          Option = "-" | "i" | "m" | "x"

          CapturedGroup = "(" [Regex] ")"
                        | "(?<" Name ">" [Regex] ")"
 
          Name = <one or more word character>

          NonCapturedGroup = "(?" Options ":" [Regex] ")"
                           | "(?>" [Regex] ")" /* Atomic group */
                           
          Context = "(?=" [Regex] ")" // look ahead
                  | "(?!" [Regex] ")" // negative look ahead
                  | "(?<=" [Regex] ")" // look behind
                  | "(?<!" [Regex] ")" // negative look behind

          BackReference = "\" Number    // back ref. by group
                                        //   number
                        | "\k<" Number ">" // back ref. by group
                                           //   number
                        | "\k<-" Number ">" // back ref. by relative
                                            //   group number
                        | "\k<" Name ">" // back ref. by group name
	                // back ref. by group name and nest level:
                        | "\k<" Name "+" | "-" Number ">"

          Number = <any integer >= 0>
				    
</verb></tscreen>
<p>
Some groups are captured groups.  It means that you can refer the
substrings they match (see the back references) or get the start and
the end positions of the matched substrings by calling the Dino regex
match functions.  A captured group may have a name which can be used
in the back references or in the subexp calls.
<p>
You can place comments not containing <tt>)</tt> in regex
betweeen <tt>(?#</tt> and <tt>)</tt>.
<p>
Options without a regex always matches.  They just change how matching
works.  The option <tt>i</tt> switches on igoring the letter cases
during the match.  The pption <tt>m</tt> makes <tt>.</tt> to match a
newline too.  The option <tt>x</tt> switches on ignoring the white
spaces as a character atom and permits to add comments starting
with <tt>#</tt> and ending at the end of line.  The
character <tt>-</tt> after the corresponding <tt>?</tt> has an
opposite effect, e.g. it makes a letter case important in matching
again etc.
<p>
You can define the options in non captured groups.  These options
affect only this group.  Another form of non-captured group is an
atomic group.  Once regex in an atomic group mathes something, the
matching stays the same during back-tracking.
<p>
       Examples:
<tscreen><verb>
          `(?i:ab)`     // matches "Ab"
          `(?x: a a a)` // matches "aaa"
          `(?>.*)c`     // can not match "abc"
</verb></tscreen>
<p>
The atom can be a context.  A context match does not advance the
current position in a matching string.  A look ahead context succeeds
if the corresponding regex matches a sub-string starting from the
current position.  A look behind context succeeds if the corresponding
regex matches a sub-string finishing right before the current
position.  There are negative forms of the context atom.  They succeed
when the corresponding regex does not match.
<p>
       Examples:
<tscreen><verb>
          `(?=bcd)bc`   // matches "bc" in "aabcd"
          `(?<=aa)bc`   // matches "bc" in "aabc"
</verb></tscreen>
<p>
The atom can be a back reference.  It refers to the matched string of
the corresponding captured group.  The captured groups are counted by
their left parantheses starting from one going from left to right.
The negative number denotes relative order number, in other words, the
order is taken starting from the back reference going from right to
left.  If the captured group has a name, its matched string can be
referenced by its name.  If several group has the same name, the name
in the back reference corresponds to the last such group.  You can add
a nest level to the name.  If the nest level is zero it is the same as
named back reference without nested level.  A back reference with
non-zero nest level never matches.
<p>
       Examples:
<tscreen><verb>
          `(a)\k<1>`     // matches "aa"
          `(?<p>a)\k<p>` // Ditto
</verb></tscreen>
<p>
The Atom can be a subexp call:
<tscreen><verb>
          SubexpCall = "\g<" Name ">"
</verb></tscreen>
<p>
The subexp call is actually another occurence of the group it refers to.
But if the call is in the group it refers, it is a recursive
description.  Only left recursion is not permitted as this results in
never ending recursion.
<p>
       Examples:
<tscreen><verb>
          `(?<p>cd)\g<p>`   // matches "cdcd"
          `(?<p>a|b\g<p>c)` // matches "a", "bac", "bbacc" etc
          `(?<p>a|b\g<p>c)` // wrong left recursion.
</verb></tscreen>
<p>
There are the following pattern matching functions in
the space <tt>re</tt>:
     <itemize>
     <item><tt>match (regex, string)</tt>.  The function searches for
       matching the regular expression <tt>regex</tt> in the
       <tt>string</tt>.  The both parameters should be strings after
       their implicit string conversions.
       <p>
       The matching is made according to the standard POSIX 1003.2:
       The regular expression matches the substring starting earliest
       in the string.  If the regular expression could match more than
       one substring starting at that point, it matches the longest.
       Subexpressions also match the longest possible substrings,
       subject to the constraint that the whole match be as long as
       possible, with subexpressions starting earlier in the regular
       expression taking priority over ones starting later.  In other
       words, higher-level subexpressions take priority over their
       component subexpressions.  Match lengths are measured in
       characters, not the collating elements.  A null string is
       considered longer than no match at all.
       <p>
       If there is no matching, the function returns the
       value <tt>nil</tt>.  Otherwise, the function returns a new
       mutable vector of integers.  The length of the vector is <tt>2
       * (N + 1)</tt> where <tt>N</tt> is the number of the captured
       groups.  The first two elements are the index of the first
       character of the substring corresponding to the whole regular
       expression and the index of the last character matched plus
       one.  The subsequent two elements are the index of the first
       character of the substring corresponding to the first captured
       group in the regular expression and the index of the last
       character plus one, and so on.  If there is no matching with a
       captured group, the corresponding vector elements will have
       negative values.
       <p>
       Example: The program
<tscreen><verb>
          println (re.match (`\n()(a)((a)(a))`, "b\naaab"));
</verb></tscreen>
<p>
       outputs
<tscreen><verb>
          [1, 5, 2, 2, 2, 3, 3, 5, 3, 4, 4, 5]
</verb></tscreen>
     <item><tt>gmatch (regex, string[, flag])</tt>.  The function
       searches for different occurrences of the regular expression
       <tt>regex</tt> in <tt>string</tt>.  Both parameters should be
       strings after their implicit string conversion.  The third
       parameter is optional.  If it is present, it should be integer
       after an implicit integer conversion.  If its value is nonzero,
       the substrings matched by regex can be overlapped.  Otherwise,
       the substrings are never overlapped.  If the parameter is
       absent, the function behaves as its value were zero.  The
       function returns a new mutable vector of integers.  The length
       of the vector is <tt>2 * N</tt> where <tt>N</tt> is number of
       the found occurrences.  Pairs of the vector elements correspond
       to the occurrences.  The first element of the pairs is an index
       of the first character of substring corresponding to all
       regular expression in the corresponding occurrences and the
       second element is an index of the last character plus one.  If
       there is no one occurrence, the function returns <tt>nil</tt>.
       <p>
       Example: The program
<tscreen><verb>
          println (re.gmatch (`aa`, "aaaaa"));
          println (re.gmatch (`aa`, "aaaaa", 1));
</verb></tscreen>
<p>
       outputs
<tscreen><verb>
          [0, 2, 2, 4]
          [0, 2, 1, 3, 2, 4, 3, 5]
</verb></tscreen>
     <item><tt>sub (regex, string, subst)</tt>.  The function searches
       for substrings matching the regular expression <tt>regex</tt>
       in <tt>string</tt>.  All parameters should be string after an
       implicit string conversion.
       <p>
       If there is no matching, the function returns the
       value <tt>nil</tt>.  Otherwise, the function returns a new
       mutable vector of characters in which the first substring
       matched has been changed to the string <tt>subst</tt>.  Within
       the replacement string <tt>subst</tt>, the
       sequence <tt>\n</tt>, where <tt>n</tt> is a digit from 1 to 9,
       may be used to indicate the text that matched the
       <tt>n</tt>'th captured group of the regex.  The sequence
       <tt>\0</tt> represents the entire matched text, as does the
       character <tt>&</tt>.
     <item><tt>gsub (regex, string, subst)</tt>.  The function is
       analogous to the function <tt>sub</tt> except for the function
       searches for all non-overlapping substrings matched with the
       regular expression and returns a new mutable vector of
       characters in which all matched substrings have been changed to
       the string <tt>subst</tt>.
     <item><tt>split (string [, regex])</tt>.  The function splits
       <tt>string</tt> into non-overlapped substrings separated in the
       input string by strings matching the regular expression.  All
       parameters should be strings after an implicit string
       conversion.  If the second parameter is omitted the value of
       the predeclared variable <tt>split_regex</tt> is used instead
       of the second parameter value.  In this case the function may
       generate the exception <tt>invenvar</tt> (corrupted value of a
       predeclared variable).
       <p>
       The function returns a new mutable vector with the elements
       which are the separated substrings.  If the regular expression
       is the null string, the function returns a new mutable vector
       with the elements which are strings each containing one
       character of string.
       <p>
       Examples: The program
<tscreen><verb>
          println (re.split ("aaa bbb ccc	ddd"));
</verb></tscreen>
<p>
       outputs
<tscreen><verb>
          ["aaa", "bbb", "ccc", "ddd"]
</verb></tscreen>
<p>
       The program
<tscreen><verb>
          println (re.split ("abcdef", ``));
</verb></tscreen>
<p>
       outputs
<tscreen><verb>
          ["a", "b", "c", "d", "e", "f"]
</verb></tscreen>
     </itemize>
<p>
If the regular expression is incorrect, the functions generate the
exception <tt>invregex</tt> with a message explaining the error.

<sect1>Space <tt>math</tt>
<p>
The space contains mostly mathematical functions.

<sect2>Mathematical functions
<p>
The following functions make an implicit arithmetic conversion of the
parameters.  After the conversions the parameters are expected to be
of integer, long integer, or floating point type.  The result is
always a floating point number.
     <itemize>
     <item><tt>sqrt (x)</tt>.  The function returns the square root of
       <tt>x</tt>.  The function generates the exception <tt>edom</tt>
       if <tt>x</tt> is negative.
     <item><tt>exp (x)</tt>.  The function returns <tt>e</tt> (the
       base of the natural logarithm) raised to the power of
       <tt>x</tt>.
     <item><tt>log (x)</tt>.  The function returns the natural
       logarithm of <tt>x</tt>.  The function generates the exception
       <tt>edom</tt> if <tt>x</tt> is negative or may generate
       <tt>erange</tt> if the value is zero.
     <item><tt>log10 (x)</tt>.  The function returns the decimal
       logarithm of <tt>x</tt>.  The function generates the exception
       <tt>edom</tt> if <tt>x</tt> is negative or may generate
       <tt>erange</tt> if the value is zero.
     <item><tt>pow (x, y)</tt>.  The function returns <tt>x</tt>
       raised to the power of <tt>y</tt>.  The function generates
       exception <tt>edom</tt> if x is negative and y is not of
       integral value.
     <item><tt>sin (x)</tt>.  The function returns the sine of
       <tt>x</tt>.
     <item><tt>cos (x)</tt>.  The function returns the cosine of
       <tt>x</tt>.
     <item><tt>atan2 (x, y)</tt>.  The function returns the arc
       tangent of the two variables <tt>x</tt> and <tt>y</tt>.  It is
       similar to calculating the arc tangent of <tt>y / x</tt>,
       except that the signs of both arguments are used to determine
       the quadrant of the result.
     </itemize>

<sect2>Other space <tt>math</tt> functions
<p>
There are the following miscellaneous functions:
     <itemize>
     <item><tt>max (v1, v2, ...)</tt>.  The function searches for and
       returns the maximal value in all of its parameters.  The
       parameters should be of integer, long integer, or floating
       point type after an implicit arithmetic conversion.  So the
       function can return an integer, a long integer, or floating
       point number depending on the type of the first maximal value
       after the conversion.
     <item><tt>min (v1, v2, ...)</tt>.  The function is analogous to
       the previous function, but searches for and returns the minimal
       value.
     <item><tt>srand ([seed])</tt>.  The function sets the parameter
       value (after an implicit integer conversion) as a seed for a
       new sequence of pseudo-random integers to be returned by
       <tt>rand</tt>.  These sequences are repeatable by calling
       <tt>srand</tt> with the same seed value.  If the parameter is
       not given, the seed will be the result of calling function
       <tt>time</tt>.
     <item><tt>rand ()</tt>.  The function returns a pseudo-random
       floating point value between 0 and 1.  If the function
       <tt>srand</tt> was not called before, 1 will be used as the
       seed value.
     </itemize>

<sect1>Space <tt>yaep</tt>
<p>
This space contains declarations to work with Yet Another Earley
Parser (YAEP).  YAEP is a very powerful tool to implement language
compilers, processors, or translators.  The implementation of the
Earley parser used in Dino has the following features:
     <itemize>
     <item>It is sufficiently fast and does not require much memory.
       This is the fastest implementation of the Earley parser which I
       know.  The main design goal was to achieve a speed and memory
       requirements which are necessary to use it in prototyping
       compilers and language processors.  It can parse 300,000 lines
       of C code per second on modern computers and allocates about
       5MB memory for a 10,000 line C program.
     <item>It makes a simple syntax directed translation, so an
       abstract tree is already the output of the Earley parser.
     <item>It can parse input described by an ambiguous grammar.  In
       this case the parse result can be an abstract tree or all
       possible abstract trees.  Moreover, it produces the compact
       representation of all possible parse trees by using DAG instead
       of real trees.  These features can be used to parse natural
       language sentences.
     <item>It can make a syntax error recovery.  Moreover its error
       recovery algorithms find an error recovery with a minimal
       number of ignored tokens.  It permits an implemention of
       parsers with very good error recovery and reporting.
     <item>It has a fast startup.  There is practically no delay between
       processing of the grammar and the start of parsing.
     <item>It has a flexible interface.  The input grammar is given by
       a YACC-like description.
     <item>It has a good debugging features.  It can print huge amount
       of information about grammar, parsing, error recovery,
       translation.  You can even get the result translation in a form
       for a graphic visualization program.
     </itemize>

<sect2>Exception classes of space <tt>yaep</tt>
<p>
The space <tt>yaep</tt> contains the class <tt>invparser</tt> which is
a sub-class of <tt>invcall</tt>.  The following sub-classes of the
class <tt>invparser</tt> describe exceptions specific for the work with
YAEP.
     <itemize>
     <item><tt>invgrammar</tt>.  This class describes an exception
       that the Earley parser got a bad grammar, e.g. without rules,
       with loops in rules, with nonterminals unachievable from the
       axiom, with nonterminals not deriving any terminal string etc.
     <item><tt>invtoken</tt>.  This class describes an exception that
       the parser got an input token with unknown (undeclared) code.
     <item><tt>pmemory</tt>.  This class describes an exception that
       there is not enough memory for the internal parser data.
     </itemize>

<sect2>Class parser
<p>
The space <tt>yaep</tt> has the predeclared final class <tt>parser</tt> which
implements Earley parser.  The following public functions and
variables are declared in the class <tt>parser</tt>:
     <itemize>
     <item><tt>ambiguous_p</tt>.  This public variable stores
       information about the last parsing.  A nonzero variable value
       means that during the last parsing on a given inputm the parser
       found that the grammar is ambiguous.  The parser can find this
       even if you asked for only one parser tree (see the function
       <tt>set_one_parse</tt>).

     <item><tt>set_grammar (descr, strict_p)</tt>.  This function
       tunes the parser to given grammar.  The grammar is given by
       the string <tt>descr</tt>.  A nonzero value of the parameter
       <tt>strict_p</tt> (after an implicit integer conversion) means
       more strict grammer checking.  In this case, all nonterminals
       will be checked on their ability to derive a terminal string
       instead of only checking the axiom for this.  The function can
       generate the exceptions <tt>partype</tt> (if the parameters
       have wrong types) or <tt>invgrammar</tt> if the description is
       a bad grammar.  The function can also generate the
       exception <tt>pmemory</tt> if there is no memory for the
       internal parser data.

       The description is similiar to the <em>YACC</em> one.  It has
       the following syntax:
       <tscreen><verb>
          file : file terms [';']
               | file rule
               | terms [';']
               | rule
       
          terms : terms IDENTIFIER ['=' NUMBER]
                | TERM
       
          rule : IDENTIFIER ':' rhs [';']
          
          rhs : rhs '|' sequence [translation]
              | sequence [translation]
          
          sequence :
                   | sequence IDENTIFIER
                   | sequence C_CHARACTER_CONSTANT
          
          translation : '#'
                      | '#' NUMBER
                      | '#' '-'
                      | '#' IDENTIFIER [NUMBER] '(' numbers ')'
          
          numbers :
                  | numbers NUMBER
                  | numbers '-'
       </verb></tscreen>
       <p>
       So the description consists of terminal declaration and
       rule sections.
       <p>
       The terminal declaration section describes the names of
       terminals and their codes.  The terminal code is optional.  If
       it is omitted, the terminal code will the next free code
       starting with 256.  You can declare a terminal several times
       (the single condition is that its code should be the same).
       <p>
       A character constant present in the rules is a terminal
       described by default.  Its code is always the ASCII code of the
       character constant.
       <p>
       The rules syntax is the same as <em>YACC</em> rule syntax.  The
       single difference is an optional translation construction
       starting with <tt>#</tt> right after each alternative.  The
       translation part could be a single number which means that the
       translation of the alternative will be the translation of the
       symbol with the given number (symbol numbers in the alternative
       start with 0).  Or the translation can be empty or
       `<tt>-</tt>' which designates the value of the variable
       <tt>nil_anode</tt>.  Or the translation can be an abstract node
       with the given name, optional cost, and with the fields whose
       values are the translations of the alternative symbols with
       numbers given in parentheses after the abstract node name.  You
       can use `<tt>-</tt>' in an abstract node to show that the empty
       node should be used in this place.  If the cost is absent it is
       believed to be 1.  The cost of the terminal, error node, and
       empty node is always zero.
       <p>
       There is a reserved terminal <tt>error</tt> which marks the
       start point of an error recovery.  The translation of the
       terminal is the value of the variable <tt>error_anode</tt>.
     <item><tt>set_debug (level)</tt>.  This function sets up the
       level of debugging information output to <tt>stderr</tt>.  The
       higher the level, the more information is output.  The default
       value is 0 (no output).  The debugging information includes
       statistics, the result translation tree, the grammar, parser
       sets, parser sets with all situations, situations with
       contexts.  The function returns the previously set up debug
       level.  Setting up a negative debug level results in output of
       the translation for the utility <bf>dot</bf> of the graphic
       visualization package <bf>graphviz</bf>.  The parameter should
       be an integer after an implicit integer conversion.  The
       function will generate the exception <tt>partype</tt> if it is
       not true.
     <item><tt>set_one_parse (flag)</tt>.  This function sets up a
       flag whose nonzero value means building only one translation
       tree (without any alternative nodes).  For an unambiguous
       grammar the flag does not affect the result.  The function
       returns the previously set up flag value.  The default value of
       the flag is 1.  The parameter should be an integer after an
       implicit integer conversion.  The function will generate
       the exception <tt>partype</tt> if it is not true.
     <item><tt>set_lookahead (flag)</tt>.  This function sets up a
       flag of usage of a look ahead in the parser work.  The usage
       of the lookahead gives the best results with the point of view of
       the space and speed.  The default value is 1 (the lookahead usage).
       The function returns the previously set up flag.  No usage of
       the lookahead is useful sometimes to get more understandable
       debug output of the parser work (see the function
       <tt>set_debug</tt>).  The parameter should be an integer after
       an implicit integer conversion.  The function will generate the
       exception <tt>partype</tt> if it is not true.
     <item><tt>set_cost (flag)</tt>.  This function sets up building
       the only translation tree (trees if we set up one_parse_flag to
       0) with minimal cost.  For an unambiguous grammar the flag does
       not affect the result.  The default value is 0. The function
       returns the previously set up flag value.  The parameter should
       be an integer after an implicit integer conversion.  The
       function will generate the exception <tt>partype</tt> if it is
       not true.
     <item><tt>set_recovery (flag)</tt>.  This function sets up a flag
       whose nonzero value means making error recovery if a syntax
       error occurred.  Otherwise, a syntax error results in finishing
       parsing (although the syntax error function passed to
       <tt>parse</tt> still be called once).  The function returns the
       previously set up flag value.  The default value of the flag is
       1.  The parameter should be an integer after an implicit
       integer conversion.  The function will generate the exception
       <tt>partype</tt> if it is not true.
     <item><tt>set_recovery_match (n_toks)</tt>.  This function sets
       up an internal parser parameter meaning how much subsequent
       tokens should be successfully shifted to finish the error
       recovery.  The default value is 3.  The function returns the
       previously set up value.  The parameter should be an integer
       after an implicit integer conversion.  The function will
       generate the exception <tt>partype</tt> if it is not true.

     <item><tt>parse (tokens, error_func)</tt>. This function is the
       major function of the class.  It makes the translation
       according to the previously set up grammar of input given by
       the parameter <tt>tokens</tt> whose value should be an array of
       objects of predeclared class <tt>token</tt> or of its subtype.
       If the parser recognizes a syntax error it calls the function
       given through parameter <tt>error_func</tt> with six
       parameters:
          <itemize>
          <item>an index of the token (in the array <tt>tokens</tt>)
            on which the syntax error occured.
          <item>the error token itself.  It may be <tt>nil</tt> for
            end of file.
          <item>an index of the first token (in the
            array <tt>tokens</tt>) ignored due to error recovery.
          <item>the first ignored token itself.  It may be
            <tt>nil</tt> for end of file.
          <item>an index of the first token (in the
            array <tt>tokens</tt>) which is not ignored after the
            error recovery.
          <item>the first not ignored token itself.  It may be
            <tt>nil</tt> for end of file.
          </itemize>
       <p>
       If the parser works with switched off error recovery (see the
       function <tt>set_recovery</tt>, the third and fifth parameters
       will be negative and forth and sixth parameter will be
       <tt>nil</tt>.
       <p>
       The function returns an object of the predeclared class
       <tt>anode</tt> which is the root of the abtsract tree
       representing the translation of the parser input.  The function
       returns <tt>nil</tt> only if a syntax error was occurred and
       the error recovery was switched off.  The function can generate
       the exception <tt>partype</tt> if the parameter types are wrong
       or the exception <tt>invtoken_decl</tt> if any of the input
       tokens have a wrong code.  The function also can generate teh
       exception <tt>pmemory</tt> if there is no memory for the
       internal parser data.
     </itemize>

The call of the class <tt>parser</tt> itself can generate the
exception <tt>pmemory</tt> if there is no memory for the internal
parser data.

<sect2>Class <tt>token</tt>
<p>
The space <tt>yaep</tt> has a predeclared class <tt>token</tt>.
Objects of this class should be the input of the Earley parser (see
the function <tt>parse</tt> in the class <tt>parser</tt>).  The result
abstract tree representing the translation will have input tokens as
leaves.  The class <tt>token</tt> has one public
variable <tt>code</tt> whose value should be the code of the
corresponding terminal described in the grammar.  You could extend the
class description e.g. by adding variables whose values could be
attributes of the token (e.g. a source line number, the name of an
identifier, or the value for a number).

<sect3>Class <tt>anode</tt>
<p>
The space <tt>yaep</tt> has a predeclared class <tt>anode</tt> whose
objects are nodes of the abtract tree representing the translation
(see teh function <tt>parse</tt> of class <tt>parser</tt>).  Objects
of this class are generated by Earley parser.  The class has two
public variables <tt>name</tt> whose value is a string representing a
name of the abstract node as it given in the grammar
and <tt>transl</tt> whose value is an array with abstract node fields
as the array elements.  There are a few node types which have special
meaning:

     <itemize>
     <item>A terminal node which has the reserved name <tt>$term</tt>.
       The value of the public variable <tt>transl</tt> for this node
       is an object of the class <tt>token</tt> representing the
       corresponding input token which was an element of the array
       passed as a parameter of the function <tt>parse</tt>.
     <item>An error node which has the reserved name <tt>$error</tt>.
       This node exists in one exemplar (see description of the
       variable <tt>error_anode</tt>) and represents the translation
       of the reserved grammar symbol <tt>error</tt>.  The value in
       the public variable <tt>transl</tt> will be <tt>nil</tt> in
       this case.
     <item>An empty node which has the reserved name <tt>$nil</tt>.
       This node also exists in one exemplar (see description of the
       variable <tt>nil_anode</tt>) and represents the translation of
       a grammar symbol for which we did not describe a translation.
       For example, in a grammar rule an abstract node refers for the
       translation of a nonterminal for which we do not produce a
       translation.  The value in the public variable of such class
       object will be <tt>nil</tt> in this case.
     <item>An alternative node which has the reserved name <tt>$alt</tt>.
       It represents all possible alternatives in the translation of
       the grammar nonterminal.  The value of the public variable
       <tt>transl</tt> will be an array with elements whose values are
       objects of the class <tt>anode</tt> which represent all
       possible translations.  Such nodes can be generated by the
       parser only if the grammar is ambiguous and we did not ask it
       to produce only one translation.
     </itemize>

<sect2>Variables <tt>nil_anode</tt> and <tt>error_anode</tt>
<p>
There is only one instance of <tt>anode</tt> which represents empty
(nil) nodes.  The same is true for the error nodes.  The final
variables <tt>nil_anode</tt> and <tt>error_anode</tt> correspondingly
refer to these nodes.

<sect2>Example of Earley parser usage.
<p>
Let us write a program which transforms an expression into the postfix
polish form.  Please, read the program comments to understand what the
code does.  The program should output string <tt>"abcda*+*+"</tt>
which is the postfix polish form of input string
<tt>"a+b*(c+d*a)"</tt>.
<tscreen><verb>
          expose yaep.*;
          // The following is the expression grammar:
          var grammar = "E : E '+' T   # plus (0 2)\n\
                           | T         # 0\n\
                           | error     # 0\n\
                         T : T '*' F   # mult (0 2)\n\
                           | F         # 0\n\
                         F : 'a'       # 0\n\
                           | 'b'       # 0\n\
                           | 'c'       # 0\n\
                           | 'd'       # 0\n\
                           | '(' E ')' # 1";
          // Create the parser and set up the grammar.
          var p = parser ();
          p.set_grammar (grammar, 1);

          // Add attribute repr to the token:
          class our_token (code) { use token former code; var repr; }
          // The following code forms input tokens from the string:
          var str = "a+b*(c+d*a)";
          var i, inp = [#str : nil];
          for (i = 0; i < #str; i++) {
            inp [i] = our_token (str[i] + 0);
            inp [i].repr = str[i];
          }
          // The following function outputs messages about the syntax errors
          // and the syntax error recovery:
          fun error (err_start, err_tok,
                      start_ignored_num, start_ignored_tok_attr,
	              start_recovered_num, start_recovered_tok) {
            put ("syntax error on token #", err_start,
                 " (" @ err_tok.code @ ")");
            putln (" -- ignore ", start_recovered_num - start_ignored_num,
                   " tokens starting with token #", start_ignored_num);
          }

          var root = p.parse (inp, error); // parse

          // Output the translation in the polish inverse form
          fun pr (r) {
            var i, n = r.name;

            if (n == "$term")
              put (r.transl.repr);
            else if (n == "mult" || n == "plus") {
              for (i = 0; i < #r.transl; i++)
                pr (r.transl [i]);
              put (n == "mult" ? "*" : "+");
            }
            else if (n != "$error") {
              putln ("internal error");
	      exit (1);
            }
          }

          pr (root);
          putln ();
</verb></tscreen>


<sect>Appendix A. The Dino syntax
<p>
<tscreen><verb>
Expr = Expr "?"  Expr ":" Expr
     | Expr "||"  Expr
     | Expr "&&"  Expr
     | Expr in  Expr
     | Expr "|"  Expr
     | Expr "^"  Expr
     | Expr "&"  Expr 
     | Expr "=="  Expr  
     | Expr "!="  Expr  
     | Expr "==="  Expr  
     | Expr "!=="  Expr  
     | Expr "<"  Expr
     | Expr ">"  Expr  
     | Expr "<="  Expr
     | Expr ">="  Expr 
     | Expr "<<"  Expr
     | Expr ">>"  Expr
     | Expr ">>>"  Expr
     | Expr "@"  Expr
     | Expr "+"  Expr
     | Expr "-"  Expr
     | Expr "*"  Expr
     | Expr "/"  Expr
     | Expr "%"  Expr
     | "!"  Expr
     | "+"  Expr
     | "-"  Expr
     | "~"  Expr
     | "#"  Expr
     | final  Expr
     | new  Expr
     | ".+"  Expr
     | ".*"  Expr
     | ".&"  Expr
     | ".^"  Expr
     | ".|"  Expr
     | Designator
     | INTEGER
     | FLOATINGPOINTNUMBER
     | CHARACTER
     | nil
     | "(" Expr ")"
     | Call
     | "["  ElistPartsList "]"
     | tab "["  ElistPartsList "]"
     | STRING
     | char
     | int
     | long
     | float
     | hide
     | hideblock
     | vec
     | tab
     | fun
     | fiber
     | class
     | obj
     | thread
     | type
     | this
     | char "(" Expr ")"
     | int "(" Expr ")"
     | float "(" Expr ")"
     | vec "(" Expr ["," Expr] ")"
     | tab "(" Expr ")"
     | type "(" Expr ")"
     | AnonHeader FormalParameters Block
     | try "(" ExecutiveStmt [ ","  ExceptClassList] ")"
     | "_"
     | "..."

Designator = DesignatorOrCall "["  Expr "]"
           | DesignatorOrCall ActualParameters
           | DesignatorOrCall "."  IDENT
           | IDENT

ElistPartsList = [ Expr [ ":" Expr ] {"," Expr [ ":" Expr ] } ]
       	
DesignatorOrCall = Designator
                 | Call

Call = Designator ActualParameters

ActualParameters = "(" [ Expr { "," Expr } ] ")"
       	
AnonHeader = [Qualifiers] FuncFiberClass
			  
Stmt = ExecutiveStmt
     | Declaration

Assign = "="
       | "*="
       | "/="
       | "%="
       | "+="
       | "-="
       | "@="
       | "<<="
       | ">>="
       | ">>>="
       | "&="
       | "^="
       | "|="

Pattern = Expr

ExecutiveStmt = ";"
              | Expr ";"
              | Designator Assign  Expr ";"
              | Designator ("++" | "--")  ";"
              | ("++" | "--")  Designator ";"
              | if  "(" Expr ")" Stmt [ else Stmt ]
              | for  "(" Stmt ForGuardExpr ";"  Stmt ")" Stmt
              | for  "(" Designator in Expr ")" Stmt
	      | (pmatch | rmatch) "(" Expr ")" "{" CaseList "}"
	      | break ";"
              | continue ";"
              | return  [ Expr ] ";"
              | throw  Expr ";"
              | wait  "(" Expr ")" Stmt
              | BlockStmt
              | TryBlockStmt
              | C_CODE

ForGuardExpr = [Expr]

CaseList = { case Pattern [CaseCond] ":" StmtList }
CaseCond = if Expr
		  
BlockStmt = Block

TryBlockStmt = try Block { Catch }
       	
Catch = catch  "(" ExceptClassList ")" Block

ExceptClassList = Expr { "," Expr }

Declaration = VarDeclarations
            | FriendClause
            | ExternDeclarations
            | FuncClassDeclaration
            | SingletonObject
            | ForwardDeclaration
            | ExposeClause
            | UseClause
            | IncludeDeclaration

VarDeclarations =  [pub | priv] (val | var)  VarList ";"

VarList = Var { "," Var }
       	
Var = IDENT | pattern "="  Expr

ExternDeclarations = [pub | priv] extern ExternItems ";"

FuncClassDeclaration = Header FormalParameters Hint Block

Hint = [ "!" IDENT ]

FriendClause = friend IDENT { "," IDENT } ";"
     	
IncludeDeclaration = include ["+"] STRING ";"

ExternItems = ExternItem { "," ExternItem }

ExternItem = IDENT 
           | IDENT  "(" ")"

Header = [Qualifiers] FuncFiberClass IDENT

Qualifiers = pub | priv | final
           | pub final | priv final
           | final pub | final priv

FuncFiberClass = fun 
       	       | fiber 
       	       | class 
      	
FormalParameters =
                 | "(" [ ParList ] ")"
       	         | "(" ParList "," "..." ")"
       	         | "(" "..." ")"
       	
ParList = Par { "," Par}

Par = [pub | priv] [val | var] IDENT [ "=" Expr]

ExposeClause = expose ExposeItem { "," ExposeItem }

ExposeItem = QualIdent ["(" IDENT ")"] | QaulIdent ".*"

QualIdent = IDENT {"." IDENT}

UseClause = use IDENT { UseItemClause }

UseItemClause = [former | later] UseItem { "," UseItem }

Item = IDENT [ "(" IDENT ")"]

Block = "{"  StmtList "}"

StmtList = { Stmt }
       	
Program = StmtList
</verb></tscreen>

<sect>Appendix B. Implementation
<p>
<tscreen><verb>
%%%
</verb></tscreen>
</article>
