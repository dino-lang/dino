<!doctype linuxdoc system>
<article>

<!-- Title information -->

<title>The Programming Language DINO
<author>Vladimir Makarov, <tt>vmakarov@gcc.gnu.org</tt>.
Edited by Serhei Makarov.
<date>Dec. 16, 2015
<abstract>
This document describes the programming language DINO.
</abstract>
<toc>

<sect>Introduction
<p>
DINO is a high level dynamic-typed scripting language.  DINO is
designed taking such design principles as simplicity, uniformity, and
expressiveness into account.  Dino is oriented on the same domain of
applications as the famous scripting languages Perl, TCL, and Python.
Most programmers know the C programming language.  Therefore Dino aims
to look like C where it is possible.  Dino is an object oriented
language with garbage collection.  Dino has possibilities of
concurrency execution and exception handling.  Dino is an extensible
language with the possibility of dynamic loading of libraries written
on other languages.  The high level structures of Dino are
    <itemize>
    <item>heterogenous extensible vectors
    <item>extensible associative tables with the ability to delete
      table elements
    <item>objects
    </itemize>
Originally, Dino was used in the russian graphics company ANIMATEK for
description of the movement of dinosaurs in a project.  It has been
considerably redesigned and was implemented with the aid of the COCOM
tool set.
<p>
This document is not intended for use as a programmer's tutorial.  It
is a concise description of the language DINO and can be used as a
programmer's reference.

<sect>Syntax
<p>
An extended Backus-Naur Formalism (EBNF) is used to describe the
syntax of Dino.  Alternatives are separated by <tt>|</tt>.  Brackets
<tt>[</tt> and <tt>]</tt> denote optionality of the enclosed
expression, and braces <tt>{</tt> and <tt>}</tt> denote repetition
(zero or more times).  Parentheses <tt>(</tt> and <tt>)</tt> are used
for grouping a EBNF construction containing alternatives inside it as
one construction.
<p>
Terminal symbols denoting a class of terminals (e.g. identifier)
consist of only upper-case letters (e.g. IDENT).  The remaining
terminal symbols either start with a lower-case letter (e.g. keyword
else), or are denoted by ASCII character sequences in double quotes
(e.g. <tt>"=="</tt>).  Non-terminal symbols start with an upper-case
letter and contain at least one lower-case letter
(e.g. FormalParameters).


<sect>Vocabulary and Representation
<p>
Wherever it is possible, we use also EBNF for description of lexical
symbols through ASCII set characters.  Otherwise, we will use natural
language sentences in <tt><</tt> and <tt>></tt>.  Lexical symbols are
identifiers, numbers, character constants, strings, operators,
delimiters, and comments.  White characters (blanks and line breaks)
must not occur within the symbols (except in comments, and blanks in
strings).  White characters are ignored unless they are essential to
separate two consecutive lexical symbols.  Upper- and lower-case
letters are considered to be distinct.
     <enum>

     <item>An <em>identifier</em> is a sequence of letters and digits
        starting with a letter.  The underline is believed to be a
        valid letter in an identifier.  A single underline is fixed
        for other usage (see wildcard in section "Patterns").
<tscreen><verb>
          Ident = Letter {Letter | Digit}

          Letter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j"
                 | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t"
                 | "u" | "v" | "w" | "x" | "y" | "z"
                 | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
                 | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
                 | "U" | "V" | "W" | "X" | "Y" | "Z"
                 | "_"

          OctalDigit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7"

          Digit = OctalDigit | "8" | "9"

          HexDigit = Digit | "a" | "A" | "b" | "B" | "c" | "C"
	           | "d" | "D" | "e" | "E" | "f" | "F"
	            
</verb></tscreen>
        Examples:
<tscreen><verb>
          line  line2  next_line  NextLine
</verb></tscreen>

     <item><em>Numbers</em> are (unsigned) integer or floating point
        numbers.  Numbers start with a digit.  Numbers starting with
        prefix <tt>0x</tt> or <tt>0X</tt> are hexadecimal integer
        numbers.  Otherwise integer numbers starting with <tt>0</tt>
        are octal integer numbers.  Octal integer numbers should not
        contain <tt>8</tt> or <tt>9</tt>.  If an integer number has
        suffix <tt>l</tt> or <tt>L</tt>, it is a long number (see long
        values in section "Types and Values").  Floating point numbers
        are distinguished from decimal integer numbers by the presence
        of decimal point <tt>.</tt> or an exponent in the number.
<tscreen><verb>
          Number = Integer | Long | FloatingPointNumber

          Integer = Digit {Digit} | "0" ("x" | "X") HexDigit { HexDigit }

          Long = Integer ("l" | "L")

          FloatingPointNumber = Digit {Digit} "." { Digit } [Exponent]
                              | Digit {Digit} [Exponent]

          Exponent = ("e" | "E") [ "+" | "-" ] Digit { Digit }
</verb></tscreen>
        Examples:
<tscreen><verb>
          10
          10L
          22222222222222222222222222222222222222222222222222222222l
          100.
          1e2
          100.0E+0
</verb></tscreen>
     <item>A Dino <em>character constant</em> denotes an Unicode
        character.  The following sequences starting with the ASCII
        backslash have a special meaning inside a Dino character
        constant:
          <itemize>
          <item><tt><bf>\a</bf>    - </tt> ASCII character alert
          <item><tt><bf>\b</bf>     -</tt> ASCII character backspace
          <item><tt><bf>\f</bf>     -</tt> ASCII character form feed
          <item><tt><bf>\n</bf>     -</tt> ASCII character new line
          <item><tt><bf>\r</bf>     -</tt> ASCII character carriage return
          <item><tt><bf>\t</bf>     -</tt> ASCII character horizontal tab
          <item><tt><bf>\v</bf>     -</tt> ASCII character vertical tab
          <item><tt><bf>\code</bf>  -</tt> Character with code given
          up to tree octal digits
          <item><tt><bf>\xcode</bf> -</tt> Character with code given
          by two hexdecimal digits
          <item><tt><bf>\ucode</bf> -</tt> Character with code given
          by four hexdecimal digits
          <item><tt><bf>\Ucode</bf> -</tt> Character with code given
          by eight hexdecimal digits
          <item><tt><bf>\char</bf>  -</tt> Character char for all
          remaining characters
          </itemize>
        To denote a single quote mark use the sequence <tt>\'</tt>.
        The double quote mark can be represented either by <tt>\"</tt>
        or simply by <tt>"</tt>.  To represent a backslash inside the
        character constant, use two consecutive ASCII backslashes.
<tscreen><verb>
          Character = "'" Char "'"

          Char = <any character except for the single quote ',
                  backslash \, or line break>
               | SimpleEscapeSeq
               | OctalEscapeSeq

          SimpleEscapeSeq = <one of  \'  \"  \\  \a  \b  \f  \n  \r  \t  \v>

          OctalEscapeSeq = "\" OctalDigit [ OctalDigit [ OctalDigit ] ]
</verb></tscreen>
        Examples:
<tscreen><verb>
          'a'  '\''  '\\'  '\12'  '"'
</verb></tscreen>
     <item>A <em>string</em> is sequence of characters enclosed
        in double quotes. There are the same sequences of
        characters with special meaning as in a character constant.
        To denote a double quote mark use sequence <tt>\"</tt>.  The
        single quote mark can be represented either by <tt>\'</tt> or
        simply by <tt>'</tt>.  To represent a backslash inside the
        character constant, use two consecutive ASCII backslashes.
<tscreen><verb>
          String = '"' {Char} '"'
</verb></tscreen>
        Examples:
<tscreen><verb>
          "This is Dino"  "Don't worry\n"
</verb></tscreen>
        Another variant of string representation uses
        back-quotes <tt>`</tt>.  A character inside the back-quotes are
        present in the string as it is, in other words, the escape
        sequences do now work in such representation.  To denote
        back-quote in such string representation use double back-qoutes.
        The newline may not be in such string representation.  It
        means that string with back-quotes can reside only on one line.
<tscreen><verb>
          String = '`' {Char} '`'
</verb></tscreen>
        Examples:
<tscreen><verb>
          `\p{Greek}+`  `back qoute `` is here`
</verb></tscreen>
     <item>The remaining essential symbols are called
        <em>operators</em> and <em>delimiters</em>.  Operators are
        used for forming expressions, delimiters are used for forming
        syntax constructions.  There is a special kind of operators
        and delimiters which look like identifiers containing only
        lower-case letters.  They are reserved identifiers (keywords).
        Keywords can not be used in the place of an identifier.
<tscreen><verb>
          OperatorOrDelimeter = "?" | ":" | "|" | "||" | "&" | "&&" | "^"
	                      | "==" | "!=" | "===" | "!==" | "<" | ">"
			      | "<=" | ">=" | "<<" | ">>" | ">>>" | "@"
	                      | "+" | "-" | "/" | "*" | "%" | "!" | "~"
     			      | "#" | ".+" | ".*" | ".&" | ".^" | ".|"
			      | "(" | ")" | "[" | "]" | "{" | "}"
                              | "." | "," | ";" | "=" | "*=" | "/="
                              | "%=" | "+=" | "-=" | "@=" | "<<=" | ">>="
                              | ">>>=" | "&=" | "^=" | "|=" | "++" | "--"
			      | "..." | Keyword

          Keyword = "_" | "break" | "case" | "catch" | "char" | "class"
                  | "continue" | "else" | "extern" | "final" | "float"
                  | "for" | "former" | "friend" | "fun" | "hide"
                  | "hideblock" | "if" | "in" | "int" | "later" | "long"
                  | "new" | "nil" | "obj" | "priv" | "process" | "pub"
                  | "return" | "swicth" | "tab" | "thread" | "this"
                  | "throw" | "try" | "type" | "use" | "val" | "var"
                  | "vec" | "wait"
</verb></tscreen>

     <item><em>Comments</em> are considered analogous to blanks on the
        syntax level of the program.  There are two types of comments.
        The first type is an arbitrary character sequence starting
        with <tt>/*</tt> and finishing with <tt>*/</tt>.  The second
        type of comment starts with <tt>//</tt> and finishes with the
        first line break or with the end of file.
<tscreen><verb>
          Comment = "/*" <arbitrary char. sequence not containing pair */> "*/"
                  | "//" <arbitrary char. sequence finishing on line break>
</verb></tscreen>
     </enum>


<sect>Declarations and Scope Rules
<p>
A Dino program is block structured.  Each block introduces a new
identifier scope.  A block consists of executive statements and
declarations and may contain nested blocks.  There are also implicit
blocks containing each case-part of switch statements (see
below). Each identifier used in a program should be declared in a
declaration in the program, unless it is a predeclared identifier.
<tscreen><verb>
          Block = "{"  StmtList "}"

          StmtList = { Stmt }
       	
          Stmt = ExecutiveStmt
               | Declaration
</verb></tscreen>
When declaring an identifier, you also specify certain permanent
properties of a declaration, such as whether it is a variable, a
function, a class, or a singleton object.  The identifier is then used
to refer to the associated declaration (more correctly with the
declaration instance).
<tscreen><verb>
          Declaration = VarDeclarations
                      | AccessClause
                      | ExternDeclarations
                      | FuncClassDeclaration
                      | SingletonObject
                      | ForwardDeclaration
                      | IncludeDeclaration
</verb></tscreen>
The scope of a declaration is textually from the point of declaration
to the end of the block to which the declaration belongs and hence to
which the declaration is local.  The declaration scope can stop
earlier at the point of another declaration with the same identifier
in the same block.  The declaration scope excludes the scopes of
declarations with the same identifier which are in nested blocks.
<p>
It is important to understand the notion of instantiation of the
declaration.  This notion reflects program execution, not the static
structure of program.  An instance exists in a <em>context</em>.
Actually, a context is an execution environment consisting of the
covering block instances and/or class objects.  A new instance of the
block is created when execution of the block starts.  There may be
more than one instance of the same block, e.g. when the block is a
function or class body (in this case the block instance is a class
object), or when the block is executed on different threads (parallel
execution branches) or when there is a reference to a block instance
after its execution.  When a new instance of the block starts, all the
block declarations are instantiated too.  For a variable declaration,
it means a new instance of variable is created in the given context.
For a function or class declaration, it means that the function or
class is bound to the given context.
<p>
        Example: 
          The following program illustrates a case when a reference to
          a block instance exists after its execution.  The program
          outputs the result 8.
<tscreen><verb>
          var i, f;
        
          for (i = 0; i < 10; i++)
            if (i % 4 == 0)
              {
                var j = i;
                fun r () {return j;}
                f = r;
              }
          putln (f ());
</verb></tscreen>
<p>
There are certain rules for declaration accessibility.  Declaration is
always either <em>private</em> or <em>public</em>.  Private
declaration is accessible only inside the declaration scope or inside
functions or classes which are declared as <em>friend</em> in the
declaration block.  A public declaration instance is always accessible
when association (see below) of the identifier is successful.  By
default, (instances of) declarations in a class block are public.  In
all other places, the (instances of) declarations are private by
default.  The following constructions are used for declaring an
identifier to be a friend:
<tscreen><verb>
          FriendClause = friend IDENT { "," IDENT } ";"
</verb></tscreen>
        Examples:
<tscreen><verb>
          friend class2;
</verb></tscreen>
Association of an identifier and the corresponding declaration
instance is performed by the following rules:
     <itemize>
     <item>The corresponding declaration instance is searched for a
       separate identifier occurrence in the instance of the block in
       which the identifier occurs.  The identifier should be in the scope
       of the corresponding declaration.  If there is no such declaration, the
       declaration is searched in the covering block instance of the
       current block instance back from the current block, and so on.
       In any case, the identifier should be in the scope of the
       corresponding declaration.
     <item>Declaration instance for an identifier in the following
       construction
<tscreen><verb>
       designator.identifier
</verb></tscreen>
       is searched in the block instance (e.g. in a class object)
       whose value is in the designator.  The scope of the found
       declaration should always include the block end.  The
       exception <tt>accessop</tt> occurs if the declaration is not
       found with such identifier, or the declaration is private and
       the construction is not inside a friend of the declaration
       scope.
     </itemize>
The following identifiers are predeclared on the top level (in the
implicit block covering the whole program).  They are described in
more detail later in the report.
<tscreen><verb>
  abstrcall      accessop       accessvalue    anode
  argv           atan2
  callop         chdir          chgmod         chomod
  chumod         clock          close          closure
  cmpv           context        cos            curr_thread
  deadlock       del
  eaccess        eagain         ebadf          ebusy
  echild         edeadlk        edom           eexist
  efault         efbig          eintr          einval
  eio            eisdir         eltype         emfile
  emlink         enametoolong   enfile         enodev
  enoent         enoexec        enolck         enomem
  enospc         enosys         enotdir        enotempty
  enotty         env            enxio          eof
  eperm          epipe          erofs          error_anode
  error          espipe         esrch          exdev
  except         exit           exp
  fatime         fctime         fget           fgetf
  fgetln         fgmode         fgrpn          file
  filter         flush          fmtime         fold
  fomode         fprint         fprintln       fput
  fputln         fscan          fscanln        fsize
  ftype          fuidn          fumode
  gc             get            get_encoding   get_file_encoding
  getcwd         getegn         geteun         getgn
  getgroups      getf           getln          getpid
  getun          gmatch         gsub
  immutable      indexop        indextype      indexvalue     
  ins            inside         insv           invaccess
  invcall        invector       invencoding    invenv
  invenvar       invextern      invfmt         invgrammar
  invindex       invinput       invkey         invop
  invparser      invregex       invresult      invslice
  invtoken       isa            isatty
  keyop          keys           keyvalue
  libclose       log            log10
  main_thread    match          matrixform     max
  min            mkdir
  nil_anode      noextern       noexternsupp   noshell
  open           optype         opvalue
  parser         parnumber      partype        parvalue
  patternmatch   pclose         pmemory        popen
  pow            print          println        put
  putln          rand           readdir        remove
  rename         rev            rmdir
  scan           scanln         seek           set_encoding
  set_file_encoding signal      sigabrt        sigfpe
  sigill         sigint         sigsegv        sigterm
  sin            sliceform      slicetype      sort
  split          split_regex    sprint         sprintln
  sput           sputln         sqrt           srand
  stderr         stdin          stdout         strtime
  sub            subv           syncthreadcall syncwait
  syserror       system         systemcall     systemfail
  transpose      tell           time           time_format
  token          tolower        toupper        trans
  veclen         vecform        version
</verb></tscreen>

<sect1>Variable Declarations
<p>
Dino is an imperative language. In other words it has
<em>variables</em> which are named containers of values.  A variable
can contain any value.  This means that DINO is a dynamically-typed
language.  The declaration of a variable also may define the initial
value of the variable.  In this case a <em>pattern</em> can stand on
the left side of the assignment instead of just an identifier.  The
pattern should contain at least one variable.  The pattern variables
are declared at the assignment point.  Pattern should match the
assigned value, otherwise exception <tt>patternmatch</tt> is
generated.  Details about patterns, pattern variables, and pattern
matching is decribed later in this document.
<p>
Assigning of the initial value to the variable instance is made after
execution of the previous statements of the block and after execution
of previous assignments in the variable list.  By default the initial
value of variables is undefined.  Nothing can be done with this value.
This value even can not be stored.
<p>
The value of the variable can not be changed after its initialization
if its declaration is in a list starting with keyword <tt>val</tt>.
<p>
Keywords <tt>pub</tt> and <tt>priv</tt> can be used to redefine the
default accessibility.  They make the declared variables
correspondingly public and private.
<tscreen><verb>
          VarDeclarations = [pub | priv] (val | var) VarList ";"

          VarList = Var { "," Var }
       	
          Var = IDENT | Pattern "="  Expr
</verb></tscreen>
        Examples:
<tscreen><verb>
          var i = 0, [el1, el2] = [2, 5], j, k;
          val constant = 10, nil_constant = nil;
</verb></tscreen>

<sect1>External Declarations
<p>
Dino permits to use functions written in other languages, e.g. C.  The
functions should have special prototypes and must have to access to
the DINO standard procedural interface (SPI).  Dino can also have
access to variables of a special type declared in the source code in
another language.  The details of the implementation of such features
and the DINO SPI are not described here (some details are given in
appendix B).  As rule, the external functions and variables will be
implemented as dynamically loaded libraries.  This is the powerful
instrument of DINO extension.  The external functions and variables
are declared after keyword <tt>extern</tt>.  An external function
identifier is followed by <tt>()</tt>.  All external declarations
(e.g. in different blocks) with the same identifier refer the the same
external function or variable.  As in variable declaration,
keywords <tt>pub</tt> and <tt>priv</tt> can be used to redefine the
default accessibility.
<tscreen><verb>
          ExternDeclarations = [pub | priv] extern ExternItems ";"

          ExternItems = ExternItem { "," ExternItem }

          ExternItem = IDENT 
                     | IDENT  "(" ")"
</verb></tscreen>
        Examples:
<tscreen><verb>
          extern function (), variable;
</verb></tscreen>

<sect1>Functions and Classes
<p>
A function/class declaration consists of a
function/class <em>header</em>, <em>formal parameters</em>, and a
function/class block (body).  The header specifies the function/class
identifier.
<p>
A function can return the result with the aid of the
statement <em>return</em>.  If the result value after the
keyword <em>return</em> is absent or the return statement is not
executed, the function result is undefined.  Expression-statement as
the last statement in the function block is actually abbreviation of
return with the expression.
<p>
A class call returns the class block instance (an <em>object</em> of
the class).  The return-statement for classes must be without a result.
<p>
<em>Thread-functions</em> are analogous to general functions.  The
difference is in that a new execution thread (<em>process</em>) is
created during the thread-function call, the return-statement inside
thread-function must be without an expression, and the thread-function
returns the corresponding process.  The process finishes when the
corresponding thread block finishes.  Processes are executed
concurrently.  Originally only one process (called the <em>main
thread</em>) exists in a DINO program.
<p>
The formal parameters are considered to be declared in a
function/class block and to be initialized by values of <em>actual
parameters</em> during a call of the function/class.  By default they
can change their value.  Keyword <tt>val</tt> prevents changing value
of the corresponding formal parameter after the initialization.
<p>
Default accessibility of the formal parameter can be changed by using
keywords <tt>pub</tt> or <tt>priv</tt> (see accessibility in section
"Declarations and Scope Rules").
<p>
The number of <em>actual parameters</em> should be the same as the
number of formal parameters.  There are two exclusion to this
requirement.  One exclusion is formal parameters initialized by a
default value in a way analogous to variable initialization.  The
actual parameters corresponding to the formal parameters with default
values can be omitted.  In this case, the formal parameters will have
the default value.  Another exclusion is an usage of <tt>...</tt> at
the end of the list of formal parameter declarations, the number of
actual parameters can be more the number of formal parameters.
Using <tt>...</tt> results in that the formal parameter with the
identifier <tt>args</tt> will be declared implicitly.  The value of
the parameter will be a vector whose elements will be the remaining
actual parameter values.  If the number of actual parameters is equal
to the number of formal parameters (not taking the implicit
parameter <tt>args</tt> into account), the value of <tt>args</tt> will
be the empty vector.
<p>
All formal parameters with default values should be at the end of the
parameter list.  Usage of formal parameters with default values is
prohibited in case when <tt>...</tt> is used.
<p>
If a class contains a function with the name <tt>destroy</tt>, the
function will be called when the class object becomes garbage during
the garbage collection process or at the end of the program.  The
function can also be called explicitly from outside if it is declared
as public.  You should remember that the function is called by the
garbage collector without actual parameters and the garbage collector
(or finishing the program) ignores the result value.  So the function
should satisfy the above rules to be called without actual parameters.
<p>
You may prevent removing the corresponding object by the garbage
collector in the function destroy by assigning the object to a
variable.  It means that the function can be called several times
(during several garbage collections) for the same object.  But you
should also avoid creation of objects during the call of
function <tt>destroy</tt> because it may result in increase of the
heap.
<p>
A function/class declaration can have optional qualifiers.
Qualifier <tt>final</tt> can not be mentioned in use-clause.
Qualifiers <tt>pub</tt> and <tt>priv</tt> changes default
accessibility of the declaration.
<tscreen><verb>
          FuncClassDeclaration = Header FormalParameters Hint Block

          Header = [Qualifiers] FuncThreadClass IDENT

          Qualifiers = pub | priv | final
	              | pub final | priv final
	              | final pub | final priv

          FuncThreadClass = fun 
                 	  | thread 
                 	  | class 
      	
          FormalParameters =
	                   | "(" [ ParList ] ")"
                 	   | "(" ParList "," "..." ")"
                 	   | "(" "..." ")"

	  ParList = Par { "," Par}

	  Par = [pub | priv] [val | var] IDENT [ "=" Expr]

          Hint = [ "!" IDENT ]
</verb></tscreen>
        Examples:
<p>
        The following is parameterless class:
<tscreen><verb>
          class stack () {}
          class stack {}
</verb></tscreen>
        The following is a class header with initialization parameters:
<tscreen><verb>
          class stack (max_height = variable,
                       val a = 1, priv val b = 2)
</verb></tscreen>
        The following is a function with a variable number of parameters:
<tscreen><verb>
          fun print_args (...)
            {
              for (i = 0; i < #args; i++)
                println (args[i]);
            }
</verb></tscreen>
        The following example is a class with the function <tt>destroy</tt>:
<tscreen><verb>
          var objs_number = 0;
          class obj () {
            priv var n = objs_number;
            objs_number++;
            priv fun destroy () {objs_number--; objs_number--;}
          }
</verb></tscreen>
        The following example illustrates threads:
<tscreen><verb>
          class buffer (length = 3) {
            var b = [length:nil], first = 0, free = 0, empty = 1;
            priv b, first, free, length;
            fun consume () {
              var res;
          
              wait (!empty);
              res = b [first];
              first = (first + 1) % length;
              wait (1) empty = first == free;
              return res;
            }
            fun produce (value) {
              wait (empty || free != first);
              b [free] = value;
              free = (free + 1) % length;
              wait (1) empty = 0;
            }
          }
          
          thread consumer (buffer) {
              fun produce (value) {
                buffer.produce (value);
                put ("produce: ");
                println (value);
              }
              produce (10);
              produce (10.5);
              produce ("string");
              produce ('c');
              produce (nil);
          }
          
          thread producer (buffer) {
            var value;
          
            for (;;) {
              value = buffer.consume ();
              if (value == nil)
                break;
              put ("consume: ");
              println (value);
            }
          }
          
          var queue = buffer ();
          consumer (queue);
          producer (queue);
</verb></tscreen>
<p>
According to Dino scope rules, a declaration should be present before
any usage of the declared identifier.  Sometimes we need to use
function/class identifier before its declaration, e.g. in the case of
mutually recursive functions.  To do this, Dino has forward
declarations.
<p>
  A forward declaration is just a function/class header followed by
semicolon:
<tscreen><verb>
            ForwardDeclaration = Header ";"
</verb></tscreen>
<p>
Forward declaration denotes first declaration with the same identifier
in the same block after the forward declaration.  The forward and the
corresponding declaration should be the same declaration type
(function, class, or thread), and have the same accessibility and the
same qualifier <tt>final</tt>.
<p>
The corresponding declaration may be absent.  In this case a call of
the function/class results in occuring exception <tt>abstrcall</tt>.
Forward declaration without the corresponding declaration can be
usefull to describe <em>abstract classes</em>.  The following are
examples of forward declarations:
<tscreen><verb>
          fun even;
          fun odd (i) { if (i == 0) return 0; return even (i - 1);}
          fun even (i) { if (i == 0) return 1; return odd (i - 1);}
	  class operation { // abstract class
            fun print_op (); fun apply ();
	  }
</verb></tscreen>
<p>
Function/class declaration may have an optimization hint.  Currently,
there are only 3 hints.  Hint <tt>!pure</tt> means that the function
is pure, i.e. it has no side effects and returns result depending only
on the call arguments.  Hint <tt>!inline</tt> means inlining the
function calls.  Hint <tt>!jit</tt> use JIT compiler for the
function/class.

<sect1>Use Clause
<p>
Dino has a powerful block composition operator <em>use</em>.  Using it
inside a class block can emulate <em>(multiple) inheritance, traits,
duck typing, and dynamic dispatching</em>.  The use-clause has the
following syntax:
<tscreen><verb>
          UseClause = use IDENT { UseItemClause }

          UseItemClause = [former | later] UseItem { "," UseItem }

          Item = IDENT [ "(" IDENT ")"]
</verb></tscreen>
<p>
Use-clause provides a safe way to support object oriented programming.
It has the following semantics:
<itemize>
  <item>Declarations of class/function with identifier given in
  <em>use</em> are inlayed.
  <item>Declarations before the use-clause rewrite corresponding
  inlayed declarations mentioned in <em>former</em>-items.
  <item>Declarations after the use-clause rewrite corresponding
  inserted declarations mentioned in <em>later</em>-items.
  <item>The original (rewritten) and new (rewritting) declarations
  should be <em>present</em> if they are given in former- or
  later-items.
  <item>The original and new declarations should be <em>matched</em>.
  It means that they should be the same declaration type (variable,
  function, class, thread, and external), they should have the same
  accessibility, they should the same final attribute for functions,
  classes, and threads.
  <item>The original rewritten declaration can be still used in the
  block if it is <em>renamed</em>.  The declaration is renamed when a
  identfier in parentheses is given.  The original declaration can be
  used with this identfier.
</itemize>
These rules are necessary for correct <em>duck-typing</em> or class
<em>sub-typing</em>.
<p>
        The following example illustrates use-clause:
<tscreen><verb>
           class point (x, y) {
           }
           class circle (x, y, radius) {
             use point former x, y;
	     fun square () {3.14 * radius * radius;}
           }
           class ellipse (x, y, radius, width) {
             use circle former x, y, radius later square;
             fun square () {
               ...
             }
           }
</verb></tscreen>

<sect1>Singleton Object
<p>
Sometimes it is usefull to guarantee that there is only single object
(<em>singleton object</em>) of a class.  Although it can be achieved
by creating of object of an anonymous class (see section "Anonymous
Functions and Classes") and assigning it to a variable declared
as <tt>val</tt>, Dino has a special declaration for singleton object:
<tscreen><verb>
        SingletonObject = [pub | priv] obj IDENT block
</verb></tscreen>
<p>
Keywords <tt>pub</tt> and <tt>priv</tt> can be used to redefine the
default accessibility.  They make the declared object correspondingly
public and private.  Example of singleton object declaration:
<tscreen><verb>
           priv obj coord {
             val x = 0, y = 10;
           }
</verb></tscreen>

<sect>Expressions
<p>
Expressions are constructs denoting rules of computation of a value
from other values by the application of <em>operators</em>.
Expressions consist of <em>operands</em> and operators.  Parentheses
may be used to express specific associations of operators and
operands.  Dino is a dynamic-typed language.  This means that a
variable can store any Dino value.

<sect1>Types and Values
<p>
All Dino values are <em>first class values</em>, i.e. they can be
assigned to a variable, can be passed as a parameter of
a function/class, and can be returned by functions.  Operators require
operands whose values are of given type and return the value of the
result type.  Most values have a representation in Dino.  When a
value representation is encountered in an expression during the
expression evaluation, the new value is generated.
<p>
There are values of <em>structured types</em>, i.e. values which are
built from other values.  The value of a structured type may be
<em>mutable</em> or <em>immutable</em>.  A value or sub-value of a
mutable value can be changed.  An immutable value can not be changed
after its generation.  You can make a mutable value immutable as a
side effect by applying the operator <tt>final</tt> (the table key is
also made immutable as a side effect of writing to the table).  In all
cases, the operator returns the operand value as the result.  If you
try to change an immutable value, exception <tt>immutable</tt> is
generated.  You can make a new mutable value as a side effect of
applying operator <tt>new</tt>.  The operator returns a new value
equal to the operand value.
<tscreen><verb>
          Expr = final  Expr
               | new  Expr
</verb></tscreen>
Structured value types are also <em>shared value types</em>.  This
notion means that if two or more different variables (array elements
or table elements or keys) refer to the same value and the value is
changed through one variable, the value which is referred through the
other variables is changed too.  There is no difference between the
notion "the same value" and the notion "equal values" for non-shared
type values.  For the shared type operands, equality means that the
operands have the same structure (e.g. vectors with the same length)
and the corresponding element values are the same.
<p>
        Examples:
<tscreen><verb>
          new 5
          new ['a', 'b', 'c']
          new "abc"
          new {"key0" : 10, "key1" : 20}
          final 5
          final ['a', 'b', 'c']
          final "abc"
          final {"key0" : 10, "key1" : 20}
</verb></tscreen>
<p>
Dino has the following types of values:
          <itemize>
          <item>the special value <em>nil</em>.  The value is
            represented by the keyword <tt>nil</tt>.
<tscreen><verb>
                 Expr = nil
</verb></tscreen>
          <item><em>character</em> which represents unicode characters.
            For the representation see <tt>Character</tt> in the
            section <em>Vocabulary and Representation</em>.
<tscreen><verb>
                 Expr = CHARACTER
</verb></tscreen>
          <item><em>integer</em>.  For its representation see
            <tt>Integer</tt> in the section <em>Vocabulary and
            Representation</em>.  It is always stored as a 64-bit
            integer value.
<tscreen><verb>
                 Expr = INTEGER
</verb></tscreen>
          <item><em>long</em>.  For its representation see
            <tt>Long</tt> in the section <em>Vocabulary and
            Representation</em>.  Long values are signed
            multi-precision integer.  The maximal and minimimal values
            are constrained only by overall memory size.
<tscreen><verb>
                 Expr = LONG
</verb></tscreen>
          <item><em>floating point number</em>.  For its
            representation see <tt>FloatingPointNumber</tt> in section
            <em>Vocabulary and Representation</em>.  It is always
            stored as an IEEE double (64-bit) floating point value.
<tscreen><verb>
                 Expr = FLOATINGPOINTNUMBER
</verb></tscreen>
          <item><em>vector</em>.  This is a structured shared type
            value.  A vector value is represented by a list of values
            (or expressions) in brackets with optional repetitions of
            the vector elements preceded by <tt>:</tt>.  The
            repetition value is converted into an integer value by
            default.  If the repetition value after the conversion is
            not integer, exception <tt>optype</tt> is generated. If
            the repetition value is negative or zero, the element
            value will be absent in the vector.  Elements of vector
            are accessed by their indexes.  Indexes always starts with
            0.  Vectors in Dino are heterogenous, i.e. elements of a
            vector may be of different types.  A string represents an
            immutable vector all of whose elements are characters in
            the string.  Elements of mutable vectors can be added to
            or removed from the vector (see predefined functions
            <em>ins, insv, and del</em>).
<tscreen><verb>
                 Expr = "["  ElistPartsList "]"
                      | STRING
                 ElistPartsList = [ Expr [":" Expr ] {"," Expr [":" Expr ] } ]
</verb></tscreen>
            Examples:
<tscreen><verb>
               "aaab"
               ['a', 'a', 'a', 'b']
               [3 : 'a', 'b']
               [3.0 : 'a', 'b']
               ["3" : 'a', 'b']
               ['a', 10, 10.0, "abcd", {}]
               []
</verb></tscreen>
          <item><em>table</em>.  This is a structured shared type
            value.  A table value is represented keyword tab, followed
            by a list of key values (expression values) in brackets
            <tt>[</tt> and <tt>]</tt> with optional element values
            with a preceding <tt>:</tt>.  By default the element value
            is equal to <tt>nil</tt>.  It is not allowed to have
            elements with equal keys in a table.  If it is not true in
            a table constructor, exception <tt>keyvalue</tt> is
            generated.  Elements of tables are accessed by their keys.
            Elements of mutable tables can be added to or removed from
            the table correspondingly by assigning values and with the
            aid of the function <em>del</em>.  The side effect of the
            table constructor execution is that the keys become
            immutable.
<tscreen><verb>
                 Expr = tab "["  ElistPartsList "]"
</verb></tscreen>
            Examples:
<tscreen><verb>
               tab ['a', 'b', 10:[10]]
               tab ['a' : nil, 'b' : nil, 10 : [10]]
               tab [[10, 'a', tab [10]] : 10, [10] : tab [20:20]]
               tab [}
</verb></tscreen>
          <item><em>function</em>.  Its value is represented by the
            function designator.  It is important to remember that the
            function is bound to a context.
          <item><em>thread-function</em>.  Its value is represented by
            the thread-function designator.  It is important to
            remember that the thread-function is bound to a context.
          <item><em>class</em>.  Its value is represented by the class
            designator.  It is important to remember that the class is
            bound to a context.
          <item><em>process</em>.  There is no literal Dino
            representation of such values.  A process is
            generated by calling a thread-function.
          <item><em>object</em> (block instance, usually a class block
            instance).  This is a structured shared type value.  There
            is no literal Dino representation of such values.  Objects
            are generated by a block instantiation and usually
            accessed by value <tt>this</tt>.
          <item><em>hide value</em>.  A hide value can not be
            generated by a Dino code.  They are generated by external
            functions.
          <item><em>hide block</em>.  This value is analogous to a
            hide value.  The differences are in that the size of a
            hide value is constrained by a C program pointer.  The
            size of q hideblock value has no such constraint.  Also a
            hideblock is of shared type.
          <item><em>type</em>.  The values of such types are returned
            by th special operator <tt>type (expression)</tt>.
<tscreen><verb>
                 Expr = char
                      | int
                      | float
                      | hide
                      | hideblock
                      | vec
                      | tab
                      | fun
                      | thread
                      | class
                      | process
                      | obj
                      | type
</verb></tscreen>
            There are the following type values:
            <itemize>
            <item>type of <tt>nil</tt>.  There is no value
              representing type of <tt>nil</tt>.  So use the
              construction <tt>type (nil)</tt> to get it.
            <item>type of characters.  The value is represented by
              the Dino keyword <tt>char</tt>.
            <item>type of integers.  The value is represented by the
              Dino keyword <tt>int</tt>.
            <item>type of floating point numbers.  The value is
              represented by the Dino keyword <tt>float</tt>.
            <item>type of vectors.  The value is represented by the
              Dino keyword <tt>vec</tt>.
            <item>type of tables.  The value is represented by the
              Dino keyword <tt>tab</tt>.
            <item>type of functions.  The value is represented by the
              Dino keyword <tt>fun</tt>.
            <item>type of thread-functions.  The value is represented
              by the Dino keyword <tt>thread</tt>.
            <item>type of classes.  The value is represented by the
              Dino keyword <tt>class</tt>.
            <item>type of block instances (objects).  The value is
              represented by the Dino keyword <tt>obj</tt>.
            <item>type of threads.  The value is represented by the
              Dino keyword <tt>process</tt>.
            <item>type of hide values.  The value is represented by
              the Dino keyword <tt>hide</tt>.
            <item>type of hideblocks.  The value is represented by
              the Dino keyword <tt>hideblock</tt>.
            <item>type of types.  The value is represented by the Dino
              keyword <tt>type</tt>.
            </itemize>
          </itemize>

<sect1>Designators
<p>
There is a special Dino construction called a <em>designator</em>.  A
designator refers for a vector or table element or for a declaration.
If the designator refers to a vector or table element or for a
variable declaration, it can stand in the left hand side of an
assignment statement.  If the designator stands in an expression, the
corresponding value is used (vector/table element value, variable
value, function, thread-function, or class).  When the designator
referring to table element stands up in the left hand side of an
assignment statement, <em>its key becomes immutable</em>.
<p>
A designator referring to a vector or table element has the following
syntax:
<tscreen><verb>
           Designator = (Designator | Call) "["  Expr "]"
</verb></tscreen>
The value of the construction before the brackets must be a vector or table.
Otherwise, the exception <tt>indexop</tt> is generated.
<p>
If the value of the construction before the brackets is a vector, the
value of expression in the brackets (so called the <em>index</em>) is
converted to integer.  If this is not possible,
exception <tt>indextype</tt> is generated.  If the index is negative
or greater than or equal to the vector length, the
exception <tt>indexvalue</tt> is generated.  The value of the
designator will be the vector element value with given index (the
indexes starts with zero).  Examples:
<tscreen><verb>
          vector [1]
          vector ["1"]
          vector [1.0]
</verb></tscreen>
<p>
If the value of the construction before the brackets is a table, the
value of expression in the brackets is called the <em>key</em>.
The value of the designator will be the table element value with the
key which is equal to given key.  If the element with the given key is
absent in the table, exception <tt>keyvalue</tt> is generated.
Examples:
<tscreen><verb>
          table ['c']
          table [10]
          table ["1"]
          table [1.0]
</verb></tscreen>
The remaining forms of designator refer to a declaration.  See section
<em>Declarations and Scope Rules</em> for a description on how they
work.
<tscreen><verb>
          Designator = (Designator | Call) "."  IDENT
                     | IDENT
</verb></tscreen>
        Examples:
<tscreen><verb>
          value
          value.f
</verb></tscreen>
<p>
Dino also has an extended form of the designator described above.
This form is called <em>vector slice</em>:
<tscreen><verb>
          Expr = ExtDesignator

          ExtDesignator = Designator {Slice}

          Slice = "["  [Expr] ":" [Expr] [":" Expr] "]"
</verb></tscreen>
<p>
Slice is applied to a vector, otherwise exception <tt>sliceform</tt>
is generated.  Slice refers for a part of vector given by start index,
bound, and the step.  If they are not integer,
exception <tt>slicetype</tt> is generated.
<p>
The negative bound means counting index from the vector
end.  <tt>-1</tt> corresponds to the vector length, <tt>-2</tt>
corresponds to the vector length - 1, <tt>-3</tt> corresponds to the
vector length -2, and so on.  If the bound is more than the vector
length, the bound is assumed to be equal to the vector length.  If the
bound is omitted, it is believed to be equal <tt>-1</tt>, or in other
words, to the vector length.
<p>
If the start index is less than zero, exception <tt>sliceform</tt> is
generated.  The same happens if the step is zero.  If the start index
is omitted, it is believed to be zero.  If the step is omitted, it is
believed to be one.
<p>
The slice refers to vector elements with
indexes <tt>start</tt>, <tt>start + abs (step)</tt>, <tt>start + 2 *
abs (step)</tt>, <tt>start + 3 * abs (step)</tt> and so on while the
index is less than the bound.  If the step is negative, the elements
are considered in the reverse order.
        Examples:
<tscreen><verb>
          v[:]    // all vector elements
          v[1:]   // all vector elements except the first one
	  v[:-2]  // all vector elements except the last one
	  v[::-1] // all vector elements in reverse order
	  v[0::2] // all vector elements with even indexes
</verb></tscreen>
<p>
More one slice can be given after the designator.  In this case, next
slice is applicable to each element of the previous slice.  That means that
each element and the next slice should abide by the above rules.  The
first slice is called the first <em>dimension</em> slice, the second one is
called the second dimension slice and so on.
        Examples of multi-dimensional slices:
<tscreen><verb>
          m[:][:]     // all matrix elements
          m[:][::2]   // matrix elements with even columns
          m[::2][::]  // matrix elements with even rows
          m[::2][::]  // matrix elements with even rows and columns
</verb></tscreen>
<p>
Slices are actually not real reference values.  They can be considered
as an attribute which exists in a statement at most.  If vector with
slices is an operand of an operation which has a slice variant, the
operation is applied to each element of the vector referenced by the
slices in given order.  The result is a new vector with the same
dimension slices referencing all elements with the step equal to one.
<p>
When vector with slices is an operand of an operation, the new vector
consisting of elements referenced by the slices is created.  The new
vector will have the same dimension slices referencing for all new
vector elements with the step equal one.  This is done to avoid
side-effects of function-calls inside a statement with slices.


<sect1>Calls
<p>
One form of expression is the call of a function, thread-function, or
class.  The value of the designator before the actual parameters
should be a function, thread-function, or class.  Otherwise, the
exception <tt>callop</tt> is generated.  An instance of the block
corresponding to the body of the function, thread-function, or class
is created.  The actual parameter values are assigned to the
corresponding formal parameters.  If the corresponding function,
thread-function, or class has no default formal parameter
<tt>args</tt> (see section <em>Declarations</em>), the remaining
actual parameter values are ignored.  Otherwise, a vector whose
elements are the remaining parameter values is created and assigned to
the parameter <tt>args</tt>.  If there is no corresponding actual
parameter for a formal parameter, the default parameter value (see
section <em>Declarations</em>) is assigned to the formal parameter.
Otherwise, the value is undefined. Then statements in the block are
executed.  If it is the call of a thread-function, a new execution
thread is created, and the statements of the block is executed in the
new thread.  The value of call of the thread-function is the
corresponding thread.  It is returned before starting the execution of
statements in the new thread.
<p>
Execution of the body is finished by reaching the block end or by
execution of a return-statement.  Finishing of the thread-function
results in finishing the corresponding thread.  The return-statement
in a thread-function or in class should be without an expression.  The
call of a class returns the created object.  A function call returns
the value of the expression in the executed return-statement.
Otherwise, the function return value is undefined.
<tscreen><verb>
          Expr = Call

          Call = Designator ActualParameters

          ActualParameters = "(" [ Expr { "," Expr } ] ")"
</verb></tscreen>
       Examples:
<tscreen><verb>
          f ()
          f (10, 11, ni, [])
          obj.objf ()
</verb></tscreen>

<sect1>Operators
<p>
Expressions consist of operands and operators.  The order in which
operators are executed in an expression is defined by their
<em>priority</em> and <em>associativity</em> of operators.  That means
that the expression <tt>a op1 b op2 c</tt> when the operator
<tt>op2</tt> has higher priority than <tt>op1</tt> is analogous to
<tt>a op1 (b op2 c)</tt>.  Dino operators have analogous priorities to
the ones in C language.  The following Dino operators are placed in
the order of their priority (the higher the line on which the operator
is placed, the higher its priority).
<tscreen><verb>
          !  #  ~  final  new
          *  /  %
          +  -
          @
          <<  >>  >>>
          <  >  <=  >=
          ==  !=  ===  !==
          &
          ^
          |
          in
          &&
          ||
          :
          ?
</verb></tscreen>
All binary operators have left associativity in Dino.  That means that
the expression <tt>a op1 b op2 c</tt> when operators <tt>op1</tt> and
<tt>op2</tt> have the same priority is analogous to <tt>(a op1 b) op2
c</tt>.  Parentheses may be used to express specific associations of
operators and operands.
<tscreen><verb>
          Expr = "(" Expr ")"
</verb></tscreen>
Most of the Dino operators require the operands to be of given types.
If an operand is not of given type, the conversion of it into the type
needed may be made.  If after the possible conversions the operands
are still not of necessary types, exception <tt>optype</tt> is
generated (when something about exceptions in this case is not
mentioned).  The following conversions may be made by default:
    <itemize>
    <item><em>Integer conversion</em>.  If the operand is a character,
      its code becomes integer.  If the operand is a long integer, it
      becomes integer.  If the long integer requires more 64 bits,
      exception <tt>opvalue</tt> is generated.  If the operand is a
      floating point number, its fractional part is thrown away and
      integral part becomes integer.  If the operand is a vector of
      characters, the corresponding string is believed to be the
      decimal representation of integer and is converted into the
      corresponding integer.  If the corresponding string is not a
      correct integer representation, the result is undefined.  If the
      corresponding string represents an integer whose representation
      requires more 64 bits, exception <tt>erange</tt> may be
      generated.  In all remaining cases the results of conversion
      coincide with the operand.
    <item><em>Arithmetic conversion</em>.  Analogous to integer
      conversion except for that the conversion of long integer or
      float pointing number to integer is not made and if the string
      represents a long integer (i.e. contains suffix <tt>l</tt>
      or <tt>L</tt>) or a floating point number (i.e. contains an
      exponent or fraction), the result will be the corresponding long
      integer or floating point number instead of integer.  If the
      result of conversion to integer from the string is out of range
      of 64-bit representation or the result of conversion to
      floating-point number from the string is out of IEEE double
      format range, the exception <tt>erange</tt> may be generated.
      <p>
      Additionally if the operand is in a non-short circuit binary
      operator (non-logical operators) and another operand is a
      floating point number after the conversion, the first operand is
      converted into a floating point number too.  In this case, if
      the firts operand is a long integer out of IEEE double format
      range, the result is undefined.  Otherwise, if another operand
      is a long integer after the conversion, the first operand is
      converted into long integer too.
    <item><em>String conversion</em>.  If the operand is a character,
      the result will be a new string (immutable vector of characters)
      with one element which is the character.  If the operand is an
      integer, long integer, or a floating point number, the result
      will be a new string of characters which is a decimal string
      representation of the number (long will have no suffix).
    </itemize>

<sect2>Logical operators
<p>
Logical operators produce the integer result 1 which means
<em>true</em> or 0 which means <em>false</em>.  Logical `or'
<tt>||</tt> and logical `and' <tt>&&</tt> are <em>short circuit</em>
operators.  That means that the second operand is evaluated depending
on the result of the first operand.  When the operands of the
operators are evaluated, the arithmetic conversion is made.
<p>
If the first operand of logical `or' is nonzero (integer, long
integer, or floating point), the result will be 1.  Otherwise, the
second operand is evaluated.  If the second operand is nonzero, the
result will be 1.  Otherwise, the result will be 0.
<p>
If the first operand of logical `and' is zero (integer, long integer,
or floating point), the result will be 0.  Otherwise, the second
operand is evaluated.  If the second operand is nonzero, the result
will be 1.  Otherwise, the result will be 0.
<p>
Logical negation `!' makes impilict integer conversion of the operand.
If the operand is zero (integer, long integer or floating point), the
result will be 1.  Otherwise, the result will be 0.
<p>
Operator <tt>in</tt> checks that there is an element with the given
key (the first operand) in the given table (the second operand).  If
the element is in the table, the result will be 1.  Otherwise the
result will be 0.  If the second operand is not a table, exception
<tt>keyop</tt> is generated.
<tscreen><verb>
          Expr = Expr "||"  Expr
               | Expr "&&"  Expr
               | Expr in  Expr
               | "!"  Expr
</verb></tscreen>
        Examples:
<tscreen><verb>
          !(type (i) == int && type (a) == tab && i >= 0 && i < #a)
          k in t && t {k} == 0
          0.0  || another_try
          0  || another_try
</verb></tscreen>

<sect2>Bit operators
<p>
The following operators work on integers (implicit integer conversion
is made) and return an integer result.  Operators <tt>| ^ & ~</tt>
denote correspondingly bitwise or, bitwise exclusive or, bitwise and,
and bitwise negation of 64-bit integers.
<p>
Operators <tt><< >>> >></tt> denote correspondingly logical left bit
shift, logical right bit shift, and arithmetic (with sign extension)
right bit shift of given number (the first operand) by given number of
bits (the second operand).  The value of the second operand must be
non-negative, otherwise the result is undefined.
<tscreen><verb>
          Expr = Expr "|"  Expr
               | Expr "^"  Expr
               | Expr "&"  Expr 
               | Expr "<<"  Expr
               | Expr ">>"  Expr
               | Expr ">>>"  Expr
               | "~"  Expr
</verb></tscreen>
        Examples:
<tscreen><verb>
          (i >> shift) & mask
          i & ~mask | (value << shift) & mask
          i >>> 2
          i << 2
</verb></tscreen>

<sect2>Comparison operators
<p>
All comparison operators return a logical value (integer 0 which
means false or integer 1 which means true).
<p>
Operators equality <tt>==</tt> and inequality <tt>!=</tt> may make
some conversion of the operands.  If one of the two operands is
string, then the string conversion is applied to the other operand
before the comparison.  Otherwise, standard arithmetic conversion is
applied to the operands.  The operators do not generate exceptions
(but the conversions may).  The operands are equal if they have the
same type and equal values (see section <em>Types and Values</em>).
For instances, functions and classes, the equality requires also the
same context.
<p>
Operator identity <tt>===</tt> or unidentity <tt>!==</tt> returns 1
if the operands have (or not) the same value or 0 otherwise.  The
operators never generate exceptions.
<p>
By default the arithmetic conversion is applied to the operands of
operators <tt>< > <= >=</tt>.  There is no exception if the operands
after the conversion are of integer, long integer, or floating point
type.  So the operands should be characters, integers, long integers,
floating point numbers, or strings representing integers, long
integers, or floating point numbers.
<tscreen><verb>
          Expr = Expr "=="  Expr  
               | Expr "!="  Expr  
               | Expr "==="  Expr  
               | Expr "!=="  Expr  
               | Expr "<"  Expr
               | Expr ">"  Expr  
               | Expr "<="  Expr
               | Expr ">="  Expr 
</verb></tscreen>
        Examples:
<tscreen><verb>
          10 == 10
          10 === 10
          10 == 10l
          10 == 10.0
          10 !== 10l
          10 !== 10.0
          10 <= 'c'
          p != nil
          'c' == "c"
          10 < "20.0"
          [10, 20] == [10, 20]
          [10, 20] !== [10, 20]
</verb></tscreen>

<sect2>Arithmetic operators
<p>
The following operators return integer, long integer, or floating
point numbers.  Before operator execution, implicit arithmetic
conversion is made on the operands.  The binary operators <tt>+ - * /
%</tt> denote correspondingly integer, long integer, or floating point
addition, subtraction, multiplication, division, and evaluation of
remainder.  Unary operator
<tt>-</tt> denotes arithmetic negation.  The unary operator <tt>+</tt>
is given for symmetry and it returns simply the operand after the
conversion.  It can be used for conversion of a string into an
integer, a long integer, or floating point number.
<tscreen><verb>
          Expr = Expr "+"  Expr
               | Expr "-"  Expr
               | Expr "*"  Expr
               | Expr "/"  Expr
               | Expr "%"  Expr
               | "+"  Expr
               | "-"  Expr
</verb></tscreen>
        Examples:
<tscreen><verb>
          +"0"
          +"10l"
          +"10."
          +"1e1"
          -i
          (value + m - 1) / m * m
          index % bound 
</verb></tscreen>

<sect2>Miscellaneous operators
<p>
The Dino conditional expression is analogous to the C language one.
Implicit arithmetic conversion is made for the first expression
followed by <tt>?</tt>.  If the value of the expression is non zero
(integer, long integer, or floating point), the second expression with
following
<tt>:</tt> is evaluated and it will be the result of the condition
expression.  Otherwise, the third expression is evaluated and it
becomes the result.
<p>
The operator <tt>#</tt> can be applied to a vector or a table.  It returns
the length of the vector or the number of elements in the table.
<p>
The operator <tt>@</tt> denotes concatenation of two vectors into a new
vector.  Before the concatenation implicit string conversion of the
operands is made.
<p>
The remaining operators look like function calls.  Operator
<tt>type</tt> returns the expression type.  Never is exception
generation possible during the operator evaluation.
<p>
The operator <tt>char</tt> is used to conversion of a value into a
character.  First, implicit integer conversion is applied to the
operand.  The operand should be an integer after the conversion.
Otherwise, exception <tt>optype</tt> will be generated.  The integer
is transformed into the character with the corresponding code.  If the
code is too big to be a character or is negative, exception
<tt>erange</tt> is generated.
<p>
The operator <tt>int</tt> is used to conversion of a value into an
integer.  Implicit integer conversion is applied to the operand.  The
operand should be an integer after the conversion.  Otherwise,
exception <tt>optype</tt> will be generated.  If the code is too big
to be an integer, exception <tt>erange</tt> is generated.
<p>
The operator <tt>float</tt> is used to conversion of a value into
floating-point number.  The first, implicit arithmetic conversion is
applied to the operand.  The operand should be an integer, an long
integer, or a floating-point number after the conversion.  Otherwise,
exception
<tt>optype</tt> will be generated.  Integer is transformed the
corresponding floating-point number.  The same is done for long
integer but if the number is too big or too small to be a
floating-point number, the result is undefined.
<p>
The operator <tt>vec</tt> is used for conversion of a value into a
vector.  First, implicit string conversion is applied to the operand.
The optional second expression defines the format used only for the
string conversion of a character, an integer, a long integer, a
floating point number, or a string.  The second parameter value should
be a string after implicit string conversion.  The format should not
be given for a table.  The first operand should be a table or a vector
after conversion.  The table is transformed into a new vector which
consists of pairs (one pair for each element in the table).  The first
element of the pair is a key of the corresponding element, and the
second one is the element itself.  The order of pairs in the result
vector is undefined.
<p>
The operator <tt>tab</tt> is used to conversion of a value into
table.  First, string conversion is applied to the operand.  The
operand should be a vector or a table after the conversion.  The
vector is transformed into a new table whose elements are equal to the
vector elements that have integer keys equal to the corresponding
vector indexes.
<tscreen><verb>
          Expr = Expr "?"  Expr ":" Expr
               | "#"  Expr
               | Expr "@"  Expr
               | type "(" Expr ")"
               | char "(" Expr ")"
               | int "(" Expr ")"
               | float "(" Expr ")"
               | vec "(" Expr ["," Expr] ")"
               | tab "(" Expr ")"
</verb></tscreen>
        Examples:
<tscreen><verb>
          i < 10 ? i : 10
          #{"a", 'b'}
          #["a", 'b']
          "concat this " @ "and this"
          type (type)
          type (10)
          char (12)
          vec  (10)
          vec  (10, "%x")
          vec ({"1":1, "2":2})
          tab ([1, 2, 3, 4])
</verb></tscreen>

<sect2>Slice Operators
<p>
There are slice variants of all operators of mentioned above except
for short circuit operators <tt>&&</tt> and <tt>||</tt> and
conditional expression.
<p>
For unary operators, operator execution on slices creates a new
vector structure consisting of elements referenced by the slices in
given order, creates the same dimension slices referencing all elements of the new
vector structure and execute the operator on each element of the
created slices which will be the result of the operator.  Examples:
<tscreen><verb>
          var v = [1, 2, "3"], m = [[1, 2.], [3, 4, 5]];
          ! v[:];
	  - m[1:][::2];
	  float (m[:][:]);
</verb></tscreen>
<p>
Binary operators on slices are a bit more complicated.  If the both
operands have slices, they should have the same <em>form</em>
(dimension, number of elements in each corresponding sub-vector
referenced by the slices), otherwise <tt>sliceform</tt> exception is
generated.  The operator execution can be considered as creating a new
vector structure consisting of elements referenced by the slices in
and creating the same dimension slices referencing all elements of the
new vector structure.  The same is done for the second slice.  Than
the elements of the new vector structure created for the first operand
is changed by the result of the operator applied to this element and
the corresponding element from the slices created for the second
operand.  The slices created for the first operand will be the result.  Examples:
<tscreen><verb>
          var v = [1, 2, 3], m = [[4, 5], [6, 7]];
          v[:] * v[:];
	  m[:][0::2] + m[:][1::2];
</verb></tscreen>
<p>
If only one operand has the slices, the operator execution can be
considered as creating a new vector structure consisting of elements
referenced by the slices and creating the same dimension slice
referencing all elements of the new vector structure.  Than the
elements of the new vector structure is changed by the result of the
operator applied to this element and another operand in given operand
order.  The created slices will be the result.  Examples:
<tscreen><verb>
          var v = [1, 2, 3], m = [[4, 5], [6, 7]];
          1 - v[:];
	  v[:] * v[:] * 2;
	  m[:][0::2] + 1;
</verb></tscreen>
<p>
Dino has additional unary operators which work only on slices:
<tscreen><verb>
          Expr = ".+"  Expr
               | ".*"  Expr
               | ".&"  Expr
               | ".^"  Expr
               | ".|"  Expr
</verb></tscreen>
<p>
The are called <em>fold operators</em>.  If the operand has no
slices, exception <tt>vecform</tt> is generated.  The operator execution
is to apply the corresponing non-fold operator to all elements
referenced by the slices.  Examples:
<tscreen><verb>
          var v = [1, 2, 3], m = [[4, 5], [6, 7]];
          .+ v[:];
	  .* v[:];
	  .& m[:][:];
</verb></tscreen>

<sect1>Current block instance
<p>
The instance of the block immediately surrounding the current program
point can be accessed by using keyword <tt>this</tt>.
<tscreen><verb>
          Expr = this
</verb></tscreen>
        Example of usage of <tt>this</tt>:
<tscreen><verb>
          class c (x) { putln (this.x, "===", x); }
          fun f (pub x) { return this; }
</verb></tscreen>

<sect1>Anonymous Functions and Classes
<p>
Instead of declaring a function/class and using its identifier
once in an expression, anonymous function/class can be used.
The anonymous functions/classes are regular expressions.  They
have the same syntax as the corresponding declarations.  The only
difference is an absence of function/class identifier:
<tscreen><verb>
          Expr = AnonHeader FormalParameters Block

          AnonHeader = [Qualifiers] FuncThreadClass
</verb></tscreen>
        Examples:
<tscreen><verb>
          fun (a) {a > 0;}
          class (x, y) {}
          thread (n) {for (var i = 0; i < n; i++) putln (i);}
</verb></tscreen>
        Example of anonymous function usage:
<tscreen><verb>
          fold (fun (a, b) {a * b;}, v, 1);
</verb></tscreen>


<sect>Patterns
<p>
Patterns have form of expressions.  They are used to match an
expression and decompose it.  Pattern can have form a vector value, a
table value, a function call, identifier, or special <em>wildcard</em>
symbol <tt>"_"</tt>.  Anything else is treated as an expression.
<tscreen><verb>
           Pattern = Expr
           Expr = "_" | "..."
</verb></tscreen>
<p>
A separate wildcard matches any value.  Identifier also matches any
value but additionally the matched value is assigned to
the <em>pattern variable</em> denoted by the identifier.  Expression
pattern matches any value equal to the the expression value.
<p>
A <em>vector pattern</em> matches a <em>vector value</em>.  All vector
pattern elements should match all subsequent elements of the vector
value.  If a vector pattern element has a form of another pattern than
it matches the corresponding vector value element iff the element
pattern matches the corresponding element value of the vector value.
<p>
A vector pattern element can also have a form <tt>expr ":"
pattern</tt>.  The value of the expression before <tt>":"</tt> is
converted into an integer value by default.  If the value after the
conversion is not integer, exception <tt>optype</tt> is generated.
The value can be zero or negative.  In this case matching the pattern
element is always successful and this matching does not correspond any
element of the matched vector value.  Othewise, the pattern
after <tt>":"</tt> should match corresponding elements in the vector
value.  The exact number of the elements is defined by expression
value before <tt>":"</tt>.  The matched element values should be equal
unless the pattern after <tt>":"</tt> is a wildcard <tt>"_"</tt>.
<p>
The last element of the vector pattern can be <tt>"..."</tt>.  It
matches the rest elements in the matched vector value.  The following
are examples of vector patterns (a, b, and c are identifies of pattern
variables):
<tscreen><verb>
           [a, b]
	   [a, ...]
	   [2, [a, b], 3 : c, 4 : _]
</verb></tscreen>
<p>
A <em>table pattern</em> matches a <em>table value</em>.  All table
pattern elements should match all elements of the table value.  If a
table pattern element has a form <tt>expr</tt>, then the table value
should have an element with a key given by the expression.
<p>
A table pattern element can also have a form <tt>expr ":"
pattern</tt>.  In this case the table value also should have an
element with a key given by the expression.  Additionally the element
value with given key should match the pattern after <tt>":"</tt>.
<p>
The last element of the table pattern can be <tt>"..."</tt>.  It
matches the rest elements in the matched table value.  The following
are examples of table patterns (a, b, and c are identifies of pattern
variables):
<tscreen><verb>
           tab ["k1", "k2"]
	   tab ["k1" : _, ...]
	   tab ["k" @ 1, [a, b], "k2" : c, ...]
</verb></tscreen>
<p>
An object pattern has a form of function/class call.  A <em>object
pattern</em> matches a class/function instance.  The function/class
should be a subtype of class/function given by the value of the
expression before <tt>"("</tt>.  The parameters in the pattern should
match all corresponding instance parameter values.  The number of the
values is taken from function/class given by the expression
before <tt>"("</tt>, not from function class of the instance.
Remember that arguments corresponding to <tt>"..."</tt> in
function/class parameter definitions become one array value.
<p>
The last parameter of the object pattern can be <tt>"..."</tt>.  It
matches the rest arguments of the corresponding object.  The following
are examples of object patterns (a, b, and c are identifies of pattern
variables):
<tscreen><verb>
	   leaf (10)
           node (_, a)
	   node (node (a, b), leaf (c))
</verb></tscreen>
<p>
Symbols <tt>"_"</tt> and <tt>"..."</tt> can be used only in patterns - they
can not be used in expressions.

<sect>Executive statements
<p>
Statements denote actions.  There are <em>simple</em> and
<em>compound</em> statements.  Simple statements do not consist of any
parts that are statements themselves.  They are the assignment,
procedure call, return, break, continue, throw, and the wait
statements.  Analogous to the C language the last symbol of a Dino
simple statement is semicolon <tt>;</tt>.  Compound statements
consists of parts that are statements themselves.  They are used to
express sequencing, exception handling, conditional, and repetitive
execution.

<sect1>Empty statement
<p>
There is also the empty statement in Dino.  It denotes no action.  The
empty statement is included in Dino for convenience.
<tscreen><verb>
          ExecutiveStmt = ";"
</verb></tscreen>
        Example: Usage of an empty statement in a for-statement:
<tscreen><verb>
          for (i = 0; a[i] == 0; i++)
            ;
</verb></tscreen>

<sect1>Block-statement
<p>
A block-statement is simply a block and can used to group statements
into one statement and/or describe local declarations.  For details on
how the block is executed see section <em>Declaration and Scope
Rules</em>.
<tscreen><verb>
          ExecutiveStmt = BlockStmt

          BlockStmt = Block
</verb></tscreen>
        Example: Usage of a block-statement in a for-statement:
<tscreen><verb>
          sum = 0;
          for (i = 0; i < #a; i++)
            {
	      var value = a[i];
              if (value > 0)
                sum += value;
            }
</verb></tscreen>

<sect1>Expression-statement
<p>
Dino has an expression statement.  Although it seems that the
expression value is not used, the expression evaluation can results in
side-effects, e.g. through calling a function/class.
Expression-statement as the last statement in the function block means
return of the expression value as the function call result.  In REPL
(see Appendix B. Implementation), execution of an expression-statement
results in printing the expression value.
<tscreen><verb>
          ExecutiveStmt = Expr ";"
</verb></tscreen>
        Examples:
<tscreen><verb>
          putln ("percent=" @ percent @ "%");
          newthread ();
	  5 + 10;
</verb></tscreen>
    
<sect1>Assignment statements
<p>
Assignment-statements are used to change variable values or element
values of a structured value which are referred through a designator
(see sub-section <em>Designator</em> in section <em>Expressions</em>.
The designator can not denote a final variable (see section
<em>Variable Declaration</em>).  You can not change the element value
of an immutable value (see section <em>Types and Values</em>).  In
this case exception <tt>immutable</tt> is generated.  Assignment to a
table element has a side effect, the element key becomes immutable.
<p>
A simple assignment statement looks like <tt>Designator = Expr;</tt>.
That means that the expression value is assigned to variable or
element of structured type value denoted by the designator.  For the
convenience of C programmers there are also the Dino assignments
<tt>Designator op= Expr;</tt>, <tt>Designator++;</tt>,
<tt>++Designator;</tt>, <tt>Designator--;</tt>, and
<tt>--Designator;</tt>.  They are analogous correspondingly to
<tt>Designator = Designator op Expr;</tt>, <tt>Designator = Designator
+ 1;</tt>, and <tt>Designator = Designator - 1;</tt>.  The only
difference is in the fact that the designator is evaluated only once,
not twice as in the analogous form.  It is important to know if you
have <em>side effects</em> in the statement.
<tscreen><verb>
          ExecutiveStmt = Designator Assign Expr ";"
                        | Designator ("++" | "--")  ";"
                        | ("++" | "--")  Designator ";"
          Assign = "="
                 | "*="
                 | "/="
                 | "%="
                 | "+="
                 | "-="
                 | "@="
                 | "<<="
                 | ">>="
                 | ">>>="
                 | "&="
                 | "^="
                 | "|="
</verb></tscreen>
        Examples:
<tscreen><verb>
          v = [10, 20];
          i = 1;
          i++;
          --i;
          i *= 20;
</verb></tscreen>
<p>
If the designator is a slice and the expression value is a slice too,
they both should have the same <em>form</em>,
otherwise <tt>sliceform</tt> exception is generated.  In this case
each element referenced by the designator slice gets value of the
corresponding element referenced by the expression slice.  If the
designator is a slice but the expression value is not, each element
referenced by the designator slice gets the expression value.  Examples
of the slice assignment:
<tscreen><verb>
          v = [1, 2, 3, 4];
          v[:] += 1;
          v[::-1] = v[:]; // reverse v
</verb></tscreen>

<sect1>If-statement
<p>
The Dino if-statement is analogous to the C language one.  First, the
expression after <tt>if</tt> is evaluated and arithmetic conversion is
done to it.  The value should be an integer, a long integer, or a
floating-point number, otherwise the exception <tt>optype</tt> is
generated.  If the value is nonzero the first statement is executed,
otherwise the statement after <tt>else</tt> is executed (if any).  The
problem with
<em>dangling else</em> is resolved analogous to the C language --
<tt>else</tt> is associated with the closest <tt>if</tt>.
<tscreen><verb>
          ExecutiveStmt = if  "(" Expr ")" Stmt [ else Stmt ]
</verb></tscreen>
        Examples:
<tscreen><verb>
          if (i < 0) i = 0;
          if (i < j) return -1; else if (i > 0) return 1; else return 0;
</verb></tscreen>

<sect1>For-statement
<p>
The Dino for-statement is analogous to the C language one.  The
statement is executed in the following way.
     <enum>
     <item>Execution of the first statement in the parentheses.
     <item>The expression (<em>for-guard</em>) is evaluated and
        implicit arithmetic conversion is made.  The value should be
        an integer, a long integer, or a floating point number.  If
        this is not true, exception <tt>optype</tt> is generated.
     <item>If the value of for-guard is nonzero, the body of the loop
        (the last statement) is executed.  Otherwise, the
        for-statement execution finishes.
     <item>When the body has been executed, the second statement in
        the parentheses is executed and steps 2,3,4 (one iteration) are
        repeated.
     </enum>
If the second statement is a simple statement, the statement semicolon
can be omitted.  The for-statement also can be finished by execution
of the statement <tt>break</tt> in the body.  The body can be finished
by execution of statement <tt>continue</tt>.  In this case, the
for-statement execution continues with the step 4.
<tscreen><verb>
          ExecutiveStmt = for  "(" Stmt ForGuardExpr ";"  Stmt ")" Stmt

          ForGuardExpr = [Expr]
</verb></tscreen>
        Examples:
<tscreen><verb>
          for (i = 0; i < 10; i++;) sum += v [i];
          for (i = 0; i < 10; i++) sum += v [i];
          for ({sum = 0; i = 0;} i < 10; i++) sum += v [i];
</verb></tscreen>

<sect1>Foreach-statement
<p>
This statement is used to execution of the foreach-statement body (the
statement) for all keys of table which is value of the expression.
The expression value should be a table.  If this is not true,
exception <tt>keyop</tt> is generated.  The current key value on each
iteration is assigned to the designator.  The order in which the key
values are assigned on each iteration is undefined.  One iteration can
be finished with the aid of the statement <tt>continue</tt> and a
foreach-statement can be finished by execution of statement
<tt>break</tt>.
<tscreen><verb>
          ExecutiveStmt = for  "(" Designator in Expr ")" Stmt
</verb></tscreen>
        Examples:
<tscreen><verb>
          putln ("The table is");
          for (k in t) {
            put ("key=");
            print (k);
            put (", element=");
            println (t{k});
          }
</verb></tscreen>

<sect1>Switch-statement
<p>
This statement is used to try matching switch-expression value (it is
evaluated only once) and the patterns in given order and execute the
statements corresponding to the first matched pattern.  Each case
forms an own scope.  Pattern variables are declared in the
corresponding case scope.  Execution of continue-statement in
case-statements results in continuing the process of matching
switch-expression value with the subsequent patterns.  Execution of
break-statement in case-statements results in finishing the
switch-statement execution.  There is implicit break at the end of
each case statement list.
<p>
If optional case condition is given, then it is evaluated after
succesfull matching with the corresponding pattern and arithmetic
conversion is done to it.  The value should be an integer, a long
integer, or a floating-point number, otherwise the
exception <tt>optype</tt> is generated.  If the value is nonzero the
all match is considered successfull, otherwise the subsequent case
patterns are tried.
<tscreen><verb>
          ExecutiveStmt = switch "(" Expr ")" "{" CaseList "}"
          CaseList = { case Pattern [CaseCond] ":" StmtList }
	  CaseCond = if Expr
</verb></tscreen>
        Examples:
          class c (a1, a2) {}
          switch (c (2, 3)) {
            case c (i, j): putln (i, j);
            case _: putln ("default");
          }
          switch (c (2, 3)) {
            case c (i, j) if i == j: putln ("eq=", i, j);
            case c (i, j) if i != j: putln ("neq=", i, j);
            case _: putln ("default");
          }
<tscreen><verb>
</verb></tscreen>

<sect1>Break- and continue-statement
<p>
Statements <tt>break</tt> and <tt>continue</tt> are used
correspondingly to finish execution of the closest-containing for-,
foreach-, or switch-statement covering the statement and to finish one iteration
of the body of the for- or foreach-statement and to continue trying
subsequent cases for switch-statement.  These statement can be
used only inside a for-, foreach-, or switch-statement.
<tscreen><verb>
          ExecutiveStmt = break ";"
                        | continue ";"
</verb></tscreen>
        Examples:
<tscreen><verb>
          for (i = 0; i < 10; i++) {
             if (ind [i] < 0)
               continue;
             val = v [ind[i]];
          }
          for (i in t)
            if (t{i} == elval)
              break;
          switch (tree) {
	    case leaf (n):
              putln ("leaf");
              if (n == 10) continue;
            case node (n1, n2):
              if (n1 != n2) break;
              putln ("special node");
	    case _: putln ("might be a leaf with 10");		   
          }
</verb></tscreen>

<sect1>Return-statement
<p>
Return-statement is used to finish execution of a function, a thread,
or class block.  The statement corresponds to the closest-containing
function, thread-function, or class covering the statement, so the
return-statement can be placed only in a function, a function-thread,
or a class.  The expression in a return-statement can be given only
for functions.  In this case, the expression value will be the value
of the function call (instead of undefined value).
<tscreen><verb>
          ExecutiveStmt = return  [ Expr ] ";"
</verb></tscreen>
        Examples:
<tscreen><verb>
          return;
          return [10, 2:0]
</verb></tscreen>

<sect1>Throw-statement
<p>
This statement generates an exception which is given by value of the
expression.  The expression should evaluate to an object of
predeclared class <tt>except</tt> or an object of a class declared
somewhere in predeclared class <tt>except</tt>.  If this is not true,
exception <tt>optype</tt> is generated.  How exceptions are processed
is described in the following section.
<tscreen><verb>
          ExecutiveStmt = throw  Expr ";"
</verb></tscreen>
        Examples:
<tscreen><verb>
          class myexcept (msg) {use error former msg;}
          throw myexcept ("this is an user defined exception");
</verb></tscreen>

<sect1>Try-block
<p>
Exceptions can be generated by the Dino interpreter when some
conditions are not satisfied, by predeclared Dino functions, by other
OS processes, by user interruptions, or by the user with the aid of a
throw-statement.  Actually, the exceptions are represented by an
object of the predeclared class <tt>except</tt> or by an object of a
class declared inside the predeclared class <tt>except</tt>.  All
predeclared exceptions are described in the section <em>Predeclared
Identifiers</em>.  To detect and process exceptions, a try-block can
be used.
<p>
When an exception is generated, the closest-containing try-block which
is covering the statement generating the exception or currently being
executed (when this is is generated by an OS process or by an user
interruption) is searched for.  Then, expressions in the catch list
elements are processed.  The expression value in the catch list
element being currently processed should be the predeclared class
<tt>except</tt> or a class declared inside the predeclared class
<tt>except</tt>.  If the expression being processed is a class and the
exception is an object of the class or an object of a class declared
inside the class, the block corresponding to the given catch list
element is executed.  If there is no such catch expression, the
closest-containing try-block covering the current try-block is
searched for and processing the exception is repeated.  If there are
no more try-blocks, the program finishes with a diagnostic message
which is dependent on the generated exception.
<p>
Blocks corresponding to catch list elements have a predeclared
variable <tt>e</tt>.  When block execution starts, the variable
contains the object representing the exception.
<tscreen><verb>
          ExecutiveStmt = TryBlockStmt

          TryBlockStmt = try Block { Catch }
       	
          Catch = catch  "(" ExceptClassList ")" Block

          ExceptClassList = Expr { "," Expr }
</verb></tscreen>
        Examples:
<tscreen><verb>
          try {
            var ln;
            for (;;)
              ln = getln ();
          } catch (eof) {
          }
          try {
            var v = [];
            v {1} = 0;
          } catch (except) {
            put ("catching and propagating exception"); println (class (e));
            throw e;
          }
</verb></tscreen>

<sect1>Wait-statement
<p>
This statement is used for the synchronization of different threads in
a Dino program.  The expression can not contain a function, class, or
a thread-function call.  The thread in which the statement has been
executed waits until the expression value becomes nonzero.  The
expression value (after implicit arithmetic conversion) should be an
integer, a long integer, or a floating point number.  Otherwise the
exception <tt>optype</tt> is generated.  When the expression value
becomes nonzero, the statement after the expression (it is called
sync-statement) is executed without interruption by other process.  It
is used as critical region for process synchronization.  In a critical
region execution of wait-statement is prohibited (it results in
generation of exception <tt>syncwait</tt>).  Also thread calls inside
a critical region result in generation exception
<tt>syncthreadcall</tt>.
<tscreen><verb>
          ExecutiveStmt = wait  "(" Expr ")" Stmt
</verb></tscreen>
        Examples:
<tscreen><verb>
          wait (!empty);
</verb></tscreen>

<sect>Program
<p>
A Dino program is simply a sequence of statements.  There is a special
declaration useful for writing programs consisting of several files or
for making Dino packages.  This is the include-declaration.  Before
execution of any statements all include-declarations are replaced by
files whose base names are given by the strings.  It is made
recursively, i.e.  the files themselves can contain other
include-declarations.  There should be no infinite recursion in this.
If <tt>+</tt> is present in the include-declaration, the file is
inserted in any case.  Without <tt>+</tt> the file is inserted only if
it has been yet not inserted into the block of the declaration.
<tscreen><verb>
          Program = StmtList

          IncludeDeclaration = include ["+"] STRING ";"
</verb></tscreen>
        Examples:
<p>
        The following program outputs the first 24 Fibonachi numbers:
<tscreen><verb>
          // Recursive function to compute Fibonacci numbers
          fun fibonacci (n)
            {
               if (n <= 1) return 1;
               return (fibonacci(n-1) + fibonacci(n-2));
            }
          
          var i, fibnum;
          
          fibnum = 0;
          for (i = 0; i <= 24; i++) 
            {
              fibnum = fibonacci(i);
              putln (i @ " " @ fibnum); 
            }
</verb></tscreen>
<p>
        The following program outputs the number of prime numbers less
        than 8190:
<tscreen><verb>
          var i, prime, k, count, flags;
          var final SieveSize = 8190;

          flags = [SieveSize + 1 : 0];
          count = 0;
          for (i = 0; i <= SieveSize; i++)
            flags[i] = 1;
          for (i = 0; i <= SieveSize; i++)
            if (flags[i])
              {
                prime = i + i + 3;
                k = i + prime;
                for (;1;;)
                  {
          	      if (k > SieveSize)
                      break;
                    flags[k] = 0;
                    k += prime;
                  }
                count++;
              }
          println (count);
</verb></tscreen>
<p>
        The following program outputs the number of occurrences of
        different numbers and identifiers in stdin:
<tscreen><verb>
          var i, key, voc = {};
          for (;;)
            try {
              var ln, a;

              ln = getln ();
              if (ln == "")
                continue;
              a = split (ln, "[^[:alnum:]]");
              for (i = 0; i < #a; i++)
                voc {a[i]} = (a[i] in voc ? voc {a[i]} + 1 : 1);
            } catch (eof) {
              break;
            }
          fun comp (el1, el2) {
            return cmpv (tolower (el1), tolower (el2));
          }
          key = sort (keys (voc), comp);
          for (i = 0; i < #key; i++)
            putln (key[i], " : ", voc{key[i]});
</verb></tscreen>
<p>
        The following program uses the Dino package <tt>socket</tt>:
<tscreen><verb>
          include "socket";
          var s, cl, str, l = 0;
          s = sockets.stream_server (10003, 4);
          cl = s.accept ();
          try {
            for (;;) {
               str = cl.read (64); l += #str; cl.write (str);
            }
          } catch (socket_eof_except) {
            putln ("i got ", l, " bytes");
          }
</verb></tscreen>

<sect>Predeclared identifiers
<p>
Dino has quite a lot of predeclared identifiers.  The section <em>Declarations
and Scope Rules</em> contains them in alphanumeric order.  Here they
are described according to the declaration category which they belongs
to.

<sect1>Predeclared variables
<p>
Dino has some predeclared variables which contain useful information
or can be used to control the behaviour of the Dino interpreter.

<sect2>Arguments and environment
<p>
To access arguments to the program and the environment, the following
variables can be used:
     <itemize>
     <item><tt>argv</tt>.  The variable value is an immutable vector
       whose elements are strings (immutable vectors of characters)
       representing arguments to the program (see implementation).
     <item><tt>env</tt>.  The variable value is immutable table whose
       elements are strings (immutable vectors of characters)
       representing values of environment variables whose names are
       the keys of the table.
     </itemize>

<sect2>Version
<p>
As Dino is a live programming language, it and its interpreter are in
the process of permanent development.  To access the Dino interpreter's
version number and consequently the language version, the final variable
<tt>version</tt> can be used.  The variable value is the Dino version as a
floating point number.  For example, if the current Dino version is
0.54, the variable value will be 0.54.


<sect2>Threads
<p>
To access some information about threads in Dino program, the
following variables can be used.
     <itemize>
     <item><tt>main_thread</tt>.  The variable value is the main
       thread.  When the program starts, there is only one thread
       which is called <em>the main thread</em>.
     <item><tt>curr_thread</tt>.  The variable value is the thread in
       which you reference the variable.
     </itemize>
All these variables are final, so you can not change their values.

<sect2>Files
<p>
To output something into standard streams or to input something from
the standard input stream, the following variables can be used:
     <itemize>
     <item><tt>stdin</tt>.  The variable value is an object of the
       class <tt>file</tt> which corresponds to the standard input
       stream.
     <item><tt>stdout</tt>.  The variable value is an object of the
       class <tt>file</tt> which corresponds to the standard output
       stream.
     <item><tt>stderr</tt>.  The variable value is an object of the
       class <tt>file</tt> which corresponds to the standard error
       stream.
     </itemize>
All these variables are final, so you can not change their values.
Encoding of the files is DINO current encoding at the program start
(see function <tt>set_encoding</tt>).

<sect2>Miscellaneous variables
<p>
Values of the following variables are used by some predeclared
functions:
     <itemize>
     <item><tt>split_regex</tt>.  The variable value is a string which
       represents regular expression which is used by the predeclared
       function <tt>split</tt> when the second parameter is not given.
       The initial value of the variable is string <tt>"[ \t]+"</tt>.
     <item><tt>time_format</tt>.  The variable value is a string which
       is the output format of time used by the function
       <tt>strtime</tt> when it is called without parameters.  The
       initial value of the variable is the string <tt>"%a %b %d
       %H:%M:%S %Z %Y"</tt>.
     </itemize>

<sect1>Predeclared classes
<p>
The most of the predeclared classes describe exceptions which may be
generated in Dino program.

<sect2>File
<p>
Dino has predeclared final class <tt>file</tt>.  Work with files in
Dino program are made through objects of the class.  All declarations
inside of class are private.  The objects of the class can be created
only by predeclared functions <tt>open</tt> or <tt>popen</tt>.  If you
create an object of the class by calling the class, exception
<tt>callop</tt> will be generated.  File encoding is defined by the
current DINO encoding at the file creation time (see
functions <tt>set_encoding</tt>, <tt>set_file_encoding</tt>).  If you
want to work with files on the byte level without any encoding
decoding, you can use encoding called <tt>"RAW"</tt>.

<sect2>Exception classes
<p>
All Dino exceptions are represented by objects of the predeclared
class <tt>except</tt> or of a class in the class <tt>except</tt>.  The
class <tt>except</tt> has no parameters, therefore all arguments in
calling the class will be ignored.  There is one predeclared class
<tt>error</tt> inside class <tt>except</tt>.  All classes
corresponding to user-defined exceptions are suggested to be declared
in class <tt>except</tt> not in the class <tt>error</tt> because all
other exceptions (e.g. generated by the Dino interpreter itself or by
predeclared functions) are objects of the class <tt>error</tt> or
predeclared classes inside the class <tt>error</tt>. The class
<tt>error</tt> and all classes inside the class has one parameter
<tt>msg</tt> which contains a readable message about the exception.
The following classes are declared in the class <tt>error</tt>:
     <itemize>
     <item><tt>signal</tt>.  Classes inside this class describe
       exceptions from receiving a signal from other OS processes.  They
       are
         <itemize>
         <item><tt>sigint</tt>.  This class describes the exception
           generated by the user's interrupt from the keyboard.
         <item><tt>sigill</tt>.  This class describes the exception
           generated by illegal execution of an instruction .
         <item><tt>sigabrt</tt>.  This class describes the exception
           generated by the signal abort.
         <item><tt>sigfpe</tt>.  This class describes floating point
           exception.
         <item><tt>sigterm</tt>.  This class describes the exception
           generated by the termination signal.
         <item><tt>sigsegv</tt>.  This class describes the exception
           generated by an invalid memory reference.
         </itemize>
     <item><tt>invenv</tt>.  This class describes corruption of the Dino
       program environment (see predeclared variable <tt>env</tt>).
     <item><tt>invop</tt>.  Classes inside this class describe
       exceptions when operands of operations have an incorrect type or
       value.
         <itemize>
         <item><tt>optype</tt>.  This class describes that the operand
           of an operation is not of the required type (possibly after
           implicit conversions).
         <item><tt>opvalue</tt>.  This class is reserved for the error
           of that an operand of an operation has invalid value.  Now
           this exception is not generated.
         </itemize>
     <item><tt>invindex</tt>.  Classes inside this class describe
       exceptions in referring for a vector element.
         <itemize>
         <item><tt>indextype</tt>.  This class describes that the
           index is not of integer type (possibly after implicit
           integer conversion).
         <item><tt>indexvalue</tt>.  This class describes that the
           index is negative or equal to or more than the vector
           length.
         <item><tt>indexop</tt>.  This class describes that the first
           operand in referring to a vector element is not a vector.
         </itemize>
     <item><tt>invkey</tt>.  Classes inside this class describe
       exceptions in referring to a table element.
         <itemize>
         <item><tt>keyvalue</tt>.  This class describes that there is
           no such element in the table with the given key when we
           need the value of the element.  The exception does not
           occur when a table element reference stands in the left
           hand side of an assignment-statement.
         <item><tt>keyop</tt>.  This class describes that the first
           operand in referring to a table element is not a table.
         </itemize>
     <item><tt>invcall</tt>.  Classes inside this class describe
       exceptions in calling functions (mainly predeclared ones).
         <itemize>
         <item><tt>callop</tt>.  This class describes that we try to
           call something which is not a function, class, or
           thread-function.  The exception is also generated when you
           try to create a class <tt>file</tt> instance by calling the
           class.
         <item><tt>partype</tt>.  This class describes that a
           parameter value of a predeclared function is not of
           required type.
         <item><tt>parvalue</tt>.  This class describes that a
           parameter value of a predeclared function is not one of
           permitted values (see functions <tt>set_encoding</tt>,
           <tt>set_file_encoding</tt>).
         <item><tt>invfmt</tt>.  This class describes that a format of
           a format output function is wrong (see function
           <tt>putf</tt>).
         <item><tt>invencoding</tt>.  This class describes different
           exceptions with used encodings, e.g. file contains bytes
           not corresponding to the expected encoding or in some cases
           the encoding should contain ASCII characters.
         <item><tt>invresult</tt>.  This class describes that the
           result value of function call is not of required type,
           e.g. comparison function used in a call to function
           <tt>sort</tt> returns a non integer value.
         <item><tt>invinput</tt>.  This class describes that the file
           input is not of required format.  Usually the exception is
           generated by function <tt>scan</tt> etc.
         <item><tt>eof</tt>.  This class describes that end of file is
           encountered.  Usually the exception is generated by
           functions reading files (<tt>get</tt>, <tt>scan</tt> etc).
         <item><tt>parnumber</tt>.  This class describes that the
           number of actual parameters is not valid when we call a
           predeclared function.
         <item><tt>syserror</tt>.  Classes inside this class describe
           exceptions in predeclared functions which call OS system
           functions.  Some exceptions are never generated but may
           be generated in the future on some OSes.
           <itemize>
           <item><tt>eaccess</tt>.  This describes the system error
             "Permission denied".
           <item><tt>eagain</tt>.  This describes the system error
             "Resource temporarily unavailable".
           <item><tt>ebadf</tt>.  This describes the system error
             "Bad file descriptor".
           <item><tt>ebusy</tt>.  This describes the system error
             "Resource busy".
           <item><tt>echild</tt>.  This describes the system error
             "No child processes".
           <item><tt>edeadlk</tt>.  This describes the system error
             "Resource deadlock avoided".
           <item><tt>edom</tt>.  This describes the system error
             "Domain error".
           <item><tt>eexist</tt>.  This describes the system error
             "File exists".
           <item><tt>efault</tt>.  This describes the system error
             "Bad address".
           <item><tt>efbig</tt>.  This describes the system error
             "File too large".
           <item><tt>eintr</tt>.  This describes the system error
             "Interrupted function call".
           <item><tt>einval</tt>.  This describes the system error
             "Invalid argument".
           <item><tt>eio</tt>.  This describes the system error
             "Input/output error".
           <item><tt>eisdir</tt>.  This describes the system error
             "Is a directory".
           <item><tt>emfile</tt>.  This describes the system error
             "Too many open files".
           <item><tt>emlink</tt>.  This describes the system error
             "Too many links".
           <item><tt>enametoolong</tt>.  This describes the system
             error "Filename too long".
           <item><tt>enfile</tt>.  This describes the system error
             "Too many open files in system".
           <item><tt>enodev</tt>.  This describes the system error "No
             such device".
           <item><tt>enoent</tt>.  This describes the system error "No
             such file or directory".
           <item><tt>enoexec</tt>.  This describes the system error
             "Exec format error".
           <item><tt>enolck</tt>.  This describes the system error "No
             locks available".
           <item><tt>enomem</tt>.  This describes the system error
             "Not enough space".
           <item><tt>enospc</tt>.  This describes the system error "No
             space left on device".
           <item><tt>enosys</tt>.  This describes the system error
             "Function not implemented".
           <item><tt>enotdir</tt>.  This describes the system error
             "Not a directory".
           <item><tt>enotempty</tt>.  This describes the system error
             "Directory not empty".
           <item><tt>enotty</tt>.  This describes the system error
             "Inappropriate I/O control operation".
           <item><tt>enxio</tt>.  This describes the system error "No
             such device or address".
           <item><tt>eperm</tt>.  This describes the system error
             "Operation not permitted".
           <item><tt>epipe</tt>.  This describes the system error
             "Broken pipe".
           <item><tt>erange</tt>.  This describes the system error
             "Result too large".
           <item><tt>erofs</tt>.  This describes the system error
             "Read-only file system".
           <item><tt>espipe</tt>.  This describes the system error
             "Invalid seek".
           <item><tt>esrch</tt>.  This describes the system error "No
             such process".
           <item><tt>exdev</tt>.  This describes the system error
             "Improper link".
           </itemize>
         <item><tt>systemcall</tt>.  Classes inside this class
           describe exceptions in calling the predeclared function
           <tt>system</tt>.
           <itemize>
           <item><tt>noshell</tt>.  This class describes the exception
             that the function <tt>system</tt> can not find the OS
             command interpreter (the shell).
           <item><tt>systemfail</tt>.  This class describes all
             remaining exceptions in calling the OS function
             <tt>system</tt>.
           </itemize>
         <item><tt>invparser</tt>.  Classes inside this class describe
           exceptions specific for calling functions of the predeclared
           class <tt>parser</tt> implementing the Earley parser.
           <itemize>
           <item><tt>invgrammar</tt>.  This class describes
             the exception that the Earley parser got a bad grammar,
             e.g. without rules, with loops in rules, with
             nonterminals unachievable from the axiom, with nonterminals
             not deriving any terminal string etc.
           <item><tt>invtoken</tt>.  This class describes the
             exception that the parser got an input token with unknown
             (undeclared) code.
           <item><tt>pmemory</tt>.  This class describes the exception
             that there is not enough memory for internal parser
             data.
           </itemize>
         <item><tt>invregex</tt>.  This class describes exceptions
           specific for calling predeclared functions implementing
           regular expression pattern matching.
         <item><tt>invextern</tt>.  Classes inside this class describe
           exceptions in calling external functions or in accessing
           an external variable.
           <itemize>
           <item><tt>noextern</tt>.  This class describes the
             exception that the given external can not be find.
           <item><tt>libclose</tt>.  This class describes the
             exception that there is an error in closing a shared
             library.
           <item><tt>noexternsupp</tt>.  This class describes an
             exception in the usage of externals when they are not
             implemented under this OS.
           </itemize>
         <item><tt>invenvar</tt>.  This class describes corruption in
           the type of variables <tt>split_regex</tt> and
           <tt>time_format</tt> (e.g. their values are not strings).
         <item><tt>internal</tt>.  This class describes all other
           (nonspecified) exceptions in calling predeclared functions.
         </itemize>
     </itemize>

<sect2>Earley parser classes
<p>
Dino has the three following classes which are used by the Earley parser
embedded into the Dino interpreter.

<sect3>Parser.
<p>
Dino has predeclared final class <tt>parser</tt> which implements
the Earley parser.  The Earley parser is a very powerful tool to implement
serious language compilers, processors, or translators.  The
implementation of the Earley parser used in Dino has the following
features:

     <itemize>
     <item>It is sufficiently fast and does not require much memory.
       This is the fastest implementation of the Earley parser which I
       know.  The main design goal is to achieve speed and memory
       requirements which are necessary to use it in prototype
       compilers and language processors.  It parses 30,000 lines of C
       per second on 500 MHz Pentium III and allocates about
       5Mb memory for a 10,000 line C program.
     <item>It makes simple syntax directed translation, so an
       abstract tree is already the output of the Earley parser.
     <item>It can parse input described by an ambiguous grammar.  In
       this case the parse result can be an abstract tree or all
       possible abstract trees.  Moreover, it produces the compact
       representation of all possible parse trees by using DAG instead
       of real trees.  These features can be used to parse natural
       language sentences.
     <item>It can make syntax error recovery.  Moreover its error
       recovery algorithms find error recovery with a minimal number
       of ignored tokens.  It permits implemention of parsers with
       very good error recovery and reporting.
     <item>It has fast startup.  There is practically no delay between
       processing of grammar and start of parsing.
     <item>It has a flexible interface.  The input grammar is given by
       a YACC-like description.
     <item>It has a good debugging features.  It can print huge amount
       of information about grammar, parsing, error recovery,
       translation.  You can even get the result translation in a form
       for a graphic visualization program.
     </itemize>
The following public functions and variables are declared in the class
<tt>parser</tt>:
     <itemize>
     <item><tt>ambiguous_p</tt>.  This public variable stores
       information about the last parsing.  A nonzero variable value
       means that during the last parsing on a given input the parser
       found that the grammar is ambiguous.  The parser can find this
       even if you asked for only one parser tree (see function
       <tt>set_one_parse</tt>).

     <item><tt>set_grammar (descr, strict_p)</tt>.  This function
       tunes the parser to given grammar.  The grammar is given by
       string <tt>descr</tt>.  Nonzero value of parameter
       <tt>strict_p</tt> (after implicit integer conversion) means
       more strict checking the grammar.  In this case, all
       nonterminals will be checked on their ability to derive a
       terminal string instead of only checking the axiom for this.
       The function can generate exceptions <tt>partype</tt> (if the
       parameters have wrong types) or <tt>invgrammar</tt> if the
       description is a bad grammar.  The function can also generate
       exception <tt>pmemory</tt> if there is no memory for internal
       parser data.

       The description is similiar to the <em>YACC</em> one.  It has
       the following syntax:
       <tscreen><verb>
          file : file terms [';']
               | file rule
               | terms [';']
               | rule
       
          terms : terms IDENTIFIER ['=' NUMBER]
                | TERM
       
          rule : IDENTIFIER ':' rhs [';']
          
          rhs : rhs '|' sequence [translation]
              | sequence [translation]
          
          sequence :
                   | sequence IDENTIFIER
                   | sequence C_CHARACTER_CONSTANT
          
          translation : '#'
                      | '#' NUMBER
                      | '#' '-'
                      | '#' IDENTIFIER [NUMBER] '(' numbers ')'
          
          numbers :
                  | numbers NUMBER
                  | numbers '-'
       </verb></tscreen>
       So the description consists of terminal declaration and
       rule sections.
       
       The terminal declaration section describes the name of
       terminals and their codes.  The terminal code is optional.  If
       it is omitted, the terminal code will the next free code
       starting with 256.  You can declare a terminal several times
       (the single condition is that its code should be the same).
       
       A character constant present in the rules is a terminal
       described by default.  Its code is always the ASCII code of the
       character constant.
       
       Rules syntax is the same as <em>YACC</em> rule syntax.  The
       single difference is an optional translation construction
       starting with <tt>#</tt> right after each alternative.  The
       translation part could be a single number which means that the
       translation of the alternative will be the translation of the
       symbol with the given number (symbol number in the alternative
       start is with 0).  Or the translation can be empty or
       `<tt>-</tt>' which designates the value of the variable
       <tt>nil_anode</tt>.  Or the translation can be an abstract node
       with the given name, optional cost, and with fields whose
       values are the translations of the alternative symbols with
       numbers given in parentheses after the abstract node name.  You
       can use `<tt>-</tt>' in an abstract node to show that the empty
       node should be used in this place.  If the cost is absent it is
       believed to be 1.  The cost of the terminal, error node, and
       empty node is always zero.

       There is a reserved terminal <tt>error</tt> which marks the
       start point of error recovery.  The translation of the terminal
       is the value of the variable <tt>error_anode</tt>.
 
     <item><tt>set_debug (level)</tt>.  This function sets up the
       level of debugging information output to <tt>stderr</tt>.  The
       higher the level, the more information is output.  The default
       value is 0 (no output).  The debugging information includes
       statistics, the result translation tree, the grammar, parser
       sets, parser sets with all situations, situations with
       contexts.  The function returns the previously set up debug
       level.  Setting up a negative debug level results in output of
       the translation for program <bf>dot</bf> of the graphic
       visualization package <bf>graphviz</bf>.  The parameter should
       be an integer after implicit integer conversion.  The function
       will generate exception <tt>partype</tt> if it is not true.
     <item><tt>set_one_parse (flag)</tt>.  This function sets up a
       flag whose nonzero value means building only one translation
       tree (without any alternative nodes).  For an unambiguous
       grammar the flag does not affect the result.  The function
       returns the previously set up flag value.  The default value of
       the flag is 1.  The parameter should be an integer after
       implicit integer conversion.  The function will generate
       exception <tt>partype</tt> if it is not true.
     <item><tt>set_lookahead (flag)</tt>.  This function sets up a
       flag of of usage of look ahead in the parser work.  The usage
       of lookahead gives the best results with the point of view of
       space and speed.  The default value is 1 (the lookahead usage).
       The function returns the previously set up flag.  No usage of
       the lookahead is useful sometimes to get more understandable
       debug output of the parser work (see function
       <tt>set_debug</tt>).  The parameter should be an integer after
       implicit integer conversion.  The function will generate the
       exception <tt>partype</tt> if it is not true.
     <item><tt>set_cost (flag)</tt>.  This function sets up building
       the only translation tree (trees if we set up one_parse_flag to
       0) with minimal cost.  For an unambiguous grammar the flag does
       not affect the result.  The default value is 0. The function
       returns the previously set up flag value.  The default value of
       the flag is 0.  The parameter should be an integer after
       implicit integer conversion.  The function will generate
       exception <tt>partype</tt> if it is not true.
     <item><tt>set_recovery (flag)</tt>.  This function sets up a flag
       whose nonzero value means making error recovery if a syntax
       error occurred.  Otherwise, a syntax error results in finishing
       parsing (although the syntax error function passed to
       <tt>parse</tt> is called once).  The function returns the
       previously set up flag value.  The default value of the flag is
       1.  The parameter should be an integer after implicit integer
       conversion.  The function will generate exception
       <tt>partype</tt> if it is not true.
     <item><tt>set_recovery_match (n_toks)</tt>.  This function sets
       up an internal parser parameter meaning how much subsequent
       tokens should be successfully shifted to finish error recovery.
       The default value is 3.  The function returns the previously
       set up value.  The parameter should be an integer after
       implicit integer conversion.  The function will generate
       exception <tt>partype</tt> if it is not true.

     <item><tt>parse (tokens, error_func)</tt>. This function is the
       major function of the class.  It makes translation according to
       the previously set up grammar of input given by the parameter
       <tt>tokens</tt> whose value should be an array of objects of
       predeclared class <tt>token</tt> or its subtype.  If the parser
       recognizes a syntax error it calls the function given through
       parameter <tt>error_func</tt> with six parameters:
          <itemize>
          <item>index of the token (in array <tt>tokens</tt>) on which
            the syntax error occured.
          <item>the error token itself.  It may be <tt>nil</tt> for
            end of file.
          <item>index of the first token (in array <tt>tokens</tt>)
            ignored due to error recovery.
          <item>the first ignored token itself.  It may be
            <tt>nil</tt> for end of file.
          <item>index of the first token (in array <tt>tokens</tt>)
            which is not ignored after error recovery.
          <item>the first not ignored token itself.  It may be
            <tt>nil</tt> for end of file.
          </itemize>
       If the parser works with switched off error recovery (see
       function <tt>set_recovery</tt>, the third and fifth parameters
       will be negative and forth and sixth parameter will be
       <tt>nil</tt>.

       The function returns an object of the predeclared class
       <tt>anode</tt> which is the root of the abtsract tree
       representing the translation of the parser input.  The function
       returns <tt>nil</tt> only if syntax error was occurred and
       error recovery was switched off.  The function can generate
       exception <tt>partype</tt> if the parameter types are wrong or
       exception <tt>invtoken_decl</tt> if any of the input tokens
       have a wrong code.  The function also can generate exception
       <tt>pmemory</tt> if there is no memory for internal parser
       data.
     </itemize>

The call of the class <tt>parser</tt> itself can generate exception
<tt>pmemory</tt> if there is no memory for internal parser
data.

<sect3>Token.
<p>
Dino has a predeclared class <tt>token</tt>.  Objects of this class
should be the input of the Earley parser (see function <tt>parse</tt>
in class <tt>parser</tt>).  The result abstract tree representing the
translation will have input tokens as leaves.  The class
<tt>token</tt> has one public variable <tt>code</tt> whose value
should be the code of the corresponding terminal described in the
grammar.  You could extend the class description e.g. by adding
variables whose values could be attributes of the token (e.g. source
line number, name of an identifier, or value for a number).

<sect3>Anode.
<p>
Dino has a predeclared class <tt>anode</tt> whose objects are nodes of
the abtract tree representing the translation (see function
<tt>parse</tt> of class <tt>parser</tt>).  Objects of this class are
generated by the Earley parser.  The class has two public variables
<tt>name</tt> whose value is string representing name of the abstract
node as it given in the grammar and <tt>transl</tt> whose value is
array with abstract node fields as the array elements.  There are a
few node types which have special meaning:

     <itemize>
     <item>Terminal node which has reserved name <tt>$term</tt>.  The
       value of the public variable <tt>transl</tt> for this node is
       an object of class <tt>token</tt> representing the
       corresponding input token which was an element of the array
       passed as a parameter of function <tt>parse</tt> of function
       <tt>parser</tt>.
     <item>Error node which has reserved name <tt>$error</tt>.  This
       node exists in one exemplar (see description of variable
       <tt>error_anode</tt>) and represents the translation of
       reserved grammar symbol <tt>error</tt>.  The value is public
       variable <tt>transl</tt> will be <tt>nil</tt> in this case.
     <item>The empty node which has the reserved name <tt>$nil</tt>.
       This node also exists in one exemplar (see description of
       variable <tt>nil_anode</tt>) and represents the translation of
       a grammar symbol for which we did not describe a translation.
       For example, in a grammar rule an abstract node refers for the
       translation of a nonterminal for which we do not produce a
       translation.  The value is public variable of such class object
       will be <tt>nil</tt> in this case.
     <item>Alternative node which has the reserved name <tt>$alt</tt>.
       It represents all possible alternatives in the translation of
       the grammar nonterminal.  The value of the public variable
       <tt>transl</tt> will be an array with elements whose values are
       objects of class <tt>anode</tt> which represent all possible
       translations.  Such nodes can be generated by the parser only
       if the grammar is ambiguous and we did not ask it to produce
       only one translation.
     </itemize>

<sect3>Nil_anode and error_anode.
<p>
There is only one instance of <tt>anode</tt> which represents empty
(nil) nodes.  The same is true for the error nodes.  The final
variables <tt>nil_anode</tt> and <tt>error_anode</tt> correspondingly
refer to these nodes.

<sect3>Example of Earley parser usage.
<p>
Let us write a program which transforms an expression into postfix
polish form.  Please, read the program comments to understand what the
code does.  The program should output string <tt>"abcda*+*+"</tt>
which is the postfix polish form of input string
<tt>"a+b*(c+d*a)"</tt>.
<tscreen><verb>
          // The following is the expression grammar:
          var grammar = "E : E '+' T   # plus (0 2)\n\
                           | T         # 0\n\
                           | error     # 0\n\
                         T : T '*' F   # mult (0 2)\n\
                           | F         # 0\n\
                         F : 'a'       # 0\n\
                           | 'b'       # 0\n\
                           | 'c'       # 0\n\
                           | 'd'       # 0\n\
                           | '(' E ')' # 1";
          // Create parser and set up grammar.
          var p = parser ();
          p.set_grammar (grammar, 1);

          // Add attribute repr to token:
          class our_token (code) { use token former code; var repr; }
          // The following code forms input tokens from string:
          var str = "a+b*(c+d*a)";
          var i, inp = [#str : nil];
          for (i = 0; i < #str; i++) {
            inp [i] = our_token (str[i] + 0);
            inp [i].repr = str[i];
          }
          // The following function output messages about syntax errors
          // syntax error recovery:
          fun error (err_start, err_tok,
                      start_ignored_num, start_ignored_tok_attr,
	              start_recovered_num, start_recovered_tok) {
            put ("syntax error on token #", err_start,
                 " (" @ err_tok.code @ ")");
            putln (" -- ignore ", start_recovered_num - start_ignored_num,
                   " tokens starting with token #", start_ignored_num);
          }

          var root = p.parse (inp, error); // parse

          // Output translation in polish inverse form
          fun pr (r) {
            var i, n = r.name;

            if (n == "$term")
              put (r.transl.repr);
            else if (n == "mult" || n == "plus") {
              for (i = 0; i < #r.transl; i++)
                pr (r.transl [i]);
              put (n == "mult" ? "*" : "+");
            }
            else if (n != "$error") {
              putln ("internal error");
	      exit (1);
            }
          }

          pr (root);
          putln ();
</verb></tscreen>

<sect1>Predeclared functions
<p>
The predeclared functions expect a given number of actual parameters
(may be a variable number of parameters).  If the actual parameter
number is an unexpected one, exception <tt>parnumber</tt> is
generated.  The predeclared functions believe that the actual
parameters (may be after implicit conversions) are of the required
type.  If this is not true, exception <tt>partype</tt> is generated.
To show how many parameters the function requires, we will write the
names of the parameters and use brackets <tt>[</tt> and <tt>]</tt> for
the optional parameters in the description of the functions.
<p>
        Examples:  The following description
<tscreen><verb>
          strtime ([format [, time]])
</verb></tscreen>
        describes that the function can accept zero, one, or two
        parameters.  If only one parameter is given, then this is
        parameter <tt>format</tt>.
<p>
If something is not said about the returned result, the function
return value is undefined.

<sect2>Mathematical functions
<p>
The following functions make implicit arithmetic conversion of the
parameters.  After the conversions the parameters are expected to be
of integer, long integer, or floating point type.  The result is
always a floating point number.
     <itemize>
     <item><tt>sqrt (x)</tt>.  The function returns the square root of
       <tt>x</tt>.  The function generates the exception <tt>edom</tt>
       if <tt>x</tt> is negative.
     <item><tt>exp (x)</tt>.  The function returns <tt>e</tt> (the
       base of the natural logarithm) raised to the power of
       <tt>x</tt>.
     <item><tt>log (x)</tt>.  The function returns the natural
       logarithm of <tt>x</tt>.  The function generates the exception
       <tt>edom</tt> if <tt>x</tt> is negative or may generate
       <tt>erange</tt> if the value is zero.
     <item><tt>log10 (x)</tt>.  The function returns the decimal
       logarithm of <tt>x</tt>.  The function generates the exception
       <tt>edom</tt> if <tt>x</tt> is negative or may generate
       <tt>erange</tt> if the value is zero.
     <item><tt>pow (x, y)</tt>.  The function returns <tt>x</tt>
       raised to the power of <tt>y</tt>.  The function generates
       exception <tt>edom</tt> if x is negative and y is not of
       integral value.
     <item><tt>sin (x)</tt>.  The function returns the sine of
       <tt>x</tt>.
     <item><tt>cos (x)</tt>.  The function returns the cosine of
       <tt>x</tt>.
     <item><tt>atan2 (x, y)</tt>.  The function returns the arc
       tangent of the two variables <tt>x</tt> and <tt>y</tt>.  It is
       similar to calculating the arc tangent of <tt>y / x</tt>,
       except that the signs of both arguments are used to determine
       the quadrant of the result.
     </itemize>

<sect2>Pattern matching functions
<p>
Dino has the predeclared functions which are used for <em>pattern
matching</em>.  The pattern is described by <em>regular
expressions</em> (<em>regex</em>) and actually a small program
describing a string matching.  The pattern has <em>default</em> syntax
of ONIGURUMA package for Unicode.  It is hard to describe formally the
pattern syntax.  Here is not a completely strict description for full
reference, please see OINGURUMA package documentation.  The regular
expressions have the following syntax:
<tscreen><verb>
          Regex = Branch {"|" Branch}
</verb></tscreen>
A regex matches anything that matches one of the <em>branches</em>.
<tscreen><verb>
          Branch = {Piece}
</verb></tscreen>
A branch matches a match for the first <em>piece</em>, followed by a
match for the second piece, etc.  If the pieces are omitted, the
branch matches the null string.
<tscreen><verb>
          Piece = Anchor | Unit

          Unit = Atom
               | Unit Quantifier

          Quantifier = Greedy
                     | Reluctant
                     | Possesive

          Greedy = "?"                 // 0 or 1 times
                 | "*"                 // 0 or more times
                 | "+"                 // 1 or more times
                 | Bound

          Bound = "{" Min "," Max "}" // from Min to Max times
                | "{" Min "," "}"     // at least Min times
                | "{" "," Max "}"     // equivalent to {0, Max}
                | "{" Min "}"         // given number times

          Reluctant = "??"
                    | "*?"
                    | "+?"
                    | Bound "?"

          Possesive : "?+"
                    | "*+"
                    | "++"

          Min = <unsigned integer>

          Max = <unsigned integer>
</verb></tscreen>
An <em>unit</em> followed by <tt>*</tt> matches a sequence of 0 or
more matches of the unit.  An unit followed by <tt>+</tt> matches a
sequence of 1 or more matches of the unit.  An unit followed by
<tt>?</tt> matches a sequence of 0 or 1 matches of the unit.
<p>
There is a more general construction (a <em>bound</em>) for describing
repetitions of an unit.  An unit followed by a bound containing only
one integer <tt>Min</tt> matches a sequence of exactly <tt>Min</tt>
matches of the unit.  An unit followed by a bound containing one
integer <tt>Min</tt> and a comma matches a sequence of <tt>Min</tt> or
more matches of the unit.  An unit followed by a bound containing a
comma and one integer <tt>Max</tt> matches at most <tt>Max</tt>
repetitions of the unit.  An unit followed by a bound containing two
integers <tt>Min</tt> and <tt>Max</tt> matches a sequence of
<tt>Min</tt> through <tt>Max</tt> (inclusive) matches of the unit.
<p>
The described above qualifiers are <em>greedy</em> ones.  A gready
qualifier first matches as much as possible and can back-track in case
whole regex matching failure to try shorter sequence.  There
are <em>reluctant</em> qualifiers too.  They have additional
suffix <tt>?</tt> and first matches as little as possible.  The last
type of qualifiers is possesive.  Such qualifiers have additional
suffix <tt>+</tt> and behave like the corresponding greedy ones, but
they do not back-track.
<p>
       Examples:
<tscreen><verb>
          `.?foo` // matches first "xfoo" in "xfooxxxxfoo"
          `.*foo` // matches all "xfooxxxxfoo"
          `.+foo` // matches all "xfooxxxxfoo"
          `.{1,8}foo` // matches all "xfooxxxxfoo"
          `.*?foo` // matches first "xfoo" in "xfooxxxxfoo"
          `.+?foo` // Ditto
          `.{1,8}?foo` // Ditto
	  `.*+foo` // fail to match in "xfooxxxxfoo"
	  `.++foo` // fail to match in "xfooxxxxfoo"
</verb></tscreen>
<tscreen><verb>
         Atom =  Anchors
	       | Character
               | CharacterType
               | CharacterProperty
               | CharacterClass
               | Group
               | BackReference
	       | SubexpCall
	 
	  Character = "\t"     // horizontal tab (0x09)
	            | "\v"     // vertical tab (0x0B)
	            | "\n"     // newline tab (0x0A)
	            | "\r"     // return (0x0D)
	            | "\f"     // form feed (0x0C)
	            | "\a"     // bell (0x07)
	            | "\e"     // escape (0x1B)
	            | "\" OctalCode // char with given octal code
	            | "\x" HexCode  // char with given hexadecimal code
                    | <any but special character \ ? * + ^ $ [ ( ) >
                    | "\" <special character>
      
          OctalCode = <3 octal digits>
	
	  HexCode = <2 heaxadecimal digits>
	  
          CharacterType = '.'  // any character but newline
                        | "\w" // Unicode Letter, Mark, Number, or
                               //   Connector_Punctuation
                        | "\W" // opposite to the above 
                        | "\s" // Unicode Line_Separator, 
                               //   Paragraph_Separator, or
                               //   Space_Separator
                        | "\S" // opposite to the above 
                        | "\d" // Unicode decimal number 
                        | "\D" // opposite to the above 
                        | "\h" // hexadecimal digit char [0-9a-fA-F] 
                        | "\H" // opposite to the above 

          CharacterProperty = "\p{" PropertyName "}"
                            | "\p{^" PropertyName "}"
                            | "\P{" PropertyName "}"

         PropertyName = "Alnum" | "Alpha" | "Blank" | "Cntrl"
                      | "Digit" | "Graph" | "Lower" | "Print"
                      | "Punct" | "Space" | "Upper" | "XDigit"
                      | "Word" | "ASCII"
                      | "Any" | "Assigned" | "C" | "Cc" | "Cf"
                      | "Cn" | "Co" | "Cs" | "L" | "Ll" | "Lm"
                      | "Lo" | "Lt" | "Lu" | "M" | "Mc" | "Me"
                      | "Mn" | "N" | "Nd" | "Nl" | "No" | "P"
                      | "Pc" | "Pd" | "Pe" | "Pf" | "Pi" | "Po"
                      | "Ps" | "S" | "Sc" | "Sk" | "Sm" | "So"
                      | "Z" | "Zl" | "Zp" | "Zs" | "Arabic"
                      | "Armenian" | "Bengali" | "Bopomofo"
                      | "Braille" | "Buginese" |  "Buhid"
                      | "Canadian_Aboriginal" | "Cherokee"
                      | "Common" | "Coptic" | "Cypriot"
                      | "Cyrillic" | "Deseret" | "Devanagari"
                      | "Ethiopic" | "Georgian" |  "Glagolitic"
                      | "Gothic" | "Greek" | "Gujarati"
                      | "Gurmukhi" | "Han" | "Hangul" | "Hanunoo"
                      | "Hebrew" | "Hiragana" | "Inherited"
                      | "Kannada" | "Katakana" | "Kharoshthi"
                      | "Khmer" | "Lao" | "Latin" | "Limbu"
                      | "Linear_B" | "Malayalam" | "Mongolian"
                      | "Myanmar" | "New_Tai_Lue" | "Ogham"
                      | "Old_Italic" | "Old_Persian" | "Oriya"
                      | "Osmanya" | "Runic" | "Shavian" | "Sinhala"
                      | "Syloti_Nagri" | "Syriac" | "Tagalog"
                      | "Tagbanwa" | "Tai_Le" | "Tamil" | "Telugu"
                      | "Thaana" | "Thai" | "Tibetan" | "Tifinagh"
                      | "Ugaritic" | "Yi"

          Anchors = "^"           // beginning of the line
                  | "$"           // end of the line
                  | "\b"          // word boundary
                  | "\B"          // not word boundary
                  | "\A"          // beginning of string
                  | "\Z"          // end of string, or before newline
                                  //   at the end
                  | "\z"          // end of string
</verb></tscreen>
The atom can be an character.  Some characters has a special meaning
in regex (see comments in the character syntax).  The rest characters
match the same character in matching string.  To match a special
character, use <tt>\</tt> before the character.  Some characters can
be represented by a sequence starting with <tt>\</tt> (see the syntax
comments).
<p>
       Examples:
<tscreen><verb>
          `\t`        // matches "\\t"
          `\x65`      // matches "e"
	  `\p{Alpha}` // matches "a"
	  `\w`        // matches "a"
	  `b$`        // matches "b" in "b\na"
</verb></tscreen>
<p>
The atom can be an anchor.  Matching anchors succeed only their
positions correspond a specific place at the matching string (see
comments in the anchor syntax).
<p>
       Examples:
<tscreen><verb>
	  `b$`        // matches "b" in "b\na"
          `abc\Z`     // matches "abc" in "abc"
          `abc\Z`     // matches "abc" in "abc\n"
</verb></tscreen>
<p>
The atom which is a character type matches a specific class of
character (see comments in the character type syntax).
<p>
The atom which is a character property matches a specific class of
character.  For meaning <tt>Alnum</tt> - <tt>ASCII</tt>, please see
the corresponding <tt>BracketClass</tt>.  For meaning <tt>C</tt>
- <tt>Zs</tt>, please see Unicode categories.  For
meaning <tt>Armenian</tt> - <tt>Yi</tt>, please see Unicode scripts
(alphabets). If the property contains <tt>p</tt> with <tt>^</tt>
or <tt>P</tt>, the match succeeds when the matching character is not
of the class.
<p>
       Examples:
<tscreen><verb>
          `\p{Alpha}` // matches "a"
          `\p{ASCII}` // matches ";"
</verb></tscreen>
<p>
<tscreen><verb>
          CharacterClass = "[" Intersections "]"
                         | "[^" Intersections "]"

	  Intersections = Set
                        | Intersections "&&" Set

	  Set = SetElement
              | Set SetElement
	  
          SetElement = Char ["-" Char]
                     | "[:" BracketClass ":]"
                     | "[:^" BracketClass ":]"
                     | CharacterClass

          BracketClass = "alnum"   // Unicode letter, mark,
		                   //   or decimal number
                       | "alpha"   // Unicode letter or mark
                       | "ascii"   // character in range 0 - 0x7f
                       | "blank"   // Unicode space separator
       		                   //   or \t (0x09)
                       | "ctrl"    // Unicode control, format,
	                           //   unassigned, private use,
	                           //   or surrogate
                       | "digit"   // Unicode decimal number 
                       | "graph"   // not a space class and not an
	                           //   Unicode control, unassigned,
                                   //   or surrogate
                       | "lower"   // Unicode lower case letter
                       | "print"   // graph or space class
                       | "punct"   // any Unicode punctuation
                       | "space"   // any Unicode separator,
        		           //   \t (0x09), \n (0x0A), \v (0x0B),
                                   //   \f (0x0C), \r (0x0D),
	                           //   or 0x85 (next line)
                       | "upper"   // Unicode upper case letter
                       | "xdigit"  // ascii 0-9, a-f, or a-f
                       | "word"    // Unicode letter, mark, decimal
	                           //   number or punctuation connector
</verb></tscreen>
An atom can be a bracket expression which is a <em>list</em> of
intersections of character sets separated by <tt>&&</tt> and enclosed
in <tt>[]</tt>.  If the character class contains <tt>^</tt> right
after <tt>[</tt>, it matches any character which does match the
corresponding character class without <tt>^</tt>.  A set is sequence
of set elements.
<p>
Element given by a character denotes the character itself.  Element
given by two characters in the list separated by <tt>-</tt> is
shorthand for the full <em>range</em> of characters between those two
(inclusive) in the sequence of unicode codes, e.g. <tt>[0-9]</tt>
matches any decimal digit.
<p>
Element given by a bracket class enclosed in <tt>[[::]]</tt> matches a
character from this class (see comments in BracketClass).  If
character <tt>^</tt> is present right after <tt>[[:</tt>, the match
succeeds if the character is not in this class.
<p>
Element can be given by a character class, in other words the
character clases can be nested.
<p>
If you need to use <tt>[</tt>, <tt>-</tt>, or <tt>]</tt> as a normal
character in a character class, you can use prefix <tt>\</tt> for
this.
<p>
       Examples:
<tscreen><verb>
          `[[:alpha:]]`  // matches "a"
          `[[[:lower:]]&&[^a-x]]` // matches "y" or "z"
</verb></tscreen>
<p>
An atom can be a group, a regular expression enclosed in <tt>()</tt>.
There are several types of groups:
<tscreen><verb>
          Group = CapturedGroup
                | NonCapturedGroup
                | "(?#" <any characters but )> ")" // comment
                | "(?" Options ")"
                | Context
          
          Options =
                  | Options Option

          Option = "-" | "i" | "m" | "x"

          CapturedGroup = "(" [Regex] ")"
                        | "(?<" Name ">" [Regex] ")"
 
          Name = <one or more word character>

          NonCapturedGroup = "(?" Options ":" [Regex] ")"
                           | "(?>" [Regex] ")" /* Atomic group */
                           
          Context = "(?=" [Regex] ")" // look ahead
                  | "(?!" [Regex] ")" // negative look ahead
                  | "(?<=" [Regex] ")" // look behind
                  | "(?<!" [Regex] ")" // negative look behind

          BackReference = "\" Number    // back ref. by group
                                        //   number
                        | "\k<" Number ">" // back ref. by group
                                           //   number
                        | "\k<-" Number ">" // back ref. by relative
                                            //   group number
                        | "\k<" Name ">" // back ref. by group name
	                // back ref. by group name and nest level:
                        | "\k<" Name "+" | "-" Number ">"

          Number = <any integer >= 0>
				    
</verb></tscreen>
Some groups are captured groups.  It means that you can refer the
substrings they match (see back references) or get start and end
positions of the matched substrings by calling Dino regex match
functions.  A captured group may have a name which can be used in the
back references or subexp calls.
<p>
You can place comments not containing <tt>)</tt> in regex
betweeen <tt>(?#</tt> and <tt>)</tt>.
<p>
Options without regex always matches.  They just change how matching
works.  Option <tt>i</tt> switches on igoring letter cases during
matches.  Option <tt>m</tt> makes <tt>.</tt> to match newline too.
Option <tt>x</tt> switches on ignoring white spaces as character atom
and permits to add comments starting with <tt>#</tt> and ending at the
end of line.  Character <tt>-</tt> after the corresponding <tt>?</tt> and
before has an opposite effect, e.g. it makes a letter case important
in matching again etc.
<p>
You can define options in non captured groups.  These options affect
only this group.  Another form of non-captured group is an atomic
group.  Once regex in an atomic group mathes something, the matching
stays the same during back-tracking.
<p>
       Examples:
<tscreen><verb>
          `(?i:ab)`     // matches "Ab"
          `(?x: a a a)` // matches "aaa"
          `(?>.*)c`     // can not match "abc"
</verb></tscreen>
<p>
The atom can be a context.  A context match does not advance the
current position in a matching string.  A look ahead context succeeds
if the corresponding regex matches a sub-string starting from the
current positions.  A look behind context succeeds if the
corresponding regex matches a sub-string finishing right before the
current positions.  There are negative forms of context atom.  They
succeed when the corresponding regex does not match.
<p>
       Examples:
<tscreen><verb>
          `(?=bcd)bc`   // matches "bc" in "aabcd"
          `(?<=aa)bc`   // matches "bc" in "aabc"
</verb></tscreen>
<p>
The atom can be a back reference.  It refers to the matched string of
the corresponding captured group.  The captured groups are counted by
their left parantheses starting from one going from left to right.
The negative number denotes relative order number, in other words, the
order is taken starting from the back reference going from right to
left.  If captured group has a name, its matched string can be
referenced by its name.  If several group has the same name, name in
the back reference corresponds to the last such group.  You can add
nest level to the name.  If the nest level is zero it is the same as
named back reference without nested level.  Back reference with
non-zero nest level never matches.
<p>
       Examples:
<tscreen><verb>
          `(a)\k<1>`     // matches "aa"
          `(?<p>a)\k<p>` // Ditto
</verb></tscreen>
<p>
Atom can be a subexp call:
<tscreen><verb>
          SubexpCall = "\g<" Name ">"
</verb></tscreen>
Subexp call is actually another occurence of the group
it refers to.  But if the call is in the group it refers, it is a
recursive description.  Only left recursion is not permitted as this
results in never ending recursion.
<p>
       Examples:
<tscreen><verb>
          `(?<p>cd)\g<p>`   // matches "cdcd"
          `(?<p>a|b\g<p>c)` // matches "a", "bac", "bbacc" etc
          `(?<p>a|b\g<p>c)` // wrong left recursion.
</verb></tscreen>
<p>
There are the following Dino pattern matching functions:
     <itemize>
     <item><tt>match (regex, string)</tt>.  The function searches for
       the matching regular expression <tt>regex</tt> in
       <tt>string</tt>.  The both parameters should be strings after
       their implicit string conversion.  The matching is made
       according to the standard POSIX 1003.2: The regular expression
       matches the substring starting earliest in the string.  If the
       regular expression could match more than one substring starting
       at that point, it matches the longest.  Subexpressions also
       match the longest possible substrings, subject to the
       constraint that the whole match be as long as possible, with
       subexpressions starting earlier in the regular expression
       taking priority over ones starting later.  In other words,
       higher-level subexpressions take priority over their component
       subexpressions.  Match lengths are measured in characters, not
       collating elements.  A null string is considered longer than no
       match at all.  If there is no matching, the function returns
       the value <tt>nil</tt>.  Otherwise, the function returns a new
       mutable vector of integers.  The length of the vector is <tt>2
       * (N + 1)</tt> where <tt>N</tt> is the number of atoms which
       are regular expressions in parentheses.  The first two elements
       are the index of the first character of the substring
       corresponding to the whole regular expression and the index of
       the last character matched plus one.  The subsequent two
       elements are the index of the first character of the substring
       corresponding to the first atom in the regular expression (the
       atoms are ordered by their open parentheses) and the index of
       the last character plus one, and so on.  If there is no
       matching with a regular expression in parentheses, the
       corresponding vector elements will have negative values.
       <p>
       Example: The program
<tscreen><verb>
          println (match (`\n()(a)((a)(a))`, "b\naaab"));
</verb></tscreen>
       outputs
<tscreen><verb>
          [1, 5, 2, 2, 2, 3, 3, 5, 3, 4, 4, 5]
</verb></tscreen>
     <item><tt>gmatch (regex, string[, flag])</tt>.  The function
       searches for different occurrences of regular expression
       <tt>regex</tt> in <tt>string</tt>.  Both parameters should
       be strings after their implicit string conversion.  The third
       parameter is optional.  If it is present, it should be integer
       after implicit integer conversion.  If its value is nonzero,
       the substrings matched by regex can be overlapped.  Otherwise,
       the substrings are never overlapped.  If the parameter is
       absent, the function behaves as its value were zero.  The
       function returns a new mutable vector of integers.  The length
       of the vector is <tt>2 * N</tt> where <tt>N</tt> is number of
       the found occurrences.  Pairs of the vector elements correspond
       to the occurrences.  The first element of the pairs is index of
       the first character of substring corresponding to all regular
       expression in the corresponding occurrences and the second
       element is index of the last character plus one.  If there is
       no one occurrence, the function returns <tt>nil</tt>.
       <p>
       Example: The program
<tscreen><verb>
          println (gmatch (`aa`, "aaaaa"));
          println (gmatch (`aa`, "aaaaa", 1));
</verb></tscreen>
       outputs
<tscreen><verb>
          [0, 2, 2, 4]
          [0, 2, 1, 3, 2, 4, 3, 5]
</verb></tscreen>
     <item><tt>sub (regex, string, subst)</tt>.  The function searches
       for substrings matching the regular expression <tt>regex</tt>
       in <tt>string</tt>.  All parameters should be string after
       implicit string conversion.  If there is no matching, the
       function returns the value <tt>nil</tt>.  Otherwise, the
       function returns a new mutable vector of characters in which
       the first substring matched has been changed to the string
       <tt>subst</tt>.  Within the replacement string <tt>subst</tt>,
       the sequence <tt>\n</tt>, where <tt>n</tt> is a digit from 1 to
       9, may be used to indicate the text that matched the
       <tt>n</tt>'th atom of the regex in parentheses.  The sequence
       <tt>\0</tt> represents the entire matched text, as does the
       character <tt>&</tt>.
     <item><tt>gsub (regex, string, subst)</tt>.  The function is
       analogous to the function <tt>sub</tt> except for the function
       searches for all non-overlapping substrings matched with the
       regular expression and returns a new mutable vector of
       characters in which all matched substrings have been changed to
       the string <tt>subst</tt>.
     <item><tt>split (string [, regex])</tt>.  The function splits
       <tt>string</tt> into non-overlapped substrings separated by
       strings matching the regular expression.  All parameters should
       be strings after implicit string conversion.  If the second
       parameter is omitted the value of the predeclared variable
       <tt>split_regex</tt> is used instead of the second parameter
       value.  In this case the function may generate the exception
       <tt>invenvar</tt> (corrupted value of a predeclared variable).
       The function returns a new mutable vector with elements which
       are the separated substrings.  If the regular expression is the
       null string, the function returns a new mutable vector with
       elements which are strings each containing one character of
       string.
       <p>
       Examples: The program
<tscreen><verb>
          println (split ("aaa bbb ccc	ddd"));
</verb></tscreen>
       outputs
<tscreen><verb>
          ["aaa", "bbb", "ccc", "ddd"]
</verb></tscreen>
       The program
<tscreen><verb>
          println (split ("abcdef", ``));
</verb></tscreen>
       outputs
<tscreen><verb>
          ["a", "b", "c", "d", "e", "f"]
</verb></tscreen>
     </itemize>
If the regular expression is incorrect, the functions generate
exception <tt>invregex</tt> with a message explaining the error.

<sect2>Encoding functions
<p>
Dino internally uses Unicode for characters.  To provide communication
with the rest of world, it can use different encodings.  The default
encoding is UTF-8.  Dino has two functions to get and change the
current encoding:
     <itemize>
     <item><tt>get_encoding ()</tt>.  The function returns a new
       mutable string which is a name of the current encoding.
     <item><tt>set_encoding (name)</tt>.  The function accepts string
       and changes the current encoding.  If the name represents
       unknown encoding name, the function generates
       exceptions <tt>parvalue</tt>.
     </itemize>
       <p>
       Examples:
<tscreen><verb>
          putln (get_encoding ());
          set_encoding ("KOI8-R");
</verb></tscreen>

<sect2>File functions
<p>
Dino has some predeclared functions to work on files and
directories.

<sect3>Functions for access to file/directory information
<p>
The following predeclared functions can be used for accessing file or
directory information.  The functions may generate an exception
declared in the class <tt>syserror</tt> (e.g. <tt>eaccess</tt>,
<tt>enametoolong</tt>, <tt>enfile</tt> and so on) besides the standard
<tt>partype</tt>, and <tt>parnumber</tt>.  The functions expect one
parameter which should be a file instance (see the predeclared class
<tt>file</tt>) or the path name of a file represented by a string (the
functions make implicit string conversion of the parameter).  The
single exception to this is <tt>isatty</tt> which expects a file
instance.
     <itemize>
     <item><tt>ftype (fileinstance_or_filename)</tt>.  The function
       returns one the following characters:
       <itemize>
       <item><tt>'f'</tt>.  A regular file.
       <item><tt>'d'</tt>.  A directory.
       <item><tt>'L'</tt>.  A symbolic link.
       <item><tt>'c'</tt>.  A character device.
       <item><tt>'b'</tt>.  A block device.
       <item><tt>'p'</tt>.  A fifo.
       <item><tt>'S'</tt>.  A socket.
       </itemize>
       Under some OSes the function never returns some of the
       characters (e.g. 'c' or 'b').  The function may return nil if
       it can not categorize the file as above.
     <item><tt>fuidn (fileinstance_or_filename)</tt>.  The function
       returns new string representing name of owner of the file
       (directory).  Under some OSes the function may return the new
       string <tt>"Unknown"</tt> if there is no notion "owner" in the
       OS file system.
     <item><tt>fgrpn (fileinstance_or_filename)</tt>.  Analogous to the
       previous function except for it returns a new string
       representing name of the group of the file (directory).  Under
       some OSes the function may return the new string
       <tt>"Unknown"</tt> if there is no notion "group" in the OS file
       system.
     <item><tt>fsize (fileinstance_or_filename)</tt>.  The function
       returns an integer value which is the length of the file in
       bytes.
     <item><tt>fatime (fileinstance_or_filename)</tt>.  The function
       returns integer value which is time of the last access to the
       file (directory).  The time is measured in seconds since the
       fixed time (usually since January 1, 1970).  See also <em>time
       functions</em>.
     <item><tt>fmtime (fileinstance_or_filename)</tt>.  Analogous to
       the previous functions but returns the time of the last
       modification.
     <item><tt>fctime (fileinstance_or_filename)</tt>.  Analogous to
       the previous functions but it returns the time of the last
       change.  Here `change' usually means changing the file
       attributes (owner, modes and so on), while `modification' means
       usually changing the file itself.
     <item><tt>fumode (fileinstance_or_filename)</tt>.  The function
       returns a new string representing the rights of the owner of
       the file (directory).  The string may contain the following
       characters (in the following order if the string contains more
       than one character):
       <itemize>
       <item><tt>'s'</tt>.  Sticky bit of the file (directory).
       <item><tt>'r'</tt>.  Right to read.
       <item><tt>'w'</tt>.  Right to write.
       <item><tt>'x'</tt>.  Right to execute.
       </itemize>
     <item><tt>fgmode (fileinstance_or_filename)</tt>.  Analogous to
       the previous function except for the fact that it returns
       information about the file (directory) group user rights and
       that the function never returns a string containing the
       character <tt>'s'</tt>.
     <item><tt>fomode (fileinstance_or_filename)</tt>.  Analogous to
       the previous function except for the act that it returns
       information about the rights of all other users.
     <item><tt>isatty (fileinstance)</tt>.  The function returns 1 if
       the file instance given as a parameter is an open file
       connected to a terminal and 0 otherwise.
     </itemize>
The following functions can be used to change rights of usage of the
file (directory) for different users.  The function expects two
strings (after implicit string conversion).  The first one is the path
name of the file (directory).  The second one is the rights.  For
instance, if the string contains a character 'r', this is right to
read (see characters used to denote different rights in the
description of the function <tt>fumode</tt>).  The function return
values are always undefined.
     <itemize>
     <item><tt>chumod (path, mode)</tt>.  The function sets up rights
       for the file (directory) owner according to the given mode.
     <item><tt>chgmod (path, mode)</tt>.  Analogous to the previous
       function except for the fact that it sets up rights for the
       file (directory) group users and that the function ignores the
       character <tt>'s'</tt>.
     <item><tt>chomod (path, mode)</tt>.  Analogous to the previous
       function except for the fact that it sets up rights for all
       other users.
     </itemize>

<sect3>Functions for work with directories
<p>
The following functions work with directories.  The functions may
generate an exception declared in class syserror
(e.g. <tt>eaccess</tt>, <tt>enametoolong</tt>, <tt>enotdir</tt> and so
on) besides the standard <tt>partype</tt>, <tt>parnumber</tt>.
     <itemize>
     <item><tt>readdir (dirpath)</tt>.  The function makes implicit
       string conversion of the parameter value which should be a
       string (directory path).  The function returns a new mutable
       vector with elements which are strings representing names of
       all files and sub-directories (including <tt>"."</tt> and
       <tt>".."</tt> for the current and parent directory
       respectively) in given directory.
     <item><tt>mkdir (dirpath)</tt>.  The function creates a directory
       with the given name represented by a string (the parameter
       value after implicit string conversion).  The directory has
       read/write/execute rights for all.  You can change it with the
       aid of the functions <tt>ch*mod</tt>.
     <item><tt>rmdir (dirpath)</tt>.  The function removes the
       directory given by a string which is parameter value after
       implicit string conversion.
     <item><tt>getcwd ()</tt>.  The function returns a new string
       representing the full path of the current directory.
     <item><tt>chdir (dirpath)</tt>.  The function makes the directory
       given by <tt>dirpath</tt> (which should be a string after
       implicit string conversion) the current directory.
     </itemize>

<sect3>Functions for work with files.
<p>
The following functions (besides input/output functions) work with OS
files.  The functions may generate an exception declared in the class
<tt>syserror</tt> (e.g. <tt>eaccess</tt>, <tt>enametoolong</tt>,
<tt>eisdir</tt> and so on) besides the standard <tt>partype</tt>,
and <tt>parnumber</tt>.  The function <tt>rename</tt> can be used for
renaming a directory, not only a file.
     <itemize>
     <item><tt>rename (old_path, new_path)</tt>.  The function renames
       the file (directory) given by its path name.  The old and new
       names are given by parameter values which should be strings
       after implicit string conversion.
     <item><tt>remove (file_path)</tt>.  The function removes the OS
       file given by its path name.  The file path name should be a
       string after implicit string conversion.
     <item><tt>open (file_path, mode)</tt>.  The function opens the
       file for work in the given <em>mode</em>, creates a new class
       <tt>file</tt> instance, associates the opened file with the
       instance, and returns the instance.  The parameter values
       should be strings after implicit string conversions.  The first
       parameter value is a string representing the file path.  The
       second parameter value is string representing the mode for work
       with the file (for all possible modes see the ANSI C function
       <tt>fopen</tt> documentation).  All work with an opened file is
       made through the file instance.
     <item><tt>close (fileinstance)</tt>.  The function closes a file
       opened by the function <tt>open</tt>.  The file is given by the
       class <tt>file</tt> instance.  The function also removes all
       association of the instance with the file.
     <item><tt>flush (fileinstance)</tt>.  The function flushes any
       output that has been buffered for the opened file given by
       the class <tt>file</tt> instance.
     <item><tt>popen (command, mode)</tt>.  The function starts the
       shell command given by the first parameter value (which should
       be a string after implicit string conversion), creates a pipe,
       creates a new class <tt>file</tt> instance, associates the pipe
       with the instance, and returns the instance.  Writing to such a
       pipe (through the class file instance) writes to the standard
       input of the command.  Conversely, reading from the pipe reads
       the command's standard output.  After implicit string
       conversion the second parameter value should be the string "r"
       (for reading from the pipe) or "w" (for writing to the pipe).
       The pipe should be closed by the function <tt>pclose</tt>.
     <item><tt>pclose (fileinstance)</tt>.  The function waits for the
       command connected to a pipe to terminate.  The pipe is given by
       the class <tt>file</tt> instance returned by the function
       <tt>popen</tt>.  The function also removes the association of
       the instance with the pipe.
     <item><tt>tell (fileinstance)</tt>.  The function returns the
       current value of the file position indicator for the file
       (opened by function <tt>open</tt>) given by the class
       <tt>file</tt> instance.
     <item><tt>seek (fileinstance, offset, whence)</tt>.  The function
       sets up the current file position indicator for the file
       (opened by function <tt>open</tt>) given by the class
       <tt>file</tt> instance.  The position is given by
       <tt>offset</tt> which should be an integer after implicit
       arithmetic conversion and <tt>whence</tt> which should be a
       string after implicit string conversion.  The first character
       of the string should be <tt>'s'</tt>, <tt>'c'</tt>, or
       <tt>'e'</tt> (these characters mean that the offset is relative
       to the start of the file, the current position indicator, or
       the end-of-file, respectively).
     <item><tt>get_file_encoding (fileinstance)</tt>.  The function
       returns a new mutabe string which is a name of the current file
       encoding.
     <item><tt>set_file_encoding (fileinstance, name)</tt>.  The
       accepts file and string and changes the current file encoding.
       If the name represents unknown encoding name, the function
       generates exceptions <tt>parvalue</tt>.
     </itemize>

<sect3>File output functions
<p>
The following functions are used to output something into opened
files.  All the function return values are undefined.  The
functions may generate an exception declared in the class <tt>syserror</tt>
(e.g. <tt>eio</tt>, <tt>enospc</tt> and so on) besides the standard
<tt>partype</tt>, and <tt>parnumber</tt>.
     <itemize>
     <item><tt>put (...)</tt>.  All parameters should be strings after
       implicit string conversion.  The function outputs all strings
       into the standard output stream.
     <item><tt>putln (...)</tt>.  The function is analogous to the
       function <tt>put</tt> except for the fact that it additionally
       outputs a new line character after output of all the strings.
     <item><tt>fput (fileinstance, ...)</tt>.  The function is
       analogous to the function <tt>put</tt> except for the fact that
       it outputs the string into an opened file associated with a
       class <tt>file</tt> instance which is the first parameter
       value.
     <item><tt>fputln (fileinstance, ...)</tt>.  The function is
       analogous to function <tt>fput</tt> except for the fact that it
       additionally outputs a new line character after output of all
       the strings.

     <item><tt>putf (format, ...)</tt>.  The first parameter should be
       strings after implicit string conversion.  The function outputs
       the rest of parameters according to the format.  The number of
       the rest parameters should be exactly equal to the conversions
       (including parameterized widths and precisions) in the format.
       Otherwise, exception <tt>parnumber</tt> will be generated.  The
       types of the parameter should correspond to the corresponding
       conversion specifier (or to be integer for parameterized widths
       and precisions).  If it is not true, exception <tt>partype</tt>
       will be generated.  The format is subset of one of standard C
       function <tt>printf</tt> and has the following syntax:
       <tscreen><verb>
          format : <any character except %>
                 | '%' flags [width] [precision]
                       conversion_specifier
          flags :
                | flag

          flag : '#' | '0' | '-' | ' ' | '+'

          width : '*' | <decimal number starting with non-zero>

          precision : '.' ['*' | <decimal number>]

          conversion_specifier : 'd' | 'o' | 'x' | 'X'
                               | 'e' | 'E' | 'f' | 'g'
                               | 'G' | 'c' | 's' | '%'
       </verb></tscreen>
       If the format syntax is wrong, exception <tt>invfmt</tt> is
       generated.

       Flag '#' means that the value should be converted into an
       alternative form.  It can be present only for conversion
       specifiers 'o', 'x', 'X', 'e', 'E', 'f', 'g', and 'G'.  If the
       flag is used for conversion specifier 'o', the output will be
       prefixed by '0'.  For 'x' and 'X' the output will be prefixed
       by '0x' and '0X' correspondingly. For conversions 'e', 'E',
       'f', 'g', and 'G' the output will always contain a decimal
       point.  For conversions 'g' and 'G' it also means that trailing
       zeros are not removed from the output as they would be without
       the flag.  The following code using flag '#' in format
<tscreen><verb>
         putf ("->%#o %#x %#x %#.0e %#.0f %#g<-\n",
               8, 10, 16l, 2., 3., 4.);
</verb></tscreen>
       will output
<tscreen><verb>
         ->010 0xa 0x10 2.e+00 3. 4.00000<-
</verb></tscreen>

       Flag '0' means that the output value will be zero padded on the
       left. If both flags '0' and '-' appear, the flag '0' is
       ignored.  It is also ignored for conversions 'd', 'o', 'x', and
       'X' if a precision is given.  The flag is prohibited for
       conversions 'c' and 's'.  The following code using flag '0' in
       format
<tscreen><verb>
         putf ("->%04d %04x %04x %09.2e %05.2f %05.2g<-\n",
               8, 10, 16l, 2., 3., 4.);
</verb></tscreen>
       will output
<tscreen><verb>
         ->0008 000a 0010 02.00e+00 03.00 00004<-
</verb></tscreen>

       Flag '-' means that the output will be left adjusted on the
       field boundary.  (The default is right justification). Flag '-'
       overrides flag '0' if the both are given.  The following code
       using flag '-' in format
<tscreen><verb>
         putf ("->%-04d %-04x %-04x %-09.2e %-05.2f %-05.2g<-\n",
               8, 10, 16l, 2., 3., 4.);
</verb></tscreen>
       will output
<tscreen><verb>
         ->8    a    10    2.00e+00  3.00  4    <-
</verb></tscreen>

       Flag ' ' means that the output of a signed number will start
       with a blank for positives number.  The flag can be used only
       for conversions 'd', 'e', 'E', 'f', 'g', and 'G'.  If both
       flags ' ' and '+' appear, the flag ' ' is ignored.  The
       following code using flag ' ' in format
<tscreen><verb>
         putf ("->% d % d % .2e % .2f % .2g<-\n",
               8, 16l, 2., 3., 4.);
</verb></tscreen>
       will output
<tscreen><verb>
         -> 8  16  2.00e+00  3.00  4<-
</verb></tscreen>

       Flag '+' means that the output of a signed number will start
       with a plus for positives number.  The flag can be used only
       for conversions 'd', 'e', 'E', 'f', 'g', and 'G'.  Flag '+'
       overrides flag ' ' if both are given.  The following code using
       flag '+' in format
<tscreen><verb>
         putf ("->%+d %+d %+.2e %+.2f %+.2g<-\n",
               8, 16l, 2., 3., 4.);
</verb></tscreen>
       will output
<tscreen><verb>
         ->+8 +16 +2.00e+00 +3.00 +4<-
</verb></tscreen>

       The width defines a minimum width of the output value.  If the
       output is smaller, it is padded with spaces (or zeros -- see
       flag '0') on the left (if flag '-' is used) or right.  The
       output is never truncated.  The width should be no more than
       maximal integer value, otherwise exception <tt>invfmt</tt> is
       generated.  The width can be given as a parameter of integer
       type if '*' is used.  If the value of width given by the
       parameter is negative, flag '-' is believed to be given and the
       width is believed to be equal to zero.  The following code
       using width in format
<tscreen><verb>
         putf ("->%5d %05d %-5d %5d %*d %*d<-\n",
               8, 9, 10, 16l, 5, 8, -5, 10);
</verb></tscreen>
       will output
<tscreen><verb>
         ->    8 00009 10       16     8 10   <-
</verb></tscreen>

       The precision is prohibited for conversions 'c'.  If the number
       after the period is absent, its value will be zero.  The
       precision can be given as a parameter of integer type if '*' is
       used after the period.  If the value of precision given by the
       parameter is negative, its value is believed to be zero too.
       For conversions 'd', 'o', 'x', and 'X' the precision means
       minimum number of output digits.  For conversions 'e', 'E', and
       'f' it means the number of digits to appear after the decimal
       point.  For 'g' and 'G' it means the maximum number of
       significant digits.  For 's' it means the maximum number of
       characters to be output from a string.  The following code
       using precision in format
<tscreen><verb>
         putf ("->%.d %.0d %.5d %.d %.0f %.0e %.2g<-\n",
               8, 8, 9, 16l, 2.3, 2.3, 3.53);
         putf ("->%.2s %.0d %.*d %.*d %.*d<-\n",
               "long", 0, 5, 8, -5, 8, 5, 16l);
</verb></tscreen>
       will output
<tscreen><verb>
         ->8 8 00009 16 2 2e+00 3.5<-
         ->lo  00008 8 00016<-
</verb></tscreen>

       Conversion 'd' should be used to output integer or long
       integer.  The default precision is 1.  When 0 is output with an
       explicit precision 0, the output is empty.

       Conversions 'o', 'x', and 'X' should be used to output an
       integer or long integer value as unsigned in octal and
       hexadecimal form.  The lower case letters <tt>abcdef</tt> are
       used for 'x' and the upper case letters <tt>ABCDEF</tt> are
       used for 'X'.  The precision gives the minimum number of digits
       that must appear. If the output value requires fewer digits, it
       is padded on the left with zeros.  The default precision is 1.
       When 0 is output with an explicit precision 0, the output is
       empty.

       Conversion 'f' should be used to output floating point values.
       The output value has a form <tt>[-]ddd.ddd</tt> where the
       number of digits after the decimal point is given by the
       precision specification.  The default precision value is 6.  If
       the precision is explicitly zero, no decimal-point character
       appears.

       Conversions 'e' and 'E' should be used to output floating point
       values with an exponent in form <tt>[-]d.ddd[e|E][+|-]dd</tt>.
       There is always one digit before the decimal-point.  The number
       of digits after the decimal point is defined by the precision.
       The default precision value is 6.  If the precision is zero, no
       decimal-point appears.  Conversion 'E' uses the letter
       <tt>E</tt> (rather than <tt>e</tt>) to introduce the exponent.
       The exponent always contains at least two digits.  If the
       exponent value is zero, the exponent is output as <tt>00</tt>.

       Conversions 'g' and 'G' should be used to output floating point
       values in style 'f' or 'e' (or 'E' for conversion 'G').  The
       precision defines the number of significant digits.  The
       default value of the precision is 6.  If the precision is zero,
       it is treated as 1.  Conversion 'e' is used if the exponent
       from the conversion is less than -4 or not less than the
       precision.  Trailing zeros are removed from the fractional part
       of the output.  If all fractional part is zero, the decimal
       point is removed too.

       Conversion 'c' should be used to output a character value.

       Conversion 's' should be used to output strings.

       Conversion '%' should be used to output <tt>%</tt>.

       The following code using different conversions in format
<tscreen><verb>
         putf ("->%% %c %s %d %o %x %X %d %o %x %X<-\n",
               'c', "string", 7, 8, 20, 20, 8l, 9l, 21l, 21l);
         putf ("->%f<-\n", 1.5);
         putf ("->%e %E %g %G %g %G<-\n",
               2.8, 2.8, 3.7, 3.7, 455555555.555, 5.9e-5);
</verb></tscreen>
       will output
<tscreen><verb>
         ->% c string 7 10 14 14 8 11 15 15<-
         ->1.500000<-
         ->2.800000e+00 2.800000E+00 3.7 3.7 4.55556e+08 5.9E-05<-
</verb></tscreen>

     <item><tt>fput (fileinstance, format, ...)</tt>.  The function is
       analogous to the function <tt>putf</tt> except for the fact that
       it outputs the string into an opened file associated with a
       class <tt>file</tt> instance which is the first parameter
       value.
     <item><tt>print (...)</tt>.  The function outputs all parameter
       values into standard output stream.  The function never makes
       implicit conversions of the parameter values.  The parameter
       values are output as they could be represented in Dino itself
       (e.g. character <tt>'c'</tt> is output as <tt>'c'</tt>, vector
       <tt>['a', 'b', 'c']</tt> is output as <tt>"abc"</tt>, vector
       <tt>[10, 20]</tt> as <tt>[10, 20]</tt> and so on).  As you know
       some values (functions, classes, block instances, class
       instances, threads) are not represented fully in DINO.  Such
       values are represented schematically.  For example, the output
       <tt>fun f {}.g(unique_number)</tt> would mean function
       <tt>f</tt> in the call of function (or class) <tt>g</tt> with
       the given unique number and function g is in the instance of
       the implicit block covering the whole program.  For the
       function <tt>g</tt>, output would look simply like <tt>fun
       g</tt> because there is only one instance of the implicit block
       covering the whole program.  Output for an instance of the
       class <tt>c</tt> in the function <tt>f</tt> looks like
       <tt>instance {}.f(unique_number).c(unique_number)</tt>.  Output
       for a block instance of the function <tt>f</tt> looks like
       <tt>stack {}.f(unique_number)</tt>.  Output for a thread whose
       thread-function <tt>t</tt> is declared in the function
       <tt>f</tt> would look like <tt>thread unique_number
       {}.f(unique_number).t(unique_number)</tt>.
     <item><tt>println (...)</tt>.  The function is analogous to the
       function <tt>print</tt> except for the fact that it
       additionally outputs new line character after output of all
       parameters.
     <item><tt>fprint (fileinstance, ...)</tt>.  The function is
       analogous to the function <tt>print</tt> except for the fact
       that it outputs the parameters into an opened file associated
       with a class <tt>file</tt> instance which is the value of first
       parameter.
     <item><tt>fprintln (fileinstance, ...)</tt>.  The function is
       analogous to function <tt>fprint</tt> except for the fact that
       it additionally outputs a new line character after the output
       of all the parameters.
     </itemize>

<sect3>File input functions
<p>
The following functions are used to input something from opened files.
The functions may generate an exception declared in the class <tt>syserror</tt>
(e.g. <tt>eio</tt>, <tt>enospc</tt> and so on) or <tt>eof</tt> besides
the standard <tt>partype</tt>, and <tt>parnumber</tt>.
     <itemize>
     <item><tt>get ()</tt>.  The function reads one character from
       standard input stream and returns it.  The function generates
       the exception <tt>eof</tt> if the function tries to read the
       end of file.
     <item><tt>getln ()</tt>.  The function reads one line from
       standard input stream and returns it as a new string.  The end
       of line is the newline character or end of file.  The returned
       string does not contain the newline character.  The function
       generates the exception <tt>eof</tt> only when the file
       position indicator before the function call stands exactly on
       the end of file.
     <item><tt>getf ([ln_flag])</tt>.  The function reads the whole
       standard input stream and returns it as a new string.  The
       function generates the exception <tt>eof</tt> only when the
       file position indicator before the function call stands exactly
       on the end of file.  The function has an optional parameter
       which should be integer after implicit integer conversion.  If
       the parameter value is nonzero, the function returns a vector
       of strings.  Otherwise it behaves as usually.  Each string is a
       line in the input stream.  The strings do not contain the
       newline character.
     <item><tt>fget (fileinstance)</tt>.  The function is analogous to
       function <tt>get</tt> except for the fact that it reads from an
       opened file associated with the class <tt>file</tt> instance
       which is the parameter's value.
     <item><tt>fgetln (fileinstance)</tt>.  The function is analogous
       to the function <tt>getln</tt> except for the fact that it
       reads from an opened file associated with a class <tt>file</tt>
       instance which is the parameter value.
     <item><tt>fgetf (fileinstance [, ln_flag])</tt>.  The function is
       analogous to the function <tt>getf</tt> except for the fact
       that it reads from an opened file associated with a class
       <tt>file</tt> instance which is the parameter's value.
     <item><tt>scan ()</tt>.  The functions reads a character,
       integer, floating point number, string, vector, or table and
       returns it as the result.  The input values should be
       represented in the file as the ones in the Dino language
       (except for the fact that there should be no identifiers in the
       input values and there should be no operators in the values,
       although the signs <tt>+</tt> and <tt>-</tt> are possible in an
       integer or floating point represenation).  The table or vector
       should contains only values of types mentioned above.  The
       values in the file can be separated by white characters.  If
       there is an error (e.g. unbalanced brackets in a vector value)
       in the read value representation the function generates the
       exception <tt>invinput</tt>.  The functions generates the
       exception <tt>eof</tt> if only white characters are still
       unread in the file.
     <item><tt>scanln ()</tt>.  The function is analogous to the
       function <tt>scan</tt> except for the fact that it skips all
       characters until the end of line or the end of file after
       reading the value.  Skipping is made even if the exception
       <tt>invinput</tt> is generated.
     <item><tt>fscan (fileinstance)</tt>.  The function is analogous
       to the function <tt>scan</tt> except for the fact that it reads
       from an opened file associated with a class <tt>file</tt>
       instance which is the parameter's value.
     <item><tt>fscanln (fileinstance)</tt>.  The function is analogous
       to the function <tt>scanln</tt> except for that it reads from
       an opened file associated with a class <tt>file</tt> instance
       which is the parameter value.
     </itemize>

<sect2>Time functions
<p>
The following functions can be used to get information about real
time.
     <itemize>
     <item><tt>time ()</tt>.  The function returns the time in seconds
       since the fixed time (usually since January 1, 1970).
     <item><tt>strtime ([format [, time]])</tt>.  The function returns
       a string representing the <tt>time</tt> (integer representing
       time in seconds since the fixed time) according to the
       <tt>format</tt> (string).  If the format is not given, the
       value of variable <tt>time_format</tt> is used.  In this case
       if the value of <tt>time_format</tt> is corrupted (it is not a
       string), the function generates exception <tt>invenvar</tt>.
       If the time is not given, the current time is used.  The format
       is the same as in C library function <tt>strftime</tt>.  Here
       is an extraction from the OS function documentation.  The
       following format specifiers can be used in the format:
         <itemize>
         <item><tt>%a</tt> - the abbreviated weekday name according to
           the current locale.
         <item><tt>%A</tt> - the full weekday name according to the
           current locale.
         <item><tt>%b</tt> - the abbreviated month name according to
           the current locale.
         <item><tt>%B</tt> - the full month name according to the
           current locale.
         <item><tt>%c</tt> - the preferred date and time
           representation for the current locale.
         <item><tt>%d</tt> - the day of the month as a decimal number
           (range 01 to 31).
         <item><tt>%H</tt> - the hour as a decimal number using a
           24-hour clock (range 00 to 23).
         <item><tt>%I</tt> - the hour as a decimal number using a
           12-hour clock (range 01 to 12).
         <item><tt>%j</tt> - the day of the year as a decimal number
           (range 001 to 366).
         <item><tt>%m</tt> - the month as a decimal number (range 01
           to 12).
         <item><tt>%M</tt> - the minute as a decimal number.
         <item><tt>%p</tt> - either `am' or `pm' according to the given time
           value, or the corresponding strings for the current locale.
         <item><tt>%S</tt> - the second as a decimal number.
         <item><tt>%U</tt> - the week number of the current year as a
           decimal number, starting with the first Sunday as the first
           day of the first week.
         <item><tt>%W</tt> - the week number of the current year as a
           decimal number, starting with the first Monday as the first
           day of the first week.
         <item><tt>%w</tt> - the day of the week as a decimal, Sunday
           being 0.
         <item><tt>%x</tt> - the preferred date representation for
           the current locale without the time.
         <item><tt>%X</tt> - the preferred time representation for
           the current locale without the date.
         <item><tt>%y</tt> - the year as a decimal number without a
           century (range 00 to 99).
         <item><tt>%Y</tt> - the year as a decimal number including
           the century.
         <item><tt>%Z</tt> - the time zone or the name or an
           abbreviation.
         <item><tt>%%</tt> - a literal `%' character.
         </itemize>
     </itemize>

<sect2>Functions for access to process information
<p>
There are Dino predeclared functions which are used to get information
about the current OS process (the Dino interpreter which executes the
program).  Each OS process has unique identifier and usually OS
processes are called by a concrete user and group and are executed on
behalf of the concrete user and group (so called effective
identifiers).  The following functions return such information.  On
some OSes the function may return string "Unknown" as a name if there
are notions of user and group identifiers.
     <itemize>
     <item><tt>getpid ()</tt>.  The function returns an integer value
       which is the process ID of the current OS process.
     <item><tt>getun ()</tt>.  The function returns a new string which
       is the user name for the current OS process.
     <item><tt>geteun ()</tt>.  The function returns a new string
       which is the effective user name for the current OS process.
     <item><tt>getgn ()</tt>.  The function returns a new string which
       is the group name for the current OS process.
     <item><tt>getegn ()</tt>.  The function returns a new string
       which is the effective group name for the current OS process.
     <item><tt>getgroups ()</tt>.  The function returns a new vector
       of strings (possibly the empty vector) representing
       supplementary group names for the current OS process.
     </itemize>

<sect2>Miscellaneous functions
<p>
There are the following miscellaneous functions:
     <itemize>
     <item><tt>max (v1, v2, ...)</tt>.  The function searches for and
       returns the maximal value in all of its parameters.  The
       parameters should be of integer, long integer, or floating
       point type after implicit arithmetic conversion.  So the
       function can return an integer, a long integer, or floating
       point number depending on the type of the first maximal value
       after the conversion.
     <item><tt>min (v1, v2, ...)</tt>.  The function is analogous to
       the previous function, but searches for and returns the minimal
       value.
     <item><tt>tolower (str)</tt>.  The function expects that the
       parameter <tt>str</tt> (after implicit string conversion) is a
       string.  The function returns new string <tt>str</tt> in which
       upper case letters are changed to the corresponding lower case
       letters.
     <item><tt>toupper (str)</tt>.  The function expects that
       the parameter <tt>str</tt> (after implicit string conversion) is
       a string.  The function returns the new string <tt>str</tt> in which
       lower case letters are changed to the corresponding upper case
       letters.
     <item><tt>trans (str, what, subst)</tt>.  The function
       transliterates charactes in a string.  The function expects
       that the parameters <tt>str</tt> (after implicit string
       conversion), <tt>what</tt>, and <tt>subst</tt> are strings.
       The function returns the new string <tt>str</tt> in which its
       characters which are present in <tt>what</tt> are changed to
       the corresponding characters in <tt>subst</tt>.  The last two
       strings should have the same length.  The second string may
       contain more than one occurence of a character.  In this case
       the last correspondence is taken.
     <item><tt>eltype (vect)</tt>.  The function expects that the
       parameter value is a vector.  The function returns <tt>nil</tt>
       if the vector is heterogenous, otherwise the function returns
       the type of the vector elements (type of <tt>nil</tt> if the
       vector is empty).
     <item><tt>keys (tab)</tt>.  The function expects that the
       parameter value is a table.  The function returns a new mutable
       vector containing all the keys in the table.  The order of keys
       in the vector is undefined.
     <item><tt>context (par)</tt>. The function returns the context
       (see section <em>Declarations and Scope Rules</em>) represented
       by a block instance or an object for the given parameter value
       which should be a function, a class, a thread, a block
       instance, or an object.
     <item><tt>inside (par1, par2[, flag])</tt>.  The goal for
       function usage is to check that something is declared inside
       something other.  If the third parameter value after implicit
       integer conversion is given and nonzero, it is checked with
       taking contexts into account.  The second parameter value
       should be a function or a class.  The first parameter value
       should be a function, a class, an object, or a block instance.
       In the first three cases, they define corresponding a function,
       class, or block.  If the function, class, or block defined by
       the first parameter is declared inside the function or class
       given by the second parameter, the function <tt>inside</tt>
       returns 1.  The function <tt>inside</tt> also returns 1 if the
       function or class defined by the first parameter is the same as
       the function or class given by the second parameter.  Otherwise
       the function <tt>inside</tt> returns 0.  The following example
       illustrates the difference between checking with taking
       contexts into account and without it.
<tscreen><verb>
          class c () {
            class subc () {
            }
          }
          inside (c ().subc (), c ().subc);
          inside (c ().subc (), c ().subc, 1);
</verb></tscreen>
       The first call of <tt>inside</tt> returns 1, while the second
       one returns 0.
     <item><tt>isa (fco, fc)</tt>.  The goal for function usage is to
       check that function, class, or object given by the first
       parameter <tt>fco</tt> uses declarations (through a use-clause)
       of a function or a class given by the second
       parameter <tt>fc</tt>, in other words the first is a subtype of
       the second.  If it is true, the function returns 1, otherwise
       it returns zero.  If the parameter types are wrong, the
       function generates exception <tt>partype</tt>.  The following
       example illustrates usage of <tt>isa</tt>.
<tscreen><verb>
          class c () {}
          class subc () { use c;}
          isa (subc, c);
          isa (subc (), c);
</verb></tscreen>
       The call of <tt>isa</tt> in the example returns 1.
     <item><tt>subv (vect, index[, length])</tt>.  The function is
       used to extract a slice of vector elements.  The first
       parameter value should be a vector after implicit string
       conversion.  The second and third parameter values should be
       integers after implicit integer conversion. The function
       extracts only an element or the part of the slice existing in
       the vector (so you can use any values of the index and the
       length).  If index is negative, it is considered to be equal to
       zero.  If the length is negative, the slice will finish on the
       vector end.  The function returns a new vector which is the
       slice.  The result vector is immutable only when the original
       vector is immutable.
     <item><tt>del (vect, index[, length]) or del (tab, key)</tt>.
       The first form of the function is used to remove the vector
       element or a slice of vector elements from the mutable vector
       <tt>vect</tt>.  The second and the third parameter values
       should be integers after implicit integer conversion. The
       function removes only an element or the part of the slice
       existing in the vector (so you can use any values of the index
       and the length).  If index is negative, it is considered to be
       equal to zero.  If the length is negative, the slice will
       finish on the vector end.  The second form of the function is
       used to remove the element (if it exists) with the given key
       from the mutable table.  The function generates the exception
       <tt>immutable</tt> if we are trying to remove from an immutable
       vector or table.  The function returns the modified vector.
     <item><tt>ins (vect, el[, index])</tt>.  The function inserts the
       element given by the second parameter into the vector given by
       the first parameter on the place given by the third parameter.
       If the third parameter is not given it is believed to be zero.
       The third parameter should be an integer after implicit integer
       conversion.  If the third parameter is negative or equal to or
       greater than the vector length, the element is inserted at the
       end of the vector.  The function generates the exception
       <tt>immutable</tt> if we are trying to insert into an immutable
       vector.  The function returns the modified vector.
     <item><tt>insv (vect, vect[, index])</tt>.  The function is
       analogous to the function <tt>ins</tt> but it is used for
       insertion of all vector elements into the vector given as the
       first parameter.  So the second parameter value should be a
       vector.  The function returns the modified vector.
     <item><tt>rev (vect)</tt>.  The function returns reversion of the
      given vector.
     <item><tt>cmpv (vect, vect)</tt>.  The function makes implicit
       string conversion of the parameter values.  After that, the
       parameter values should be vectors whose first corresponding
       equal elements should have the same type (character, integer,
       or floating point type).  The first corresponding unequal
       elements should have the same type too (the remaining elements
       can have different type).  As usual, if this is not true,
       exception <tt>partype</tt> is generated.  The function returns
       1 if the first unequal element value of the first vector is
       greater than the corresponding element in the second vector, -1
       if less, and 0 if the all corresponding vector elements are
       equal.  If the first vector is a prefix of the second vector,
       the function returns -1.  If the second vector is a prefix of
       the first vector, the function returns 1, so it is in fact
       generalized lexicographical order.
     <item><tt>sort (vect[, compare_function])</tt>.  The function
       returns a new sorted vector.  The original vector given as the
       first parameter value should be a homogeneous vector whose
       elements are of character, integer, long integer, or floating
       point type.  If the second parameter is not given, standard
       arithmetic order (see comparison operators) is used.  To use
       special ordering, use the second parameter which should be a
       function which compares two elements of the vector and returns
       a negative integer if the first parameter value (element) is
       less than the second one, a positive integer if the first
       parameter value is greater than the second one, and zero if
       they are equal.
     <item><tt>exit (code)</tt>.  The function finishes the work of
       the interpreter with the given code which should be an integer
       value after implicit integer conversion.
     <item><tt>gc ()</tt>.  The function forces garbage collection and
       heap compaction.  Usually the Dino interpreter itself invokes
       garbage collection when there is no more free memory.
     <item><tt>system (command)</tt>.  The function executes the
       command given by a string (the parameter value) in the OS
       command interpreter.  Besides standard exceptions
       <tt>parnumber</tt> and <tt>partype</tt> the function may
       generate exceptions <tt>noshell</tt> and <tt>systemfail</tt>.
     <item><tt>srand ([seed])</tt>.  The function sets the parameter
       value (after implicit integer conversion) as the seed for a new
       sequence of pseudo-random integers to be returned by
       <tt>rand</tt>.  These sequences are repeatable by calling
       <tt>srand</tt> with the same seed value.  If the parameter is
       not given, the seed will be the result of calling function
       <tt>time</tt>.
     <item><tt>rand ()</tt>.  The function returns a pseudo-random
       floating point value between 0 and 1.  If the function
       <tt>srand</tt> was not called before, 1 will be used as the
       seed value.
     <item><tt>transpose (m)</tt>.  The function expects
       matrix <tt>m</tt>.  It means that <tt>m</tt> should be vector
       (each element is a matrix row) of vectors of equal length.
       If <tt>m</tt> is not a vector, exception <tt>partype</tt> is
       generated.  If elements of <tt>m</tt> are not vectors of the
       same length, exceptions <tt>matrixform</tt> is generated.  The
       function returns a new mutable vector of mutable vectors which
       is a matrix transposition of <tt>m</tt>.
     <item><tt>filter (f, v [, d])</tt>.  The function expects
       function <tt>f</tt>, vector <tt>v</tt>, and optional
       integer <tt>d</tt> after integer conversion.  Otherwise
       exception <tt>partype</tt> is generated.  If <tt>d</tt> is not
       given, it is believed to be 1.  The function processes v's
       elements if <tt>d</tt> is equal one, elements of vectors which
       are v's elements if <tt>d</tt> is equal to 2 and so on.  In
       other words, <tt>d</tt> is level on which vector elements are
       processed.  If v has no structure necessary for processing,
       exception <tt>vecform</tt> is generated.  If <tt>d</tt> is zero
       or negative, the function just returns <tt>v</tt>.  Otherwise
       the function creates new mutable vector having the same
       structure as <tt>v</tt> with only elements on level <tt>d</tt>
       for which function <tt>f</tt> returns nonzero value after
       integer conversion.  If the result of function <tt>f</tt> after
       the integer conversion is not integer,
       exception <tt>invresult</tt> is generated.  The following
       example illustrates usage of <tt>filter</tt>.
<tscreen><verb>
          var i, v = [0, 1, -2, 3, -4];
          println (filter (fun (a) {a > 0;}, v));
          v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
          println (filter (fun (a) {a > 0;}, v, 2));
</verb></tscreen>
    <item><tt>map (f, v [, d])</tt>.  The meaning of function
       parameters and constraints to their values are analogous to
       ones of function <tt>filter</tt>.  Only function <tt>f</tt> can
       return any value.  The elements processed by
       function <tt>f</tt> is changed onto the result of
       function <tt>f</tt>.  The following example illustrates usage
       of <tt>map</tt>.
<tscreen><verb>
          var i, v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
          println (map (fun (a) {a < 0 ? nil : a;}, v, 2));
</verb></tscreen>
     <item><tt>fold (f, v, init [, d])</tt>.  The meaning of function
       parameters <tt>f</tt>, <tt>v</tt>, and <tt>d</tt> and
       constraints to their values are analogous to ones of
       function <tt>filter</tt>.  The function processes all elements
       of vectors on level <tt>d</tt> and returns value
       <tt>f (f (f (f (init, el0), el1), ...) , eln)</tt> where
       <tt>el0</tt>, ..., <tt>eln</tt> are vector elements on
       level <tt>d</tt> taken from left to right.  If <tt>d</tt> is
       zero or negative or the vectors are empty, the function
       returns <tt>init</tt>.  The following example illustrates usage
       of <tt>fold</tt>.
<tscreen><verb>
          var v = [1,2,3,4];
          println (fold (fun (a, b) {a + b;}, v, 0));
</verb></tscreen> 
     <item><tt>sput (...), sputln (...), sputf (format, ...)</tt> The
       functions are analogous to functions put, putln, print, and
       println but they return the result string instead of output of
       the formed string into the standard output stream.
     <item><tt>sprint (...), sprintln (...)</tt>.  The functions are
       analogous to functions print and println but they return the
       result string instead of output of the formed string into the
       standard output stream.
     </itemize>

<sect>Appendix A. Syntax of Dino
<p>
<tscreen><verb>
Expr = Expr "?"  Expr ":" Expr
     | Expr "||"  Expr
     | Expr "&&"  Expr
     | Expr in  Expr
     | Expr "|"  Expr
     | Expr "^"  Expr
     | Expr "&"  Expr 
     | Expr "=="  Expr  
     | Expr "!="  Expr  
     | Expr "==="  Expr  
     | Expr "!=="  Expr  
     | Expr "<"  Expr
     | Expr ">"  Expr  
     | Expr "<="  Expr
     | Expr ">="  Expr 
     | Expr "<<"  Expr
     | Expr ">>"  Expr
     | Expr ">>>"  Expr
     | Expr "@"  Expr
     | Expr "+"  Expr
     | Expr "-"  Expr
     | Expr "*"  Expr
     | Expr "/"  Expr
     | Expr "%"  Expr
     | "!"  Expr
     | "+"  Expr
     | "-"  Expr
     | "~"  Expr
     | "#"  Expr
     | final  Expr
     | new  Expr
     | ".+"  Expr
     | ".*"  Expr
     | ".&"  Expr
     | ".^"  Expr
     | ".|"  Expr
     | Designator
     | INTEGER
     | FLOATINGPOINTNUMBER
     | CHARACTER
     | nil
     | "(" Expr ")"
     | Call
     | "["  ElistPartsList "]"
     | tab "["  ElistPartsList "]"
     | STRING
     | char
     | int
     | long
     | float
     | hide
     | hideblock
     | vec
     | tab
     | fun
     | thread
     | class
     | obj
     | process
     | type
     | this
     | char "(" Expr ")"
     | int "(" Expr ")"
     | float "(" Expr ")"
     | vec "(" Expr ["," Expr] ")"
     | tab "(" Expr ")"
     | type "(" Expr ")"
     | AnonHeader FormalParameters Block
     | "_"
     | "..."

Designator = DesignatorOrCall "["  Expr "]"
           | DesignatorOrCall ActualParameters
           | DesignatorOrCall "."  IDENT
           | IDENT

ElistPartsList = [ Expr [ ":" Expr ] {"," Expr [ ":" Expr ] } ]
       	
DesignatorOrCall = Designator
                 | Call

Call = Designator ActualParameters

ActualParameters = "(" [ Expr { "," Expr } ] ")"
       	
AnonHeader = [Qualifiers] FuncThreadClass
			  
Stmt = ExecutiveStmt
     | Declaration

Assign = "="
       | "*="
       | "/="
       | "%="
       | "+="
       | "-="
       | "@="
       | "<<="
       | ">>="
       | ">>>="
       | "&="
       | "^="
       | "|="

Pattern = Expr

ExecutiveStmt = ";"
              | Expr ";"
              | Designator Assign  Expr ";"
              | Designator ("++" | "--")  ";"
              | ("++" | "--")  Designator ";"
              | if  "(" Expr ")" Stmt [ else Stmt ]
              | for  "(" Stmt ForGuardExpr ";"  Stmt ")" Stmt
              | for  "(" Designator in Expr ")" Stmt
	      | switch "(" Expr ")" "{" CaseList "}"
	      | break ";"
              | continue ";"
              | return  [ Expr ] ";"
              | throw  Expr ";"
              | wait  "(" Expr ")" Stmt
              | BlockStmt
              | TryBlockStmt

ForGuardExpr = [Expr]

CaseList = { case Pattern [CaseCond] ":" StmtList }
CaseCond = if Expr
		  
BlockStmt = Block

TryBlockStmt = try Block { Catch }
       	
Catch = catch  "(" ExceptClassList ")" Block

ExceptClassList = Expr { "," Expr }

Declaration = VarDeclarations
            | FriendClause
            | ExternDeclarations
            | FuncClassDeclaration
            | SingletonObject
            | ForwardDeclaration
            | UseClause
            | IncludeDeclaration

VarDeclarations =  [pub | priv] (val | var)  VarList ";"

VarList = Var { "," Var }
       	
Var = IDENT | pattern "="  Expr

ExternDeclarations = [pub | priv] extern ExternItems ";"

FuncClassDeclaration = Header FormalParameters Hint Block

Hint = [ "!" IDENT ]

FriendClause = friend IDENT { "," IDENT } ";"
     	
IncludeDeclaration = include ["+"] STRING ";"

ExternItems = ExternItem { "," ExternItem }

ExternItem = IDENT 
           | IDENT  "(" ")"

Header = [Qualifiers] FuncThreadClass IDENT

Qualifiers = pub | priv | final
           | pub final | priv final
           | final pub | final priv

FuncThreadClass = fun 
       	        | thread 
       	        | class 
      	
FormalParameters =
                 | "(" [ ParList ] ")"
       	         | "(" ParList "," "..." ")"
       	         | "(" "..." ")"
       	
ParList = Par { "," Par}

Par = [pub | priv] [val | var] IDENT [ "=" Expr]

UseClause = use IDENT { UseItemClause }

UseItemClause = [former | later] UseItem { "," UseItem }

Item = IDENT [ "(" IDENT ")"]

Block = "{"  StmtList "}"

StmtList = { Stmt }
       	
Program = StmtList
</verb></tscreen>

<sect>Appendix B. Implementation
<p>
<tscreen><verb>
%%%
</verb></tscreen>
</article>
