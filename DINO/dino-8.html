<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.20">
 <TITLE>The Programming Language DINO: Predeclared identifiers</TITLE>
 <LINK HREF="dino-9.html" REL=next>
 <LINK HREF="dino-7.html" REL=previous>
 <LINK HREF="dino.html#toc8" REL=contents>
</HEAD>
<BODY>
<A HREF="dino-9.html">Next</A>
<A HREF="dino-7.html">Previous</A>
<A HREF="dino.html#toc8">Contents</A>
<HR>
<H2><A NAME="s8">8.</A> <A HREF="dino.html#toc8">Predeclared identifiers</A></H2>

<P>Dino has quite a lot of predeclared identifiers.  The section <EM>Declarations
and Scope Rules</EM> contains them in alphanumeric order.  Here they
are described according to the declaration category which they belongs
to.</P>

<H2><A NAME="ss8.1">8.1</A> <A HREF="dino.html#toc8.1">Predeclared variables</A>
</H2>

<P>Dino has some predeclared variables which contain useful information
or can be used to control the behaviour of the Dino interpreter.</P>

<H3>Arguments and environment</H3>

<P>To access arguments to the program and the environment, the following
variables can be used:
<UL>
<LI><CODE>argv</CODE>.  The variable value is an immutable vector
whose elements are strings (immutable vectors of characters)
representing arguments to the program (see implementation).</LI>
<LI><CODE>env</CODE>.  The variable value is immutable table whose
elements are strings (immutable vectors of characters)
representing values of environment variables whose names are
the keys of the table.</LI>
</UL>
</P>

<H3>Version</H3>

<P>As Dino is a live programming language, it and its interpreter are in
the process of permanent development.  To access the Dino interpreter's
version number and consequently the language version, the final variable
<CODE>version</CODE> can be used.  The variable value is the Dino version as a
floating point number.  For example, if the current Dino version is
0.54, the variable value will be 0.54.</P>


<H3>Threads</H3>

<P>To access some information about threads in Dino program, the
following variables can be used.
<UL>
<LI><CODE>main_thread</CODE>.  The variable value is the main
thread.  When the program starts, there is only one thread
which is called <EM>the main thread</EM>.</LI>
<LI><CODE>curr_thread</CODE>.  The variable value is the thread in
which you reference the variable.</LI>
</UL>

All these variables are final, so you can not change their values.</P>

<H3>Exceptions</H3>

<P>When it is necessary to create an exception which is a object of a
class declared inside class <CODE>except</CODE> or when it is necessary to
refer to a class inside class <CODE>except</CODE>, the following variables
can be used.  Instead of typing <CODE>catch
(except().signal().sigint)</CODE>, you could type <CODE>catch
(signals.sigint)</CODE>.
<UL>
<LI><CODE>excepts</CODE>.  The variable value is an object of the
class <CODE>except</CODE>.</LI>
<LI><CODE>errors</CODE>.  The variable value is an object of the
class <CODE>excepts.error</CODE>.</LI>
<LI><CODE>signals</CODE>.  The variable value is an object of the
class <CODE>errors.signal</CODE>.</LI>
<LI><CODE>invops</CODE>.  The variable value is an object of the
class <CODE>errors.invop</CODE>.</LI>
<LI><CODE>invindexes</CODE>.  The variable value is an object of
the class <CODE>errors.invindex</CODE>.</LI>
<LI><CODE>invkeys</CODE>.  The variable value is an object of the
class <CODE>errors.invkey</CODE>.</LI>
<LI><CODE>invcalls</CODE>.  The variable value is an object of the
class <CODE>errors.invcall</CODE>.</LI>
<LI><CODE>syserrors</CODE>.  The variable value is an object of the
class <CODE>invcalls.syserror</CODE>.</LI>
<LI><CODE>systemcalls</CODE>.  The variable value is an object of
the class <CODE>invcalls.systemcall</CODE>.</LI>
<LI><CODE>invparsers</CODE>.  The variable value is an object of
the class <CODE>invcalls.invparser</CODE>.</LI>
<LI><CODE>invregexps</CODE>.  The variable value is an object of
the class <CODE>invcalls.invregexp</CODE>.</LI>
<LI><CODE>invexterns</CODE>.  The variable value is an object of
the class <CODE>invcalls.invextern</CODE>.</LI>
<LI><CODE>invaccesses</CODE>.  The variable value is an object of
the class <CODE>errors.invaccess</CODE>.</LI>
</UL>

All these variables are final, so you can not change their values.</P>

<H3>Files</H3>

<P>To output something into standard streams or to input something from
the standard input stream, the following variables can be used:
<UL>
<LI><CODE>stdin</CODE>.  The variable value is an object of the
class <CODE>file</CODE> which corresponds to the standard input
stream.</LI>
<LI><CODE>stdout</CODE>.  The variable value is an object of the
class <CODE>file</CODE> which corresponds to the standard output
stream.</LI>
<LI><CODE>stderr</CODE>.  The variable value is an object of the
class <CODE>file</CODE> which corresponds to the standard error
stream.</LI>
</UL>

All these variables are final, so you can not change their values.</P>

<H3>Miscellaneous variables</H3>

<P>Values of the following variables are used by some predeclared
functions:
<UL>
<LI><CODE>split_regex</CODE>.  The variable value is a string which
represents regular expression which is used by the predeclared
function <CODE>split</CODE> when the second parameter is not given.
The initial value of the variable is string <CODE>"[ \t]+"</CODE>.</LI>
<LI><CODE>time_format</CODE>.  The variable value is a string which
is the output format of time used by the function
<CODE>strtime</CODE> when it is called without parameters.  The
initial value of the variable is the string <CODE>"%a %b %d
%H:%M:%S %Z %Y"</CODE>.</LI>
</UL>
</P>

<H2><A NAME="ss8.2">8.2</A> <A HREF="dino.html#toc8.2">Predeclared classes</A>
</H2>

<P>The most of the predeclared classes describe exceptions which may be
generated in Dino program.</P>

<H3>File</H3>

<P>Dino has predeclared final class <CODE>file</CODE>.  Work with files in
Dino program are made through objects of the class.  All declarations
inside of class are private.  The objects of the class can be created
only by predeclared functions <CODE>open</CODE> or <CODE>popen</CODE>.  If you
create an object of the class by calling the class, exception
<CODE>callop</CODE> will be generated.</P>

<H3>Exception classes</H3>

<P>All Dino exceptions are represented by objects of the predeclared
class <CODE>except</CODE> or of a class in the class <CODE>except</CODE>.  The
class <CODE>except</CODE> has no parameters, therefore all arguments in
calling the class will be ignored.  There is one predeclared class
<CODE>error</CODE> inside class <CODE>except</CODE>.  All classes
corresponding to user-defined exceptions are suggested to be declared
in class <CODE>except</CODE> not in the class <CODE>error</CODE> because all
other exceptions (e.g. generated by the Dino interpreter itself or by
predeclared functions) are objects of the class <CODE>error</CODE> or
predeclared classes inside the class <CODE>error</CODE>. The class
<CODE>error</CODE> and all classes inside the class has one parameter
<CODE>msg</CODE> which contains a readable message about the exception.
The following classes are declared in the class <CODE>error</CODE>:
<UL>
<LI><CODE>signal</CODE>.  Classes inside this class describe
exceptions from receiving a signal from other OS processes.  They
are
<UL>
<LI><CODE>sigint</CODE>.  This class describes the exception
generated by the user's interrupt from the keyboard.</LI>
<LI><CODE>sigill</CODE>.  This class describes the exception
generated by illegal execution of an instruction .</LI>
<LI><CODE>sigabrt</CODE>.  This class describes the exception
generated by the signal abort.</LI>
<LI><CODE>sigfpe</CODE>.  This class describes floating point
exception.</LI>
<LI><CODE>sigterm</CODE>.  This class describes the exception
generated by the termination signal.</LI>
<LI><CODE>sigsegv</CODE>.  This class describes the exception
generated by an invalid memory reference.</LI>
</UL>
</LI>
<LI><CODE>invenv</CODE>.  This class describes corruption of the Dino
program environment (see predeclared variable <CODE>env</CODE>).</LI>
<LI><CODE>invop</CODE>.  Classes inside this class describe
exceptions when operands of operations have an incorrect type or
value.
<UL>
<LI><CODE>optype</CODE>.  This class describes that the operand
of an operation is not of the required type (possibly after
implicit conversions).</LI>
<LI><CODE>opvalue</CODE>.  This class is reserved for the error
of that an operand of an operation has invalid value.  Now
this exception is not generated.</LI>
</UL>
</LI>
<LI><CODE>invindex</CODE>.  Classes inside this class describe
exceptions in referring for a vector element.
<UL>
<LI><CODE>indextype</CODE>.  This class describes that the
index is not of integer type (possibly after implicit
integer conversion).</LI>
<LI><CODE>indexvalue</CODE>.  This class describes that the
index is negative or equal to or more than the vector
length.</LI>
<LI><CODE>indexop</CODE>.  This class describes that the first
operand in referring to a vector element is not a vector.</LI>
</UL>
</LI>
<LI><CODE>invkey</CODE>.  Classes inside this class describe
exceptions in referring to a table element.
<UL>
<LI><CODE>keyvalue</CODE>.  This class describes that there is
no such element in the table with the given key when we
need the value of the element.  The exception does not
occur when a table element reference stands in the left
hand side of an assignment-statement.</LI>
<LI><CODE>keyop</CODE>.  This class describes that the first
operand in referring to a table element is not a table.</LI>
</UL>
</LI>
<LI><CODE>invcall</CODE>.  Classes inside this class describe
exceptions in calling functions (mainly predeclared ones).
<UL>
<LI><CODE>callop</CODE>.  This class describes that we try to
call something which is not a function, class, or
thread-function.  The exception is also generated when you
try to create a class <CODE>file</CODE> instance by calling the
class.</LI>
<LI><CODE>partype</CODE>.  This class describes that a
parameter value of a predeclared function is not of
required type.</LI>
<LI><CODE>invfmt</CODE>.  This class describes that a format of
a format output function is wrong (see function
<CODE>putf</CODE>.</LI>
<LI><CODE>invresult</CODE>.  This class describes that the
result value of function call is not of required type,
e.g. comparison function used in a call to function
<CODE>sort</CODE> returns a non integer value.</LI>
<LI><CODE>invinput</CODE>.  This class describes that the file
input is not of required format.  Usually the exception is
generated by function <CODE>scan</CODE> etc.</LI>
<LI><CODE>eof</CODE>.  This class describes that end of file is
encountered.  Usually the exception is generated by
functions reading files (<CODE>get</CODE>, <CODE>scan</CODE> etc).</LI>
<LI><CODE>parnumber</CODE>.  This class describes that the
number of actual parameters is not valid when we call a
predeclared function.</LI>
<LI><CODE>syserror</CODE>.  Classes inside this class describe
exceptions in predeclared functions which call OS system
functions.  Some exceptions are never generated but may
be generated in the future on some OSes.
<UL>
<LI><CODE>eaccess</CODE>.  This describes the system error
"Permission denied".</LI>
<LI><CODE>eagain</CODE>.  This describes the system error
"Resource temporarily unavailable".</LI>
<LI><CODE>ebadf</CODE>.  This describes the system error
"Bad file descriptor".</LI>
<LI><CODE>ebusy</CODE>.  This describes the system error
"Resource busy".</LI>
<LI><CODE>echild</CODE>.  This describes the system error
"No child processes".</LI>
<LI><CODE>edeadlk</CODE>.  This describes the system error
"Resource deadlock avoided".</LI>
<LI><CODE>edom</CODE>.  This describes the system error
"Domain error".</LI>
<LI><CODE>eexist</CODE>.  This describes the system error
"File exists".</LI>
<LI><CODE>efault</CODE>.  This describes the system error
"Bad address".</LI>
<LI><CODE>efbig</CODE>.  This describes the system error
"File too large".</LI>
<LI><CODE>eintr</CODE>.  This describes the system error
"Interrupted function call".</LI>
<LI><CODE>einval</CODE>.  This describes the system error
"Invalid argument".</LI>
<LI><CODE>eio</CODE>.  This describes the system error
"Input/output error".</LI>
<LI><CODE>eisdir</CODE>.  This describes the system error
"Is a directory".</LI>
<LI><CODE>emfile</CODE>.  This describes the system error
"Too many open files".</LI>
<LI><CODE>emlink</CODE>.  This describes the system error
"Too many links".</LI>
<LI><CODE>enametoolong</CODE>.  This describes the system
error "Filename too long".</LI>
<LI><CODE>enfile</CODE>.  This describes the system error
"Too many open files in system".</LI>
<LI><CODE>enodev</CODE>.  This describes the system error "No
such device".</LI>
<LI><CODE>enoent</CODE>.  This describes the system error "No
such file or directory".</LI>
<LI><CODE>enoexec</CODE>.  This describes the system error
"Exec format error".</LI>
<LI><CODE>enolck</CODE>.  This describes the system error "No
locks available".</LI>
<LI><CODE>enomem</CODE>.  This describes the system error
"Not enough space".</LI>
<LI><CODE>enospc</CODE>.  This describes the system error "No
space left on device".</LI>
<LI><CODE>enosys</CODE>.  This describes the system error
"Function not implemented".</LI>
<LI><CODE>enotdir</CODE>.  This describes the system error
"Not a directory".</LI>
<LI><CODE>enotempty</CODE>.  This describes the system error
"Directory not empty".</LI>
<LI><CODE>enotty</CODE>.  This describes the system error
"Inappropriate I/O control operation".</LI>
<LI><CODE>enxio</CODE>.  This describes the system error "No
such device or address".</LI>
<LI><CODE>eperm</CODE>.  This describes the system error
"Operation not permitted".</LI>
<LI><CODE>epipe</CODE>.  This describes the system error
"Broken pipe".</LI>
<LI><CODE>erange</CODE>.  This describes the system error
"Result too large".</LI>
<LI><CODE>erofs</CODE>.  This describes the system error
"Read-only file system".</LI>
<LI><CODE>espipe</CODE>.  This describes the system error
"Invalid seek".</LI>
<LI><CODE>esrch</CODE>.  This describes the system error "No
such process".</LI>
<LI><CODE>exdev</CODE>.  This describes the system error
"Improper link".</LI>
</UL>
</LI>
<LI><CODE>systemcall</CODE>.  Classes inside this class
describe exceptions in calling the predeclared function
<CODE>system</CODE>.
<UL>
<LI><CODE>noshell</CODE>.  This class describes the exception
that the function <CODE>system</CODE> can not find the OS
command interpreter (the shell).</LI>
<LI><CODE>systemfail</CODE>.  This class describes all
remaining exceptions in calling the OS function
<CODE>system</CODE>.</LI>
</UL>
</LI>
<LI><CODE>invparser</CODE>.  Classes inside this class describe
exceptions specific for calling functions of the predeclared
class <CODE>parser</CODE> implementing the Earley parser.
<UL>
<LI><CODE>invgrammar</CODE>.  This class describes
the exception that the Earley parser got a bad grammar,
e.g. without rules, with loops in rules, with
nonterminals unachievable from the axiom, with nonterminals
not deriving any terminal string etc.</LI>
<LI><CODE>invtoken</CODE>.  This class describes the
exception that the parser got an input token with unknown
(undeclared) code.</LI>
<LI><CODE>pmemory</CODE>.  This class describes the exception
that there is not enough memory for internal parser
data.</LI>
</UL>
</LI>
<LI><CODE>invregexp</CODE>.  Classes inside this class describe
exceptions specific for calling predeclared functions
implementing regular expression pattern matching.
<UL>
<LI><CODE>ebrack</CODE>.  This class describes the exception
that a regular expression has an unmatched bracket.</LI>
<LI><CODE>erange</CODE>.  This class describes the exception
that there is an invalid use of range in regular
expression.</LI>
<LI><CODE>ectype</CODE>.  This class describes the exception
that there is an unknown character class name in regular
expression.</LI>
<LI><CODE>eparen</CODE>.  This class describes the exception
that a regular expression has an unmatched parenthesis.</LI>
<LI><CODE>esubreg</CODE>.  This class describes the exception
that there is an invalid back reference to a
subexpression in a regular expression.</LI>
<LI><CODE>eend</CODE>.  This class describes the exception
that there is a non specific error in regular expression.</LI>
<LI><CODE>eescape</CODE>.  This class describes the exception
that there is a trailing backslash.</LI>
<LI><CODE>badpat</CODE>.  This class describes the exception
that there is invalid use of pattern operators in a
regular expression.</LI>
<LI><CODE>esize</CODE>.  This class describes exception that
the compiled regular expression is too big.</LI>
<LI><CODE>espace</CODE>.  This class describes the exception
that there is no memory for a regular expression function
to work.</LI>
</UL>
</LI>
<LI><CODE>invextern</CODE>.  Classes inside this class describe
exceptions in calling external functions or in accessing
an external variable.
<UL>
<LI><CODE>noextern</CODE>.  This class describes the
exception that the given external can not be find.</LI>
<LI><CODE>libclose</CODE>.  This class describes the
exception that there is an error in closing a shared
library.</LI>
<LI><CODE>noexternsupp</CODE>.  This class describes an
exception in the usage of externals when they are not
implemented under this OS.</LI>
</UL>
</LI>
<LI><CODE>invenvar</CODE>.  This class describes corruption in
the type of variables <CODE>split_regex</CODE> and
<CODE>time_format</CODE> (e.g. their values are not strings).</LI>
<LI><CODE>internal</CODE>.  This class describes all other
(nonspecified) exceptions in calling predeclared functions.</LI>
</UL>
</LI>
</UL>
</P>

<H3>Earley parser classes</H3>

<P>Dino has the three following classes which are used by the Earley parser
embedded into the Dino interpreter.</P>

<H3>Parser.</H3>

<P>Dino has predeclared final class <CODE>parser</CODE> which implements
the Earley parser.  The Earley parser is a very powerful tool to implement
serious language compilers, processors, or translators.  The
implementation of the Earley parser used in Dino has the following
features:</P>
<P>
<UL>
<LI>It is sufficiently fast and does not require much memory.
This is the fastest implementation of the Earley parser which I
know.  The main design goal is to achieve speed and memory
requirements which are necessary to use it in prototype
compilers and language processors.  It parses 30,000 lines of C
per second on 500 MHz Pentium III and allocates about
5Mb memory for a 10,000 line C program.</LI>
<LI>It makes simple syntax directed translation, so an
abstract tree is already the output of the Earley parser.</LI>
<LI>It can parse input described by an ambiguous grammar.  In
this case the parse result can be an abstract tree or all
possible abstract trees.  Moreover, it produces the compact
representation of all possible parse trees by using DAG instead
of real trees.  These features can be used to parse natural
language sentences.</LI>
<LI>It can make syntax error recovery.  Moreover its error
recovery algorithms find error recovery with a minimal number
of ignored tokens.  It permits implemention of parsers with
very good error recovery and reporting.</LI>
<LI>It has fast startup.  There is practically no delay between
processing of grammar and start of parsing.</LI>
<LI>It has a flexible interface.  The input grammar is given by
a YACC-like description.</LI>
<LI>It has a good debugging features.  It can print huge amount
of information about grammar, parsing, error recovery,
translation.  You can even get the result translation in a form
for a graphic visualization program.</LI>
</UL>

The following public functions and variables are declared in the class
<CODE>parser</CODE>:
<UL>
<LI><CODE>ambiguous_p</CODE>.  This public variable stores
information about the last parsing.  A nonzero variable value
means that during the last parsing on a given input the parser
found that the grammar is ambiguous.  The parser can find this
even if you asked for only one parser tree (see function
<CODE>set_one_parse</CODE>).
</LI>
<LI><CODE>set_grammar (descr, strict_p)</CODE>.  This function
tunes the parser to given grammar.  The grammar is given by
string <CODE>descr</CODE>.  Nonzero value of parameter
<CODE>strict_p</CODE> (after implicit integer conversion) means
more strict checking the grammar.  In this case, all
nonterminals will be checked on their ability to derive a
terminal string instead of only checking the axiom for this.
The function can generate exceptions <CODE>partype</CODE> (if the
parameters have wrong types) or <CODE>invgrammar</CODE> if the
description is a bad grammar.  The function can also generate
exception <CODE>pmemory</CODE> if there is no memory for internal
parser data.

The description is similiar to the <EM>YACC</EM> one.  It has
the following syntax:
<BLOCKQUOTE><CODE>
<PRE>
          file : file terms [';']
               | file rule
               | terms [';']
               | rule
       
          terms : terms IDENTIFIER ['=' NUMBER]
                | TERM
       
          rule : IDENTIFIER ':' rhs [';']
          
          rhs : rhs '|' sequence [translation]
              | sequence [translation]
          
          sequence :
                   | sequence IDENTIFIER
                   | sequence C_CHARACTER_CONSTANT
          
          translation : '#'
                      | '#' NUMBER
                      | '#' '-'
                      | '#' IDENTIFIER [NUMBER] '(' numbers ')'
          
          numbers :
                  | numbers NUMBER
                  | numbers '-'
       
</PRE>
</CODE></BLOCKQUOTE>

So the description consists of terminal declaration and
rule sections.
       
The terminal declaration section describes the name of
terminals and their codes.  The terminal code is optional.  If
it is omitted, the terminal code will the next free code
starting with 256.  You can declare a terminal several times
(the single condition is that its code should be the same).
       
A character constant present in the rules is a terminal
described by default.  Its code is always the ASCII code of the
character constant.
       
Rules syntax is the same as <EM>YACC</EM> rule syntax.  The
single difference is an optional translation construction
starting with <CODE>#</CODE> right after each alternative.  The
translation part could be a single number which means that the
translation of the alternative will be the translation of the
symbol with the given number (symbol number in the alternative
start is with 0).  Or the translation can be empty or
`<CODE>-</CODE>' which designates the value of the variable
<CODE>nil_anode</CODE>.  Or the translation can be an abstract node
with the given name, optional cost, and with fields whose
values are the translations of the alternative symbols with
numbers given in parentheses after the abstract node name.  You
can use `<CODE>-</CODE>' in an abstract node to show that the empty
node should be used in this place.  If the cost is absent it is
believed to be 1.  The cost of the terminal, error node, and
empty node is always zero.

There is a reserved terminal <CODE>error</CODE> which marks the
start point of error recovery.  The translation of the terminal
is the value of the variable <CODE>error_anode</CODE>.
 </LI>
<LI><CODE>set_debug (level)</CODE>.  This function sets up the
level of debugging information output to <CODE>stderr</CODE>.  The
higher the level, the more information is output.  The default
value is 0 (no output).  The debugging information includes
statistics, the result translation tree, the grammar, parser
sets, parser sets with all situations, situations with
contexts.  The function returns the previously set up debug
level.  Setting up a negative debug level results in output of
the translation for program <B>dot</B> of the graphic
visualization package <B>graphviz</B>.  The parameter should
be an integer after implicit integer conversion.  The function
will generate exception <CODE>partype</CODE> if it is not true.</LI>
<LI><CODE>set_one_parse (flag)</CODE>.  This function sets up a
flag whose nonzero value means building only one translation
tree (without any alternative nodes).  For an unambiguous
grammar the flag does not affect the result.  The function
returns the previously set up flag value.  The default value of
the flag is 1.  The parameter should be an integer after
implicit integer conversion.  The function will generate
exception <CODE>partype</CODE> if it is not true.</LI>
<LI><CODE>set_lookahead (flag)</CODE>.  This function sets up a
flag of of usage of look ahead in the parser work.  The usage
of lookahead gives the best results with the point of view of
space and speed.  The default value is 1 (the lookahead usage).
The function returns the previously set up flag.  No usage of
the lookahead is useful sometimes to get more understandable
debug output of the parser work (see function
<CODE>set_debug</CODE>).  The parameter should be an integer after
implicit integer conversion.  The function will generate the
exception <CODE>partype</CODE> if it is not true.</LI>
<LI><CODE>set_cost (flag)</CODE>.  This function sets up building
the only translation tree (trees if we set up one_parse_flag to
0) with minimal cost.  For an unambiguous grammar the flag does
not affect the result.  The default value is 0. The function
returns the previously set up flag value.  The default value of
the flag is 0.  The parameter should be an integer after
implicit integer conversion.  The function will generate
exception <CODE>partype</CODE> if it is not true.</LI>
<LI><CODE>set_recovery (flag)</CODE>.  This function sets up a flag
whose nonzero value means making error recovery if a syntax
error occurred.  Otherwise, a syntax error results in finishing
parsing (although the syntax error function passed to
<CODE>parse</CODE> is called once).  The function returns the
previously set up flag value.  The default value of the flag is
1.  The parameter should be an integer after implicit integer
conversion.  The function will generate exception
<CODE>partype</CODE> if it is not true.</LI>
<LI><CODE>set_recovery_match (n_toks)</CODE>.  This function sets
up an internal parser parameter meaning how much subsequent
tokens should be successfully shifted to finish error recovery.
The default value is 3.  The function returns the previously
set up value.  The parameter should be an integer after
implicit integer conversion.  The function will generate
exception <CODE>partype</CODE> if it is not true.
</LI>
<LI><CODE>parse (tokens, error_func)</CODE>. This function is the
major function of the class.  It makes translation according to
the previously set up grammar of input given by the parameter
<CODE>tokens</CODE> whose value should be an array of objects of
predeclared class <CODE>token</CODE>.  If the parser recognizes a
syntax error it calls the function given through parameter
<CODE>error_func</CODE> with six parameters:
<UL>
<LI>index of the token (in array <CODE>tokens</CODE>) on which
the syntax error occured.</LI>
<LI>the error token itself.  It may be <B>nil</B> for
end of file.</LI>
<LI>index of the first token (in array <CODE>tokens</CODE>)
ignored due to error recovery.</LI>
<LI>the first ignored token itself.  It may be
<B>nil</B> for end of file.</LI>
<LI>index of the first token (in array <CODE>tokens</CODE>)
which is not ignored after error recovery.</LI>
<LI>the first not ignored token itself.  It may be
<B>nil</B> for end of file.</LI>
</UL>

If the parser works with switched off error recovery (see
function <CODE>set_recovery</CODE>, the third and fifth parameters
will be negative and forth and sixth parameter will be
<B>nil</B>.

The function returns an object of the predeclared class
<CODE>anode</CODE> which is the root of the abtsract tree
representing the translation of the parser input.  The function
returns <B>nil</B> only if syntax error was occurred and
error recovery was switched off.  The function can generate
exception <CODE>partype</CODE> if the parameter types are wrong or
exception <CODE>invtoken_decl</CODE> if any of the input tokens
have a wrong code.  The function also can generate exception
<CODE>pmemory</CODE> if there is no memory for internal parser
data.</LI>
</UL>
</P>
<P>The call of the class <CODE>parser</CODE> itself can generate exception
<CODE>pmemory</CODE> if there is no memory for internal parser
data.</P>

<H3>Token.</H3>

<P>Dino has a predeclared class <CODE>token</CODE>.  Objects of this class
should be the input of the Earley parser (see function <CODE>parse</CODE>
in class <CODE>parser</CODE>).  The result abstract tree representing the
translation will have input tokens as leaves.  The class
<CODE>token</CODE> has one public variable <CODE>code</CODE> whose value
should be the code of the corresponding terminal described in the
grammar.  You could extend the class description e.g. by adding
variables whose values could be attributes of the token (e.g. source
line number, name of an identifier, or value for a number).</P>

<H3>Anode.</H3>

<P>Dino has a predeclared class <CODE>anode</CODE> whose objects are nodes of
the abtract tree representing the translation (see function
<CODE>parse</CODE> of class <CODE>parser</CODE>).  Objects of this class are
generated by the Earley parser.  The class has two public variables
<CODE>name</CODE> whose value is string representing name of the abstract
node as it given in the grammar and <CODE>transl</CODE> whose value is
array with abstract node fields as the array elements.  There are a
few node types which have special meaning:</P>
<P>
<UL>
<LI>Terminal node which has reserved name <CODE>$term</CODE>.  The
value of the public variable <CODE>transl</CODE> for this node is
an object of class <CODE>token</CODE> representing the
corresponding input token which was an element of the array
passed as a parameter of function <CODE>parse</CODE> of function
<CODE>parser</CODE>.</LI>
<LI>Error node which has reserved name <CODE>$error</CODE>.  This
node exists in one exemplar (see description of variable
<CODE>error_anode</CODE>) and represents the translation of
reserved grammar symbol <CODE>error</CODE>.  The value is public
variable <CODE>transl</CODE> will be <B>nil</B> in this case.</LI>
<LI>The empty node which has the reserved name <CODE>$nil</CODE>.
This node also exists in one exemplar (see description of
variable <CODE>nil_anode</CODE>) and represents the translation of
a grammar symbol for which we did not describe a translation.
For example, in a grammar rule an abstract node refers for the
translation of a nonterminal for which we do not produce a
translation.  The value is public variable of such class object
will be <B>nil</B> in this case.</LI>
<LI>Alternative node which has the reserved name <CODE>$alt</CODE>.
It represents all possible alternatives in the translation of
the grammar nonterminal.  The value of the public variable
<CODE>transl</CODE> will be an array with elements whose values are
objects of class <CODE>anode</CODE> which represent all possible
translations.  Such nodes can be generated by the parser only
if the grammar is ambiguous and we did not ask it to produce
only one translation.</LI>
</UL>
</P>

<H3>Nil_anode and error_anode.</H3>

<P>There is only one instance of <CODE>anode</CODE> which represents empty
(nil) nodes.  The same is true for the error nodes.  The final
variables <CODE>nil_anode</CODE> and <CODE>error_anode</CODE> correspondingly
refer to these nodes.</P>

<H3>Example of Earley parser usage.</H3>

<P>Let us write a program which transforms an expression into postfix
polish form.  Please, read the program comments to understand what the
code does.  The program should output string <CODE>"abcda*+*+"</CODE>
which is the postfix polish form of input string
<CODE>"a+b*(c+d*a)"</CODE>.
<BLOCKQUOTE><CODE>
<PRE>
          // The following is the expression grammar:
          var grammar = "E : E '+' T   # plus (0 2)\n\
                           | T         # 0\n\
                           | error     # 0\n\
                         T : T '*' F   # mult (0 2)\n\
                           | F         # 0\n\
                         F : 'a'       # 0\n\
                           | 'b'       # 0\n\
                           | 'c'       # 0\n\
                           | 'd'       # 0\n\
                           | '(' E ')' # 1";
          // Create parser and set up grammar.
          var p = parser ();
          p.set_grammar (grammar, 1);

          // Add attribute repr to token:
          ext token { var repr; }
          // The following code forms input tokens from string:
          var str = "a+b*(c+d*a)";
          var i, inp = [#str : nil];
          for (i = 0; i &lt; #str; i++) {
            inp [i] = token (str[i] + 0);
            inp [i].repr = str[i];
          }
          // The following function output messages about syntax errors
          // syntax error recovery:
          func error (err_start, err_tok,
                      start_ignored_num, start_ignored_tok_attr,
                      start_recovered_num, start_recovered_tok) {
            put ("syntax error on token #", err_start,
                 " (" @ err_tok.code @ ")");
            putln (" -- ignore ", start_recovered_num - start_ignored_num,
                   " tokens starting with token #", start_ignored_num);
          }

          var root = p.parse (inp, error); // parse

          // Output translation in polish inverse form
          func pr (r) {
            var i, n = r.name;

            if (n == "$term")
              put (r.transl.repr);
            else if (n == "mult" || n == "plus") {
              for (i = 0; i &lt; #r.transl; i++)
                pr (r.transl [i]);
              put (n == "mult" ? "*" : "+");
            }
            else if (n != "$error") {
              putln ("internal error");
              exit (1);
            }
          }

          pr (root);
          putln ();
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="ss8.3">8.3</A> <A HREF="dino.html#toc8.3">Predeclared functions</A>
</H2>

<P>The predeclared functions expect a given number of actual parameters
(may be a variable number of parameters).  If the actual parameter
number is an unexpected one, exception <CODE>parnumber</CODE> is
generated.  The predeclared functions believe that the actual
parameters (may be after implicit conversions) are of the required
type.  If this is not true, exception <CODE>partype</CODE> is generated.
To show how many parameters the function requires, we will write the
names of the parameters and use brackets <CODE>[</CODE> and <CODE>]</CODE> for
the optional parameters in the description of the functions.</P>
<P>Examples:  The following description
<BLOCKQUOTE><CODE>
<PRE>
          strtime ([format [, time]])
</PRE>
</CODE></BLOCKQUOTE>

describes that the function can accept zero, one, or two
parameters.  If only one parameter is given, then this is
parameter <CODE>format</CODE>.</P>
<P>If something is not said about the returned result, the function
returns the default value <B>nil</B>.</P>

<H3>Mathematical functions</H3>

<P>The following functions make implicit arithmetic conversion of the
parameters.  After the conversions the parameters are expected to be
of integer or floating point type.  The result is always a floating
point number.
<UL>
<LI><CODE>sqrt (x)</CODE>.  The function returns the square root of
<CODE>x</CODE>.  The function generates the exception <CODE>edom</CODE>
if <CODE>x</CODE> is negative.</LI>
<LI><CODE>exp (x)</CODE>.  The function returns <CODE>e</CODE> (the
base of the natural logarithm) raised to the power of
<CODE>x</CODE>.</LI>
<LI><CODE>log (x)</CODE>.  The function returns the natural
logarithm of <CODE>x</CODE>.  The function generates the exception
<CODE>edom</CODE> if <CODE>x</CODE> is negative or may generate
<CODE>erange</CODE> if the value is zero.</LI>
<LI><CODE>log10 (x)</CODE>.  The function returns the decimal
logarithm of <CODE>x</CODE>.  The function generates the exception
<CODE>edom</CODE> if <CODE>x</CODE> is negative or may generate
<CODE>erange</CODE> if the value is zero.</LI>
<LI><CODE>pow (x, y)</CODE>.  The function returns <CODE>x</CODE>
raised to the power of <CODE>y</CODE>.  The function generates
exception <CODE>edom</CODE> if x is negative and y is not of
integral value.</LI>
<LI><CODE>sin (x)</CODE>.  The function returns the sine of
<CODE>x</CODE>.</LI>
<LI><CODE>cos (x)</CODE>.  The function returns the cosine of
<CODE>x</CODE>.</LI>
<LI><CODE>atan2 (x, y)</CODE>.  The function returns the arc
tangent of the two variables <CODE>x</CODE> and <CODE>y</CODE>.  It is
similar to calculating the arc tangent of <CODE>y / x</CODE>,
except that the signs of both arguments are used to determine
the quadrant of the result.</LI>
</UL>
</P>

<H3>Pattern matching functions</H3>

<P>Dino has the predeclared functions which are used for <EM>pattern
matching</EM>.  The pattern is described by <EM>regular
expressions</EM> (<EM>regex</EM>).  The pattern has syntax of
<EM>extended</EM> POSIX (1003.2) regular expressions, i.e. the pattern
has the following syntax:
<BLOCKQUOTE><CODE>
<PRE>
          Regex = Branch {"|" Branch}
</PRE>
</CODE></BLOCKQUOTE>

A regex matches anything that matches one of the <EM>branches</EM>.
<BLOCKQUOTE><CODE>
<PRE>
          Branch = {Piece}
</PRE>
</CODE></BLOCKQUOTE>

A branch matches a match for the first <EM>piece</EM>, followed by a
match for the second piece, etc.  If the pieces are omitted, the
branch matches the null string.
<BLOCKQUOTE><CODE>
<PRE>
          Piece = Atom ["*" | "+" | "?" | Bound]

          Bound = "{" Min ["," [Max]] "}" | "{" "," Max "}"

          Min = &lt;unsigned integer between 0 and 255 inclusive>

          Max = &lt;unsigned integer between 0 and 255 inclusive>
</PRE>
</CODE></BLOCKQUOTE>

An <EM>atom</EM> followed by <CODE>*</CODE> matches a sequence of 0 or
more matches of the atom.  An atom followed by <CODE>+</CODE> matches a
sequence of 1 or more matches of the atom.  An atom followed by
<CODE>?</CODE> matches a sequence of 0 or 1 matches of the atom.</P>
<P>There is a more general construction (a <EM>bound</EM>) for describing
repetitions of an atom.  An atom followed by a bound containing only
one integer <CODE>min</CODE> matches a sequence of exactly <CODE>min</CODE>
matches of the atom.  An atom followed by a bound containing one
integer <CODE>min</CODE> and a comma matches a sequence of <CODE>min</CODE> or
more matches of the atom.  An atom followed by a bound containing a
comma and one integer <CODE>Max</CODE> matches at most <CODE>Max</CODE>
repetitions of the atom.  An atom followed by a bound containing two
integers <CODE>min</CODE> and <CODE>max</CODE> matches a sequence of
<CODE>min</CODE> through <CODE>max</CODE> (inclusive) matches of the atom.
<BLOCKQUOTE><CODE>
<PRE>
          Atom = "(" Regex ")"
               | "(" ")"
               | "."
               | "^"
               | "$"
               | BracketedList
               | "\^"
               | "\["
               | "\$"
               | "\("
               | "\)"
               | "\*"
               | "\+"
               | "\?"
               | "\{"
               | "\."
               | &lt;any pair the first character is \ and the second is any
                  except for ^.[$()|*+? >
               | &lt;any character except for ^.[$()|*+? >
</PRE>
</CODE></BLOCKQUOTE>

A regular expression enclosed in <CODE>()</CODE> can be an atom.  In this
case it matches a match for the regular expression in the
parentheses).  The atom <CODE>()</CODE> matches the null string.  The atom
<CODE>.</CODE> matches any single character.  Atoms <CODE>^</CODE> and
<CODE>$</CODE> match correspondingly the null string at the beginning of a
line and the null string at the end of a line.</P>
<P>An atom which is <CODE>\</CODE> followed by one of the characters
<CODE>^.[$()|*+?{\</CODE> matches that character taken as an ordinary
character.  Atom which is <CODE>\</CODE> followed by any other character
matches the second character taken as an ordinary character, as if the
<CODE>\</CODE> had not been present.  So you should use <CODE>\\</CODE> for
matching with a single <CODE>\</CODE>.  An atom which is any other single
character matches that character.  It is illegal to end a regular
expression with <CODE>\</CODE>.  There is an exception which is not
described by the atom syntax.  An <CODE>{</CODE> followed by a character
other than a digit or comma is an ordinary character, not the
beginning of a bound and matches the character <CODE>{</CODE>.
<BLOCKQUOTE><CODE>
<PRE>
          BracketedList = "[" List "]"

          List = FirstChar ["-" Char] {Char ["-" Char]}

          FirstChar = &lt;any character except for ^ - and ]>
                    | CollatingElement

          Char = FirstChar
               | "^"

          CollatingElement = "[:" Class ":]"

          Class = "alnum"
                | "alpha"
                | "blank"
                | "ctrl"
                | "digit"
                | "graph"
                | "lower"
                | "print"
                | "punct"
                | "space"
                | "upper"
                | "xdigit"
</PRE>
</CODE></BLOCKQUOTE>

An atom can be a bracket expression which is a <EM>list</EM> of
characters enclosed in <CODE>[]</CODE>.  Usually it is used to match any
single character from the list.  If the list begins with <CODE>^</CODE>,
it matches any single character (but see below) not in the list.  If
two characters in the list are separated by <CODE>-</CODE>, this is
shorthand for the full <EM>range</EM> of characters between those two
(inclusive) in the collating sequence of ASCII codes,
e.g. <CODE>[0-9]</CODE> matches any decimal digit.  It is illegal for two
ranges to share an <EM>endpoint</EM>, e.g. <CODE>a-c-e</CODE>.</P>

<P>There are exceptions which are not described by the atom syntax which
is used to include a literal <CODE>]</CODE> in the list by making it the first
character (following a possible <CODE>^</CODE>).  To include a literal
<CODE>-</CODE>, make it the first or the last character, or the second
endpoint of a range.  As you can see from the syntax, all special
characters (except for <CODE>[</CODE>) described in an atom lose their
special significance within a bracket expression.</P>
<P>A collating element is a name of a character class enclosed in
<CODE>[:</CODE> and <CODE>:]</CODE>.  It denotes the list of all characters
belonging to that class.  Standard character class names are:
<BLOCKQUOTE><CODE>
<PRE>
       alnum       digit       punct
       alpha       graph       space
       blank       lower       upper
       cntrl       print       xdigit
</PRE>
</CODE></BLOCKQUOTE>

These names stand for the character classes defined in the ANSI C
include file <CODE>ctype.h</CODE>.  There is an exception not described by
the syntax: a character class can not be used as an endpoint of a
range.</P>
<P>There is an extension of regular expressions used by DINO and of ones
defined in Posix 1003.2: no particular limit is imposed on the length
of the regular expression.</P>
<P>There are the following Dino pattern matching functions:
<UL>
<LI><CODE>match (regex, string)</CODE>.  The function searches for
the matching regular expression <CODE>regex</CODE> in
<CODE>string</CODE>.  The both parameters should be strings after
their implicit string conversion.  The matching is made
according to the standard POSIX 1003.2: The regular expression
matches the substring starting earliest in the string.  If the
regular expression could match more than one substring starting
at that point, it matches the longest.  Subexpressions also
match the longest possible substrings, subject to the
constraint that the whole match be as long as possible, with
subexpressions starting earlier in the regular expression
taking priority over ones starting later.  In other words,
higher-level subexpressions take priority over their component
subexpressions.  Match lengths are measured in characters, not
collating elements.  A null string is considered longer than no
match at all.  If there is no matching, the function returns
the value <B>nil</B>.  Otherwise, the function returns a new
mutable vector of integers.  The length of the vector is <CODE>2
* (N + 1)</CODE> where <CODE>N</CODE> is the number of atoms which
are regular expressions in parentheses.  The first two elements
are the index of the first character of the substring
corresponding to the whole regular expression and the index of
the last character matched plus one.  The subsequent two
elements are the index of the first character of the substring
corresponding to the first atom in the regular expression (the
atoms are ordered by their open parentheses) and the index of
the last character plus one, and so on.  If there is no
matching with a regular expression in parentheses, the
corresponding vector elements will have negative values.
<P>Example: The program
<BLOCKQUOTE><CODE>
<PRE>
          println (match ("()(a)((a)(a))", "baaab"));
</PRE>
</CODE></BLOCKQUOTE>

outputs
<BLOCKQUOTE><CODE>
<PRE>
          [1, 4, 1, 1, 1, 2, 2, 4, 2, 3, 3, 4]
</PRE>
</CODE></BLOCKQUOTE>
</P>
</LI>
<LI><CODE>gmatch (regex, string[, flag])</CODE>.  The function
searches for different occurrences of regular expression
<CODE>regex</CODE> in <CODE>string</CODE>.  Both parameters should
be strings after their implicit string conversion.  The third
parameter is optional.  If it is present, it should be integer
after implicit integer conversion.  If its value is nonzero,
the substrings matched by regexp can be overlapped.  Otherwise,
the substrings are never overlapped.  If the parameter is
absent, the function behaves as its value were zero.  The
function returns a new mutable vector of integers.  The length
of the vector is <CODE>2 * N</CODE> where <CODE>N</CODE> is number of
the found occurrences.  Pairs of the vector elements correspond
to the occurrences.  The first element of the pairs is index of
the first character of substring corresponding to all regular
expression in the corresponding occurrences and the second
element is index of the last character plus one.  If there is
no one occurrence, the function returns <B>nil</B>.
<P>Example: The program
<BLOCKQUOTE><CODE>
<PRE>
          println (gmatch ("aa", "aaaaa"));
          println (gmatch ("aa", "aaaaa", 1));
</PRE>
</CODE></BLOCKQUOTE>

outputs
<BLOCKQUOTE><CODE>
<PRE>
          [0, 2, 2, 4]
          [0, 2, 1, 3, 2, 4, 3, 5]
</PRE>
</CODE></BLOCKQUOTE>
</P>
</LI>
<LI><CODE>sub (regex, string, subst)</CODE>.  The function searches
for substrings matching the regular expression <CODE>regex</CODE>
in <CODE>string</CODE>.  All parameters should be string after
implicit string conversion.  If there is no matching, the
function returns the value <B>nil</B>.  Otherwise, the
function returns a new mutable vector of characters in which
the first substring matched has been changed to the string
<CODE>subst</CODE>.  Within the replacement string <CODE>subst</CODE>,
the sequence <CODE>\n</CODE>, where <CODE>n</CODE> is a digit from 1 to
9, may be used to indicate the text that matched the
<CODE>n</CODE>'th atom of the regex in parentheses.  The sequence
<CODE>\0</CODE> represents the entire matched text, as does the
character <CODE>&amp;</CODE>.</LI>
<LI><CODE>gsub (regex, string, subst)</CODE>.  The function is
analogous to the function <CODE>sub</CODE> except for the function
searches for all non-overlapping substrings matched with the
regular expression and returns a new mutable vector of
characters in which all matched substrings have been changed to
the string <CODE>subst</CODE>.</LI>
<LI><CODE>split (string [, regex])</CODE>.  The function splits
<CODE>string</CODE> into non-overlapped substrings separated by
strings matching the regular expression.  All parameters should
be strings after implicit string conversion.  If the second
parameter is omitted the value of the predeclared variable
<CODE>split_regex</CODE> is used instead of the second parameter
value.  In this case the function may generate the exception
<CODE>invenvar</CODE> (corrupted value of a predeclared variable).
The function returns a new mutable vector with elements which
are the separated substrings.  If the regular expression is the
null string, the function returns a new mutable vector with
elements which are strings each containing one character of
string.
<P>Examples: The program
<BLOCKQUOTE><CODE>
<PRE>
          println (split ("aaa bbb ccc  ddd"));
</PRE>
</CODE></BLOCKQUOTE>

outputs
<BLOCKQUOTE><CODE>
<PRE>
          ["aaa", "bbb", "ccc", "ddd"]
</PRE>
</CODE></BLOCKQUOTE>

The program
<BLOCKQUOTE><CODE>
<PRE>
          println (split ("abcdef", ""));
</PRE>
</CODE></BLOCKQUOTE>

outputs
<BLOCKQUOTE><CODE>
<PRE>
          ["a", "b", "c", "d", "e", "f"]
</PRE>
</CODE></BLOCKQUOTE>
</P>
</LI>
</UL>

If the regular expression is incorrect, the functions generate one of
the following predeclared exceptions (see predeclared classes):
<UL>
<LI><CODE>ebrack</CODE>.  Regular expression has unmatched bracket.</LI>
<LI><CODE>erange</CODE>.  Invalid use of range in regular
expression.</LI>
<LI><CODE>ectype</CODE>.  Unknown character class name in regular
expression.</LI>
<LI><CODE>eparen</CODE>.  Regular expression has unmatched
parenthesis.</LI>
<LI><CODE>esubreg</CODE>.  Invalid back reference to a
subexpression in regular expression.</LI>
<LI><CODE>eend</CODE>.  Non specific error in regular expression.</LI>
<LI><CODE>eescape</CODE>.  Invalid escape sequence in regular
expression.</LI>
<LI><CODE>ebadpat</CODE>.  Invalid use of pattern operators in
regular expression.</LI>
<LI><CODE>esize</CODE>.  Compiled regular expression is too big.</LI>
<LI><CODE>espace</CODE>.  No memory for the regular expression
function to work.</LI>
</UL>
</P>

<H3>File functions</H3>

<P>Dino has some predeclared functions to work on files and
directories.</P>

<H3>Functions for access to file/directory information</H3>

<P>The following predeclared functions can be used for accessing file or
directory information.  The functions may generate an exception
declared in the class <CODE>syserror</CODE> (e.g. <CODE>eaccess</CODE>,
<CODE>enametoolong</CODE>, <CODE>enfile</CODE> and so on) besides the standard
<CODE>partype</CODE>, and <CODE>parnumber</CODE>.  The functions expect one
parameter which should be a file instance (see the predeclared class
<CODE>file</CODE>) or the path name of a file represented by a string (the
functions make implicit string conversion of the parameter).  The
single exception to this is <CODE>isatty</CODE> which expects a file
instance.
<UL>
<LI><CODE>ftype (fileinstance_or_filename)</CODE>.  The function
returns one the following characters:
<UL>
<LI><CODE>'f'</CODE>.  A regular file.</LI>
<LI><CODE>'d'</CODE>.  A directory.</LI>
<LI><CODE>'L'</CODE>.  A symbolic link.</LI>
<LI><CODE>'c'</CODE>.  A character device.</LI>
<LI><CODE>'b'</CODE>.  A block device.</LI>
<LI><CODE>'p'</CODE>.  A fifo.</LI>
<LI><CODE>'S'</CODE>.  A socket.</LI>
</UL>

Under some OSes the function never returns some of the
characters (e.g. 'c' or 'b').</LI>
<LI><CODE>fun (fileinstance_or_filename)</CODE>.  The function
returns new string representing name of owner of the file
(directory).  Under some OSes the function may return the new
string <CODE>"Unknown"</CODE> if there is no notion "owner" in the
OS file system.</LI>
<LI><CODE>fgn (fileinstance_or_filename)</CODE>.  Analogous to the
previous function except for it returns a new string
representing name of the group of the file (directory).  Under
some OSes the function may return the new string
<CODE>"Unknown"</CODE> if there is no notion "group" in the OS file
system.</LI>
<LI><CODE>fsize (fileinstance_or_filename)</CODE>.  The function
returns an integer value which is the length of the file in
bytes.</LI>
<LI><CODE>fatime (fileinstance_or_filename)</CODE>.  The function
returns integer value which is time of the last access to the
file (directory).  The time is measured in seconds since the
fixed time (usually since January 1, 1970).  See also <EM>time
functions</EM>.</LI>
<LI><CODE>fmtime (fileinstance_or_filename)</CODE>.  Analogous to
the previous functions but returns the time of the last
modification.</LI>
<LI><CODE>fctime (fileinstance_or_filename)</CODE>.  Analogous to
the previous functions but it returns the time of the last
change.  Here `change' usually means changing the file
attributes (owner, modes and so on), while `modification' means
usually changing the file itself.</LI>
<LI><CODE>fumode (fileinstance_or_filename)</CODE>.  The function
returns a new string representing the rights of the owner of
the file (directory).  The string may contain the following
characters (in the following order if the string contains more
than one character):
<UL>
<LI><CODE>'s'</CODE>.  Sticky bit of the file (directory).</LI>
<LI><CODE>'r'</CODE>.  Right to read.</LI>
<LI><CODE>'w'</CODE>.  Right to write.</LI>
<LI><CODE>'x'</CODE>.  Right to execute.</LI>
</UL>
</LI>
<LI><CODE>fgmode (fileinstance_or_filename)</CODE>.  Analogous to
the previous function except for the fact that it returns
information about the file (directory) group user rights and
that the function never returns a string containing the
character <CODE>'s'</CODE>.</LI>
<LI><CODE>fomode (fileinstance_or_filename)</CODE>.  Analogous to
the previous function except for the act that it returns
information about the rights of all other users.</LI>
<LI><CODE>isatty (fileinstance)</CODE>.  The function returns 1 if
the file instance given as a parameter is an open file
connected to a terminal and 0 otherwise.</LI>
</UL>

The following functions can be used to change rights of usage of the
file (directory) for different users.  The function expects two
strings (after implicit string conversion).  The first one is the path
name of the file (directory).  The second one is the rights.  For
instance, if the string contains a character 'r', this is right to
read (see characters used to denote different rights in the
description of the function <CODE>fumode</CODE>).  The functions always
return the value <B>nil</B>.
<UL>
<LI><CODE>chumod (path, mode)</CODE>.  The function sets up rights
for the file (directory) owner according to the given mode.</LI>
<LI><CODE>chgmod (path, mode)</CODE>.  Analogous to the previous
function except for the fact that it sets up rights for the
file (directory) group users and that the function ignores the
character <CODE>'s'</CODE>.</LI>
<LI><CODE>chomod (path, mode)</CODE>.  Analogous to the previous
function except for the fact that it sets up rights for all
other users.</LI>
</UL>
</P>

<H3>Functions for work with directories</H3>

<P>The following functions work with directories.  The functions may
generate an exception declared in class syserror
(e.g. <CODE>eaccess</CODE>, <CODE>enametoolong</CODE>, <CODE>enotdir</CODE> and so
on) besides the standard <CODE>partype</CODE>, <CODE>parnumber</CODE>.
<UL>
<LI><CODE>readdir (dirpath)</CODE>.  The function makes implicit
string conversion of the parameter value which should be a
string (directory path).  The function returns a new mutable
vector with elements which are strings representing names of
all files and sub-directories (including <CODE>"."</CODE> and
<CODE>".."</CODE> for the current and parent directory
respectively) in given directory.</LI>
<LI><CODE>mkdir (dirpath)</CODE>.  The function creates a directory
with the given name represented by a string (the parameter
value after implicit string conversion).  The directory has
read/write/execute rights for all.  You can change it with the
aid of the functions <CODE>ch*mod</CODE>.</LI>
<LI><CODE>rmdir (dirpath)</CODE>.  The function removes the
directory given by a string which is parameter value after
implicit string conversion.</LI>
<LI><CODE>getcwd ()</CODE>.  The function returns a new string
representing the full path of the current directory.</LI>
<LI><CODE>chdir (dirpath)</CODE>.  The function makes the directory
given by <CODE>dirpath</CODE> (which should be a string after
implicit string conversion) the current directory.</LI>
</UL>
</P>

<H3>Functions for work with files.</H3>

<P>The following functions (besides input/output functions) work with OS
files.  The functions may generate an exception declared in the class
<CODE>syserror</CODE> (e.g. <CODE>eaccess</CODE>, <CODE>enametoolong</CODE>,
<CODE>eisdir</CODE> and so on) besides the standard <CODE>partype</CODE>,
and <CODE>parnumber</CODE>.  The function <CODE>rename</CODE> can be used for
renaming a directory, not only a file.
<UL>
<LI><CODE>rename (old_path, new_path)</CODE>.  The function renames
the file (directory) given by its path name.  The old and new
names are given by parameter values which should be strings
after implicit string conversion.</LI>
<LI><CODE>remove (file_path)</CODE>.  The function removes the OS
file given by its path name.  The file path name should be a
string after implicit string conversion.</LI>
<LI><CODE>open (file_path, mode)</CODE>.  The function opens the
file for work in the given <EM>mode</EM>, creates a new class
<CODE>file</CODE> instance, associates the opened file with the
instance, and returns the instance.  The parameter values
should be strings after implicit string conversions.  The first
parameter value is a string representing the file path.  The
second parameter value is string representing the mode for work
with the file (for all possible modes see the ANSI C function
<CODE>fopen</CODE> documentation).  All work with an opened file is
made through the file instance.</LI>
<LI><CODE>close (fileinstance)</CODE>.  The function closes a file
opened by the function <CODE>open</CODE>.  The file is given by the
class <CODE>file</CODE> instance.  The function also removes all
association of the instance with the file.</LI>
<LI><CODE>flush (fileinstance)</CODE>.  The function flushes any
output that has been buffered for the opened file given by
the class <CODE>file</CODE> instance.</LI>
<LI><CODE>popen (command, mode)</CODE>.  The function starts the
shell command given by the first parameter value (which should
be a string after implicit string conversion), creates a pipe,
creates a new class <CODE>file</CODE> instance, associates the pipe
with the instance, and returns the instance.  Writing to such a
pipe (through the class file instance) writes to the standard
input of the command.  Conversely, reading from the pipe reads
the command's standard output.  After implicit string
conversion the second parameter value should be the string "r"
(for reading from the pipe) or "w" (for writing to the pipe).
The pipe should be closed by the function <CODE>pclose</CODE>.</LI>
<LI><CODE>pclose (fileinstance)</CODE>.  The function waits for the
command connected to a pipe to terminate.  The pipe is given by
the class <CODE>file</CODE> instance returned by the function
<CODE>popen</CODE>.  The function also removes the association of
the instance with the pipe.</LI>
<LI><CODE>tell (fileinstance)</CODE>.  The function returns the
current value of the file position indicator for the file
(opened by function <CODE>open</CODE>) given by the class
<CODE>file</CODE> instance.</LI>
<LI><CODE>seek (fileinstance, offset, whence)</CODE>.  The function
sets up the current file position indicator for the file
(opened by function <CODE>open</CODE>) given by the class
<CODE>file</CODE> instance.  The position is given by
<CODE>offset</CODE> which should be an integer after implicit
arithmetic conversion and <CODE>whence</CODE> which should be a
string after implicit string conversion.  The first character
of the string should be <CODE>'s'</CODE>, <CODE>'c'</CODE>, or
<CODE>'e'</CODE> (these characters mean that the offset is relative
to the start of the file, the current position indicator, or
the end-of-file, respectively).</LI>
</UL>
</P>

<H3>File output functions</H3>

<P>The following functions are used to output something into opened
files.  All the functions always return the value <B>nil</B>.  The
functions may generate an exception declared in the class <CODE>syserror</CODE>
(e.g. <CODE>eio</CODE>, <CODE>enospc</CODE> and so on) besides the standard
<CODE>partype</CODE>, and <CODE>parnumber</CODE>.
<UL>
<LI><CODE>put (...)</CODE>.  All parameters should be strings after
implicit string conversion.  The function outputs all strings
into the standard output stream.</LI>
<LI><CODE>putln (...)</CODE>.  The function is analogous to the
function <CODE>put</CODE> except for the fact that it additionally
outputs a new line character after output of all the strings.</LI>
<LI><CODE>fput (fileinstance, ...)</CODE>.  The function is
analogous to the function <CODE>put</CODE> except for the fact that
it outputs the string into an opened file associated with a
class <CODE>file</CODE> instance which is the first parameter
value.</LI>
<LI><CODE>fputln (fileinstance, ...)</CODE>.  The function is
analogous to function <CODE>fput</CODE> except for the fact that it
additionally outputs a new line character after output of all
the strings.
</LI>
<LI><CODE>putf (format, ...)</CODE>.  The first parameter should be
strings after implicit string conversion.  The function outputs
the rest of parameters according to the format.  The number of
the rest parameters should be exactly equal to the conversions
(including parameterized widths and precisions) in the format.
Otherwise, exception <CODE>parnumber</CODE> will be generated.  The
types of the parameter should correspond to the corresponding
conversion specifier (or to be integer for parameterized widths
and precisions).  If it is not true, exception <CODE>partype</CODE>
will be generated.  The format is subset of one of standard C
function <CODE>printf</CODE> and has the following syntax:
<BLOCKQUOTE><CODE>
<PRE>
          format : &lt;any character except %>
                 | '%' flags [width] [precision]
                       conversion_specifier
          flags :
                | flag

          flag : '#' | '0' | '-' | ' ' | '+'

          width : '*' | &lt;decimal number starting with non-zero>

          precision : '.' ['*' | &lt;decimal number>]

          conversion_specifier : 'd' | 'o' | 'x' | 'X'
                               | 'e' | 'E' | 'f' | 'F'
                               | 'g' | 'G' | 'a' | 'A'
                               | 'c' | 's' | '%'
       
</PRE>
</CODE></BLOCKQUOTE>

If the format syntax is wrong, exception <CODE>invfmt</CODE> is
generated.

Flag '#' means that the value should be converted into an
alternative form.  It can be present only for conversion
specifiers 'o', 'x', 'X', 'e', 'E', 'f', 'F', 'g', 'G', 'a',
and 'A'.  If the flag is used for conversion specifier 'o', the
output will be prefixed by '0'.  For 'x' and 'X' the output
will be prefixed by '0x' and '0X' correspondingly. For
conversions 'a', 'A', 'e', 'E', 'f', 'F', 'g', and 'G' the
output will always contain a decimal point.  For conversions
'g' and 'G' it also means that trailing zeros are not removed
from the output as they would be without the flag.  The
following code using flag '#' in format
<BLOCKQUOTE><CODE>
<PRE>
         putf ("->%#o %#x %#a %#.0e %#.0f %#g\n",
               8, 10, 1., 2., 3., 4.);
</PRE>
</CODE></BLOCKQUOTE>

will output
<BLOCKQUOTE><CODE>
<PRE>
         ->010 0xa 0x1.p+0 2.e+00 3. 4.00000
</PRE>
</CODE></BLOCKQUOTE>


Flag '0' means that the output value will be zero padded on the
left. If both flags '0' and '-' appear, the flag '0' is
ignored.  It is also ignored for conversions 'd', 'o', 'x', and
'X' if a precision is given.  The flag is prohibited for
conversions 'c' and 's'.  The following code using flag '0' in
format
<BLOCKQUOTE><CODE>
<PRE>
         putf ("->%04d %04x %012.2a %09.2e %05.2f %05.2g\n",
               8, 10, 1., 2., 3., 4.);
</PRE>
</CODE></BLOCKQUOTE>

will output
<BLOCKQUOTE><CODE>
<PRE>
         ->0008 000a 0x0001.00p+0 02.00e+00 03.00 00004
</PRE>
</CODE></BLOCKQUOTE>


Flag '-' means that the output will be left adjusted on the
field boundary.  (The default is right justification). Flag '-'
overrides flag '0' if the both are given.  The following code
using flag '-' in format
<BLOCKQUOTE><CODE>
<PRE>
         putf ("->%-04d %-04x %-012.2a %-09.2e %-05.2f %-05.2g\n",
               8, 10, 1., 2., 3., 4.);
</PRE>
</CODE></BLOCKQUOTE>

will output
<BLOCKQUOTE><CODE>
<PRE>
         ->8    a    0x1.00p+0    2.00e+00  3.00  4
</PRE>
</CODE></BLOCKQUOTE>


Flag ' ' means that the output of a signed number will start
with a blank for positives number.  The flag can be used only
for conversions 'd', 'a', 'A', 'e', 'E', 'f', 'F', 'g', and
'G'.  If both flags ' ' and '+' appear, the flag ' ' is
ignored.  The following code using flag ' ' in format
<BLOCKQUOTE><CODE>
<PRE>
         putf ("->% d % .2a % .2e % .2f % .2g\n",
               8, 1., 2., 3., 4.);
</PRE>
</CODE></BLOCKQUOTE>

will output
<BLOCKQUOTE><CODE>
<PRE>
         -> 8  0x1.00p+0  2.00e+00  3.00  4
</PRE>
</CODE></BLOCKQUOTE>


Flag '+' means that the output of a signed number will start
with a plus for positives number.  The flag can be used only
for conversions 'd', 'a', 'A', 'e', 'E', 'f', 'F', 'g', and
'G'.  Flag '+' overrides flag ' ' if both are given.  The
following code using flag '+' in format
<BLOCKQUOTE><CODE>
<PRE>
         putf ("->%+d %+.2a %+.2e %+.2f %+.2g\n",
               8, 1., 2., 3., 4.);
</PRE>
</CODE></BLOCKQUOTE>

will output
<BLOCKQUOTE><CODE>
<PRE>
         ->+8 +0x1.00p+0 +2.00e+00 +3.00 +4
</PRE>
</CODE></BLOCKQUOTE>


The width defines a minimum width of the output value.  If the
output is smaller, it is padded with spaces (or zeros -- see
flag '0') on the left (if flag '-' is used) or right.  The
output is never truncated.  The width should be no more than
maximal integer value, otherwise exception <CODE>invfmt</CODE> is
generated.  The width can be given as a parameter of integer
type if '*' is used.  If the value of width given by the
parameter is negative, flag '-' is believed to be given and the
width is believed to be equal to zero.  The following code
using width in format
<BLOCKQUOTE><CODE>
<PRE>
         putf ("->%5d %05d %-5d %*d %*d&lt;-\n", 8, 9, 10, 5, 8, -5, 10);
</PRE>
</CODE></BLOCKQUOTE>

will output
<BLOCKQUOTE><CODE>
<PRE>
         ->    8 00009 10        8 10   &lt;-
</PRE>
</CODE></BLOCKQUOTE>


The precision is prohibited for conversions 'c'.  If the number
after the period is absent, its value will be zero.  The
precision can be given as a parameter of integer type if '*' is
used after the period.  If the value of precision given by the
parameter is negative, its value is believed to be zero too.
For conversions 'd', 'o', 'x', and 'X' the precision means
minimum number of output digits.  For conversions 'a', 'A',
'e', 'E', 'f', and 'F' it means the number of digits to appear
after the decimal point.  For 'g' and 'G' it means the maximum
number of significant digits.  For 's' it means the maximum
number of characters to be output from a string.  The following
code using precision in format
<BLOCKQUOTE><CODE>
<PRE>
         putf ("->%.d %.0d %.5d %.0f %.0e %.2g&lt;-\n",
               8, 8, 9, 1.6, 2.3, 3.53);
         putf ("->%.2s %.0d %.*d %.*d&lt;-\n", "long", 0, 5, 8, -5, 8);
</PRE>
</CODE></BLOCKQUOTE>

will output
<BLOCKQUOTE><CODE>
<PRE>
         ->8 8 00009 2 2e+00 3.5&lt;-
         ->lo  00008 8&lt;-
</PRE>
</CODE></BLOCKQUOTE>


Conversion 'd' should be used to output integer.  The default
precision is 1.  When 0 is output with an explicit precision 0,
the output is empty.

Conversions 'o', 'x', and 'X' should be used to output an
integer value as unsigned in octal and hexadecimal form.  The
lower case letters <CODE>abcdef</CODE> are used for 'x' and the
upper case letters <CODE>ABCDEF</CODE> are used for 'X'.  The
precision gives the minimum number of digits that must
appear. If the output value requires fewer digits, it is padded
on the left with zeros.  The default precision is 1.  When 0 is
output with an explicit precision 0, the output is empty.

Conversions 'f' and 'F' should be used to output floating point
values.  The output value has a form <CODE>[-]ddd.ddd</CODE> where
the number of digits after the decimal point is given by the
precision specification.  The default precision value is 6.  If
the precision is explicitly zero, no decimal-point character
appears.

Conversions 'e' and 'E' should be used to output floating point
values with an exponent in form <CODE>[-]d.ddd[e|E][+|-]dd</CODE>.
There is always one digit before the decimal-point.  The number
of digits after the decimal point is defined by the precision.
The default precision value is 6.  If the precision is zero, no
decimal-point appears.  Conversion 'E' uses the letter
<CODE>E</CODE> (rather than <CODE>e</CODE>) to introduce the exponent.
The exponent always contains at least two digits.  If the
exponent value is zero, the exponent is output as <CODE>00</CODE>.

Conversions 'g' and 'G' should be used to output floating point
values in style 'f' or 'e' (or 'F' or 'E' for conversion 'G').
The precision defines the number of significant digits.  The
default value of the precision is 6.  If the precision is zero,
it is treated as 1.  Conversion 'e' is used if the exponent
from the conversion is less than -4 or not less than the
precision.  Trailing zeros are removed from the fractional part
of the output.  If all fractional part is zero, the decimal
point is removed too.

Conversion 'a' and 'A' should be used to output floating point
values in hexadecimal form <CODE>[-]0[x|X]h.hhhh[p|P][+|-}d</CODE>.
For conversion 'a' the prefix <CODE>0x</CODE>, the exponent
separator <CODE>p</CODE>, and the letters <CODE>abcdef</CODE> are used.
For 'A' the corresponding upper case letters are used.  There
is always one hexadecimal digit before the decimal point, and
the number of digits after it is equal to the precision.  The
default precision suffices for an exact representation of the
value if an exact representation in base 2 exists and otherwise
is sufficiently large to distinguish all floating point values.
The digit before the decimal point is always nonzero for
normalized numbers.

Conversion 'c' should be used to output a character value.

Conversion 's' should be used to output strings.

Conversion '%' should be used to output <CODE>%</CODE>.

The following code using different conversions in format
<BLOCKQUOTE><CODE>
<PRE>
         putf ("->%% %c %s %d %o %x %X&lt;-\n",
               'c', "string", 7, 8, 20, 20);
         putf ("->%a %A %f %F&lt;-\n", 1.25, 1.2, 1.5, 1.5);
         putf ("->%e %E %g %G %g %G&lt;-\n",
               2.8, 2.8, 3.7, 3.7, 455555555.555, 5.9e-5);
</PRE>
</CODE></BLOCKQUOTE>

will output
<BLOCKQUOTE><CODE>
<PRE>
         ->% c string 7 10 14 14&lt;-
         ->0x1.4p+0 0X1.3333333333333P+0 1.500000 1.500000&lt;-
         ->2.800000e+00 2.800000E+00 3.7 3.7 4.55556e+08 5.9E-05&lt;-
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI><CODE>fput (fileinstance, format, ...)</CODE>.  The function is
analogous to the function <CODE>putf</CODE> except for the fact that
it outputs the string into an opened file associated with a
class <CODE>file</CODE> instance which is the first parameter
value.</LI>
<LI><CODE>print (...)</CODE>.  The function outputs all parameter
values into standard output stream.  The function never makes
implicit conversions of the parameter values.  The parameter
values are output as they could be represented in Dino itself
(e.g. character <CODE>'c'</CODE> is output as <CODE>'c'</CODE>, vector
<CODE>['a', 'b', 'c']</CODE> is output as <CODE>"abc"</CODE>, vector
<CODE>[10, 20]</CODE> as <CODE>[10, 20]</CODE> and so on).  As you know
some values (functions, classes, block instances, class
instances, threads) are not represented fully in DINO.  Such
values are represented schematically.  For example, the output
<CODE>func f {}.g(unique_number)</CODE> would mean function
<CODE>f</CODE> in the call of function (or class) <CODE>g</CODE> with
the given unique number and function g is in the instance of
the implicit block covering the whole program.  For the
function <CODE>g</CODE>, output would look simply like <CODE>func
g</CODE> because there is only one instance of the implicit block
covering the whole program.  Output for an instance of the
class <CODE>c</CODE> in the function <CODE>f</CODE> looks like
<CODE>instance {}.f(unique_number).c(unique_number)</CODE>.  Output
for a block instance of the function <CODE>f</CODE> looks like
<CODE>stack {}.f(unique_number)</CODE>.  Output for a thread whose
thread-function <CODE>t</CODE> is declared in the function
<CODE>f</CODE> would look like <CODE>thread unique_number
{}.f(unique_number).t(unique_number)</CODE>.</LI>
<LI><CODE>println (...)</CODE>.  The function is analogous to the
function <CODE>print</CODE> except for the fact that it
additionally outputs new line character after output of all
parameters.</LI>
<LI><CODE>fprint (fileinstance, ...)</CODE>.  The function is
analogous to the function <CODE>print</CODE> except for the fact
that it outputs the parameters into an opened file associated
with a class <CODE>file</CODE> instance which is the value of first
parameter.</LI>
<LI><CODE>fprintln (fileinstance, ...)</CODE>.  The function is
analogous to function <CODE>fprint</CODE> except for the fact that
it additionally outputs a new line character after the output
of all the parameters.</LI>
</UL>
</P>

<H3>File input functions</H3>

<P>The following functions are used to input something from opened files.
All the functions always return the value <B>nil</B>.  The functions
may generate an exception declared in the class <CODE>syserror</CODE>
(e.g. <CODE>eio</CODE>, <CODE>enospc</CODE> and so on) or <CODE>eof</CODE> besides
the standard <CODE>partype</CODE>, and <CODE>parnumber</CODE>.
<UL>
<LI><CODE>get ()</CODE>.  The function reads one character from
standard input stream and returns it.  The function generates
the exception <CODE>eof</CODE> if the function tries to read the
end of file.</LI>
<LI><CODE>getln ()</CODE>.  The function reads one line from
standard input stream and returns it as a new string.  The end
of line is the newline character or end of file.  The returned
string does not contain the newline character.  The function
generates the exception <CODE>eof</CODE> only when the file
position indicator before the function call stands exactly on
the end of file.</LI>
<LI><CODE>getf ([ln_flag])</CODE>.  The function reads the whole
standard input stream and returns it as a new string.  The
function generates the exception <CODE>eof</CODE> only when the
file position indicator before the function call stands exactly
on the end of file.  The function has an optional parameter
which should be integer after implicit integer conversion.  If
the parameter value is nonzero, the function returns a vector
of strings.  Otherwise it behaves as usually.  Each string is a
line in the input stream.  The strings do not contain the
newline character.</LI>
<LI><CODE>fget (fileinstance)</CODE>.  The function is analogous to
function <CODE>get</CODE> except for the fact that it reads from an
opened file associated with the class <CODE>file</CODE> instance
which is the parameter's value.</LI>
<LI><CODE>fgetln (fileinstance)</CODE>.  The function is analogous
to the function <CODE>getln</CODE> except for the fact that it
reads from an opened file associated with a class <CODE>file</CODE>
instance which is the parameter value.</LI>
<LI><CODE>fgetf (fileinstance [, ln_flag])</CODE>.  The function is
analogous to the function <CODE>getf</CODE> except for the fact
that it reads from an opened file associated with a class
<CODE>file</CODE> instance which is the parameter's value.</LI>
<LI><CODE>scan ()</CODE>.  The functions reads a character,
integer, floating point number, string, vector, or table and
returns it as the result.  The input values should be
represented in the file as the ones in the Dino language
(except for the fact that there should be no identifiers in the
input values and there should be no operators in the values,
although the signs <CODE>+</CODE> and <CODE>-</CODE> are possible in an
integer or floating point represenation).  The table or vector
should contains only values of types mentioned above.  The
values in the file can be separated by white characters.  If
there is an error (e.g. unbalanced brackets in a vector value)
in the read value representation the function generates the
exception <CODE>invinput</CODE>.  The functions generates the
exception <CODE>eof</CODE> if only white characters are still
unread in the file.</LI>
<LI><CODE>scanln ()</CODE>.  The function is analogous to the
function <CODE>scan</CODE> except for the fact that it skips all
characters until the end of line or the end of file after
reading the value.  Skipping is made even if the exception
<CODE>invinput</CODE> is generated.</LI>
<LI><CODE>fscan (fileinstance)</CODE>.  The function is analogous
to the function <CODE>scan</CODE> except for the fact that it reads
from an opened file associated with a class <CODE>file</CODE>
instance which is the parameter's value.</LI>
<LI><CODE>fscanln (fileinstance)</CODE>.  The function is analogous
to the function <CODE>scanln</CODE> except for that it reads from
an opened file associated with a class <CODE>file</CODE> instance
which is the parameter value.</LI>
</UL>
</P>

<H3>Time functions</H3>

<P>The following functions can be used to get information about real
time.
<UL>
<LI><CODE>time ()</CODE>.  The function returns the time in seconds
since the fixed time (usually since January 1, 1970).</LI>
<LI><CODE>strtime ([format [, time]])</CODE>.  The function returns
a string representing the <CODE>time</CODE> (integer representing
time in seconds since the fixed time) according to the
<CODE>format</CODE> (string).  If the format is not given, the
value of variable <CODE>time_format</CODE> is used.  In this case
if the value of <CODE>time_format</CODE> is corrupted (it is not a
string), the function generates exception <CODE>invenvar</CODE>.
If the time is not given, the current time is used.  The format
is the same as in C library function <CODE>strftime</CODE>.  Here
is an extraction from the OS function documentation.  The
following format specifiers can be used in the format:
<UL>
<LI><CODE>%a</CODE> - the abbreviated weekday name according to
the current locale.</LI>
<LI><CODE>%A</CODE> - the full weekday name according to the
current locale.</LI>
<LI><CODE>%%b</CODE> - the abbreviated month name according to
the current locale.</LI>
<LI><CODE>%%B</CODE> - the full month name according to the
current locale.</LI>
<LI><CODE>%%c</CODE> - the preferred date and time
representation for the current locale.</LI>
<LI><CODE>%%d</CODE> - the day of the month as a decimal number
(range 01 to 31).</LI>
<LI><CODE>%%H</CODE> - the hour as a decimal number using a
24-hour clock (range 00 to 23).</LI>
<LI><CODE>%%I</CODE> - the hour as a decimal number using a
12-hour clock (range 01 to 12).</LI>
<LI><CODE>%%j</CODE> - the day of the year as a decimal number
(range 001 to 366).</LI>
<LI><CODE>%%m</CODE> - the month as a decimal number (range 01
to 12).</LI>
<LI><CODE>%%M</CODE> - the minute as a decimal number.</LI>
<LI><CODE>%%p</CODE> - either `am' or `pm' according to the given time
value, or the corresponding strings for the current locale.</LI>
<LI><CODE>%%S</CODE> - the second as a decimal number.</LI>
<LI><CODE>%%U</CODE> - the week number of the current year as a
decimal number, starting with the first Sunday as the first
day of the first week.</LI>
<LI><CODE>%%W</CODE> - the week number of the current year as a
decimal number, starting with the first Monday as the first
day of the first week.</LI>
<LI><CODE>%%w</CODE> - the day of the week as a decimal, Sunday
being 0.</LI>
<LI><CODE>%%x</CODE> - the preferred date representation for
the current locale without the time.</LI>
<LI><CODE>%%X</CODE> - the preferred time representation for
the current locale without the date.</LI>
<LI><CODE>%%y</CODE> - the year as a decimal number without a
century (range 00 to 99).</LI>
<LI><CODE>%%Y</CODE> - the year as a decimal number including
the century.</LI>
<LI><CODE>%%Z</CODE> - the time zone or the name or an
abbreviation.</LI>
<LI><CODE>%%%</CODE> - a literal `%' character.</LI>
</UL>
</LI>
</UL>
</P>

<H3>Functions for access to process information</H3>

<P>There are Dino predeclared functions which are used to get information
about the current OS process (the Dino interpreter which executes the
program).  Each OS process has unique identifier and usually OS
processes are called by a concrete user and group and are executed on
behalf of the concrete user and group (so called effective
identifiers).  The following functions return such information.  On
some OSes the function may return string "Unknown" as a name if there
are notions of user and group identifiers.
<UL>
<LI><CODE>getpid ()</CODE>.  The function returns an integer value
which is the process ID of the current OS process.</LI>
<LI><CODE>getun ()</CODE>.  The function returns a new string which
is the user name for the current OS process.</LI>
<LI><CODE>geteun ()</CODE>.  The function returns a new string
which is the effective user name for the current OS process.</LI>
<LI><CODE>getgn ()</CODE>.  The function returns a new string which
is the group name for the current OS process.</LI>
<LI><CODE>getegn ()</CODE>.  The function returns a new string
which is the effective group name for the current OS process.</LI>
<LI><CODE>getgroups ()</CODE>.  The function returns a new vector
of strings (possibly the empty vector) representing
supplementary group names for the current OS process.</LI>
</UL>
</P>

<H3>Miscellaneous functions</H3>

<P>There are the following miscellaneous functions:
<UL>
<LI><CODE>max (v1, v2, ...)</CODE>.  The function searches for and
returns the maximal value in all of its parameters.  The
parameters should be of integer or floating point type after
implicit arithmetic conversion.  So the function can return an
integer or floating point number depending on the type of the
maximal value after the conversion.</LI>
<LI><CODE>min (v1, v2, ...)</CODE>.  The function is analogous to
the previous function, but searches for and returns the minimal
value.</LI>
<LI><CODE>tolower (str)</CODE>.  The function expects that the
parameter <CODE>str</CODE> (after implicit string conversion) is a
string.  The function returns new string <CODE>str</CODE> in which
upper case letters are changed to the corresponding lower case
letters.</LI>
<LI><CODE>toupper (str)</CODE>.  The function expects that
the parameter <CODE>str</CODE> (after implicit string conversion) is
a string.  The function returns the new string <CODE>str</CODE> in which
lower case letters are changed to the corresponding upper case
letters.</LI>
<LI><CODE>eltype (vect)</CODE>.  The function expects that the
parameter value is a vector.  The function returns <B>nil</B>
if the vector is heterogenous, otherwise the function returns
the type of the vector elements (type of <B>nil</B> if the
vector is empty).</LI>
<LI><CODE>keys (tab)</CODE>.  The function expects that the
parameter value is a table.  The function returns a new mutable
vector containing all the keys in the table.  The order of keys
in the vector is undefined.</LI>
<LI><CODE>context (par)</CODE>. The function returns the context
(see section <EM>Declarations and Scope Rules</EM>) represented
by a block instance or an object for the given parameter value
which should be a function, a class, a thread, a block
instance, or an object.</LI>
<LI><CODE>inside (par1, par2[, flag])</CODE>.  The goal for
function usage is to check that something is declared inside
something other.  If the third parameter value after implicit
integer conversion is given and nonzero, it is checked with
taking contexts into account.  The second parameter value
should be a function or a class.  The first parameter value
should be a function, a class, an object, or a block instance.
In the first three cases, they define corresponding a function,
class, or block.  If the function, class, or block defined by
the first parameter is declared inside the function or class
given by the second parameter, the function <CODE>inside</CODE>
returns 1.  The function <CODE>inside</CODE> also returns 1 if the
function or class defined by the first parameter is the same as
the function or class given by the second parameter.  Otherwise
the function <CODE>inside</CODE> returns 0.  The following example
illustrates the difference between checking with taking
contexts into account and without it.
<BLOCKQUOTE><CODE>
<PRE>
          class c () {
            class subc () {
            }
          }
          inside (c ().subc (), c ().subc);
          inside (c ().subc (), c ().subc, 1);
</PRE>
</CODE></BLOCKQUOTE>

The first call of <CODE>inside</CODE> returns 1, while the second
one returns 0.</LI>
<LI><CODE>subv (vect, index[, length])</CODE>.  The function is
used to extract a slice of vector elements.  The first
parameter value should be a vector after implicit string
conversion.  The second and third parameter values should be
integers after implicit integer conversion. The function
extracts only an element or the part of the slice existing in
the vector (so you can use any values of the index and the
length).  If index is negative, it is considered to be equal to
zero.  If the length is negative, the slice will finish on the
vector end.  The function returns a new vector which is the
slice.  The result vector is immutable only when the original
vector is immutable.</LI>
<LI><CODE>del (vect, index[, length]) or del (tab, key)</CODE>.
The first form of the function is used to remove the vector
element or a slice of vector elements from the mutable vector
<CODE>vect</CODE>.  The second and the third parameter values
should be integers after implicit integer conversion. The
function removes only an element or the part of the slice
existing in the vector (so you can use any values of the index
and the length).  If index is negative, it is considered to be
equal to zero.  If the length is negative, the slice will
finish on the vector end.  The second form of the function is
used to remove the element (if it exists) with the given key
from the mutable table.  The function generates the exception
<CODE>immutable</CODE> if we are trying to remove from an immutable
vector or table.  The function returns the modified vector.</LI>
<LI><CODE>ins (vect, el[, index])</CODE>.  The function inserts the
element given by the second parameter into the vector given by
the first parameter on the place given by the third parameter.
If the third parameter is not given it is believed to be zero.
The third parameter should be an integer after implicit integer
conversion.  If the third parameter is negative or equal to or
greater than the vector length, the element is inserted at the
end of the vector.  The function generates the exception
<CODE>immutable</CODE> if we are trying to insert into an immutable
vector.  The function returns the modified vector.</LI>
<LI><CODE>insv (vect, vect[, index])</CODE>.  The function is
analogous to the function <CODE>ins</CODE> but it is used for
insertion of all vector elements into the vector given as the
first parameter.  So the second parameter value should be a
vector.  The function returns the modified vector.</LI>
<LI><CODE>rev (vect)</CODE>.  The function reverses the given
vector.  The function generates the exception
<CODE>immutable</CODE> if we are trying to reverse an immutable
vector.  The function returns the modified vector.</LI>
<LI><CODE>cmpv (vect, vect)</CODE>.  The function makes implicit
string conversion of the parameter values.  After that, the
parameter values should be vectors whose first corresponding
equal elements should have the same type (character, integer,
or floating point type).  The first corresponding unequal
elements should have the same type too (the remaining elements
can have different type).  As usual, if this is not true,
exception <CODE>partype</CODE> is generated.  The function returns
1 if the first unequal element value of the first vector is
greater than the corresponding element in the second vector, -1
if less, and 0 if the all corresponding vector elements are
equal.  If the first vector is a prefix of the second vector,
the function returns -1.  If the second vector is a prefix of
the first vector, the function returns 1, so it is in fact
generalized lexicographical order.</LI>
<LI><CODE>sort (vect[, compare_function])</CODE>.  The function
returns a new sorted vector.  The original vector given as the
first parameter value should be a homogeneous vector whose
elements are of character, integer, or floating point type.  If
the second parameter is not given, standard arithmetic order
(see comparison operators) is used.  To use special ordering,
use the second parameter which should be a function which
compares two elements of the vector and returns a negative
integer if the first parameter value (element) is less than the
second one, a positive integer if the first parameter value is
greater than the second one, and zero if they are equal.</LI>
<LI><CODE>exit (code)</CODE>.  The function finishes the work of
the interpreter with the given code which should be an integer
value after implicit integer conversion.</LI>
<LI><CODE>gc ()</CODE>.  The function forces garbage collection and
heap compaction.  Usually the Dino interpreter itself invokes
garbage collection when there is no more free memory.</LI>
<LI><CODE>system (command)</CODE>.  The function executes the
command given by a string (the parameter value) in the OS
command interpreter.  Besides standard exceptions
<CODE>parnumber</CODE> and <CODE>partype</CODE> the function may
generate exceptions <CODE>noshell</CODE> and <CODE>systemfail</CODE>.</LI>
<LI><CODE>srand ([seed])</CODE>.  The function sets the parameter
value (after implicit integer conversion) as the seed for a new
sequence of pseudo-random integers to be returned by
<CODE>rand</CODE>.  These sequences are repeatable by calling
<CODE>srand</CODE> with the same seed value.  If the parameter is
not given, the seed will be the result of calling function
<CODE>time</CODE>.</LI>
<LI><CODE>rand ()</CODE>.  The function returns a pseudo-random
integer value.  If the function <CODE>srand</CODE> was not called
before, 1 will be used as the seed value.</LI>
<LI><CODE>sput (...), sputln (...), sputf (format, ...)</CODE> The
functions are analogous to functions put, putln, print, and
println but they return the result string instead of output of
the formed string into the standard output stream.</LI>
<LI><CODE>sprint (...), sprintln (...)</CODE>.  The functions are
analogous to functions print and println but they return the
result string instead of output of the formed string into the
standard output stream.</LI>
</UL>
</P>

<HR>
<A HREF="dino-9.html">Next</A>
<A HREF="dino-7.html">Previous</A>
<A HREF="dino.html#toc8">Contents</A>
</BODY>
</HTML>
