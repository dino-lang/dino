/*
   Copyright (C) 1997-2015 Vladimir Makarov.

   Written by Vladimir Makarov <vmakarov@gcc.gnu.org>

   This file is part of interpreter of DINO.

   This is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This software is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GNU CC; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.

*/

/* Value of node pointer to erroneous (syntactically or semantically)
   constructions is NULL.  But this value may be also used for representation
   of correct program.

   After semantic analysis idents are changed by corresponding
   decl occurrence. */

%import {

#include "d_common.h"

/* Structures representing binary_operation_node and unary_operation_node
   have member of its mode.  EVT is abbreviation of expr value type.
   The order of enumeration constants is important. */

enum expr_value_type
{
  /* To correctly initiate nodes' member value_type of this enumeration
     constant is to be equal to the following value. */
  EVT_UNKNOWN = 0,
  EVT_CHAR = 1,
  EVT_INT = 2,
  EVT_FLOAT = 4,
  EVT_VEC = 8,
  EVT_TAB = 16,
  EVT_FUN = 32,
  EVT_CLASS = 64,
  EVT_TYPE = 128,
  EVT_SLICE = 256
};

/* This is mask for number. */
#define EVT_NUMBER_MASK (EVT_CHAR | EVT_INT | EVT_FLOAT)
/* This is mask for int or vec. */
#define EVT_INT_VEC_MASK (EVT_INT | EVT_VEC)
/* This is mask for number or vec. */
#define EVT_NUMBER_VEC_MASK (EVT_CHAR | EVT_INT | EVT_FLOAT | EVT_VEC)
/* This is mask for number, vec, or tab. */
#define EVT_NUMBER_VEC_TAB_MASK\
   (EVT_CHAR | EVT_INT | EVT_FLOAT | EVT_VEC  | EVT_TAB)
/* This is mask for number or string. */
#define EVT_NUMBER_STRING_MASK EVT_NUMBER_VEC_MASK
/* This is mask for vec or slice. */
#define EVT_VEC_SLICE_MASK (EVT_VEC | EVT_SLICE)
/* This is mask for tab or slice. */
#define EVT_TAB_SLICE_MASK (EVT_TAB | EVT_SLICE)
/* This is mask for vec, tab or slice. */
#define EVT_VEC_TAB_SLICE_MASK (EVT_VEC | EVT_TAB | EVT_SLICE)
/* This is mask for number, vec, or slice. */
#define EVT_NUMBER_VEC_SLICE_MASK (EVT_NUMBER_VEC_MASK | EVT_SLICE)
/* This is mask for number, vec, tab, or slice. */
#define EVT_NUMBER_VEC_TAB_SLICE_MASK \
  (EVT_NUMBER_VEC_TAB_MASK | EVT_SLICE)

typedef enum expr_value_type expr_value_type_t;

typedef int type_mask_t;

typedef int int_t;

typedef struct BC_node *BC_hidden_node_t;

enum access_val
{
  PRIVATE_ACCESS,
  PUBLIC_ACCESS,
  DEFAULT_ACCESS
};

typedef enum access_val access_val_t;

enum hint_val
{
  NO_HINT,
  INLINE_HINT,
  PURE_HINT,
  JIT_HINT
};

typedef enum hint_val hint_val_t;

}

%export {

#if defined(NDEBUG)
#define IR_mpz_ptr(s) (&IR_gmp_(s).mpz)
#else
#define IR_mpz_ptr(s) \
  (IR_gmp_(s), &((_IR_unique_long *) s)->_IR_S_unique_long.gmp_.mpz)
#endif

/* These macros for storage management of DINO internal representation: */

/* Start work with the storage manager -- see DINO documentation. */

#define IR_START_ALLOC()    OS_CREATE (irp, 0)

/* Finish work with the storage manager -- see DINO documentation. */

#define IR_STOP_ALLOC()     OS_DELETE (irp)

/* Allocate storage for internal representation of given size
   -- see DINO documentation. */

#define IR_ALLOC(ptr, size, ptr_type)\
  do {\
    OS_TOP_EXPAND (irp, size); ptr = (ptr_type) OS_TOP_BEGIN (irp);\
    OS_TOP_FINISH (irp);\
  } while (0);

/* Free storage of internal representation of given size -- see DINO
   documentation. */

#define IR_FREE(ptr, size)


/* These macros are analogous to ones of package `object-stack'
   worked with storage of DINO internal representation: */

/* Start new internal representation object -- see also package
   `object-stack'. */

#define IR_TOP_FINISH()  OS_TOP_FINISH (irp)

/* Nullify current internal representation object -- see also package
   `object-stack'. */

#define IR_TOP_NULLIFY()  OS_TOP_NULLIFY (irp)

/* Shorten current internal representation object on given number bytes -- see
   also package `object-stack'. */

#define IR_TOP_SHORTEN(length) OS_TOP_SHORTEN (irp, length)

/* Return start address of current internal representation object -- see also
   package `object-stack'. */

#define IR_TOP_BEGIN()  OS_TOP_BEGIN (irp)

/* Return length of current internal representation object in bytes -- see
   also package `object-stack'. */

#define IR_TOP_LENGTH()  OS_TOP_LENGTH (irp)

/* Expand current internal representation object -- see also package
   `object-stack'. */

#define IR_TOP_EXPAND(length)  OS_TOP_EXPAND (irp, length)

/* Add byte to the end of current internal representation object -- see also
   package `object-stack'. */

#define IR_TOP_ADD_BYTE(b)  OS_TOP_ADD_BYTE (irp, b)

/* Add string to the end of current internal representation object -- see also
   package `object-stack'. */

#define IR_TOP_ADD_STRING(str)  OS_TOP_ADD_STRING (irp, str)

/* Add memory of given length to the end of current internal representation
   object -- see also package `object-stack'. */

#define IR_TOP_ADD_MEMORY(mem, length)  OS_TOP_ADD_MEMORY (irp, mem, length)

extern os_t irp;

extern void initiate_table (void);
extern void delete_table (void);
extern IR_node_t *find_table_entry (IR_node_t ref, int reserve);
extern void include_to_table (IR_node_t ref);
extern IR_node_t find_unique_ident (char *string);
extern IR_node_t create_node (IR_node_mode_t mode);
extern IR_node_t create_node_with_pos (IR_node_mode_t mode, position_t pos);
extern IR_node_t create_unique_node_with_string (IR_node_mode_t m,
                                                 const char *str, size_t len,
                                                 char **string_in_pool_ptr);
extern IR_node_t create_unique_ident_node (const char *str);
extern IR_node_t create_empty_block (IR_node_t scope);
extern IR_node_t merge_stmt_lists (IR_node_t list1, IR_node_t list2);
extern IR_node_t uncycle_stmt_list (IR_node_t list);
extern void initiate_icode (void);
extern void finish_icode (void);

extern IR_node_t find_decl_in_given_scope (IR_node_t ident, IR_node_t scope);
extern IR_node_t find_decl (IR_node_t ident, IR_node_t scope);
extern void set_environment_declarations (IR_node_t environment_scope);

extern IR_node_t get_ident_node (char *name, position_t pos);
extern IR_node_t get_int_node (rint_t number_value, position_t pos);
 extern IR_node_t get_long_node (const char *repr, position_t pos, int base);
extern IR_node_t get_float_node (rfloat_t number_value, position_t pos);

/* Variable name for the rest parameter values (...). */
#define ARGS_NAME "args"

/* This is name of varibale which will contains catdhed exception in
   corresponding catch block. */

#define CATCH_EXCEPTION_NAME "e"

extern IR_node_t temp_unique_ident;
extern IR_node_t temp_unique_int;
extern IR_node_t temp_unique_long;
extern IR_node_t temp_unique_float;
extern IR_node_t temp_unique_char;
extern IR_node_t temp_unique_string;
extern IR_node_t temp_unique_ucodestr;
extern IR_node_t temp_ident;
extern IR_node_t temp_decl;
extern IR_node_t destroy_unique_ident;

/* This is trick (usage that IR_NODE_MODE is macro)!!!  Therefore the
   following macro must apply to node with the same structure as node
   with mode m. */

#define IR_SET_MODE(v, m) (IR_NODE_MODE (v) = (m))

/* The macro call value is pointer to unique ident node of
   corresponding ident node V.  V may be NULL. */

#define IR_GET_UNIQUE_IDENT(v)\
  ((v) == NULL ? v : IR_unique_ident (v))

/* The following macro value is standard environment which is parsed
   before the program. The last character must be a space for correct
   parsing.  The last character of the string *should* be \n.  That is
   important for correct work OF REPL. */
#define ENVIRONMENT \
  "class except {}\n"\
  " class error (msg = nil) {use except;}\n"\
  "  class signal (msg = nil) {use error former msg;}\n"\
  "   class sigint (msg = nil) {use signal former msg;}\n"\
  "   class sigill (msg = nil) {use signal former msg;}\n"\
  "   class sigabrt (msg = nil) {use signal former msg;}\n"\
  "   class sigfpe (msg = nil) {use signal former msg;}\n"\
  "   class sigterm (msg = nil) {use signal former msg;}\n"\
  "   class sigsegv (msg = nil) {use signal former msg;}\n"\
  "  class invenv (msg = nil) {use error former msg;}\n"\
  "  class invop (msg = nil) {use error former msg;}\n"\
  "   class optype (msg = nil) {use invop former msg;}\n"\
  "   class opvalue (msg = nil) {use invop former msg;}\n"\
  "  class invindex (msg = nil) {use error former msg;}\n"\
  "   class indextype (msg = nil) {use invindex former msg;}\n"\
  "   class indexvalue (msg = nil) {use invindex former msg;}\n"\
  "   class indexop (msg = nil) {use invindex former msg;}\n"\
  "  class invslice (msg = nil) {use error former msg;}\n"\
  "   class slicetype (msg = nil) {use invslice former msg;}\n"\
  "   class sliceform (msg = nil) {use invslice former msg;}\n"\
  "  class invector (msg = nil) {use error former msg;}\n"\
  "   class veclen (msg = nil) {use invector former msg;}\n"\
  "   class vecform (msg = nil) {use invector former msg;}\n"\
  "   class matrixform (msg = nil) {use invector former msg;}\n"\
  "  class invkey (msg = nil) {use error former msg;}\n"\
  "   class keyvalue (msg = nil) {use invkey former msg;}\n"\
  "   class keyop (msg = nil) {use invkey former msg;}\n"\
  "  class invcall (msg = nil) {use error former msg;}\n"\
  "   class abstrcall (msg = nil) {use invcall former msg;}\n"\
  "   class callop (msg = nil) {use invcall former msg;}\n"\
  "   class partype (msg = nil) {use invcall former msg;}\n"\
  "   class parvalue (msg = nil) {use invcall former msg;}\n"\
  "   class invresult (msg = nil) {use invcall former msg;}\n"\
  "   class invinput (msg = nil) {use invcall former msg;}\n"\
  "   class invfmt (msg = nil) {use invcall former msg;}\n"\
  "   class invencoding (msg = nil) {use invcall former msg;}\n"\
  "   class eof (msg = nil) {use invcall former msg;}\n"\
  "   class parnumber (msg = nil) {use invcall former msg;}\n"\
  "   class syncthreadcall (msg = nil) {use invcall former msg;}\n"\
  "   class syserror (msg = nil) {use invcall former msg;}\n"\
  "    class eaccess (msg = nil) {use syserror former msg;}\n"\
  "    class eagain (msg = nil) {use syserror former msg;}\n"\
  "    class ebadf (msg = nil) {use syserror former msg;}\n"\
  "    class ebusy (msg = nil) {use syserror former msg;}\n"\
  "    class echild (msg = nil) {use syserror former msg;}\n"\
  "    class edeadlk (msg = nil) {use syserror former msg;}\n"\
  "    class edom (msg = nil) {use syserror former msg;}\n"\
  "    class eexist (msg = nil) {use syserror former msg;}\n"\
  "    class efault (msg = nil) {use syserror former msg;}\n"\
  "    class efbig (msg = nil) {use syserror former msg;}\n"\
  "    class eintr (msg = nil) {use syserror former msg;}\n"\
  "    class einval (msg = nil) {use syserror former msg;}\n"\
  "    class eio (msg = nil) {use syserror former msg;}\n"\
  "    class eisdir (msg = nil) {use syserror former msg;}\n"\
  "    class emfile (msg = nil) {use syserror former msg;}\n"\
  "    class emlink (msg = nil) {use syserror former msg;}\n"\
  "    class enametoolong (msg = nil) {use syserror former msg;}\n"\
  "    class enfile (msg = nil) {use syserror former msg;}\n"\
  "    class enodev (msg = nil) {use syserror former msg;}\n"\
  "    class enoent (msg = nil) {use syserror former msg;}\n"\
  "    class enoexec (msg = nil) {use syserror former msg;}\n"\
  "    class enolck (msg = nil) {use syserror former msg;}\n"\
  "    class enomem (msg = nil) {use syserror former msg;}\n"\
  "    class enospc (msg = nil) {use syserror former msg;}\n"\
  "    class enosys (msg = nil) {use syserror former msg;}\n"\
  "    class enotdir (msg = nil) {use syserror former msg;}\n"\
  "    class enotempty (msg = nil) {use syserror former msg;}\n"\
  "    class enotty (msg = nil) {use syserror former msg;}\n"\
  "    class enxio (msg = nil) {use syserror former msg;}\n"\
  "    class eperm (msg = nil) {use syserror former msg;}\n"\
  "    class epipe (msg = nil) {use syserror former msg;}\n"\
  "    class erange (msg = nil) {use syserror former msg;}\n"\
  "    class erofs (msg = nil) {use syserror former msg;}\n"\
  "    class espipe (msg = nil) {use syserror former msg;}\n"\
  "    class esrch (msg = nil) {use syserror former msg;}\n"\
  "    class exdev (msg = nil) {use syserror former msg;}\n"\
  "   class systemcall (msg = nil) {use invcall former msg;}\n"\
  "    class noshell (msg = nil) {use systemcall former msg;}\n"\
  "    class systemfail (msg = nil) {use systemcall former msg;}\n"\
  "   class invregexp (msg = nil) {use invcall former msg;}\n"\
  "    class ebrack (msg = nil) {use invregexp former msg;}\n"\
  "    class erange (msg = nil) {use invregexp former msg;}\n"\
  "    class ectype (msg = nil) {use invregexp former msg;}\n"\
  "    class eparen (msg = nil) {use invregexp former msg;}\n"\
  "    class esubreg (msg = nil) {use invregexp former msg;}\n"\
  "    class eend (msg = nil) {use invregexp former msg;}\n"\
  "    class eescape (msg = nil) {use invregexp former msg;}\n"\
  "    class badpat (msg = nil) {use invregexp former msg;}\n"\
  "    class esize (msg = nil) {use invregexp former msg;}\n"\
  "    class espace (msg = nil) {use invregexp former msg;}\n"\
  "   class invparser (msg = nil) {use invcall former msg;}\n"\
  "    class invgrammar (msg = nil) {use invparser former msg;}\n"\
  "    class invtoken (msg = nil) {use invparser former msg;}\n"\
  "    class pmemory (msg = nil) {use invparser former msg;}\n"\
  "   class invextern (msg = nil) {use invcall former msg;}\n"\
  "    class noextern (msg = nil) {use invextern former msg;}\n"\
  "    class libclose (msg = nil) {use invextern former msg;}\n"\
  "    class noexternsupp (msg = nil) {use invextern former msg;}\n"\
  "   class invenvar (msg = nil) {use invcall former msg;}\n"\
  "   class internal (msg = nil) {use invcall former msg;}\n"\
  "  class invaccess (msg = nil) {use error former msg;}\n"\
  "   class accessop (msg = nil) {use invaccess former msg;}\n"\
  "   class accessvalue (msg = nil) {use invaccess former msg;}\n"\
  "   class immutable (msg = nil) {use invaccess former msg;}\n"\
  "   class patternmatch (msg = nil) {use invaccess former msg;}\n"\
  "  class deadlock (msg = nil) {use error former msg;}\n"\
  "  class syncwait (msg = nil) {use error former msg;}\n"\
  "var argv, env; val version, main_thread, curr_thread;\n"\
  "class anode (name, transl) {}\n"\
  "class token (code) {}\n"\
  "if (0) {var t; t.msg; t.code;} // mark some fields\n"\
  "val nil_anode = anode (\"$nil\", nil);\n"\
  "val error_anode = anode (\"$error\", nil);\n"\
  "final class parser \n"\
  "{\n"\
  "  var ambiguous_p;\n"\
  "  priv var grammar;\n"\
  "\n"\
  "  priv fun int_earley_parse_grammar {} priv fun int_earley_set_debug_level {}\n"\
  "  priv fun int_earley_set_one_parse_flag {}\n"\
  "  priv fun int_earley_set_lookahead_level {}\n"\
  "  priv fun int_earley_set_cost_flag {}\n"\
  "  priv fun int_earley_set_error_recovery_flag {}\n"\
  "  priv fun int_earley_set_recovery_match {} priv fun int_earley_parse {}\n"\
  "  priv fun int_earley_create_grammar {}\n"\
  "\n"\
  "  fun set_grammar (descr, strict_p) {\n"\
  "    int_earley_parse_grammar (grammar, strict_p, descr);\n"\
  "  }\n"\
  "  fun set_debug (level) {\n"\
  "    return int_earley_set_debug_level (grammar, level);\n"\
  "  }\n"\
  "  fun set_one_parse (flag) {\n"\
  "    return int_earley_set_one_parse_flag (grammar, flag);\n"\
  "  }\n"\
  "  fun set_lookahead (flag) {\n"\
  "    return int_earley_set_lookahead_level (grammar, flag);\n"\
  "  }\n"\
  "  fun set_cost (flag) {\n"\
  "    return int_earley_set_cost_flag (grammar, flag);\n"\
  "  }\n"\
  "  fun set_recovery (flag) {\n"\
  "    return int_earley_set_error_recovery_flag (grammar, flag);\n"\
  "  }\n"\
  "  fun set_recovery_match (n_toks) {\n"\
  "    return int_earley_set_recovery_match (grammar, n_toks);\n"\
  "  }\n"\
  "  fun parse (tokens, error_fun) {\n"\
  "    var __i; // Trick to guarantee temp. vars to call error_fun\n"\
  "    __i = 1 ^ 2 & (3 ^ 4 & (5 ^ 6 & (7 ^ 8 & (9 ^ 10 & (11 ^ 12 & 13)))));\n"\
  "    return int_earley_parse (grammar, tokens, error_fun);\n"\
  "  }\n"\
  "\n"\
  "  grammar = int_earley_create_grammar ();\n"\
  "}\n"\
  "// Do not place any code inside file (it is only for internal purposes)\n"\
  "final class file {\n"\
  "  priv var file_ptr, unget_char;\n"\
  "  priv var file_icd, file_byte_ocd, file_ucode_ocd, file_encoding;\n"\
  "  throw callop\n"\
  "    (\"File can be created only by functions open or popen\");}\n"\
  "val stdin;\n"\
  "val stdout;\n"\
  "val stderr;\n"\
  "fun max {} fun min {}\n"\
  "fun tolower {} fun toupper {} fun translit {}\n"\
  "fun eltype {}\n"\
  "fun keys {}\n"\
  "fun closure {} fun context {} fun inside {} fun isa {}\n"\
  "fun subv {} fun cmpv {} fun del {} fun ins {}  fun insv {}\n"\
  "fun rev {} fun sort {}\n"\
  "fun sqrt {} fun exp {} fun log {} fun log10 {} fun pow {} \n"\
  "fun sin {} fun cos {} fun atan2 {} \n"\
  "fun match {} fun gmatch {} fun sub {} fun gsub {}\n"\
  "fun split {} var split_regex = \"[ \t]+\";\n"\
  "fun srand {} fun rand {} \n"\
  "fun __process_errno__ {} \n"\
  "fun readdir {} fun ftype {}\n"\
  "fun fuidn {} fun fgrpn {} fun fsize {}\n"\
  "fun fatime {} fun fmtime {} fun fctime {}\n"\
  "fun fumode {} fun fgmode {} fun fomode {}\n"\
  "fun time {}\n"\
  "fun strtime {} var time_format = \"%a %b %d %H:%M:%S %Z %Y\";\n"\
  "fun clock {}\n"\
  "fun gc {} \n"\
  "fun rename {} fun remove {}\n"\
  "fun mkdir {} fun rmdir {}\n"\
  "fun getcwd {} fun chdir {}\n"\
  "fun chumod {} fun chgmod {} fun chomod {} fun isatty {}\n"\
  "fun open {} fun close {} fun flush {}\n"\
  "fun popen {} fun pclose {}\n"\
  "fun tell {} fun seek {}\n"\
  "fun put {} fun putln {}\n"\
  "fun fput {} fun fputln {} fun sput {} fun sputln {}\n"\
  "fun putf {} fun fputf {} fun sputf {}\n"\
  "fun print {} fun println {}\n"\
  "fun fprint {} fun fprintln {} fun sprint {} fun sprintln {}\n"\
  "fun get {} fun getln {} fun getf {}\n"\
  "fun fget {} fun fgetln {} fun fgetf {}\n"\
  "fun scan {} fun scanln {} fun fscan {} fun fscanln {}\n"\
  "fun getpid {} fun getun {} fun geteun {}\n"\
  "fun getgn {} fun getegn {} fun getgroups {}\n"\
  "fun system {}\n"\
  "fun exit {}\n"\
  "fun fold {} fun filter {} fun map {}\n"\
  "fun transpose {}\n"\
  "fun set_encoding {} fun get_encoding {}\n"\
  "fun set_file_encoding {} fun get_file_encoding {}\n"\
  "fun __init__ {} __init__();\n"
}

%local {
#include "d_common.h"

/* All internal representation storage is implemented by object stack.  See
   package `object-stack'. */

os_t irp;

IR_node_t temp_unique_ident;
IR_node_t temp_unique_int;
IR_node_t temp_unique_long;
IR_node_t temp_unique_float;
IR_node_t temp_unique_char;
IR_node_t temp_unique_string;
IR_node_t temp_unique_ucodestr;
IR_node_t temp_ident;
IR_node_t temp_decl;
IR_node_t destroy_unique_ident;

}

%type ucode_t size_t rint_t gmp_t rfloat_t string_t ucodestr_t int_t bool_t
      position_t type_mask_t ticker_t BC_hidden_node_t access_val_t hint_val_t

%%

%abstract
ir_node :: %root
;

%abstract
generic_pos :: ir_node
%other
        /* The following field is set in context analyzer.  It is
	   important place it here to have the same field displacement
	   for all nodes.  It is important for interpreter speed.  */
        pos : position_t
;


/************* The following part are set in syntax analyzer **************/

/* Only char_node can refer to this node. */
unique_char :: ir_node
%other
        char_value : ucode_t
;

/* Only number_node can refer to this node. */
unique_int :: ir_node
%other
        int_value : rint_t
;

unique_long :: ir_node
%other
        /* Don't use directly gmp_, only use IR_mpz_ptr instead.  */
        gmp_ : gmp_t
;

unique_float :: ir_node
%other
        float_value : rfloat_t
;

unique_string :: ir_node
%other
        string_value : string_t
;

unique_ucodestr :: ir_node
%other
        ucodestr_value : ucodestr_t
        /* Byte size of the ucodestr without trailing zero ucode.  */
        ucodestr_size : size_t
;

/* Only ident can refer to this node. */
unique_ident :: ir_node
%other
        ident_string : string_t
;

%abstract
expr :: generic_pos
;

%abstract
designator :: expr
;

/* After semantic analysis reference from any code node to the
   following node is changed on reference to node representing the
   corresponding object occurrence (e.g. var occurrence). */
ident :: designator
%other
        unique_ident : unique_ident /* always defined */
;

nil ::  expr;

char :: expr
%other
        unique_char : unique_char /* always defined */
;

int :: expr
%other
        unique_int : unique_int /* always defined */
;

long :: expr
%other
        unique_long : unique_long /* always defined */
;

float :: expr
%other
        unique_float : unique_float /* always defined */
;

string :: expr
%other
        unique_string : unique_string /* always defined */
;

ucodestr :: expr
%other
        unique_ucodestr : unique_ucodestr /* always defined */
;

%abstract
operation :: expr
;

/* The following structures are representing all binary and unary
   operation nodes. */
%abstract
binary_operation :: operation
%other
        left_operand, right_operand : expr
;

%abstract
unary_operation :: operation
%other
        operand : expr
;

%abstract
component_designator :: designator
%other
        designator : expr
        component : expr
;

in, or, xor, and, eq, ne, identity, unidentity, lt, gt, le, ge,
   lshift, rshift, ashift, concat, plus, minus,
   mult, div, mod :: binary_operation
;

%abstract
logical_binary_operation :: unary_operation
%other
        cont_operand : expr
;

logical_or, logical_and :: logical_binary_operation
;

/* conditional expression */
cond :: expr
%other
   cond_expr : expr
   true_expr : expr
   false_expr : expr
;

const, new, not, unary_plus, unary_minus, bitwise_not, length,
  fold_plus, fold_mult, fold_and, fold_xor, fold_or,
  typeof, charof, intof, longof, floatof, vecof, tabof,
  funof, threadof, classof :: unary_operation
;

format_vecof :: binary_operation
;

%abstract
index_designator :: component_designator
;

index :: index_designator
;

%abstract
period_designator :: component_designator
;

period :: period_designator
;

/* component for slice is the slice start.  */
slice :: index_designator
%other
        bound : expr
        step : expr
;

this :: expr
;

/* These are parts of a pattern.  */
wildcard, dots :: expr
;

%abstract
type :: expr
;

/* The following nodes represent different types.  Type of nil is used
   only in the evaluator.  Actually there is no nodes `nil_type'. */
nil_type, hide_type, hideblock_type, char_type, int_type, long_type, float_type,
   vec_type, tab_type, fun_type, class_type, thread_type,
   stack_type, process_type, type_type :: type
;

/* The following structure represents vec, tab construction
   nodes. */
%abstract
vec_tab :: expr
%other
        elist : elist_element
;

vec, tab ::  vec_tab
;

/* The following structure is representing expr list element
   nodes. */
elist_element :: generic_pos
%other
        /* It can be true only for vect/tab elements if repetition/key
	   was actually given.  */
        repetition_key_flag : bool_t {$ = FALSE;}
        /* Always null for actual parameters. */
        repetition_key : expr
        expr : expr
        /* Pointer to next expr list element (elist). */
        next_elist : elist_element
;

class_fun_thread_call :: expr
%other
        /* Reference to expr that defines the called fun. */
        fun_expr : expr
        /* The following member refers to expr list representing
           actual parameter node. */
        actuals : elist_element
;

/* Identifier in a friend clause. */
friend_ident :: ir_node
%other
	ident_in_clause : ident
	next_friend_ident : friend_ident
;

%abstract
stmt :: generic_pos
%other
        next_stmt : stmt
;

%abstract
assign_stmt :: stmt
%other
        assignment_var : expr
        assignment_expr : expr
;

/* var_assign is an assign inside var-clause.  par_assign (or assign for
   parameter) if the parameter value is not given.  See also node
   par_assign_test. */
assign, mult_assign, div_assign, mod_assign,
  plus_assign, minus_assign, concat_assign, lshift_assign,
  rshift_assign, ashift_assign, and_assign, xor_assign, or_assign,
  var_assign, par_assign :: assign_stmt
;

/* The node is created from pattern assignment.  */
pattern_var :: stmt
%other
        /* The following is shared with assignment_var of
	   corresponding pattern asignment node.  */
        pattern : expr
        pattern_var_access : access_val_t
	/* Flag of that the pattern vars are constant (can not be
	   changed). */
        pattern_const_flag : bool_t
;

%abstract
pattern_assign_stmt :: assign_stmt
;

var_pattern_assign, par_pattern_assign :: pattern_assign_stmt
;

expr_stmt :: stmt
%other
        /* See commentaries for fun call node. */
        stmt_expr : expr
;

if_stmt :: stmt
%other
        if_expr : expr
        /* Reference to stmts after keyword then. */
        if_part : stmt
        /* Reference to stmts after keyword else. */
        else_part : stmt
;

/* This node serves as test loop expr in interpreter. */
for_stmt :: stmt
%other
        /* Reference to the stmt which is first in the for-construction.*/
        for_initial_stmt : stmt
        for_guard_expr : expr
        /* Reference to the stmt which is last in the for-construction. */
        for_iterate_stmt : stmt
        /* Reference to stmts in given for-stmt. */
        for_stmts : stmt
;

foreach_stmt :: stmt
%other
        /* Reference to index designator. */
        foreach_index_designator : designator
        /* Reference to tab right to `:'.*/
        foreach_tab : expr
        /* Reference to stmts in given for-stmt. */
        foreach_stmts : stmt
;

switch_stmt :: stmt
%other
        switch_expr : expr
        switch_cases : stmt
;

%abstract
for_break_contintue :: stmt
;

break_stmt, continue_stmt :: for_break_contintue
;

return_without_result :: stmt
;

return_with_result :: stmt
%other
        /* Reference to expr after keyword return. */
        returned_expr : expr
;

throw :: stmt
%other
        /* Reference to expr (instance value) after keyword THROW. */
        throw_expr : expr
;

wait_stmt :: stmt
%other
        /* Reference to expr after keyword wait. */
        wait_guard_expr : expr
	/* Wait stmt.  */
        wait_stmt : stmt
;

/* The following structure is representing block nodes. */
block :: stmt
%other
        block_scope : block
        /* Reference to stmts in given block. */
        block_stmts : stmt
        /* Reference to corresponding fun or class (NULL for separate
           block). */
        fun_class : fun_class
        /* Lists of identifiers in friend clauses. */
        friend_list : friend_ident
        /* The list of exceptions for TRY block, NULL for simple
           block. */
        exceptions : exception
        /* Flag of the hint presence */
        hint : hint_val_t {$ = NO_HINT;}
        /* The three fields following are non-null if the block corresponds a
	   switch case.  */
        switch_stmt : switch_stmt { $ = NULL; }
        implicit_case_break_stmt : break_stmt { $ = NULL; }
        case_pattern : expr { $ = NULL; }
        case_cond : expr { $ = NULL; }
;

exception :: generic_pos
%other
          exception_class_expr : expr
          /* The following field is not NULL only for the first
             identifier in the exception list. */
          catch_block : block
          next_exception : exception
;

%abstract
decl :: stmt
%other
        scope : block
        ident : ident
	access : access_val_t
	/* Flag of that this (external) var is constant (can not be
	   changed). */
	const_flag : bool_t
;

%abstract
external_decl :: decl
;

/* The following node represents formal parameter of funcs and classes
   too. */
var :: decl
%other
        /* Flag of a parameter  */
        par_flag : bool_t {$ = FALSE;}
;

/* The following node represents external variable declaration. */
external_var :: external_decl
;

/* The following node represents external function declaration. */
external_fun :: external_decl
;

%abstract
fun_class :: decl
;

%abstract
fun_or_class :: fun_class
        /* The next stmt is always corresponding block node if it is
	   not forward declaration. */
%other
	/* Flag of that args must be defined.  In order words ... is
           used. */
	args_flag : bool_t
	/* Flag of that this is final (can not be extended). */
	final_flag : bool_t
        /* TRUE if it is a just forward declaration. */
        forward_decl_flag : bool_t
;

/* The first nodes in corresponding block is fun parameter
   represented by var nodes.  Its scope is this block. */
fun :: fun_or_class
%other
	/* Thrue if this true. */
	thread_flag : bool_t
;

/* See commentaries for fun node. */
class :: fun_or_class
;

use :: stmt
%other
	use_ident : ident
        use_items : use_item
;
%abstract
use_item :: generic_pos
%other
	use_item_ident : ident
        next_use_item : use_item
	alias : ident
;

former_item, later_item :: use_item
;

/************* The following part is set in context analyzer **************/

ident
%other
        decl : decl
;

unique_ident
%other
        /* If the following member is negative than the ident is not
           used for access to any block decl through field operation.
           Otherwise the member value is number of the ident in all
           idents used for access to any block decl through field
           access operation.  This member must be initiated by
           negative value for the node creation time. */
        field_ident_number : int_t {$ = -1;}
        /* If the following member is TRUE than the ident is
           decalared in some block. */
        it_is_declared_in_block : bool_t
;

expr
%other
	/* Possible types of value of given operation. */
        value_type : type_mask_t
;

vec_tab
%other
        /* Number of elements in the list elist. */
        parts_number : int_t
;

class_fun_thread_call
%other
        /* Number of elements in the list actuals. */
        class_fun_thread_call_parameters_number : int_t
;

slice
%other
        /* Dimension of the slice.  In other words, how many triples
	   (start, bound, step) is in the final slice.  */
        dim : int_t {$ = 1;}
;

foreach_stmt
%other
        /* holder for calculated table and current table search
	   start. */
        foreach_tab_place : int_t
        foreach_search_start_place : int_t
;

switch_stmt
%other
        /* holder for calculated switch expression */
        switch_expr_var : var
;

block
%other
        /* Number of all blocks which contain given block. */
        block_level : int_t
        /* Number of vars immediately placed in given block. */
        vars_number : int_t {$ = 0;}
        /* Number of temporary vars needed for expr
           evaluation in given block. */
        temporary_vars_number : int_t {$ = 0;}
        /* Chain of non-function, try or catch blocks immediately
	   inside given block and chain of next such blocks
	   immediately inside the same block.  */
        children, sibling : block
        /* Block which will contain given block.  It is NULL if it
	   will have own stack.  */
        real_block_scope : block {$ = NULL;}
        /* Variable base of the block.  If it is in anothe block
	   stack, the value most probably will be non_zero.  */
        vars_base : int_t {$ = 0;}
        /* See the following comment.  The field value is NULL if the
	   corresponding block is not try-block. */
        catch_list_pc : generic_pos
	/* True if this block should be inlined.  Block can be inlined
	   if it does not contain fun/class decls, it is not a
	   fun/class, try, or catch block.  */
        inline_flag : bool_t {$ = TRUE;}
        /* The following flag is TRUE if an instance of the block may
           be used after block execution finish.  It is possibly if
           there is a function or class value is assigned to variable,
           passed as parameter, returned as function result or became
           as vec/tab element.  This flag is used to solve can we
           try to pop block instance after its execution and as
           consequence to decrease number of GC.  We could be more
           accurate in several ways:
             o Check only function/class inside the block.
             o Check that vec whose element is the function class
               is assigned to, passed as parameter, returned as
               function result or became as vec/tab element. */
        extended_life_context_flag : bool_t {$ = FALSE;}
        /* The following is the list of friends of the block. */
        friends : friend {$ = NULL;}
        /* The following is the list of uses of the block. */
        block_uses : block_use {$ = NULL;}
        bc_block : BC_hidden_node_t {$ = NULL;} /* Byte code block */
;

/* The following is a node of the list of friends of block (it means
   that the friend (all blocks inside it) can have access to the block
   private declarations). */
friend :: ir_node
%other
        friend_decl : decl
        next_friend : friend
;

/* The following is a node of the list of uses of block (it means that
   the use (all blocks inside it) can have access to the block private
   declarations). */
block_use :: ir_node
%other
        use_decl : decl
        next_block_use : block_use
;

decl
%other
        /* The following field is the first friend ident if the decl
           ident is in an friend clause. */
	friend_ident : friend_ident
        /* Non-null if given declaration is a copy of the original
	   one created by processing an use-clause. */
        origin_decl : decl {$ = NULL;}
        /* The declaration copied from the original declaration during
           processing use-clause refers for the use clause.  */
        use_clause : use {$ = NULL;}
        /* Used to change field TO of copied redirs. The field value
	   can be a decl or temporarily another redir.  */
        redir_to_subst : stmt {$ = NULL;}
        /* True if it is a renamed definition from an use-clause.  */
        alias_flag : bool_t {$ = FALSE;}
        bc_decl : BC_hidden_node_t {$ = NULL;} /* Byte code decl */
        
;

fun_or_class
%other
        /* Number of parameters of the fun.  The formal
           parameters are the start vars in the fun block.  The
           number takes into account variable for `...' too. */
        parameters_number : int_t
        /* Number of minimal actual parameters for the fun.  It is
	   actually number of first formal parameters without default
	   value. */
        min_actual_parameters_number : int_t {$ = -1;}
        /* Previous statement.  It is defined and used only for
	   forward decls.  */
        forward_prev : stmt
        /* Byte code block of the func/class.  It is the same as the
           byte code of the fun/class block if the func/class has it.
           In case forward declaration without definition we have no
           corresponidng block and the field is the only way to access
           the byte code block.  Calling such function will generate
           an exception during the program evaluation. */
        fdecl_bc_block : BC_hidden_node_t {$ = NULL;}
;

class
%other
        /* True if there is no statements in class block.  */
        simple_class_flag : bool_t {$ = FALSE;}
;

external_fun
%other
	/* Order number of the external function.  */
	no : int_t {$ = -1;}
;

var
%other
        /* Number (0, ...) of the var (only immediatly placed) in
           block vars.  The numeration of vars in fun starts with 0. */
        var_number_in_block : int_t
;

use_item
%other
        /* Use-clause which is origin of the item.  */
        item_use_clause : use {$ = NULL;}
        /* Flag of used decls for this item were redefined. */
        redefine_flag : bool_t {$ = FALSE;}
;

later_item
%other
        /* List of all redirs for given item. */
        redirs : decl_redir {$ = NULL;}
;

/* It used during generation of BC for blocks with use-clauses in
   cases rewriting decls afterwards to setup BC substituion in a right
   place.  It is also used for forward declaration in order to process
   them correctly if they are used. */
decl_redir :: stmt
%other
        /* Reference in given scope for definition or temporarily
	   another redir. */
	to : stmt
        /* Reference for original used declaration which is
	   substituted by given redirection.  */
        redir_origin : decl
        /* All redirs for a later use item are chained by the following
	   field.  */
        next_redir : decl_redir
;

/************* The following part is set in evaluator **************/

fun_or_class
%other
        /* Number of function/class calls. */
        calls_number : int_t {$ = 0;}
	/* Time of function (class body) execution.  Defined if the
	   previous field is not zero. */
        exec_time : ticker_t
        interrupts_number : int_t
;

external_decl
%other
        /* Address of loaded external. */
        address : string_t {$ = NULL;}
;
  
block
%other
        /* The following field is cached address of container for the
           current block.  The cached value is not
           defined if cached_container_tick is not equal to the
           current value. */
	cached_container_address : string_t
	cached_container_tick : int_t {$ = -1;}
        /* The following field is set up on enter of the block.  */
        block_saved_sync_flag : bool_t
;

%%

#define IR_PTR(p) ((IR_node_t) p)

/* Funcs for work with code node hash table.  The table contains pointers
   to code nodes representing unique idents, values (cardinal, integer
   and etc.), decls (i.e. nodes having members ident and scope). */

/* The node hash table. */

static hash_table_t node_hash_table;

/* Func for evaluation of hash value of code node represented by EL_PTR. */

static unsigned
hash_func (hash_table_entry_t el_ptr)
{
  IR_node_t node_ref;
  IR_node_mode_t mode;
  const char *chp;
  char ch;
  rint_t int_number;
  rfloat_t float_number;
  size_t i, size, hash_value;

  node_ref = IR_PTR (el_ptr);
  mode = IR_NODE_MODE (node_ref);
  if (mode == IR_NM_var || mode == IR_NM_external_var
      || mode == IR_NM_external_fun || mode == IR_NM_fun || mode == IR_NM_class)
    hash_value
      = ((unsigned) (long) IR_scope (node_ref)
	 + (unsigned) (long) IR_GET_UNIQUE_IDENT (IR_ident (node_ref)));
  else if (mode == IR_NM_unique_long)
    hash_value = hash_mpz (*IR_mpz_ptr (node_ref));
  else
    {
      if (mode == IR_NM_unique_char)
	{
	  size = sizeof (ucode_t);
          ch = IR_char_value (node_ref);
	  chp = &ch;
	}
      else if (mode == IR_NM_unique_int)
	{
	  size = sizeof (rint_t);
          int_number = IR_int_value (node_ref);
	  chp = (char *) &int_number;
	}
      else if (mode == IR_NM_unique_float)
	{
	  size = sizeof (rfloat_t);
          float_number = IR_float_value (node_ref);
	  chp = (char *) &float_number;
	}
      else if (mode == IR_NM_unique_string)
	{
	  chp = IR_string_value (node_ref);
	  size = strlen (chp);
	}
      else if (mode == IR_NM_unique_ucodestr)
	{
	  chp = (char *) IR_ucodestr_value (node_ref);
	  size = IR_ucodestr_size (node_ref);
	}
      else if (mode == IR_NM_unique_ident)
	{
	  chp = IR_ident_string (node_ref);
	  size = strlen (chp);
	}
      else
	d_unreachable ();
      for (hash_value = 0, i = 0; i < size; i++, chp++)
	hash_value += (*chp) << (i & 0x7);
    }
  return hash_value;
}

/* Func used for comparison of hash table elements represented by EL1_PTR,
   EL2_PTR.  Return TRUE if the elements represent equal nodes. */

static int
compare_func (hash_table_entry_t el1_ptr, hash_table_entry_t el2_ptr)
{
  IR_node_t node_ref1, node_ref2;
  IR_node_mode_t mode1, mode2;
  int elements_are_equal;

  node_ref1 = IR_PTR (el1_ptr);
  node_ref2 = IR_PTR (el2_ptr);
  mode1 = IR_NODE_MODE (node_ref1);
  mode2 = IR_NODE_MODE (node_ref2);
  if ((mode1 == IR_NM_var || mode1 == IR_NM_external_var
       || mode1 == IR_NM_external_fun || mode1 == IR_NM_fun
       || mode1 == IR_NM_class)
      && (mode2 == IR_NM_var || mode2 == IR_NM_external_var
	  || mode2 == IR_NM_external_fun || mode2 == IR_NM_fun
	  || mode2 == IR_NM_class))
    elements_are_equal
      = (IR_scope (node_ref1) == IR_scope (node_ref2)
	 && (IR_GET_UNIQUE_IDENT (IR_ident (node_ref1))
	     == IR_GET_UNIQUE_IDENT (IR_ident (node_ref2))));
  else
    {
      elements_are_equal = mode1 == mode2;
      if (elements_are_equal)
	{
	  if (mode1 == IR_NM_unique_ident)
	    elements_are_equal
	      = (strcmp (IR_ident_string (node_ref1),
			 IR_ident_string (node_ref2))
		 == 0);
	  else if (mode1 == IR_NM_unique_char)
	    elements_are_equal = (IR_char_value (node_ref1)
				  == IR_char_value (node_ref2));
	  else if (mode1 == IR_NM_unique_int)
	    elements_are_equal
	      = (IR_int_value (node_ref1) == IR_int_value (node_ref2));
	  else if (mode1 == IR_NM_unique_long)
	    elements_are_equal
	      = mpz_cmp (*IR_mpz_ptr (node_ref1), *IR_mpz_ptr (node_ref2)) == 0;
	  else if (mode1 == IR_NM_unique_float)
	    elements_are_equal
	      = (IR_float_value (node_ref1) == IR_float_value (node_ref2));
	  else if (mode1 == IR_NM_unique_string)
	    elements_are_equal
	      = strcmp (IR_string_value (node_ref1),
                        IR_string_value (node_ref2)) == 0;
	  else if (mode1 == IR_NM_unique_ucodestr)
	    elements_are_equal
	      = (IR_ucodestr_size (node_ref1) == IR_ucodestr_size (node_ref2)
		 && memcmp (IR_ucodestr_value (node_ref1),
			    IR_ucodestr_value (node_ref2),
			    IR_ucodestr_size (node_ref1)) == 0);
	  else
	    d_unreachable ();
	}
    }
  return elements_are_equal;
}

void
initiate_table (void)
{
  node_hash_table = create_hash_table (1000, hash_func, compare_func);
}

/* Delete the code node hash table. */

void
delete_table (void)
{
  delete_hash_table (node_hash_table);
}

/* Find pointer to the code node hash table entry which contains pointer to
   node with the same keys as in node starting with REF or else the empty entry
   (its value is NULL).  If RESERVE is TRUE than the empty entry is reseved
   and must be filled by node with the same keys as in node starting with
   REF. */

IR_node_t *
find_table_entry (IR_node_t ref, int reserve)
{
  return
    (IR_node_t *) find_hash_table_entry (node_hash_table,
					 (hash_table_entry_t) ref, reserve);
}

/* Include node starting with REF to the code node hash table.  If node with
   the same keys is already in the table than delete it and include the node
   starting with REF to the table. */

void
include_to_table (IR_node_t ref)
{
  IR_node_t *table_entry_pointer;

  table_entry_pointer = find_table_entry (ref, TRUE);
  *table_entry_pointer = ref;
}

/* Return pointer to unique ident node with the hash table key STRING. */

IR_node_t
find_unique_ident (char *string)
{
  IR_node_t result;

  IR_set_ident_string (temp_unique_ident, string);
  result = (*find_table_entry (temp_unique_ident, FALSE));
  return result;
}

/* Allocate memory for node with given mode and initiate its mode. */

IR_node_t
create_node (IR_node_mode_t mode)
{
  return IR_create_node (mode);
}

/* Allocate memory for node with given mode and initiate its common
   members MODE and POS. */

IR_node_t
create_node_with_pos (IR_node_mode_t mode, position_t pos)
{
  IR_node_t ref;

  ref = IR_create_node (mode);
  IR_set_pos (ref, pos);
  return ref;
}

/* Allocate memory for node with given mode and string STR of length
   LEN and initiate its common member mode.  Return pointer to the
   string in the allocated memory through parameter
   string_in_pool_ptr.  Nodes with string attribute are unique string,
   unique ident, and unique ucode string.  */

IR_node_t
create_unique_node_with_string (IR_node_mode_t m,
				const char *str, size_t len,
				char **string_in_pool_ptr)
{
  IR_node_t ref;

  ref = IR_create_node (m);
  IR_TOP_EXPAND (len);
  *string_in_pool_ptr = IR_TOP_BEGIN ();
  IR_TOP_FINISH ();
  memcpy (*string_in_pool_ptr, str, len);
  return ref;
}

/* Create unique ident with name STR (allocate memory, copy attribute
   in pool, initiate members and include to the hash table if the unique
   ident does not exist).  Only this func must be used for creation
   of unique ident because only this func initiates correctly some
   members. */

IR_node_t
create_unique_ident_node (const char *str)
{
  IR_node_t ref;
  char *string_in_pool;

  IR_set_ident_string (temp_unique_ident, (char *) str);
  ref = *find_table_entry (temp_unique_ident, FALSE);
  if (ref == NULL)
    {
      ref = create_unique_node_with_string (IR_NM_unique_ident, str,
					    strlen (str) + 1,
                                            &string_in_pool);
      IR_set_ident_string (ref, string_in_pool);
      /* The following means that the ident is not used for access to 
         any class decl. */
      IR_set_field_ident_number (ref, -1);
      include_to_table (ref);
    }
  return ref;
}

/* Create and return new empty block in SCOPE.  */
IR_node_t
create_empty_block (IR_node_t scope)
{
  IR_node_t block = create_node_with_pos (IR_NM_block, current_position);
  IR_set_fun_class (block, NULL);
  IR_set_friend_list (block, NULL);
  IR_set_block_scope (block, scope);
  IR_set_exceptions (block, NULL);
  return block;
}

/* Merging two cyclic lists into one cyclic list. */
IR_node_t
merge_stmt_lists (IR_node_t list1, IR_node_t list2)
{
  IR_node_t result;

  if (list2 != NULL) {
    if (list1 != NULL)
      {
        IR_node_t first;
        
        first = IR_next_stmt (list2);
        IR_set_next_stmt (list2, IR_next_stmt (list1));
        IR_set_next_stmt (list1, first);
      }
    result = list2;
  }
  else
    result = list1;
  return result;
}

/* Make normal list from cycle stmt list with the pointer to the last
   stmt. */
IR_node_t
uncycle_stmt_list (IR_node_t list)
{
  IR_node_t first;

  if (list == NULL)
    return list;
  first = IR_next_stmt (list);
  IR_set_next_stmt (list, NULL);
  return first;
}

/* This func should be invoked only one before any work with intermediate
   code but after initiation of table.  The func creates standard
   environment. */

void
initiate_icode (void)
{
  IR_start ();
  temp_unique_ident = IR_create_node (IR_NM_unique_ident);
  temp_unique_int = IR_create_node (IR_NM_unique_int);
  temp_unique_long = IR_create_node (IR_NM_unique_long);
  temp_unique_float = IR_create_node (IR_NM_unique_float);
  temp_unique_char = IR_create_node (IR_NM_unique_char);
  temp_unique_string = IR_create_node (IR_NM_unique_string);
  temp_unique_ucodestr = IR_create_node (IR_NM_unique_ucodestr);
  temp_ident = IR_create_node (IR_NM_ident);
  temp_decl = IR_create_node (IR_NM_var);
  destroy_unique_ident = create_unique_ident_node ("destroy");
  IR_set_field_ident_number (destroy_unique_ident, DESTROY_FLDID_NUM);
}

void
finish_icode (void)
{
}



/* This page contains func for searching for idents according to
   language visibility rules. */

/* The func returns pointer to decl with key (IDENT, SCOPE)
   or NULL if such decl does not exist.  IDENT is to be not NULL.
   SCOPE may be NULL. */

IR_node_t
find_decl_in_given_scope (IR_node_t ident, IR_node_t scope)
{
  IR_set_ident (temp_decl, ident);
  IR_set_scope (temp_decl, scope);
  return *find_table_entry (temp_decl, FALSE);
}

/* The func returns pointer to decl visible according language
   rule from SCOPE and designated by IDENT, or returns NULL if such
   decl does not exist.  IDENT is to be not NULL.
   SCOPE may be NULL. */

IR_node_t
find_decl (IR_node_t ident, IR_node_t scope)
{
  IR_node_t decl;

  d_assert (scope != NULL);
  for (;;)
    {
      decl = find_decl_in_given_scope (ident, scope);
      if (decl != NULL || scope == NULL)
	break;
      scope = IR_block_scope (scope);
    }
  return decl;
}



/* Return new identifier node with given NAME and POS. */

IR_node_t
get_ident_node (char *name, position_t pos)
{
  IR_node_t result;

  result = create_node_with_pos (IR_NM_ident, pos);
  IR_set_unique_ident (result, create_unique_ident_node (name));
  return result;
}

/* Return new int node with given NUMBER_VALUE and POS. */

IR_node_t
get_int_node (rint_t number_value, position_t pos)
{
  IR_node_t result;
  IR_node_t unique_number_value_node;

  IR_set_int_value (temp_unique_int, number_value);
  unique_number_value_node = *find_table_entry (temp_unique_int, FALSE);
  if (unique_number_value_node == NULL)
    {
      unique_number_value_node = create_node (IR_NM_unique_int);
      IR_set_int_value (unique_number_value_node, number_value);
      include_to_table (unique_number_value_node);
    }
  result = create_node_with_pos (IR_NM_int, pos);
  IR_set_unique_int (result, unique_number_value_node);
  return result;
}

/* Return new long node with given representation REP in BASE and
   POS. */
IR_node_t
get_long_node (const char *rep, position_t pos, int base)
{
  IR_node_t result;
  IR_node_t unique_number_value_node;

  mpz_init_set_str (*IR_mpz_ptr (temp_unique_long), rep, base);
  unique_number_value_node = *find_table_entry (temp_unique_long, FALSE);
  if (unique_number_value_node == NULL)
    {
      unique_number_value_node = create_node (IR_NM_unique_long);
      mpz_init_set_str (*IR_mpz_ptr (unique_number_value_node), rep, base);
      include_to_table (unique_number_value_node);
    }
  mpz_clear (*IR_mpz_ptr (temp_unique_long));
  result = create_node_with_pos (IR_NM_long, pos);
  IR_set_unique_long (result, unique_number_value_node);
  return result;
}


/* Return new number node with given NUMBER_VALUE and POS. */

IR_node_t
get_float_node (rfloat_t number_value, position_t pos)
{
  IR_node_t result;
  IR_node_t unique_number_value_node;

  IR_set_float_value (temp_unique_float, number_value);
  unique_number_value_node = *find_table_entry (temp_unique_float, FALSE);
  if (unique_number_value_node == NULL)
    {
      unique_number_value_node = create_node (IR_NM_unique_float);
      IR_set_float_value (unique_number_value_node, number_value);
      include_to_table (unique_number_value_node);
    }
  result = create_node_with_pos (IR_NM_float, pos);
  IR_set_unique_float (result, unique_number_value_node);
  return result;
}

/*
Local Variables:
mode:c
End:
*/
