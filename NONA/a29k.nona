/*
   FILE NAME:   a29k.nona

   Copyright (C) 1997-2002 Vladimir Makarov.

   Written by Vladimir Makarov <vmakarov@users.sourceforge.net>

   This file is part of the tool NONA.

   This is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This software is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GNU CC; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.

   TITLE:       Description of Am29k instructions

   DESCRIPTION: This file contains machine-dependent A29k instructions
       description for high quality code selection.  This file is
       processed by NONA (code selector description translator).
*/

%import {

typedef int integer_t;
typedef unsigned int unit_size_t;

typedef struct LL_node *LL_node_t;
typedef struct BE_node *BE_node_t;

/* The following macro value is type of nodes of graphs processed by
   NONA (see NONA decsription). */

#define CS_NODE                  LL_node_t

}


/* The following union describes types of attributes of of nodes of
   graphs processed by NONA. */

%union {
  LL_node_t ll_node;
  BE_node_t be_node;
  struct {BE_node_t reg; unsigned char const8;} reg_or_byte;
  struct
    {
      BE_node_t reg;
      unsigned char const8;
      char minus_flag;
    } reg_or_any_sign_byte;
  struct {BE_node_t q; BE_node_t reg;} q_and_reg;
}

%local {

extern int LL_NODE_MODE (LL_node_t node);

extern LL_node_t LL_operand (LL_node_t node);

extern LL_node_t LL_operand_1 (LL_node_t node);

extern LL_node_t LL_operand_2 (LL_node_t node);

extern LL_node_t LL_operand_3 (LL_node_t node);

extern CS_cover LL_state (LL_node_t node);

extern CS_cover LL_set_state (LL_node_t node, CS_cover state);

extern CS_TYPE attribute_value (LL_node_t arg);

extern char *LL_function_name (LL_node_t node);

extern void error (int fatal, int position, const char *str);

/* The following definition redefines macros generated by NONA (see
   description of Machine description translator - NONA). */

#define CS_OPERATION(node)       LL_NODE_MODE (node)

#define CS_OPERAND_1_OF_1(node)  LL_operand (node)

#define CS_OPERAND_1_OF_2(node)  LL_operand_1 (node)

#define CS_OPERAND_2_OF_2(node)  LL_operand_2 (node)

#define CS_OPERAND_1_OF_3(node)  LL_operand_1 (node)

#define CS_OPERAND_2_OF_3(node)  LL_operand_2 (node)

#define CS_OPERAND_3_OF_3(node)  LL_operand_3 (node)

#define CS_STATE(node)           LL_state (node)

#define CS_SET_STATE(node, state)  LL_set_state (node, state)

#define CS_ATTRIBUTE(arg)   attribute_value (arg)

#define CS_ERROR(str)       error (1/*TRUE*/, 0 /* no position */, str)


int flag_29050;
}

%local {

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int it_is_zero_integer (integer_t integer);
int it_is_integer_immediate_operand (integer_t integer);
int it_is_any_sign_integer_immediate_operand (integer_t integer);

extern integer_t LL_integer (LL_node_t);

int it_is_address_immediate_operand (unit_size_t unit_size);
int it_is_any_sign_address_immediate_operand (unit_size_t unit_size);

int power_of_integer (integer_t integer);
int power_of_address (unit_size_t address);

extern unit_size_t LL_address (LL_node_t);

}

%term <ll_node> LLNM_expression_statement

%term <ll_node> LLNM_integer_constant LLNM_real_constant

%term <ll_node> LLNM_integer_addition
             LLNM_integer_subtraction LLNM_integer_subtraction_without_overflow
             LLNM_integer_multiplication LLNM_integer_division
             LLNM_integer_quotient
             LLNM_integer_and LLNM_integer_or
             LLNM_integer_eq LLNM_integer_as_unsigned_eq LLNM_integer_ne
             LLNM_integer_gt LLNM_integer_as_unsigned_gt LLNM_integer_lt
             LLNM_integer_ge LLNM_integer_le
             LLNM_unsigned_shift_right LLNM_shift_right
             LLNM_shift_left LLNM_unsigned_shift_left

%term <ll_node> LLNM_integer_negotiation LLNM_integer_not LLNM_integer_to_real
             LLNM_integer_to_scaled LLNM_unsigned_integer_to_address

%term <ll_node> LLNM_index_check
             LLNM_min_subrange_value_check LLNM_max_subrange_value_check
             LLNM_nil_pointer_check LLNM_second_mod_operand_check
             LLNM_case_tag_check

%term <ll_node> LLNM_real_addition LLNM_real_subtraction
             LLNM_real_multiplication LLNM_real_division
             LLNM_real_eq LLNM_real_ne LLNM_real_gt LLNM_real_lt
             LLNM_real_ge LLNM_real_le

%term <ll_node> LLNM_real_negotiation

/*
%term <ll_node> LLNM_scaled_addition LLNM_scaled_subtraction
             LLNM_scaled_multiplication
             LLNM_scaled_division LLNM_scaled_eq LLNM_scaled_ne
             LLNM_scaled_gt scaled_lt LLNM_scaled_ge LLNM_scaled_le

%term <ll_node> LLNM_scaled_negotiation LLNM_scaled_to_integer LLNM_scaled_to_real
*/

%term <ll_node> LLNM_dynamic_dynamic_set_union LLNM_static_dynamic_set_union
             LLNM_dynamic_static_set_union LLNM_static_static_set_union
             LLNM_dynamic_dynamic_set_difference
             LLNM_static_dynamic_set_difference
             LLNM_dynamic_static_set_difference
             LLNM_static_static_set_difference
             LLNM_dynamic_dynamic_set_intersection
             LLNM_static_dynamic_set_intersection
             LLNM_dynamic_static_set_intersection
             LLNM_static_static_set_intersection
             LLNM_dynamic_dynamic_set_eq LLNM_static_dynamic_set_eq
             LLNM_dynamic_static_set_eq LLNM_static_static_set_eq
             LLNM_dynamic_dynamic_set_le LLNM_static_dynamic_set_le
             LLNM_dynamic_static_set_le LLNM_static_static_set_le
             LLNM_in_dynamic_set LLNM_in_static_set
             LLNM_dynamic_set_check LLNM_static_set_check
             LLNM_range_set LLNM_element_set
             LLNM_restore_stack_top LLNM_save_stack_top
             LLNM_dynamic_set_assignment LLNM_static_set_assignment

%term <ll_node> LLNM_contest LLNM_store
             LLNM_move_block LLNM_move_dynamic_size_block

%term <ll_node> LLNM_address_constant LLNM_string_address LLNM_label_address
             LLNM_static_variable

%term <ll_node> LLNM_frame_address LLNM_static_link
             LLNM_indirect_address LLNM_address_eq LLNM_address_ne
             LLNM_address_addition LLNM_address_scaling
             LLNM_function_address

%term <ll_node> LLNM_jump LLNM_long_jump LLNM_jump_true LLNM_jump_false
             LLNM_jump_through_table

%term <ll_node> LLNM_compare_block

%term <ll_node> LLNM_epilogue LLNM_prologue

%term <ll_node> LLNM_procedure_call LLNM_function_call
             LLNM_standard_procedure_call LLNM_standard_function_call
             LLNM_simple_standard_function_call LLNM_low_level_return

%commutative LLNM_integer_addition LLNM_integer_multiplication
             LLNM_integer_and LLNM_integer_or
             LLNM_integer_eq LLNM_integer_as_unsigned_eq LLNM_integer_ne

%commutative LLNM_real_addition LLNM_real_multiplication
             LLNM_real_eq LLNM_real_ne

%commutative LLNM_address_eq LLNM_address_ne LLNM_address_addition

%type <reg_or_byte> reg_or_byte

%type <reg_or_any_sign_byte> reg_or_any_sign_byte

%type <be_node> reg accumulator accumulator0

%type <q_and_reg> q_and_reg q_undefined_and_reg

%%

stmt : LLNM_expression_statement (reg) [0]
;

reg_or_byte : reg [0]  {}
;

reg_or_byte : LLNM_integer_constant [0]
                   %if [it_is_integer_immediate_operand (LL_integer ($1))]
           {
           }
;

reg_or_any_sign_byte : reg [0]
           {
           }
;

reg_or_any_sign_byte : LLNM_integer_constant [0]
               %if [it_is_any_sign_integer_immediate_operand (LL_integer ($1))]
           {
           }
;

reg : LLNM_integer_constant [1 /* it is important only that the value >= 1 */ ]
           {
             /* CONST, or CONSTHZ, or CONSTN, or CONST and CONSTH. */
           }
;

reg : LLNM_real_constant [1 /* The value is not important */ ]
           {
             /* CONST, or CONSTHZ, or CONSTN, or CONST and CONSTH. */
           }
;

reg : LLNM_integer_addition (reg, reg_or_any_sign_byte) [1]
           {
             /* ADD or SUB. */
           }
;

reg : LLNM_integer_subtraction (reg, reg_or_any_sign_byte) [1]
           {
             /* SUB or ADD. */
           }
;

reg : LLNM_integer_subtraction (reg_or_byte, reg) [1]
           {
             /* SUBR. */
           }
;

reg : LLNM_integer_subtraction_without_overflow (reg, reg_or_any_sign_byte) [1]
           {
             /* SUB or ADD. */
           }
;

q_undefined_and_reg : LLNM_integer_multiplication (reg, reg) [1]
           {
             /* MULTIPLY. */
           }
;

reg : LLNM_integer_multiplication (reg, LLNM_integer_constant)
           [0 /* Because it is preferable than previous rule. */]
           %if [power_of_integer (LL_integer ($3)) >= 0]
           {
             /* SLL. */
           }
;

reg : q_undefined_and_reg [0]
           {
           }
;

q_undefined_and_reg : LLNM_integer_division (q_and_reg, reg) [1]
           {
             /* DIVIDE. */
           }
;

q_and_reg : reg [2]
           {
             /* SRA, MTSR. */
           }
;

reg : LLNM_integer_quotient (q_and_reg, reg) [1]
           {
             /* DIVIDE, MFSR, CPLT, SRA, AND, ADD.  According to Pascal
                standard 0 <= i mod j < j therefore additional
                instructions are necessary.  The following
                instructions work incorrectly for negative second
                operand (this case is error in standard Pascal). */
           }
;

reg : LLNM_integer_and (reg, reg_or_byte) [1]
           {
             /* AND. */
           }
;

reg : LLNM_integer_and (reg, LLNM_integer_not (reg_or_byte)) [1]
           {
             /* ANDN. */
           }
;

reg : LLNM_integer_not (LLNM_integer_and (reg, reg_or_byte)) [1]
           {
             /* NAND. */
           }
;

reg : LLNM_integer_or (reg, reg_or_byte) [1]
           {
             /* OR. */
           }
;

reg : LLNM_integer_or (reg, LLNM_integer_not (reg_or_byte)) [1]
           {
             /* ORN. */
           }
;

reg : LLNM_integer_not (LLNM_integer_or (reg, reg_or_byte)) [1]
           {
             /* NOR. */
           }
;

reg : LLNM_integer_eq (reg, reg_or_byte) [2]
           {
             /* CPEQ and SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_integer_eq (reg, reg_or_byte),
                       LLNM_label_address) [2]
           {
             /* CPEQ and JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_integer_eq (reg, reg_or_byte),
                        LLNM_label_address) [2]
           {
             /* CPEQ and JMPF. */
           }
;

reg : LLNM_integer_as_unsigned_eq (reg, reg_or_byte) [2]
           {
             /* CPEQ and SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_integer_as_unsigned_eq (reg, reg_or_byte),
                       LLNM_label_address) [2]
           {
             /* CPEQ and JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_integer_as_unsigned_eq (reg, reg_or_byte),
                        LLNM_label_address) [2]
           {
             /* CPEQ and JMPF. */
           }
;

reg : LLNM_integer_ne (reg, reg_or_byte) [2]
           {
             /* CPNEQ and SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_integer_ne (reg, reg_or_byte),
                       LLNM_label_address) [2]
           {
             /* CPNEQ and JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_integer_ne (reg, reg_or_byte),
                        LLNM_label_address) [2]
           {
             /* CPNEQ and JMPF. */
           }
;

reg : LLNM_integer_gt (reg, reg_or_byte) [2]
           {
             /* CPGT and SRL. */
           }
;

reg : LLNM_integer_gt (LLNM_integer_constant, reg) [1]
                %if [it_is_zero_integer (LL_integer ($2))]
           {
             /* SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_integer_gt (reg, reg_or_byte),
                       LLNM_label_address) [2]
           {
             /* CPGT and JMPT. */
           }
;

stmt : LLNM_jump_true (LLNM_integer_gt (LLNM_integer_constant, reg),
                       LLNM_label_address) [1]
                %if [it_is_zero_integer (LL_integer ($3))]
           {
             /* JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_integer_gt (reg, reg_or_byte),
                        LLNM_label_address) [2]
           {
             /* CPGT and JMPF. */
           }
;

stmt : LLNM_jump_false (LLNM_integer_gt (LLNM_integer_constant, reg),
                       LLNM_label_address) [1]
                %if [it_is_zero_integer (LL_integer ($3))]
           {
             /* JMPF. */
           }
;

/* For commutativity. */
reg : LLNM_integer_gt (reg_or_byte, reg) [2]
           {
             /* CPLE and SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_integer_gt (reg_or_byte, reg),
                       LLNM_label_address) [2]
           {
             /* CPLE and JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_integer_gt (reg_or_byte, reg),
                        LLNM_label_address) [2]
           {
             /* CPLE and JMPF. */
           }
;

reg : LLNM_integer_as_unsigned_gt (reg, reg_or_byte) [2]
           {
             /* CPGTU and SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_integer_as_unsigned_gt (reg, reg_or_byte),
                       LLNM_label_address) [2]
           {
             /* CPGTU and JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_integer_as_unsigned_gt (reg, reg_or_byte),
                        LLNM_label_address) [2]
           {
             /* CPGTU and JMPF. */
           }
;

/* For commutativity. */
reg : LLNM_integer_as_unsigned_gt (reg_or_byte, reg) [2]
           {
             /* CPLEU and SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_integer_as_unsigned_gt (reg_or_byte, reg),
                       LLNM_label_address) [2]
           {
             /* CPLEU and JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_integer_as_unsigned_gt (reg_or_byte, reg),
                        LLNM_label_address) [2]
           {
             /* CPLEU and JMPF. */
           }
;

reg : LLNM_integer_lt (reg, reg_or_byte) [2]
           {
             /* CPLT and SRL. */
           }
;

reg : LLNM_integer_lt (reg, LLNM_integer_constant) [1]
                %if [it_is_zero_integer (LL_integer ($3))]
           {
             /* SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_integer_lt (reg, reg_or_byte),
                       LLNM_label_address) [2]
           {
             /* CPLT and JMPT. */
           }
;

stmt : LLNM_jump_true (LLNM_integer_lt (reg, LLNM_integer_constant),
                       LLNM_label_address) [1]
                %if [it_is_zero_integer (LL_integer ($4))]
           {
             /* JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_integer_lt (reg, reg_or_byte),
                        LLNM_label_address) [2]
           {
             /* CPLT and JMPF. */
           }
;

stmt : LLNM_jump_false (LLNM_integer_lt (reg, LLNM_integer_constant),
                       LLNM_label_address) [1]
                %if [it_is_zero_integer (LL_integer ($4))]
           {
             /* JMPF. */
           }
;

/* For commutativity. */
reg : LLNM_integer_lt (reg_or_byte, reg) [2]
           {
             /* CPGE and SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_integer_lt (reg_or_byte, reg),
                       LLNM_label_address) [2]
           {
             /* CPGE and JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_integer_lt (reg_or_byte, reg),
                        LLNM_label_address) [2]
           {
             /* CPGE and JMPF. */
           }
;

reg : LLNM_integer_ge (reg, reg_or_byte) [2]
           {
             /* CPGE and SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_integer_ge (reg, reg_or_byte),
                       LLNM_label_address) [2]
           {
             /* CPGE and JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_integer_ge (reg, reg_or_byte),
                        LLNM_label_address) [2]
           {
             /* CPGE and JMPF. */
           }
;

/* For commutativity. */
reg : LLNM_integer_ge (reg_or_byte, reg) [2]
           {
             /* CPLT and SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_integer_ge (reg_or_byte, reg),
                       LLNM_label_address) [2]
           {
             /* CPLT and JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_integer_ge (reg_or_byte, reg),
                        LLNM_label_address) [2]
           {
             /* CPLT and JMPF. */
           }
;

reg : LLNM_integer_le (reg, reg_or_byte) [2]
           {
             /* CPLE and SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_integer_le (reg, reg_or_byte),
                       LLNM_label_address) [2]
           {
             /* CPLE and JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_integer_le (reg, reg_or_byte),
                        LLNM_label_address) [2]
           {
             /* CPLE and JMPF. */
           }
;

/* For commutativity. */

reg : LLNM_integer_le (reg_or_byte, reg) [2]
           {
             /* CPGT and SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_integer_le (reg_or_byte, reg),
                       LLNM_label_address) [2]
           {
             /* CPGT and JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_integer_le (reg_or_byte, reg),
                        LLNM_label_address) [2]
           {
             /* CPGT and JMPF. */
           }
;

reg : LLNM_unsigned_shift_right (reg, reg_or_byte) [1]
           {
             /* SRL. */
           }
;

reg : LLNM_shift_right (reg, reg_or_byte) [1]
           {
             /* SRL. */
           }
;

reg : LLNM_shift_left (reg, reg_or_byte) [1]
           {
             /* SLL. */
           }
;

reg : LLNM_unsigned_shift_left (reg, reg_or_byte) [1]
           {
             /* SLL. */
           }
;

reg : LLNM_integer_negotiation (reg) [1]
           {
             /* SUBR. */
           }
;

reg : LLNM_integer_not (reg) [1]
           {
             /* NOR. */
           }
;

reg : LLNM_integer_to_real (reg) [1]
           {
             /* CONVERT. */
           }
;

reg : LLNM_integer_to_scaled (reg)
           {
           }
;

reg : LLNM_unsigned_integer_to_address (reg)
           {
             /* No command. */
           }
;

reg : LLNM_index_check (reg, reg_or_byte) [1]
           {
             /* ASLEU. */
           }
;

reg : LLNM_min_subrange_value_check  (reg, reg_or_byte) [1]
           {
             /* ASGE. */
           }
;

reg : LLNM_max_subrange_value_check (reg, reg_or_byte) [1]
           {
             /* ASLE. */
           }
;

reg : LLNM_nil_pointer_check (reg)
           {
             /* ASNEQ. */
           }
;

reg : LLNM_second_mod_operand_check (reg)
           {
             /* ASGT. */
           }
;

reg : LLNM_case_tag_check (reg, reg_or_byte)
           {
             /* ASEQ. */
           }
;

reg : LLNM_real_addition (reg, reg) [1]
           {
             /* FADD. */
           }
;

reg : LLNM_real_subtraction (reg, reg) [1]
           {
             /* FSUB. */
           }
;

reg : LLNM_real_multiplication (reg, reg) [1]
           {
             /* FMUL. */
           }
;

reg : LLNM_real_division (reg, reg) [1]
           {
             /* FDIV. */
           }
;

reg : LLNM_real_eq (reg, reg) [2]
           {
             /* FEQ and SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_real_eq (reg, reg), LLNM_label_address) [2]
           {
             /* FEQ and JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_real_eq (reg, reg), LLNM_label_address) [2]
           {
             /* FEQ and JMPF. */
           }
;

reg : LLNM_real_ne (reg, reg) [3]
           {
             /* FEQ, CPGE (complementing), and SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_real_ne (reg, reg), LLNM_label_address) [2]
           {
             /* FEQ and JMPF. */
           }
;

stmt : LLNM_jump_false (LLNM_real_ne (reg, reg), LLNM_label_address) [2]
           {
             /* FEQ and JMPT. */
           }
;

reg : LLNM_real_gt (reg, reg) [2]
           {
             /* FGT and SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_real_gt (reg, reg), LLNM_label_address) [2]
           {
             /* FGT and JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_real_gt (reg, reg), LLNM_label_address) [2]
           {
             /* FGT and JMPF. */
           }
;

reg : LLNM_real_lt (reg, reg) [2]
           {
             /* FGE and SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_real_lt (reg, reg), LLNM_label_address) [2]
           {
             /* FGE and JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_real_lt (reg, reg), LLNM_label_address) [2]
           {
             /* FGE and JMPF. */
           }
;

reg : LLNM_real_ge (reg, reg) [2]
           {
             /* FGE and SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_real_ge (reg, reg), LLNM_label_address) [2]
           {
             /* FGE and JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_real_ge (reg, reg), LLNM_label_address) [2]
           {
             /* FGE and JMPF. */
           }
;

reg : LLNM_real_le (reg, reg) [2]
           {
             /* FGT and SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_real_le (reg, reg), LLNM_label_address) [2]
           {
             /* FGT and JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_real_le (reg, reg), LLNM_label_address) [2]
           {
             /* FGT and JMPF. */
           }
;

reg : LLNM_real_negotiation (reg) [2]
           {
             /* CONST and FSUB.  Using FSUB is obligatory because of
                processing exceptions. */
           }
;

accumulator : LLNM_real_addition
                (LLNM_real_multiplication (reg, reg), accumulator) [1]
           %if [flag_29050]
           {
             /* FMAC. */
           }
;

accumulator0 : LLNM_real_addition
                 (LLNM_real_multiplication (reg, reg), accumulator0) [1]
           %if [flag_29050]
           {
             /* FMAC. */
           }
;

accumulator : reg  [1]
           %if [flag_29050]
           {
             /* MTACC. */
           }
;

reg : accumulator  [1]
           %if [flag_29050]
           {
             /* MFACC. */
           }
;

accumulator : LLNM_real_addition
                (LLNM_real_multiplication (reg, LLNM_real_negotiation (reg)),
                 accumulator) [1]
           %if [flag_29050]
           { 
             /* FMAC. */
           }
;

accumulator0 : LLNM_real_addition
                (LLNM_real_multiplication (reg, LLNM_real_negotiation (reg)),
                 accumulator0) [1]
           %if [flag_29050]
           { 
             /* FMAC. */
           }
;

accumulator : LLNM_real_multiplication (reg, reg) [1]
           %if [flag_29050]
           {
             /* FMAC. */
           }
;

accumulator0 : LLNM_real_multiplication (reg, reg) [1]
           %if [flag_29050]
           {
             /* FMAC. */
           }
;

accumulator : LLNM_real_negotiation (reg) [1]
           %if [flag_29050]
           {
             /* FMAC. */
           }
;

accumulator0 : LLNM_real_negotiation (reg) [1]
           %if [flag_29050]
           {
             /* FMAC. */
           }
;

reg : LLNM_real_addition (reg,
                          LLNM_real_multiplication (reg, accumulator0)) [1]
           %if [flag_29050]
           {
             /* FMSM. */
           }
;

accumulator0 : reg [1]
           %if [flag_29050]
           {
             /* MTACC. */
           }
;

reg : accumulator0  [1]
           %if [flag_29050]
           {
             /* MFACC. */
           }
;

reg : LLNM_dynamic_dynamic_set_union (reg, reg) [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_static_dynamic_set_union (reg, reg) [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_dynamic_static_set_union (reg, reg) [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_static_static_set_union (reg, reg) [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_dynamic_dynamic_set_difference (reg, reg)
           [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_static_dynamic_set_difference (reg, reg)
           [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_dynamic_static_set_difference (reg, reg)
           [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_static_static_set_difference (reg, reg)
           [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_dynamic_dynamic_set_intersection (reg, reg)
           [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_static_dynamic_set_intersection (reg, reg)
           [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_dynamic_static_set_intersection (reg, reg)
           [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_static_static_set_intersection (reg, reg)
           [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_dynamic_dynamic_set_eq (reg, reg) [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_static_dynamic_set_eq (reg, reg) [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_dynamic_static_set_eq (reg, reg) [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_static_static_set_eq (reg, reg) [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_dynamic_dynamic_set_le (reg, reg) [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_static_dynamic_set_le (reg, reg) [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_dynamic_static_set_le (reg, reg) [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_static_static_set_le (reg, reg) [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_in_dynamic_set (reg, reg) [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_in_static_set (reg, reg) [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_dynamic_set_check (reg) [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_static_set_check (reg) [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_range_set (reg, reg) [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_element_set (reg) [20 /* Value is unimportant*/]
           {
           }
;

stmt : LLNM_restore_stack_top (reg) [1]
           {
             /* LOAD. */
           }
;

stmt : LLNM_save_stack_top (reg) [1]
           {
             /* STORE. */
           }
;

stmt : LLNM_dynamic_set_assignment (reg, reg) [20 /* Value is unimportant*/]
           {
           }
;

stmt : LLNM_static_set_assignment (reg, reg) [20 /* Value is unimportant*/]
           {
           }
;

reg : LLNM_contest (reg_or_byte) [1]
           {
             /* LOAD. */
           }
;

stmt : LLNM_move_block (reg, reg) [5 /* Value is not important. */]
           {
           }
;

stmt : LLNM_move_dynamic_size_block (reg, reg, reg)
           [20 /* Value is not important. */]
           {
           }
;

stmt : LLNM_store (reg_or_byte, reg) [1]
           {
             /* STORE. */
           }
;

reg_or_byte : LLNM_address_constant [0]
                   %if [it_is_address_immediate_operand (LL_address ($1))]
           {
           }
;

reg_or_any_sign_byte : LLNM_address_constant [0]
               %if [it_is_any_sign_address_immediate_operand (LL_address ($1))]
           {
           }
;

reg : LLNM_address_constant [1 /* it is important only that the value >= 1 */ ]
           {
             /* CONST, or CONSTHZ, or CONSTN, or CONST and CONSTH. */
           }
;

reg : LLNM_string_address [2]
           {
             /* CONST and CONSTH. */
           }
;

reg : LLNM_static_variable [2]
           {
             /* CONST and CONSTH. */
           }
;

reg : LLNM_frame_address [0]
           {
           }
;

/* The following rule is necessary because of frames may be addressed
   as register (gr125) + displacement. */

reg : LLNM_address_addition (LLNM_frame_address, LLNM_address_constant)
           [0 /* Such value for obligatory using the rule. */]
           {
           }
;

/* The following rule is necessary because of transformations of
   variable/parameter frames into addition of frame address and
   constant. */

reg : LLNM_address_addition
           (LLNM_address_addition (LLNM_frame_address, LLNM_address_constant),
            LLNM_address_constant)
           [0 /* Such value for obligatory constant folding. */]
           {
           }
;

/* The following rule is necessary because frames may be addressed
   as register (gr125) + displacemnt. */

reg : LLNM_static_link (LLNM_frame_address)
           [0 /* Such value for obligatory constant folding. */]
           {
             /* LOAD. */
           }
;

/* Frame address is in operand register (see allocation of memory stack). */

reg : LLNM_static_link (reg) [1]
           {
             /* LOAD. */
           }
;

/* The following rule is necessary because of transformations of
   variable/parameter frames into addition of frame address (obtained
   from static link) and constant. */

reg : LLNM_address_addition
           (LLNM_address_addition (reg, LLNM_address_constant),
            LLNM_address_constant)
           [0 /* Such value for obligatory constant folding. */]
           {
           }
;

reg : LLNM_indirect_address (reg) [0]
           {
           }
;

reg : LLNM_address_eq (reg, reg_or_byte) [2]
           {
             /* CPEQ and SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_address_eq (reg, reg_or_byte),
                       LLNM_label_address) [2]
           {
             /* CPEQ and JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_address_eq (reg, reg_or_byte),
                        LLNM_label_address) [2]
           {
             /* CPEQ and JMPF. */
           }
;

reg : LLNM_address_ne (reg, reg_or_byte) [2]
           {
             /* CPNEQ and SRL. */
           }
;

stmt : LLNM_jump_true (LLNM_address_ne (reg, reg_or_byte),
                       LLNM_label_address) [2]
           {
             /* CPNEQ and JMPT. */
           }
;

stmt : LLNM_jump_false (LLNM_address_ne (reg, reg_or_byte),
                        LLNM_label_address) [2]
           {
             /* CPNEQ and JMPF. */
           }
;

reg : LLNM_address_addition (reg, reg_or_any_sign_byte) [1]
           {
             /* ADD (not ADDU because of possible overflow) or SUB
                (not SUBU). */
           }
;

q_undefined_and_reg : LLNM_address_scaling (reg, reg) [1]
           {
             /* MULTIPLU. */
           }
;


reg : LLNM_address_scaling (reg, LLNM_address_constant)
           [0 /* Because it is preferable than previous rule. */]
           %if [power_of_address (LL_address ($3)) >= 0]
           {
             /* SLL. */
           }
;

reg : LLNM_function_address [2]
           {
             /* CONST and CONSTH. */
           }
;

stmt : LLNM_jump (LLNM_label_address) [1]
           {
             /* JMP. */
           }
;

stmt : LLNM_long_jump (LLNM_label_address)
           [0 /* The value is not important. */]
           {
           }
;

stmt : LLNM_jump_true (reg, LLNM_label_address) [2]
           {
             /* SLL and JMPT. */
           }
;

stmt : LLNM_jump_false (reg, LLNM_label_address) [2]
           {
             /* SLL and JMPF. */
           }
;

stmt : LLNM_jump_through_table (reg) [0 /* The value is not important. */]
           {
             /* CONST, CONSTH, SLL, ADD, LOAD, pseudo-instruction. */
           }
;

reg : LLNM_compare_block (reg, reg)
           {
             /* Call function for comparing block. */
           }
;

stmt : LLNM_epilogue  [0 /* The value is unimportant. */]
           {
           }
;

stmt : LLNM_prologue  [0 /* The value is unimportant. */]
           {
           }
;

stmt : LLNM_procedure_call (reg) [0 /* The value is unimportant. */]
           {
           }
;

reg : LLNM_function_call (reg) [0 /* The value is unimportant. */]
           {
           }
;

stmt : LLNM_standard_procedure_call [0 /* The value is unimportant. */]
           {
           }
;

reg : LLNM_standard_function_call [0 /* The value is unimportant. */]
           {
           }
;

reg : LLNM_simple_standard_function_call (reg) [2]
           %if [strcmp (LL_function_name ($1), "iiabs") == 0]
           {
             /* SRA, ADD, XOR. */
           }
;

reg : LLNM_simple_standard_function_call (reg) [4]
           %if [strcmp (LL_function_name ($1), "rrabs") == 0]
           {
             /* CPLT, XOR. */
           }
;

reg : LLNM_simple_standard_function_call (reg) [1]
           %if [strcmp (LL_function_name ($1), "round") == 0]
           {
             /* CONSTHZ, CPLT, OR, FADD, CONVERT.  Round to nearest is
                not used because of special cases when infinitely
                precise result falls exactly halfway between two
                representable values.  In this cases the result will
                be whichever of those two representable values has a
                fractional part whose least significant bit is zero.
                This does not correspond to Pascal function
                `trunc'. */
           }
;

reg : LLNM_simple_standard_function_call (reg) [1]
           %if [strcmp (LL_function_name ($1), "trunc") == 0]
           {
             /* CONVERT. */
           }
;

reg : LLNM_simple_standard_function_call (reg) [1]
           %if [flag_29050
                && strcmp (LL_function_name ($1), "rrsqrt") == 0]
           {
             /* SQRT. */
           }
;

reg : LLNM_simple_standard_function_call (reg) [3]
           %if [flag_29050
                && strcmp (LL_function_name ($1), "irsqrt") == 0]
           {
             /* CONVERT (integer->double), SQRT (double),
                CONVERT (double->single). */
           }
;

reg : LLNM_simple_standard_function_call (reg) [20]
           {
           }
;

stmt : LLNM_low_level_return (reg) [1]
           {
           }
;

%%

/*
Local Variables:
mode:c
End:
*/
